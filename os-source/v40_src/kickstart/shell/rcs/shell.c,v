head     1.115;
branch   ;
access   ;
symbols  ;
locks    ; strict;
comment  @*   @;


1.115
date     93.02.15.22.52.48;  author jesup;  state Exp;
branches ;
next     1.114;

1.114
date     92.08.21.15.34.52;  author jesup;  state Exp;
branches ;
next     1.113;

1.113
date     92.08.10.15.39.19;  author jesup;  state Exp;
branches ;
next     1.112;

1.112
date     92.08.09.18.55.51;  author jesup;  state Exp;
branches ;
next     1.111;

1.111
date     92.07.31.22.00.42;  author jesup;  state Exp;
branches ;
next     1.110;

1.110
date     92.06.02.14.20.01;  author jesup;  state Exp;
branches ;
next     1.109;

1.109
date     92.06.02.13.43.50;  author jesup;  state Exp;
branches ;
next     1.108;

1.108
date     92.05.08.23.50.08;  author jesup;  state Exp;
branches ;
next     1.107;

1.107
date     91.05.22.09.47.38;  author andy;  state Exp;
branches ;
next     1.106;

1.106
date     91.05.21.19.56.16;  author andy;  state Exp;
branches ;
next     1.105;

1.105
date     91.05.16.19.37.55;  author andy;  state Exp;
branches ;
next     1.104;

1.104
date     91.05.16.14.18.16;  author andy;  state Exp;
branches ;
next     1.103;

1.103
date     91.05.16.11.35.56;  author andy;  state Exp;
branches ;
next     1.102;

1.102
date     91.05.15.20.49.32;  author andy;  state Exp;
branches ;
next     1.101;

1.101
date     91.04.23.20.32.17;  author andy;  state Exp;
branches ;
next     1.100;

1.100
date     91.04.23.18.20.10;  author andy;  state Exp;
branches ;
next     1.99;

1.99
date     91.04.19.21.17.23;  author andy;  state Exp;
branches ;
next     1.98;

1.98
date     91.04.15.17.13.06;  author andy;  state Exp;
branches ;
next     1.97;

1.97
date     91.04.10.19.39.55;  author andy;  state Exp;
branches ;
next     1.96;

1.96
date     91.04.09.09.46.53;  author andy;  state Exp;
branches ;
next     1.95;

1.95
date     91.04.09.09.36.04;  author andy;  state Exp;
branches ;
next     1.94;

1.94
date     91.04.08.21.50.33;  author andy;  state Exp;
branches ;
next     1.93;

1.93
date     91.04.08.19.39.54;  author andy;  state Exp;
branches ;
next     1.92;

1.92
date     91.04.06.18.36.53;  author andy;  state Exp;
branches ;
next     1.91;

1.91
date     91.04.05.20.59.50;  author andy;  state Exp;
branches ;
next     1.90;

1.90
date     91.04.03.20.48.02;  author andy;  state Exp;
branches ;
next     1.89;

1.89
date     91.03.26.12.42.13;  author andy;  state Exp;
branches ;
next     1.88;

1.88
date     91.03.21.12.26.28;  author andy;  state Exp;
branches ;
next     1.87;

1.87
date     91.03.20.12.01.31;  author andy;  state Exp;
branches ;
next     1.86;

1.86
date     91.03.19.16.00.12;  author andy;  state Exp;
branches ;
next     1.85;

1.85
date     91.03.14.16.47.08;  author andy;  state Exp;
branches ;
next     1.84;

1.84
date     91.03.13.23.25.32;  author andy;  state Exp;
branches ;
next     1.83;

1.83
date     91.03.08.18.37.52;  author andy;  state Exp;
branches ;
next     1.82;

1.82
date     91.03.05.21.57.48;  author andy;  state Exp;
branches ;
next     1.81;

1.81
date     91.02.27.19.48.18;  author andy;  state Exp;
branches ;
next     1.80;

1.80
date     91.02.18.17.26.27;  author andy;  state Exp;
branches ;
next     1.79;

1.79
date     91.02.14.19.08.59;  author andy;  state Exp;
branches ;
next     1.78;

1.78
date     91.02.13.21.00.12;  author andy;  state Exp;
branches ;
next     1.77;

1.77
date     91.02.12.17.47.57;  author andy;  state Exp;
branches ;
next     1.76;

1.76
date     91.02.11.18.26.53;  author andy;  state Exp;
branches ;
next     1.75;

1.75
date     91.01.28.19.39.02;  author andy;  state Exp;
branches ;
next     1.74;

1.74
date     91.01.25.22.18.33;  author andy;  state Exp;
branches ;
next     1.73;

1.73
date     91.01.21.22.46.05;  author andy;  state Exp;
branches ;
next     1.72;

1.72
date     91.01.15.19.45.19;  author andy;  state Exp;
branches ;
next     1.71;

1.71
date     91.01.15.13.47.18;  author andy;  state Exp;
branches ;
next     1.70;

1.70
date     91.01.10.20.34.35;  author andy;  state Exp;
branches ;
next     1.69;

1.69
date     91.01.06.16.20.34;  author andy;  state Exp;
branches ;
next     1.68;

1.68
date     91.01.05.19.55.45;  author andy;  state Exp;
branches ;
next     1.67;

1.67
date     91.01.05.00.34.30;  author andy;  state Exp;
branches ;
next     1.66;

1.66
date     90.12.31.02.31.29;  author andy;  state Exp;
branches ;
next     1.65;

1.65
date     90.12.17.22.56.38;  author andy;  state Exp;
branches ;
next     1.64;

1.64
date     90.12.17.22.16.54;  author andy;  state Exp;
branches ;
next     1.63;

1.63
date     90.12.17.19.29.07;  author andy;  state Exp;
branches ;
next     1.62;

1.62
date     90.12.13.14.29.16;  author andy;  state Exp;
branches ;
next     1.61;

1.61
date     90.12.12.22.49.35;  author andy;  state Exp;
branches ;
next     1.60;

1.60
date     90.12.11.15.52.02;  author andy;  state Exp;
branches ;
next     1.59;

1.59
date     90.12.02.23.14.21;  author andy;  state Exp;
branches ;
next     1.58;

1.58
date     90.12.02.21.19.32;  author andy;  state Exp;
branches ;
next     1.57;

1.57
date     90.11.30.13.46.39;  author andy;  state Exp;
branches ;
next     1.56;

1.56
date     90.11.28.12.56.43;  author andy;  state Exp;
branches ;
next     1.55;

1.55
date     90.11.23.17.43.37;  author andy;  state Exp;
branches ;
next     1.54;

1.54
date     90.11.21.18.21.22;  author andy;  state Exp;
branches ;
next     1.53;

1.53
date     90.11.21.17.44.57;  author andy;  state Exp;
branches ;
next     1.52;

1.52
date     90.11.20.21.38.25;  author andy;  state Exp;
branches ;
next     1.51;

1.51
date     90.11.15.12.20.02;  author andy;  state Exp;
branches ;
next     1.50;

1.50
date     90.09.20.17.44.45;  author andy;  state Exp;
branches ;
next     1.49;

1.49
date     90.09.12.12.52.04;  author andy;  state Exp;
branches ;
next     1.48;

1.48
date     90.09.01.11.54.36;  author andy;  state Exp;
branches ;
next     1.47;

1.47
date     90.08.31.18.10.30;  author andy;  state Exp;
branches ;
next     1.46;

1.46
date     90.08.25.17.46.17;  author andy;  state Exp;
branches ;
next     1.45;

1.45
date     90.07.07.12.03.39;  author andy;  state Exp;
branches ;
next     1.44;

1.44
date     90.06.18.21.58.16;  author andy;  state Exp;
branches ;
next     1.43;

1.43
date     90.06.17.23.25.59;  author andy;  state Exp;
branches ;
next     1.42;

1.42
date     90.06.16.01.59.22;  author andy;  state Exp;
branches ;
next     1.41;

1.41
date     90.06.13.18.31.24;  author andy;  state Exp;
branches ;
next     1.40;

1.40
date     90.06.11.21.28.35;  author andy;  state Exp;
branches ;
next     1.39;

1.39
date     90.06.11.14.52.07;  author andy;  state Exp;
branches ;
next     1.38;

1.38
date     90.06.09.20.18.03;  author andy;  state Exp;
branches ;
next     1.37;

1.37
date     90.06.01.20.42.19;  author andy;  state Exp;
branches ;
next     1.36;

1.36
date     90.06.01.20.34.03;  author andy;  state Exp;
branches ;
next     1.35;

1.35
date     90.05.31.18.35.22;  author andy;  state Exp;
branches ;
next     1.34;

1.34
date     90.05.04.22.16.49;  author andy;  state Exp;
branches ;
next     1.33;

1.33
date     90.05.03.20.11.50;  author andy;  state Exp;
branches ;
next     1.32;

1.32
date     90.04.22.02.08.16;  author andy;  state Exp;
branches ;
next     1.31;

1.31
date     90.04.18.13.35.37;  author andy;  state Exp;
branches ;
next     1.30;

1.30
date     90.04.18.00.05.58;  author andy;  state Exp;
branches ;
next     1.29;

1.29
date     90.04.17.23.23.18;  author andy;  state Exp;
branches ;
next     1.28;

1.28
date     90.04.16.17.51.59;  author andy;  state Exp;
branches ;
next     1.27;

1.27
date     90.04.16.17.02.40;  author andy;  state Exp;
branches ;
next     1.26;

1.26
date     90.04.07.04.17.41;  author andy;  state Exp;
branches ;
next     1.25;

1.25
date     90.04.07.03.47.11;  author andy;  state Exp;
branches ;
next     1.24;

1.24
date     90.04.07.03.21.10;  author andy;  state Exp;
branches ;
next     1.23;

1.23
date     90.04.07.03.00.31;  author andy;  state Exp;
branches ;
next     1.22;

1.22
date     90.04.07.00.12.08;  author andy;  state Exp;
branches ;
next     1.21;

1.21
date     90.03.19.17.19.38;  author andy;  state Exp;
branches ;
next     1.20;

1.20
date     90.03.19.05.36.38;  author andy;  state Exp;
branches ;
next     1.19;

1.19
date     90.03.05.16.51.33;  author andy;  state Exp;
branches ;
next     1.18;

1.18
date     90.03.04.23.17.19;  author andy;  state Exp;
branches ;
next     1.17;

1.17
date     90.03.04.03.06.03;  author andy;  state Exp;
branches ;
next     1.16;

1.16
date     90.03.02.22.28.32;  author andy;  state Exp;
branches ;
next     1.15;

1.15
date     90.03.02.20.56.21;  author andy;  state Exp;
branches ;
next     1.14;

1.14
date     90.01.31.20.25.20;  author andy;  state Exp;
branches ;
next     1.13;

1.13
date     90.01.29.21.53.44;  author andy;  state Exp;
branches ;
next     1.12;

1.12
date     90.01.17.19.42.54;  author andy;  state Exp;
branches ;
next     1.11;

1.11
date     89.12.18.14.19.00;  author andy;  state Exp;
branches ;
next     1.10;

1.10
date     89.12.18.06.48.36;  author andy;  state Exp;
branches ;
next     1.9;

1.9
date     89.12.18.04.41.28;  author andy;  state Exp;
branches ;
next     1.8;

1.8
date     89.12.17.03.37.50;  author andy;  state Exp;
branches ;
next     1.7;

1.7
date     89.12.16.19.21.43;  author andy;  state Exp;
branches ;
next     1.6;

1.6
date     89.12.15.07.48.28;  author andy;  state Exp;
branches ;
next     1.5;

1.5
date     89.12.11.04.20.20;  author andy;  state Exp;
branches ;
next     1.4;

1.4
date     89.12.11.03.18.15;  author andy;  state Exp;
branches ;
next     1.3;

1.3
date     89.12.10.23.21.07;  author andy;  state Exp;
branches ;
next     1.2;

1.2
date     89.12.09.18.20.10;  author andy;  state Exp;
branches ;
next     1.1;

1.1
date     89.12.09.06.48.45;  author andy;  state Exp;
branches ;
next     1.0;

1.0
date     89.12.07.05.21.35;  author andy;  state Exp;
branches ;
next     ;


desc
@Amiga Shell
@


1.115
log
@ifdefed out oldredirect and Hold, add new define to get to internal DOS
calls
@
text
@#include <exec/types.h>
#include <exec/io.h>
#include <exec/alerts.h>
#include <exec/memory.h>
#include <exec/execbase.h>

#define DOS_PRIVATE_PRAGMAS

#include <internal/librarytags.h>

/* Private ROM routine... */
struct Library *TaggedOpenLibrary(LONG);
#pragma syscall TaggedOpenLibrary 32a 001

#include "global.h"

#include <devices/timer.h>

#include <dos/dos.h>
#include <dos/dosextens.h>
#include <dos/notify.h>
#include <dos/filehandler.h>
#include <dos/var.h>
#include "dos/dostags.h"

#include "libhdr.h"
#include "cli_init.h"
#include <string.h>
#include <stddef.h>

#include "clib/macros.h"

#include "fault.h"

#include "shell_rev.h"

#define EXECBASE (*(struct ExecBase **)4)
#define THISPROC    ((struct Process *)(EXECBASE->ThisTask))

#define NMAX 31
#define VARMAX 11

#ifdef USE_HOLD
#define FIBB_HOLD	7
#define FIBF_HOLD	(1<<FIBB_HOLD)
#endif

#define ERROR_REDIRECT  -118
#define ERROR_COMMAND_LONG -124

#define DOS_SIGNAL              8
#define DOS_MASK                ( 1 << DOS_SIGNAL )

/*
   Scb.Link       =0 = fh_Link
   Scb.Id         =1 = fh_Port
   Scb.Type       =2 = fh_Type
   Scb.Buf        =3 = fh_Buf
   Scb.Pos        =4 = fh_Pos
   Scb.End        =5 fh_End
   Scb.Funcs      =6 fh_Func1
   Scb.Func1      =6 
   Scb.Rdch       = Scb.Func1
   Scb.Func2      =7 fh_Func2
   Scb.Wrch       = Scb.Func2
   Scb.Func3      =8 fh_Func3
   Scb.Args       =9 fh_Args
   Scb.Arg1       =9 fh_Arg1
   Scb.Arg2       =10 fh_Arg2
   Scb.NFunc      =Scb.Args-Scb.Funcs
   Scb.Upb        =10
   Scb.WordSize   = 49      // SCB buffer size in lwords
   Scb.ByteSize   = 200     // SCB buffer byte upb

*/

int vsprintf(char *, char *, long []);
#pragma syscall RawDoFmt 20a ba9804
extern void __builtin_emit(UWORD);
static void __regargs prbuf(char c);

/* There are four basic IO streams used through this shell. */
/* 1 stdin, set by < , defaults to console (CIS) */
/* 2 stdout, set by >, defaults to console (COS) */
/* 3 commandin, set by Execute or EOF to file or console (currentin) */
/* 4 conin default console input stream (standardin) */

int CXBRK()
{
return(0);
}

void __asm startup( register __a0 struct DosPacket *parm_pkt)
{
   struct Global *gv;
   struct CGlobal *cgv=NULL;
   struct DosLibrary *DOSBase;
   struct Library *UtilityBase;
   UBYTE *prompt;
   UBYTE *commandname;
   UBYTE *commandfile;
   UBYTE *setname;
   LONG popts[8];
   struct CommandLineInterface *clip;
   struct CliProcList *cl;
   struct Process *process;
   LONG error;
   LONG tnum;
   BPTR (*fn)(struct DosPacket *) = NULL;
   BPTR standardout;
   struct Path *p;
   struct Segment *thiseg;
   LONG init_type = 3;		// shouldn't be required!!!! fix?
   struct FileHandle *fh; /* temporary filehandle */
   struct LocalVar *current_alias;
   struct DosPacket *save_pkt;
     BOOL freeCLI;
     BOOL pipe_expand;
     UBYTE *str;

     int ch;

     LONG item;
     LONG seg;
     LONG rc;
     BPTR module;
     LONG i,j;

char *internalname[]= {
".key",
".bra",
".ket",
"Why",
"Unsetenv",
"Unset",
"Unalias",

"Stack",
"Skip",
"Setenv",
"Set",

"Run",
"Resident",

"Quit",

"Prompt",
"Path",

"NewShell",
"NewCLI",

"Lab",

"If",

"Getenv",
"Get",

"Fault",
"Failat",

"EndSkip",
"EndShell",
"EndIf",
"EndCLI",
"Else",
"Echo",

"CD",

"Ask",
"Alias" };

LONG internallink[]= {
(link_endif),
(link_endif),
(link_endif),
(link_why),
(link_setenv),
(link_setenv),
(link_setenv),
(link_stack),
(link_skip),
(link_setenv),
(link_setenv),
(link_run),
(link_resident),
(link_quit),
(link_prompt),
(link_path),
(link_newshell),
(link_newshell),
(link_endif),
(link_if),
(link_getenv),
(link_getenv),
(link_fault),
(link_failat),
(link_endif),
(link_endcli),
(link_endif),
(link_endcli),
(link_else),
(link_echo),
(link_cd),
(link_ask),	
(link_setenv)
};

#ifdef pdebug
kprintf("\n----------------------\nStarting shell rev %ld\n",REVISION);
#endif

   DOSBase=(struct DOSLibrary *)TaggedOpenLibrary(OLTAG_DOS);

   if(parm_pkt == (struct DosPacket *) 1 ) {
	parm_pkt=WaitPkt();
   }

   /* dp_Type will be CPTR to bcpl function */
   if (parm_pkt)
   {
	/* these default to NULL and 0 respectively */
   	fn = (BPTR (*)(struct DosPacket *))(parm_pkt->dp_Type);
	init_type=(parm_pkt->dp_Res1 == 0 ? 0:2) |
		  (parm_pkt->dp_Res2 == 0 ? 0:1);
   }
   save_pkt=0;

   process = THISPROC; /* ProcessID(); */
   freeCLI = FALSE; /* Assume DOS will free it for us */   

   if(!(gv = (struct Global *)
	AllocMem(sizeof(struct Global),MEMF_PUBLIC|MEMF_CLEAR)))
	    goto early_error;

   gv->DOSBase=DOSBase;


   if(process->pr_CLI) { /* for 2.0 we have a CLI process structure */
	/* for a 2.0 style process, DOS nicely provides us with a */
	/* working CLI structure.  Since it will want to free it */
	/* set the flag that we won't have to */
	clip = BADDR(process->pr_CLI); 
   }
   else {
	/* we are not given a CLI structure, so this must be */
	/* an oldstyle BCPL type call.  We'd better make our own */

	/* allocate a CLI structure */
	cgv = (struct CGlobal *)
		AllocMem(sizeof(struct CGlobal),MEMF_PUBLIC|MEMF_CLEAR);
	if(!cgv) {
	   /* if we can't get this memory, might as well leave now */
early_error:
#ifdef pdebug
kprintf("Taking Early Error Exit\n");
#endif
	    /* give out of memory reply */
       	    ReplyPkt(parm_pkt,0,ERROR_NO_FREE_STORE); 
	    goto cleanup;
	}

	clip = &(cgv->Clip);
   	clip->cli_Prompt      = TO_BPTR(cgv->prompt);
   	clip->cli_CommandName = TO_BPTR(cgv->commandname);
   	clip->cli_CommandFile = TO_BPTR(cgv->commandfile);
   	clip->cli_SetName     = TO_BPTR(cgv->setname);

        process->pr_CLI = TO_BPTR(clip);
       	freeCLI = TRUE;		/* mark so these resources get freed */
   }
   prompt = BADDR(clip->cli_Prompt);
   commandname= BADDR(clip->cli_CommandName);
   commandfile=BADDR(clip->cli_CommandFile);
   setname=BADDR(clip->cli_SetName);
   gv->Clip = clip;

   /* for string compares */
   UtilityBase=TaggedOpenLibrary(OLTAG_UTILITY);
   gv->UtilityBase=UtilityBase;


#ifdef pdebug
kprintf("seg 0 is %lx, seg1 is %lx, seg2 is %lx, seg3 is %lx, seg4 is %lx\n",
((LONG *)BADDR(process->pr_SegList))[0],
((LONG *)BADDR(process->pr_SegList))[1],
((LONG *)BADDR(process->pr_SegList))[2],
((LONG *)BADDR(process->pr_SegList))[3],
((LONG *)BADDR(process->pr_SegList))[4]);
#endif
	    /* if 2.0 run have to change its seglist */
   	    if (!(((LONG *)BADDR(process->pr_SegList))[4])) {
	        ((LONG *)BADDR(process->pr_SegList))[4] = 
			((LONG *)BADDR(process->pr_SegList))[3];
	        ((LONG *)BADDR(process->pr_SegList))[3] = 0 ;
	    }

   if ((LONG)fn) {
        if (init_type == 0) { /* Cli init for c:run */
#ifdef pdebug
kprintf("\nRUN/System/Execute\n");
#endif
       	    fn = (BPTR (*)(struct DosPacket *))CliInitRun(parm_pkt);
#ifdef pdebug
kprintf("returned from CliInitRun\n");
#endif
	    if( ((LONG)fn<0) &&(LONG)fn&8 ) {/* check for async system call */
#ifdef pdebug
kprintf("async reply\n");
#endif
		 /* so reply now */
    		ReplyPkt(parm_pkt,parm_pkt->dp_Res1,parm_pkt->dp_Res2);
	    }
	}
	else if (init_type == 2) { /* Cli init for c:NewCli/c:NewShell */
#ifdef pdebug
kprintf("\nNewshell\n");
#endif
	    /* newshell case */
	    fn = (BPTR (*)(struct DosPacket *))CliInitNewcli(parm_pkt);
	}
	else goto cleanup; /* we need to clean up , maybe do an alert*/
   }
   else {
	/* we are booting! (always returns 0) */
	fn = (BPTR (*)(struct DosPacket *))CliInit(parm_pkt);
#ifdef pdebug
	kprintf("BOOT, fn returned is %lx\n",fn);
#endif
   }


	if ((LONG)fn > 0) {
/*
	The only functions returned here are qpkt (for types 00 and 10) for
	an argument of parm_pkt; and deletetask for an argument of FindTask(0).
	We'll key off the value of result2.
*/
	    if ((LONG)IoErr() != (LONG)(THISPROC) ) {
		if(init_type == 2) {
     	    	    ReplyPkt(parm_pkt,parm_pkt->dp_Res1,parm_pkt->dp_Res2);
		}
		else {
#ifdef pdebug
	    	    kprintf("delay doing the Reply\n");
#endif
	
		    /* mark this reply to be performed after we've tried to */
		    /* loadseg.  This will prevent grinding when running */
		    /* commands from scripts. */
		    save_pkt=parm_pkt;
	    	}
	    }
	    else {
#ifdef pdebug
		kprintf("bailing out!\n");
#endif
		goto cleanup;
	    }
	}

   if(thiseg=searchsegs(DOSBase,"SHELL",NULL))thiseg->seg_UC =  -1;

   process->pr_HomeDir = 0; /* initialize to sys: */
   tnum =process->pr_TaskNum;

   standardout = clip->cli_StandardOutput;

   /* add builtin commands to the resident list */
   error=0;

   Forbid();	/* add our internal commands */
   thiseg=searchsegs(DOSBase,"alias",NULL);

   while(thiseg) {
	/* set redirection special flag for set(s) commands */

	if(thiseg->seg_Seg == TO_BPTR(link_setenv)) {
	    error=TRUE; /* commands are already installed */
	    break;
	}
	thiseg=searchsegs(DOSBase,"alias",thiseg);
   }
   if(!error) {
	for(i=0; i<33; i++)
	   AddSegment(internalname[i],TO_BPTR(internallink[i]),CMD_BUILTIN);
   }

   /* the set command(s) and the run command need special treatment */
   /* for redirection purposes */
   if(thiseg=searchsegs(DOSBase,"run",0))
	gv->run_module=((struct Segment *)thiseg)->seg_Seg;
   if(thiseg=searchsegs(DOSBase,"set",0))
	gv->set_module=((struct Segment *)thiseg)->seg_Seg;
   if(thiseg=searchsegs(DOSBase,"pipe",0))
	gv->pipe_module=((struct Segment *)thiseg)->seg_Seg;

#if 0
   /* the above code compiles smaller ! */
   for(i=0, point= &gv->run_module; i < 3; i++ ) {
   if(thiseg=searchsegs(DOSBase,specialname[i],0))
	*point++ = ((struct Segment *)thiseg)->seg_Seg;
   }	
#endif

   /* ok, we're set up, and can go public now */

   Permit();
   /* set the local variables */
   vsprintf(gv->buffer,"%ld",&tnum);
   SetVar("process",gv->buffer,VARMAX,LV_VAR|GVF_LOCAL_ONLY);
   rc = 0;
   error=0;
   setv(gv,&rc); /* initialize RC and Result2 vatriables */

   do {
      do {								
    	setname[setname[0]+1]=0; /* null terminate the bstrings */
	prompt[prompt[0]+1]=0;
	commandname[0]=0; /* ready for next command */

         clip->cli_Interactive =  (!clip->cli_Background  && 
	    (clip->cli_CurrentInput == clip->cli_StandardInput) &&
	     !((((LONG)fn) & 0x80000004) == 0x80000004)) ?
		DOSTRUE : FALSE;

         SelectInput(clip->cli_CurrentInput);
         SelectOutput(standardout); /* set process outout() */

         if (clip->cli_Interactive) {
	   if(!clip->cli_Background) {
            FPutC(Output(),'O' - '@@'); /* go into normal mode */
	    j=0;
	    strcpy(gv->alias,prompt+1);
            for (i = 1 ; prompt[i]; i++)if (prompt[i] == '%') {
		switch(ToUpper(prompt[i+1])) {
		case 'S':
			popts[j++]=(LONG)setname+1;
			break;
		case 'N':
			popts[j++]=tnum;
			break;
		case 'R':
			popts[j++]=clip->cli_ReturnCode;
			gv->alias[i]='n';
			break;
		case '%':
			i++;  // skip the second %
			break;
		default:
			gv->alias[i]=' ';
			break;
		case '\0':
			break;	// must not go to default! (trailing %)
	        }
	    }
	    popts[j]=tnum;
	    expand(gv,gv->alias,MAXALIAS);/* take care of variables in prompt */
	    ticks(gv,gv->alias,MAXALIAS); /* handle a command in prompt if present */
	    /* we don't care if ticks() failed here (the user will see it) */

            VFWritef(Output(), gv->alias, (LONG *)&popts );
	    Flush(Output());
	   }
         }
         else {
             if (testflags(SIGBREAKF_CTRL_D)) {
               error = DOS_TRUE;
	       PrintFault(304,"SHELL"); /* "**BREAK - SHELL\n" */
            }
            if (error) break;
         }
         error = FALSE;

	 /* check for local 'command' variables */
	 gv->echo = 0; /* assume they want quiet */
	 if(GetVar("echo",gv->buffer,NMAX,LV_VAR|GVF_LOCAL_ONLY) >0 ) {
	     if(!Strnicmp("on",gv->buffer,2)) gv->echo = TRUE;
	 }
#ifdef OLD_REDIRECT
	 gv->old_red=0; /* assume new style redirection */
	 if(GetVar("oldredirect",gv->buffer,NMAX,LV_VAR|GVF_LOCAL_ONLY) >0) {
	     if(!Strnicmp("on",gv->buffer,2)) gv->old_red = TRUE;
	 }
#endif
         item = ReadItem(commandname+1, NAMEMAX,FALSE);
 	 commandname[0] = strlen(commandname+1); /* convert to bstr */
	 commandname[commandname[0]+1]=0; /* and null terminate */
         ch = 0;
         if (item) {
            error = DOS_TRUE;
            if (item > 0) {
		rc = 0;	/* preset to can't find command */
		i = -1;
		seg = 0;
		gv->Res2 = 0;
		pipe_expand=FALSE;
		gv->cpos = 0;
		gv->alias[0]=0;
		current_alias = 0;

		/* if the item was unquoted */
		if(item == ITEM_UNQUOTED) {
		    // returns -1 if variable not found
		    i=GetVar(commandname+1,gv->cbuffer,255,LV_ALIAS);
		    /* get pointer to alias  for recursion prevention */
		    if (i >= 0)		// only if we found it...
			    current_alias = FindVar(commandname+1,LV_ALIAS);
		}
		/* or if its not an alias, try variable expansion */
		if(i<0)strcpy(gv->cbuffer,commandname+1);

		// gv->cbuffer has either command or alias in it
		/* trust the alias is null terminated */
		expand(gv,gv->cbuffer,MAXCOMMAND); /* expand variables */
		/* if its not an alias, do backticks before expansion */
		if(!current_alias) {
		    rc = ticks(gv,gv->cbuffer,MAXCOMMAND); /* handle backticks */
		}
		if(item == ITEM_UNQUOTED) { /* if the item was unquoted */
		    for(str=gv->cbuffer; *str; str++)
			if(*str == ' ') {
			    str++; /* skip the space */
		            strcpy(gv->alias,str); /* copy string into buffer */
		 	  			   /* for use later (arguments)*/
			    /* add a space to seperate from first argument */
			    strcat(gv->alias," ");
			    gv->cpos = strlen(gv->alias); /* and set pointer */
			    break;
			}
		}

		/* if the string was quoted, the entire str was command name */
		// else move until space.  FIX! should be until isspace()!
		for(i=1, str=gv->cbuffer;
		    i < NAMEMAX && ((item == ITEM_QUOTED) || (*str != ' '));
		     )
		{
		    commandname[i++]= *str++;
// FIX! should error on commandname too long!
		}
  	        commandname[i]=0;	/* null terminate */

		if(current_alias) {
		    /* to prevent recursion */
		    rc = ticks(gv,commandname+1,NAMEMAX); /* handle backticks */
		    current_alias->lv_Node.ln_Type |= LVF_IGNORE;
		}
	   	commandname[0] = strlen(commandname+1); /* set bstr length */

		module = clip->cli_Module = 0;
		if (rc >= 0)  /* any ticks() call succeeded */
		{
			rc = -9999;	/* preset to can't find command */
	                module=findLoad(gv,commandname+1,&seg,save_pkt,0);
			save_pkt=0;
		} else
			rc = -rc;	// ticks() returned negative of rc
		// if ticks() failed, we'll fall into the error-handling code
		// commandname now has the string: `<command>`

                testflags(SIGBREAKF_CTRL_C);/* clear the control C signal bit */
                if (module <  -1 ) {    /* a script needs an execute */
				 	/* of one sort or another */	
					/* and -1 is an error condition */
		     strins(gv->alias," ");
		     strins(gv->alias,commandname+1);
		     /* switch commandname so startups don't get unhappy */
		     /* cpos is going to always get reset at end */

		     /* if we have a rexx script, we have to treat both */
		     /* quoting conventions and commandline differently */
		     if(module == (-4)) {
			strcpy(commandname+1,"RX");
			/* if we have a homedir */
			/* which indicates we found it via path */
			if(process->pr_HomeDir > 0) {
			 if(NameFromLock(process->pr_HomeDir,gv->cbuffer,108)){
			    if(AddPart(gv->cbuffer,gv->alias,160)) {
/*				strcat(gv->cbuffer," "); */
			        strcpy(gv->alias,gv->cbuffer);
			    }
			 }
			}
		     }
		     else { /* RX has a special problem with "" so skip */
		         if(module == (-5))strcpy(commandname+1,"CD");
			 else if (module == (-6)) {
			    strcpy(commandname+1,"PIPE");
			    pipe_expand=TRUE; /* avoid redirection problems */
			 }
		         else {
			    strcpy(commandname+1,"EXECUTE");
			    /* if we have a homedir */
			    /* which indicates we found it via path */
			    if(process->pr_HomeDir > 0) {
			        strins(gv->alias,"PROGDIR:");
			    }
			 }
			 /* check if we have to double * */
			 for(i=0; i<strlen(gv->alias); i++) {
			     ch=gv->alias[i];
			     /* if the command wasn't quoted, */
			     /* stop at 1st space */
			     if((item != 2)&&(ch==' '))break;
			     if((ch == '*') || (ch == '$') || (ch == '\"')) {
				strins(&gv->alias[i++],"*");
			     }
			 }
			 if(item == 2) {
		     	     strins(gv->alias,"\""); /* handle spaces in arg */
		             strcat(gv->alias,"\"");
			 }
		     }
		     /* this may end up adding two spaces, if the script */
		     /* is part of an alias */
		     
		     if(gv->alias[(gv->cpos=strlen(gv->alias))-1]!=' ') {
			strcat(gv->alias," ");
			gv->cpos++;
		     }
		     commandname[0]=strlen(commandname+1); /* fix b length */

		     /* at this point, commandname contains the command */
		     /* to execute, ie RX, EXECUTE, CD, PIPE */
		     /* and the rest of any alias string is in gv->alias */

		     /* now find the actual command to execute */
                     module = findLoad(gv,commandname+1, &seg,0,TRUE);
		  }
		  if(gv->echo) {
			writef(DOSBase,"%s ",commandname+1);
		  	Flush(Output());
		  }

		  if (module > 2) {
		    clip->cli_Module = module;

		    // kludge to keep 1.3 SetClock from crashing A4000's
		    // 1.3 setclock starts with 48e78080, no later ones do.
		    // Must check for setclock and c:setclock.
#define SAME 0
		    if (((Stricmp(commandname+1,"setclock") != SAME) &&
			 (Stricmp(commandname+1,"c:setclock") != SAME)) ||
			(*(((LONG *) BADDR(module)) + 1) != 0x48e78080))
		    {
                    	if (module)rc = run(gv,module,pipe_expand);
		    } else {
			rc = RETURN_OK;
		    }
		    /* DOS promised unlocking a NULL is harmless */
		    UnLock(process->pr_HomeDir);
		    process->pr_HomeDir=0;
		  }
		 /* undo any redirection the command did */
                  SelectOutput(standardout);
#if 0
		  /* guess what ?  RunCommand returns -1 for can't */
		  /* allocate stack.  We have to use this kludge */
		  /* to attempt to tell this from programs that return -1 */
		  if(rc == (-1)	&& (gv->Res2 == ERROR_NO_FREE_STORE)) {
			rc = -9999;	/* its an internal error */
		  }				
#endif		  
 	          if ((rc == -9999) || (rc == -1)) { /* something went wrong before */
					/* we ran the command */
		      rc = RETURN_ERROR; /* failure */
			/* probably want to print out SHELL */
                      if(!gv->Res2 || (gv->Res2 == ERROR_OBJECT_NOT_FOUND) ||
			 (gv->Res2 == ERROR_DEVICE_NOT_MOUNTED)) {
			   PrintFault(STR_UNKNOWN_COMMAND,commandname+1);/* unknown command */
		      }
	              else { 
			  /* print actual error */
			  PrintFault(gv->Res2,commandname+1);
		      }
		  }
                  gv->Res2 = ((rc == 0) || (gv->Res2 < 0)) ? 0 : gv->Res2;
		  
                  if ((rc>=0) && (rc < clip->cli_FailLevel))error = FALSE;


		  /* if we have an error, and this is a script */
		  /* tell what happened */
// FIX!!!! make this string localized!!!!!!
                  if (error && !(clip->cli_Interactive))
		  {
// since it's commented out in the include files (private)...
		     extern BYTE *DosGetString(LONG num);
#pragma libcall DOSBase DosGetString 3d2 101
		     LONG args[2];

		     args[0] = (LONG) commandname+1;
		     args[1] = rc;
		     VPrintf(DosGetString(STR_FAILED_RETURNCODE),args);
		  }
                  clip->cli_ReturnCode = rc;


		  /* update current values of result variables */
		  setv(gv,&rc);
		  if(current_alias) { /* reset alias so it can be used again */
			current_alias->lv_Node.ln_Type &= ~LVF_IGNORE;
		  }

                  SelectInput (clip->cli_CurrentInput);
		  /* eat anything left over on the line */
                  ch = UnGetC(Input(),-1) ? 0 : '\n';
		  if(!seg) {
                      if(clip->cli_Module)UnLoadSeg(clip->cli_Module);
		  }
		  else {	/* resident program */
		      Forbid();
		      if (((struct Segment *)seg)->seg_UC > 0)
			((struct Segment *)seg)->seg_UC--;
		      Permit();
		  }
                  clip->cli_Module = 0;
                  clip->cli_Result2 = gv->Res2;
            }
            else {
		PrintFault(STR_ERROR_COMMAND,0); /* Error in command name */ 
	    }
         }

	 if(save_pkt) {
     	    ReplyPkt(save_pkt,save_pkt->dp_Res1,save_pkt->dp_Res2);
	    save_pkt=0;
	 }

	 /* eat any extra characters */
	 while ((ch != '\n') && (ch != END_STREAM_CH))ch = FGetC(Input());
 	/* system exit special case taken only if they have played*/
	/* around with the input stream */
         if (((((LONG) fn)& 0x80000004) == 0x80000004) && 
	     (clip->cli_CurrentInput == clip->cli_StandardInput))break;
      } while (ch != END_STREAM_CH);

      /* cleanup code */

#ifdef pdebug
kprintf("in cleanup,fn is %lx, clip is %lx\n",(LONG)fn,(LONG)clip);
#endif
      	if (clip->cli_CurrentInput == clip->cli_StandardInput) {
           /* endcli only if its an interactive CLI */
 	   if((ch == END_STREAM_CH)&&(!clip->cli_Background)) {
		do_end(DOSBase);
	   }
	   /* can we avoid leaving a temp file around ? */
           if(commandfile[0]) {
	     	DeleteFile(commandfile+1);
                commandfile[0] = 0;
	   }
	   break;
      	}
	/* if call is coming via the System() call, stop reading and */
        /* just return */
        else if ((((LONG) fn)& 0x80000004) == 0x80000004) {
            Close(clip->cli_CurrentInput);
	    break;
        }

      	else {
#ifdef pdebug
	kprintf("commandfile, closing input\n");
#endif
         Close(Input());
         if(commandfile[0]) { 
	     DeleteFile(commandfile+1);
             commandfile[0] = 0;
	 }
         clip->cli_CurrentInput = clip->cli_StandardInput;
         clip->cli_FailLevel = CLI_INITIAL_FAIL_LEVEL;
      }
   } while (TRUE);


   if ((LONG)fn < 0) { /* the function pointer is a flag word */
      fh = (struct FileHandle *)BADDR(Output());
	/* note: pos>0 test and setting it to 0 is probably not needed now */
      if ((fh) && (fh->fh_Pos > 0)) {
   	 Flush(Output());
         fh->fh_Pos = 0;
      }

      if (((LONG)fn & 2) == 0) {
#ifdef pdebug
kprintf("close read %lx (%lx)\n",(LONG)Input(),clip->cli_StandardInput);
#endif
	Close(clip->cli_StandardInput);
      }
      if (((LONG)fn & 1) == 1) {
#ifdef pdebug
kprintf("close write %lx (%lx)\n",(LONG)Output(),clip->cli_StandardOutput);
#endif
	 Close(clip->cli_StandardOutput); /* close for writing */
      }
      if ( ((LONG)fn >= 0) || !((LONG)fn&8)) {
#ifdef pdebug
kprintf("replying message, fn is %lx\n",(LONG)fn);
#endif
	ReplyPkt(parm_pkt,clip->cli_ReturnCode,clip->cli_Result2);
      }
   }
   else {
#ifdef pdebug
kprintf("Close read %lx, close write %lx\n",(LONG)Input(),(LONG)Output());
#endif
      if(clip->cli_StandardOutput) {
           Flush(clip->cli_StandardOutput);
           Close(clip->cli_StandardOutput);
      }
      if(clip->cli_StandardInput)Close(clip->cli_StandardInput);
   }
/* we only want to do this if we were started in the 1.3 manner */

cleanup:
#ifdef pdebug
kprintf("now in cleanup\n");
#endif

   if(freeCLI) {

#ifdef pdebug
kprintf("freeing the cli structure\n");
#endif
	/* just in case we got down here due to initial failure */
       tnum =process->pr_TaskNum;
       p = (struct Path *)BADDR(clip->cli_CommandDir);
       while (p) {
          struct Path *next;

      	  next = (struct Path *)BADDR(p->path_Next);
          UnLock(p->path_Lock);
          FreeVec(p);
          p = next;
         }
       for(cl=(struct CliProcList *)((struct RootNode *)
	   DOSBase->dl_Root)->rn_CliList.mlh_Head; cl;
           cl = (struct CliProcList *) cl->cpl_Node.mln_Succ) {
	   	if (tnum <= cl->cpl_First + ((LONG) cl->cpl_Array[0]) - 1) {
		    cl->cpl_Array[tnum - cl->cpl_First + 1] = NULL;
		    break;
	        }
       	   }

       process->pr_Flags =0;
       process->pr_CLI = 0;
   }

#ifdef pdebug
kprintf("currentdir is %lx\n",process->pr_CurrentDir);
#endif

 UnLock(process->pr_CurrentDir);
 process->pr_CurrentDir=NULL;
 if(UtilityBase)CloseLibrary(UtilityBase); /* close this before freeing the ram */

 if(cgv)FreeMem(cgv,sizeof(struct CGlobal));
 if(gv)FreeMem(gv,sizeof(struct Global));

 CloseLibrary((struct Library *)DOSBase);

#ifdef pdebug
kprintf("exit\n");
#endif

 return;
}


/* Find and Load a Command */
/* returns	-1 for error */
/* returns       0 for file not found
/* returns	 1 for file found, execute not set
/* returns	-3 AmigaDOS script
/* returns	-4 for Arexx script
/* returns	-5 for directory to CD into
/* returns	-6 for PIPE */
/* returns	 segment for success
/* seg is set to indicate resident , builtin, or normal commands
/* */

BPTR findLoad(gv,commandname, segment, parm_pkt,status)
struct Global *gv;
UBYTE  *commandname;
LONG *segment;
struct DosPacket *parm_pkt;
BOOL status;
{
   BPTR module = 0;
   LONG firsttime = 2;
   struct Path *p;
   struct DosLibrary *DOSBase=gv->DOSBase;
   struct Library *UtilityBase=gv->UtilityBase;
   struct CommandLineInterface *clip= gv->Clip;
   BOOL dirfound=FALSE;
   int i;
   struct Process *proc = THISPROC;

   if(i=pipecheck(gv,status,"_pchar"))return(i);
   if(i=pipecheck(gv,status,"_mchar"))return(i);

   /* try the resident segment list first */
   /* note: the value of segment is used to flag a resident */
   /* command that isn't unloaded */
 if(*segment = (LONG)useseg(DOSBase,commandname)) {
	module=((struct Segment *)*segment)->seg_Seg;
 }

 /* try the disk */
 else {
   while((--firsttime >=0) && (module==0)) {
   /* try in current directory first (actually, this is trying exactly */
   /*    where they typed */
   if (!module)module = load(gv,commandname,0,segment, (!firsttime));
   if(module==2) {
	dirfound=TRUE;
	module=0; /* keep looking just in case */
   }
   else if (module < -1) {
	/* we found a script via direct path means */
	/* unlocking a null is safe */
	UnLock(proc->pr_HomeDir);
	proc->pr_HomeDir = 0;
   }

   /* search the path */
   /* NOTE: don't want to do this if they specified : or / */

   if(FilePart(commandname) == commandname) {
     p = (struct Path *)BADDR(clip->cli_CommandDir);
     while (!module && p) {
           module = load(gv,commandname, p->path_Lock, segment, FALSE);
	   if(module==2) module=0; /* keep looking */
	   p = (struct Path *)BADDR(p->path_Next);
     }
     /* try c:  */
     if (!module) {
	struct DevProc *dp = NULL;
	struct MsgPort *ftask = GetFileSysTask();
	    do {
	      dp=GetDeviceProc("c:",dp); /* this should bring up a requester */
	      if (dp) {
		 SetFileSysTask(dp->dvp_Port);
		 module=load(gv,commandname,dp->dvp_Lock,segment,(firsttime>0));
		 if(module==2) module=0; /* keep looking */
	      }
	    } while (!module && dp && (dp->dvp_Flags & DVPF_ASSIGN) && 
		IoErr()==ERROR_OBJECT_NOT_FOUND); /* repeat if multi-assign */
	SetFileSysTask(ftask);
	if (dp)FreeDeviceProc(dp);
     }
     if ( module || (IoErr() == 218))break;
   }
   if(parm_pkt) {
#ifdef pdebug
	kprintf("doing the run delayed reply!\n");
#endif
	ReplyPkt(parm_pkt,parm_pkt->dp_Res1,parm_pkt->dp_Res2);
	parm_pkt=0;
    }
   /* special code to handle the case of the new builtins */
   if((!module) && !Strnicmp("c:",commandname,2) ) { /* call it in c: ? */
   if(*segment = (LONG)useseg(DOSBase,FilePart(commandname)))
	return(((struct Segment *)*segment)->seg_Seg);
   }
  }
 }
if(parm_pkt) {	/* handle the delayed run reply case */
#ifdef pdebug
    kprintf("doing the run delayed reply!\n");
#endif
    ReplyPkt(parm_pkt,parm_pkt->dp_Res1,parm_pkt->dp_Res2);
}
if((!module) && dirfound)return(-5); /* they want an implicit cd */
return(module);
}

/* LOAD function */
/* takes filename, directory lock, pointer to return code, quietflag */
/* returns	0 for file not found
/* returns     -1 for problems during load
/* returns     -2 or -3 for script file
/* returns      1 for file found, execute not set
/* returns      2 for directory found
/* returns      segment for success
/*
/* NOTE: a 0 for directory input indicates current directory
/* */

BPTR load(gv,file, ldir, segment, qflag)
struct Global *gv;
UBYTE *file;
BPTR ldir;
LONG *segment;
LONG qflag;
{
   BPTR seg=0;
   LONG res;
   APTR wp;
   BPTR olddir;
   struct Process *tid;
   BPTR dir;
   struct DosLibrary *DOSBase=gv->DOSBase;

   tid = THISPROC;

   wp= tid->pr_WindowPtr;
   if (!qflag)tid->pr_WindowPtr = (APTR)(-1); /* load quietly if requested */

   if(!ldir)dir=tid->pr_CurrentDir;
   else dir=ldir;
   olddir=CurrentDir(dir);
   res = testscript(gv,file,qflag);
   if ( (res == (-1)) || (res == (-2))) {
	seg = LoadSeg(file);
	if(seg) {
#ifdef USE_HOLD
	    /* test if this is a hold and execute module */
   	    if(res == (-2)) {
	    	res = -1; /* we'll return same as standard excutable */
	    	/* Is this name already on the resident list ? */
	    	if(searchsegs(DOSBase,FilePart(file),0) == 0) { /* no... */
	            /* lets add it to the resident list as well */
		    AddSegment(FilePart(file),seg,1);
 		    *segment = (LONG)useseg(DOSBase,FilePart(file)); /* set the flag */
		}
	    }
#endif
	}
	else {
	    gv->Res2=IoErr(); /* loadseg failed */
	    if(gv->Res2 == ERROR_OBJECT_WRONG_TYPE)
		gv->Res2=ERROR_FILE_NOT_OBJECT;  
	}
   }
   else if((res <= -3)) { /* -3 and -4 are scripts */
	tid->pr_HomeDir = DupLock(dir); /* set homedir to the script dir */
   }
   else  {
      /* this will preserve a file found with execute not set */
      /* error for later */
      if(!gv->Res2)gv->Res2 = IoErr();
   }
   if(seg) { /* we loaded the file */
	/* if we have a homedir already, this must be us loading */
        /* the proper script command, execute or RX */
	/* so don't set homedir */
	if(!tid->pr_HomeDir) {
	    dir=Lock(file,SHARED_LOCK);
	    if(dir) {
	        tid->pr_HomeDir = ParentDir(dir);
	        UnLock(dir);
	    }
	}
  	res=seg;
   }
   /* seg of 0 and res -1 means we tried to load */
   else if (res == -1) {
	/* set a reasonable error return */
	/* loadseg says nothing, make something up */
	if(!gv->Res2)gv->Res2=ERROR_FILE_NOT_OBJECT;  
   }

   CurrentDir(olddir);
   if (!qflag) tid->pr_WindowPtr = wp;
   if(res == 1)	{
	gv->Res2=ERROR_FILE_NOT_OBJECT;
	res=0; /* plain file, so we keep looking */ 
   }
   SetIoErr(gv->Res2); /* just in case */
   return(res);
}

/* test type of file
/* return 0 for file not found
/*        2 for directory (ie keep looking)
/*        1 for plain file
/*	 -1 executable
/*	 -2 for hold & execute
/*       -3 for script file
/*       -4 for Arexx script


/* */

int testscript (gv,file,qflag)
struct Global *gv;
UBYTE *file, qflag;
{
   struct DosLibrary *DOSBase=gv->DOSBase;
   struct Library *UtilityBase=gv->UtilityBase; 
   struct FileInfoBlock *exinfo;
   LONG res=0;
   BPTR lock;
   BPTR fh;
   UBYTE buffer[10];

   exinfo = &(gv->ExInfo);
   lock=Lock(file,ACCESS_READ);
   if (lock) {
      res = Examine(lock,exinfo);
      if (res) {
	if (exinfo->fib_DirEntryType >= 0) res = 2;	/* directory */
	else if (exinfo->fib_Protection & FIBF_SCRIPT) {
		res =  - 3;	/* assume AmigaDOS script */
		fh=Open(file,MODE_OLDFILE);
		if(fh) {
		    Read(fh,buffer,2);    
		    if(!Strnicmp(buffer,"/*",2))res = -4; /* no, its arexx */
		    Close(fh);
		}
	}
        else if ( (exinfo->fib_Protection & FIBF_EXECUTE) == 0) {
#ifdef USE_HOLD
	    /* check if this execute file is a hold and execute type */
	    if( (exinfo->fib_Protection & FIBF_PURE) &&
		(exinfo->fib_Protection & FIBF_HOLD)) res = -2;
	    else
#endif
		 res = -1; /* its a plain executable */
	}
        else res =  1;	/* plain file */
      }
      UnLock(lock);
   }
   else { /* if not already another error */
	if(gv->Res2 !=ERROR_FILE_NOT_OBJECT)gv->Res2 = IoErr();
   }
   return(res);
}

/* run a command on the current process */

LONG run(gv,module,pipe_expand)
struct Global *gv;
BPTR module; 
BOOL pipe_expand;
{
   BPTR termout;
   BPTR termin;
   BPTR stdin =  (BPTR)(-1);
   BPTR stdout =  (BPTR)(-1);

   LONG rc;
   int c;
   int ch;
   int lastch = ' ';	/* initialize to space so redirection is allowed */
/* State indicates parsing state. <0 -> in quotes, >0  out of quotes,
   =0 -> in comment */
   int state = 1;

   UBYTE stdvec[NAMEMAX+1];

   struct DosLibrary *DOSBase=gv->DOSBase;
   struct CommandLineInterface *clip= gv->Clip;
   struct Process *process= THISPROC; /* ProcessID(); */
#if 0
   struct FileHandle *fh;
   BPTR orig_buf;
   LONG orig_pos,orig_end;
#endif
   APTR ctask;
   BOOL past_begin=pipe_expand; /* flag to indicate whether the line */
				/* processing has started used to handle */
				/* the run redirect case.  If a pipe */
				/* expansion was performed, don't allow */
				/* new redirection */
   LONG pos=0;	
   UBYTE *private_buffer = gv->cbuffer;
   termin = clip->cli_StandardInput;
   termout = Output(); /* initialize to pr_COS */

   gv->count =0;	/* start processing the line at beginning */
   gv->fill = 0;

   /* take care of leading spaces and tabs */
   do {
      ch = getchar(gv,0);
      if((ch != ' ') && (ch != '\t'))break;
   } while (DOS_TRUE);

/*
   We now read the rest of the line and place it into a buffer.
   This is passed to runcommand to be made available to the calling
   program. We also patch up the scb so that programs calling the
   character interface read the command tail as part of their input.
   Note that the stdin stream is either a new input file; or it
   is from the terminal. In either case there are no characters
   buffered within the stream buffer at this time. Programs running
   under the CLI must not close stdin so we can safely replace the
   SCB buffer with a private one, filled with the command line.
   If stdin is new then the buffer pointer will be overwritten when
   the command line is exhausted. If stdin is the terminal then
   reads will use the replacement buffer instead.
   State indicates parsing state. <0 -> in quotes, >0  out of quotes,
   =0 -> in comment

*/

	while (TRUE) {
	    c=ch;
	    switch ((int)ch) {
		case ';':		/* comment character */
		    if (state > 0) state = 0;
			goto nextl;
		case '"':		/* quoted values */
			if(lastch != '*')state = -state;
			goto nextl;
		case '+':		/* maybe a trailing plus */
			if (getchar(gv,lastch) == '\n')c = '\n';
			else ungetchar(gv);
			goto nextl;

		case '>':
#ifdef OLD_REDIRECT
		    if((state <= 0) || (stdout > 0) || 
			((lastch != ' ') && !gv->old_red))goto nextl;
		    if(past_begin && ((module==gv->run_module) ||
			(module==gv->pipe_module)||(module==gv->set_module)||
			(gv->old_red)))goto nextl;
#else
		    if((state <= 0) || (stdout > 0) || (lastch != ' '))
			goto nextl;
		    if(past_begin && ((module==gv->run_module) ||
			(module==gv->pipe_module)||(module==gv->set_module)))
			goto nextl;
#endif
		    ch = getchar(gv,0);
 	  	    if (ch != '>') ungetchar(gv);
 		    if(readitem(gv,stdvec) <= 0 ) {
			ch=' ';
			goto nextl;
		    }
       		    if (ch == '>') {
	                stdout = openf(gv,stdvec,ACTION_FINDUPDATE);
		        if(stdout)Seek(stdout,0,1);
		    }
	            if(stdout <=0 ) { /* still don't have a redirect */
	                stdout = openf(gv,stdvec,ACTION_FINDOUTPUT);
		    }
	            /* need error check on open here */
		    if (stdout==0) {
			/* unable to open redirection file */
			return(Err(gv,ERROR_REDIRECT,stdin,stdout)); 
		    }
		    ch=' ';
		    goto nextch;
		case '<':
#ifdef OLD_REDIRECT
		    if( (state <= 0) || (stdin > 0) || 
			((lastch != ' ') && !gv->old_red))goto nextl;
		    if(past_begin && ((module==gv->run_module) ||
			(module==gv->pipe_module)||(module==gv->set_module)||
			(gv->old_red)))goto nextl;
#else
		    if( (state <= 0) || (stdin > 0) || (lastch != ' '))
			goto nextl;
		    if(past_begin && ((module==gv->run_module) ||
			(module==gv->pipe_module)||(module==gv->set_module)))
			goto nextl;
#endif
		    ch = getchar(gv,0);
		    if (ch != '>')ungetchar(gv);
	   	    if(readitem(gv,stdvec) <= 0 ) {
			ch=' ';
			goto nextl;
		    }
	  	    if(ch == '>') {
			stdin=openf(gv,stdvec,ACTION_FINDINPUT);
			if(stdin) {
			    ctask=process->pr_ConsoleTask;
			    process->pr_ConsoleTask=
			      (APTR)((struct FileHandle *)BADDR(stdin))->fh_Type;
			    stdout=Open("*",ACTION_FINDOUTPUT);
			    if (!stdout)
				SetIoErr(ERROR_REDIRECT);
			    process->pr_ConsoleTask=ctask;
			}
		    }
	  	    else stdin = openf(gv,stdvec,ACTION_FINDINPUT);
		    /* return unable to open redirection file */
		    if(stdin==0)return(Err(gv,ERROR_REDIRECT,stdin,stdout)); 
		    ch=' ';
		    goto nextch;

		default:
nextl:
		if (!state)break;
		if((ch != ' ')&&(ch != '\t'))past_begin=TRUE;

		case '\n':
		case ENDSTREAMCH:
		    private_buffer[pos++] = c;
		    if (pos > MAXCOMMAND) {
				/* command too long */
			return(Err(gv,ERROR_COMMAND_LONG,stdin,stdout));
		    }
		    if ((ch == '\n') || (ch == ENDSTREAMCH))goto endwhile2;
		} /* switch */
nextch:
		/* is the * escaped ? */
		if((ch == '*')&&(lastch=='*'))lastch=0;
		else lastch = ch;
		ch=getchar(gv,lastch);
	}

endwhile2:
		/* terminate string as CSTR */

		if(pos)private_buffer[pos-1]=10; /* rc requires a nl */
						 /* zap the endstream ? */
		private_buffer[pos] = '\0';

		/* Set up defaults for stdin and stdout */
		if ((LONG)stdin < 0) stdin = termin;
		if ((LONG)stdout < 0)stdout = termout;

		/* private buffer is always null-terminated */
		/* pos contains the length now */
		expand(gv,private_buffer,MAXCOMMAND); /* expand variables */
	 	/* handle embedded commands */
		pos=ticks(gv,private_buffer,MAXCOMMAND);
		if(gv->echo) {
		    writef(DOSBase,"%s",private_buffer);
		    Flush(Output());
		}
		if (pos >= 0)	// ticks() succeeded
		{
			/* attempt to run the command */
			SelectInput(stdin);
			SelectOutput(stdout);
			SetIoErr(0);
			SetSignal(0,SIGBREAKF_CTRL_C); /* clear the user sig */
 		        rc=RunCommand(module,4*(clip->cli_DefaultStack),
				private_buffer,pos);
			gv->Res2=IoErr(); /* save IoErr for later */
		} else {
			// ticks() failed
			rc = -pos;	// returned negative error code
			// gv->Res2 already set
		}
#ifdef pdebug
kprintf("after run,stdin is %lx,termin is %lx, stdout is %lx, termout is %lx\n",
	stdin,termin,stdout,termout);
#endif

		if (stdin != termin) {
#ifdef pdebug
kprintf("closing stdin\n");
#endif
		    Close(stdin);
		}
		if (stdout != termout) {
#ifdef pdebug
kprintf("closing stdout\n");
#endif
		    Close(stdout);
		}
	        return(rc);
}

BPTR openf(gv,name,act)
struct Global *gv;
UBYTE *name;
LONG act;
{

   BPTR s;
   struct DosLibrary *DOSBase=gv->DOSBase;
   expand(gv,name,NAMEMAX);
   s= Open(name,act);
   if (!s)SetIoErr(ERROR_REDIRECT); /* unable to open redirection file */
   return(s);
}

/* print the error and close the streams we opened */

LONG Err(gv,m,si, so)
struct Global *gv;
LONG m;
BPTR si, so;
{
   struct DosLibrary *DOSBase=gv->DOSBase;
   if (si > 0)Close(si);
   if (so > 0)Close(so);
   gv->Res2=m;
   return(-9999);
}

/* return seg pointer if its a resident command or builtin */

struct Segment *useseg(DOSBase,name)
struct DosLibrary *DOSBase;
UBYTE *name;
{
   struct Segment *seg = searchsegs(DOSBase,name,NULL);
   if(seg) {
	Forbid();
	// probably not needed, but for paranoia about the code generator...
	if(seg->seg_UC >=0)seg->seg_UC++;
	Permit();
	if((seg->seg_UC < 0) && ((seg->seg_UC > CMD_BUILTIN)  ||
	    (seg->seg_UC <= CMD_DISABLED)))seg=(struct Segment *)0;
   }
   return(seg);
}

struct Segment *searchsegs(DOSBase,name,startseg)
struct DosLibrary *DOSBase;
UBYTE *name;
struct Segment *startseg;
{
    struct Segment *seg;
//kprintf("searching for %s...",name);
    seg=FindSegment(name,startseg,0);	/* additional commands first */
    if((long)seg==0)seg=FindSegment(name,startseg,TRUE); /* now system stuff */
//kprintf("found $%lx\n",seg);
    return(seg);
}

/* check for control-C */

ULONG testflags(flag)
long flag;
{
return((SetSignal(0,flag) & flag));
}

void __stdargs writef( DOSBase, fmt, args )
struct DosLibrary *DOSBase; 
UBYTE *fmt, *args;
{
   VFWritef( Output(), fmt, (LONG *)&args );
}

int ungetchar(gv)
struct Global *gv;
{
struct DosLibrary *DOSBase=gv->DOSBase;
int res=FALSE;
if((gv->count >= gv->cpos) || gv->fill) {
	if(gv->fill != 1)(gv->count)--;
	res=UnGetC(Input(),-1);
#if 0
	/* check to see if we need to reset fill */
	if(gv->fill) {
            if((ch == ']') && 
		(gv->alias[gv->count] == '[') && (lastch != '*')) {
		}
	}
#endif
}
else if(gv->count > 0) {
    (gv->count)--;
    res=TRUE;
}
return(res);
}

// FIX! what is this used for?
// Alias handling.  Treat the buffer like a stream.
// look for [], when seen grab args
// gv->fill has 3 states: having started, currently sucking, done sucking

int getchar(gv,lastch)
struct Global *gv;
int lastch;
{
struct DosLibrary *DOSBase=gv->DOSBase;
int ch;

/* might want test if gv->cpos is non-zero to see if we have any alias */
if((gv->count < gv->cpos) && (gv->fill != 1)) {
    ch=gv->alias[(gv->count)++];
    if(!gv->fill) {
        if((ch == '[') && (gv->alias[gv->count] == ']') && (lastch != '*')) {
	    gv->fill=1; /* start filling in the string here */
	    gv->count++;
	    goto startfill;
	}
    }
}

else if((gv->count >= gv->cpos) || (gv->fill == 1)) {
startfill:
	ch = FGetC(Input());
	if((ch == '\n') || (ch == ENDSTREAMCH)) {
	    if(gv->fill == 1) {
		/* if there are still any characters left in alias */
		gv->fill=2; /* mark done filling in from the command line */
		if(gv->count < gv->cpos) {
		    gv->alias[gv->cpos++]=ch ; /* save char on end of alias */
		    ch = gv->alias[gv->count]; /* get the next char */
		}
	    }
	}
	if(gv->fill != 1)(gv->count)++; /* keep track for unread */
}
return(ch);
}

// FIX! what the HELL does this routine do?!!  It's totally obtuse!

int readitem(gv,string)
struct Global *gv;
UBYTE *string;
{
struct DosLibrary *DOSBase=gv->DOSBase;
int i,res=1;

/* in a readitem clone, we have to eat leading spaces */
while((gv->fill != 1) && (gv->count < gv->cpos) 
    && (gv->alias[gv->count] == ' '))gv->count++;

if((gv->count < gv->cpos) && (gv->fill != 1)) {
    for(i=0; (gv->count < gv->cpos) && (gv->alias[gv->count] != ' '); i++) {
	string[i]=gv->alias[(gv->count)++];
	if((gv->fill) || ((string[i] == '[') && (gv->alias[gv->count]==']'))) {
	    if(!gv->fill)gv->count++; /* skip the close bracket */
	    res=ReadItem(&string[i], NAMEMAX,FALSE);
	    if(res>0) {
		i +=strlen(string);
		break;
	    }
	}
    }
    string[i]=0;
}
else {
   res=ReadItem(string, NAMEMAX,FALSE);
   if((res>0) && (gv->fill != 1))gv->count +=strlen(string);
}
return(res);
}

LONG ticks(gv,string,mc)
struct Global *gv;
UBYTE *string;
LONG mc;
{
struct DosLibrary *DOSBase=gv->DOSBase;
int i,k,max,st,rc;
int ch,lastch=0;
BPTR file;
UBYTE *buf=gv->buffer;
UBYTE fname[NMAX]="T:tick$XX";
LONG len;
LONG pnum= (LONG)(((struct Process *)(THISPROC))->pr_TaskNum);
struct LocalVar *c_echo=0;
struct TagItem tags[] = {
	SYS_Input, NULL,
	SYS_Output, NULL,
	SYS_UserShell,TRUE,
	TAG_DONE,NULL};

/* need to change escaped backticks to backticks here */

if(!(len=strlen(string)))return(0); /* don't even bother */

if(len > mc)return(len); /* too long to handle */

// FIX! needs to handle more than one set of `...` per line!
for(i=0; i<len; i++) {
  ch=string[i];
  if (ch=='`') {
    if(lastch != '*') { /* we've found start of tick sequence */	
	lastch=0;	/* reset for reuse to find string end */
	st=i;	/* save start found */
        for(i=st+1; i<strlen(string); i++) { /* find other end */
	    ch=string[i];
	    if(ch=='`') {
		if(lastch != '*') {
		    memcpy(buf,&string[st+1],i-st-1); /* got other end, its real */
		    buf[i-st-1]=0;

	            /* build a unique command name */
		    vsprintf(&fname[7],"%ld",&pnum);
		    file=Open(fname,MODE_NEWFILE);
		    if(file) {
			tags[1].ti_Data = file;
			/* if they have echo on, turn it off for now */
			/* because echoing ticks doesn't work so well */
/* FIX!? is this needed? */
			if(gv->echo) {
				c_echo=FindVar("echo",LV_VAR);
			        if(c_echo)c_echo->lv_Node.ln_Type |= LVF_IGNORE;
			}
		        rc = System(buf,tags);
			/* ignore returncodes less than FailAt */
			if ((rc >= 0) && (rc < gv->Clip->cli_FailLevel))
				rc = 0;
			else {
				gv->Res2 = IoErr();
				/* we'll insert output at front later */
				vsprintf(string,"`%s`\n",(LONG *) &buf);
			}

		        Close(file);
		        if(c_echo)c_echo->lv_Node.ln_Type &= ~LVF_IGNORE;

			file=Open(fname,MODE_OLDFILE);
			if(file) {
			    k=Read(file,buf,mc);
			    Close(file);
			    buf[k]=0;
			    if(buf[k-1]=='\n')buf[--k]=0;
			    /* test for a long string */
			    if((max = (len-st+k+ 8 - mc))>0)
				buf[k-max]=0; /* cut it off here */
			    /* replace lf with spaces */
			    for(k=0; k<strlen(buf);k++)if(buf[k]==10)buf[k]=' ';
			    /* remove old string */
			    if (rc == 0)
			    {
				for(k=st; k<len; k++)
					string[k]=string[k+i-st+1];
				strins(&string[st],buf); /* add new one */
			    } else if (*buf) {
			        // write output (if any) from failed cmd
				writef(DOSBase,"%s\n",buf);
			    }
			    DeleteFile(fname);
			}
			/* what do we do about negative returncodes? Fix? */
			if (rc > 0)
			{
			    /* ticked command failed.  return failure (neg) and
			       failed command string (in buffer) */
			    return -rc;
			}
		        return(strlen(string));
		    }
		}
		else {
		    /* blank out the * */	
		    strcpy(&string[i-1],&string[i]);
		    i--;
		}
	    }
	    else if ((ch=='*')&&(lastch=='*'))lastch=0;
  	    else lastch = ch;
	}
      }
      else {
    	strcpy(&string[i-1],&string[i]);
	i--;
      }
  }
  else if ((ch=='*')&&(lastch=='*'))lastch=0;
  else lastch = ch;
}
return(len);	/* nothing to do */
}


/* check for active external pipe/multiple command processor */

int pipecheck(gv,status,type)
struct Global *gv;
BOOL status;
UBYTE *type;
{
   struct DOSLibrary *DOSBase=gv->DOSBase;
   int state = 1; /* State indicates parsing state. <0 -> in quotes, */
		  /* >0  out of quotes,    =0 -> in comment */
   int pstate=1;  /* same for parens */
   int ch;
   int lastch=' ';
   struct FileHandle *fh;
   UBYTE *string;
   UBYTE pbuffer[32];
   int i;

   /* check for pipes if pipechar is active */
   /* and this is the first time through */

   i=(int)GetVar(type,pbuffer,NMAX,LV_VAR|GVF_LOCAL_ONLY);
   if(!status && (i >0)) {
	/* hey, pipes are active */
	if(fh = (void *)BADDR(Input())) {
	    string= (UBYTE *)BADDR(fh->fh_Buf);

	    // scan the characters in the FH buffer!  Be VERY careful to track dos
	    // changes!
	    for(i=fh->fh_Pos; i< fh->fh_End; i++) {
		ch=string[i];
		switch ((int)ch) {
		    case ';':		/* comment character */
			if (state > 0) state = 0;
			break;
		    case '\"':		/* quoted values */
			if(lastch != '*')state = -state;
			break;
		    case '\(':
			if(lastch != '*')pstate = -1; /* in parens */
			break;
		    case '\)':
			if(lastch != '*')pstate = 1; /* and out again */
			break;
		    case '*':
			if(lastch == '*')ch=0;
			break;
		    case '\n':
			// break out of buffer scan if we're not in quotes
			if (state >= 0)
				return(0);
			break;
		    default:
	            if((state>0)&&(pstate>0)&&(pbuffer[0]==ch)&&(lastch==' ')) {
		        if(!pbuffer[1] || 
			   (i < (fh->fh_End-1)) && (pbuffer[1] == string[i+1]))
		           return(-6);
		    }
		}
nextch:
		if(!state)break;
		lastch=ch;
	    }
	}
   }
return(0);
}


/*==============================================================*/
/* Function: prbuf						*/
/*  Purpose: The following stub routine is called from RawDoFmt */
/*	     for each character in the string.	At invocation,	*/
/*	     we have:						*/
/*		D0 - next character to be formatted		*/
/*		A3 - pointer to data buffer			*/
/*==============================================================*/
static void __regargs prbuf(char c)
{
  __builtin_emit(0x16c0);   /* move.b D0,(A3)+ */
}

/*====================================================================*/
/* Function: vsprintf						      */
/*  Purpose: This is a tiny implementation of sprintf.	Note that it  */
/*	     assumes that the buffer is large enough to hold any      */
/*	     formatted string you ask it to generate.		      */
/*====================================================================*/
int vsprintf(char *buf, char *ctl, long args[])
{
  RawDoFmt(ctl, args, prbuf, buf);
  return(strlen(buf));
}


void setv(gv,rc)
struct Global *gv;
LONG *rc;
{
    struct DOSLibrary *DOSBase=gv->DOSBase;
    struct LocalVar *result_var;

    /* update current values of result variables */
    memset((UBYTE *)gv->buffer,0,8);
    /* first let's do RC */
    vsprintf(gv->buffer,"%ld",rc); /* print into the buffer */
    result_var=FindVar("RC",LV_VAR);
    /* if we find the variable and the space it big enough */
    if(result_var && (result_var->lv_Len >= VARMAX))
	memcpy(result_var->lv_Value,gv->buffer,VARMAX);
    else SetVar("RC",gv->buffer,VARMAX,LV_VAR|GVF_LOCAL_ONLY);

    /* now lets handle result2 */
    vsprintf(gv->buffer,"%ld",&gv->Res2);
    result_var=FindVar("Result2",LV_VAR);
    /* if we find the variable and the space it big enough */
    if(result_var && (result_var->lv_Len >= VARMAX))
        memcpy(result_var->lv_Value,gv->buffer,VARMAX);
    else SetVar("Result2",gv->buffer,VARMAX,LV_VAR|GVF_LOCAL_ONLY);
}

/* Function: getargs */
/* Purpose: Open dos.library, do a readargs, return readargs result */

struct RDargs *getargs(db,ub,template,opts,size)
struct Library **db;
struct Library **ub;
UBYTE *template;
LONG *opts[];
int size;
{
    struct Library *DOSBase=TaggedOpenLibrary(OLTAG_DOS);
    struct RDargs *rd=NULL;

    *db = DOSBase;	/* return dosbase */
    if(ub) { 		/* and UtilityBase */
        *ub = TaggedOpenLibrary(OLTAG_UTILITY);
    }
    if(size) {
       memset((char *)opts,0,size);
       if(!(rd=ReadArgs(template,(LONG *)opts,NULL))) {
	   PrintFault(IoErr(),NULL);
       }
    }
    return(rd);
}
@


1.114
log
@Make SetClock kludge return no error (rc was inited to -9999 = unknown
command).
@
text
@d7 2
d43 1
d46 1
d483 1
d488 1
d1022 1
d1033 1
d1119 1
d1123 3
a1125 1
	    else res = -1; /* its a plain executable */
d1220 1
d1226 7
d1254 1
d1260 7
a1266 1

@


1.113
log
@Added code to check for the 1.3 setclock, which crashes A4000's (all '040's?)
@
text
@d645 2
@


1.112
log
@Use TaggedOpenLibrary
@
text
@d635 11
a645 1
                    if (module)rc = run(gv,module,pipe_expand);
@


1.111
log
@Fixed string that needed localization
made it use STR_xxx instead of numbers
fixed piping stuff for andy
@
text
@d7 6
d212 1
a212 1
   DOSBase=(struct DOSLibrary *)OpenLibrary("dos.library",0);
d278 1
a278 1
   UtilityBase=OpenLibrary("utility.library",0);
d1754 1
a1754 1
    struct Library *DOSBase=OpenLibrary("dos.library",36);
d1759 1
a1759 1
        *ub = OpenLibrary("utility.library",36);
@


1.110
log
@Fixed write-to-rom on <> redirection
@
text
@d650 1
a650 1
			   PrintFault(-121,commandname+1);/* unknown command */
d664 1
d666 5
a670 2
                     writef(DOSBase,"%s failed returncode %n\n",commandname+1,
			    rc);
d672 4
d701 1
a701 1
		PrintFault(-122,0); /* Error in command name */ 
d1375 1
d1378 1
d1522 2
d1643 4
a1646 1
	    for(i=0; i< fh->fh_End; i++) {
d1651 1
a1651 1
			goto nextch;
d1654 1
a1654 1
			goto nextch;
d1657 1
a1657 1
			goto nextch;
d1660 1
a1660 1
			goto nextch;
d1663 6
a1668 2
			goto nextch;

@


1.109
log
@Fixed ticks().  Was failing on rc == 0 (normal case)
@
text
@d1227 3
a1229 1
			    stdout=openf(gv,"*",ACTION_FINDOUTPUT);
@


1.108
log
@Fixed enforcer hits at boot (harmless)
use case statement for prompt, also handle %%
Handle ticks() failing (`bad cmd`)
Use ITEM_XXXX instead of random numbers
Make a few things more readable (ugh)
Put in Forbid/Permit around updates of seg_UC!
@
text
@d1410 3
d1537 1
a1537 1
			if ((rc > 0) && (rc < gv->Clip->cli_FailLevel))
d1560 1
a1560 1
			    if (rc <= 0)
@


1.107
log
@varmax to 11
@
text
@d99 1
a99 1
   BPTR (*fn)(struct DosPacket *);
d103 1
a103 1
   LONG init_type;
d213 7
a219 3
   fn = (BPTR (*)(struct DosPacket *))((!parm_pkt) ? NULL:parm_pkt->dp_Type);
   init_type=(parm_pkt->dp_Res1 == 0 ? 0:2)|(parm_pkt->dp_Res2 == 0 ? 0:1);

d429 20
a448 7
              if((ch = ToUpper(prompt[i+1])) == 'S')popts[j++]=(LONG)setname+1;
	      else if(ch=='N')popts[j++]=tnum;
	      else if(ch=='R') {
		    popts[j++]=clip->cli_ReturnCode;
		    gv->alias[i]='n';
	      }
	      else gv->alias[i]=' ';
d453 2
d484 1
a484 1
		rc = -9999;	/* preset to can't find command */
d494 2
a495 1
		if(item == 1) {
d498 2
a499 1
		    current_alias = FindVar(commandname+1,LV_ALIAS);
d504 1
d509 1
a509 1
		    ticks(gv,gv->cbuffer,MAXCOMMAND); /* handle backticks */
d511 11
a521 10
		if(item == 1) { /* if the item was unquoted */
		    for(str=gv->cbuffer; *str; str++)if(*str == ' ') {
			str++; /* skip the space */
		        strcpy(gv->alias,str); /* copy string into buffer */
		 	  		       /* for use later */
			/* add a space to seperate from first argument */
			strcat(gv->alias," ");
		        gv->cpos = strlen(gv->alias); /* and set pointer */
			break;
		    }
d523 9
a531 4
		str=gv->cbuffer;
		/* if the string was quoted, the entire thing was command name */
		for(i=1; i<NAMEMAX && ((item == 2) || (*str != ' '));i++) {
		    commandname[i]= *str++;
d537 1
a537 1
		    ticks(gv,commandname+1,NAMEMAX); /* handle backticks */
d542 10
a551 3
		clip->cli_Module = 0;
                module=findLoad(gv,commandname+1,&seg,save_pkt,0);
		save_pkt=0;
d665 2
a666 1
                     writef(DOSBase,"%s failed returncode %n\n",commandname+1,rc);
d684 1
d687 1
d1278 15
a1292 10

		/* attempt to run the command */
		SelectInput(stdin);
		SelectOutput(stdout);
		SetIoErr(0);
		SetSignal(0,SIGBREAKF_CTRL_C); /* clear the user signal */
 	        rc=RunCommand(module,4*(clip->cli_DefaultStack),
			private_buffer,pos);
		gv->Res2=IoErr(); /* save IoErr for later */

d1349 2
d1352 1
d1409 2
d1448 2
d1488 1
a1488 1
int i,k,max,st;
d1527 1
d1532 10
a1541 1
		        System(buf,tags);
d1557 9
a1565 2
			    for(k=st; k<len; k++)string[k]=string[k+i-st+1];
			    strins(&string[st],buf); /* add new one */
d1567 7
@


1.106
log
@changed varmax to 8
@
text
@d33 1
a33 1
#define VARMAX 8
@


1.105
log
@the script argument code is now correct. (poof)
@
text
@d33 1
a33 1
#define VARMAX 7
@


1.104
log
@subroutine for setting rc & result2
@
text
@d522 1
d525 1
a526 3
		     gv->cpos += commandname[0]+1; /* count space we are*/
						   /* going to add on end */
			
d536 1
a536 1
				strcat(gv->cbuffer," ");
a537 1
			        gv->cpos = strlen(gv->cbuffer);
a553 1
			        gv->cpos += 8;
d563 1
a563 3
				strins(&gv->alias[i],"*");
				gv->cpos++;
				i++;
a568 1
			     gv->cpos += 2; /* allow for the quotes */
d571 7
a577 1
		     strcat(gv->alias," ");
d579 5
@


1.103
log
@switched to SetVar if not enough space for the return variables.
@
text
@a105 1
   struct LocalVar *result_var;
a398 1

d401 1
a401 3
   vsprintf(gv->buffer,"0",&tnum);
   SetVar("RC",gv->buffer,VARMAX,LV_VAR|GVF_LOCAL_ONLY);
   SetVar("Result2",gv->buffer,VARMAX,LV_VAR|GVF_LOCAL_ONLY);
d403 3
a405 1
  do {
d631 1
a631 17
		  memset((UBYTE *)gv->buffer,0,8);
		  /* first let's do RC */
		  vsprintf(gv->buffer,"%ld",&rc); /* print into the buffer */
		  result_var=FindVar("RC",LV_VAR);
		  /* if we find the variable and the space it big enough */
		  if(result_var && (result_var->lv_Len >= VARMAX))
		      memcpy(result_var->lv_Value,gv->buffer,VARMAX);
	          else SetVar("RC",gv->buffer,VARMAX,LV_VAR|GVF_LOCAL_ONLY);

		  /* now lets handle result2 */
		  vsprintf(gv->buffer,"%ld",&gv->Res2);
                  result_var=FindVar("Result2",LV_VAR);
		  /* if we find the variable and the space it big enough */
		  if(result_var && (result_var->lv_Len >= VARMAX))
		      memcpy(result_var->lv_Value,gv->buffer,VARMAX);
		  else SetVar("Result2",gv->buffer,VARMAX,LV_VAR|GVF_LOCAL_ONLY);

d1608 26
@


1.102
log
@added a min test to the copy variable routine
stopped terminating arexx commands early
@
text
@d634 2
d637 7
a643 5
		  if(result_var) {
			vsprintf(gv->buffer,"%ld",&rc);
			memcpy(result_var->lv_Value,gv->buffer,
				MIN(VARMAX,result_var->lv_Len));
		  }
d645 5
a649 5
		  if(result_var) {
			vsprintf(gv->buffer,"%ld",&gv->Res2);
			memcpy(result_var->lv_Value,gv->buffer,
				MIN(VARMAX,result_var->lv_Len));
		  }
@


1.101
log
@fixed return code packet stuff compatibly with 1.3
for early exit condition.
@
text
@d401 6
a406 6
	vsprintf(gv->buffer,"%ld",&tnum);
       	SetVar("process",gv->buffer,VARMAX,LV_VAR|GVF_LOCAL_ONLY);
	vsprintf(gv->buffer,"0",&tnum);
        SetVar("RC",gv->buffer,VARMAX,LV_VAR|GVF_LOCAL_ONLY);
	SetVar("Result2",gv->buffer,VARMAX,LV_VAR|GVF_LOCAL_ONLY);
        error=0;
d409 3
a411 3
	    setname[setname[0]+1]=0; /* null terminate the bstrings */
	    prompt[prompt[0]+1]=0;
	    commandname[0]=0; /* ready for next command */
a417 1

d539 1
a539 1
				strcat(gv->cbuffer,"\n");
d541 1
a541 1
			        gv->cpos += strlen(gv->cbuffer);
a635 1

d637 2
a638 1
			memcpy(result_var->lv_Value,gv->buffer,VARMAX);
d643 2
a644 1
			memcpy(result_var->lv_Value,gv->buffer,VARMAX);
@


1.100
log
@does the unlock here, rather than in newshell of
early failure, which prevents the newshell from having
to do two different things on the same return code.
@
text
@d212 5
d248 2
a249 3
		/* so cleanup takes place properly */
	    process->pr_CurrentDir = (BPTR)parm_pkt->dp_Arg1;
       	    ReplyPkt(parm_pkt,-1,ERROR_NO_FREE_STORE); /* give out of memory reply */
a271 2
   /* dp_Type will be CPTR to bcpl function */
   fn = (BPTR (*)(struct DosPacket *))((!parm_pkt) ? NULL:parm_pkt->dp_Type);
a288 1
        init_type=(parm_pkt->dp_Res1 == 0 ? 0:2)|(parm_pkt->dp_Res2 == 0 ? 0:1);
d301 2
a302 1
    		ReplyPkt(parm_pkt,NULL,NULL); /* so reply now */
a309 7

#if 0
	    /* this kludge for 1.3 newcli command is removed, 
	    now that DOS handles it for me */
	    if(!parm_pkt->dp_Arg3)parm_pkt->dp_Arg3=clip->cli_CommandDir;
#endif

d322 1
d593 3
a595 4
		    if(process->pr_HomeDir) {
			UnLock(process->pr_HomeDir);
			process->pr_HomeDir=0;
		    }
d760 3
d792 1
a798 1
 
d865 2
a866 1
	if(proc->pr_HomeDir)UnLock(proc->pr_HomeDir);
@


1.99
log
@returning -1 in packet for system use.  This means I'm
changing programs of -1 to ERROR_RETURN.
@
text
@d243 2
@


1.98
log
@fixed early error return to give error indication so
applications can clean up
@
text
@d243 1
a243 1
       	    ReplyPkt(parm_pkt,20,103); /* give out of memory reply */
d602 1
a602 1

d606 1
a606 1
		  if(rc == (-1) && (gv->Res2 == ERROR_NO_FREE_STORE)) {
d608 3
a610 3
		  }					
		  
 	          if (rc == -9999) { /* something went wrong before */
@


1.97
log
@uses the new universal getargs routine to save space
@
text
@d215 2
d220 1
a227 2

	freeCLI = FALSE; /* DOS will do it for us */
d234 1
a234 1
       	freeCLI = TRUE;
a237 3

	    FreeMem(gv,sizeof(struct Global));

d243 2
a244 3
       	    ReplyPkt(parm_pkt,0,0);
	    CloseLibrary((struct Library *)DOSBase);
	    return;
d254 1
a254 1

@


1.96
log
@same as above
@
text
@a66 2
#define UtilityBase gv->UtilityBase

d88 1
a88 1

d267 1
d840 1
d1035 1
a1041 1

d1625 25
@


1.95
log
@made up for the Arexxsize change by switching from stri_d to
a simple sprintf
@
text
@d408 1
a408 1
       	SetVar("process",gv->buffer,i,LV_VAR|GVF_LOCAL_ONLY);
@


1.94
log
@saves space by calling ToUpper once
@
text
@d69 5
d407 1
a407 1
	i=MIN(stci_d(gv->buffer,tnum),VARMAX);
d409 1
a409 2

	memset((UBYTE *)gv->buffer,0,8);
d474 2
a476 1
		rc = -9999;	/* preset to can't find command */
d481 1
a481 3
		i=GetVar(commandname+1,gv->cbuffer,255,LV_ALIAS);
		/* get pointer to alias  for recursion prevention */
		current_alias = FindVar(commandname+1,LV_ALIAS);
d483 7
a489 1
		/* if its not an alias, try variable expansion */
d644 2
a645 1
		  	stci_d(gv->buffer,rc); /* return status in process vars */
d650 1
a650 1
			stci_d(gv->buffer,gv->Res2);
d803 1
a803 1
 CloseLibrary(UtilityBase); /* close this before freeing the ram */
d1455 1
d1482 1
a1482 2
  		    stci_d(&fname[7],(int)((struct Process *)
						(THISPROC)->pr_TaskNum));
d1597 28
@


1.93
log
@fixes the redirection problem when using aliases in scripts
@
text
@d67 1
a84 1
   struct Library *UtilityBase;
a263 1
   gv->UtilityBase=UtilityBase;
a264 1

d430 3
a432 3
              if(ToUpper(prompt[i+1])=='S')popts[j++]=(LONG)setname+1;
	      else if(ToUpper(prompt[i+1])=='N')popts[j++]=tnum;
	      else if(ToUpper(prompt[i+1])=='R') {
d792 2
d797 1
a797 1
 CloseLibrary(UtilityBase);
a830 1
   struct Library *UtilityBase=gv->UtilityBase;
a1024 1
   struct Library *UtilityBase=gv->UtilityBase;
@


1.92
log
@fixed rexx current dir stuff so kludges can me
taken out of Arexx, and the world made wonderful.
@
text
@d1374 1
a1374 1
if(((gv->count < gv->cpos) && (gv->fill == 0)) || (gv->fill == 2)) {
d1411 4
a1414 4
while((gv->count < gv->cpos) && (gv->alias[gv->count] == ' ')){
	gv->count++;
}
if(gv->count < gv->cpos) {
d1430 1
a1430 1
   if(res>0)gv->count +=strlen(string);
@


1.91
log
@arexx currentdir fix; part of the 3 part plan
to keep the definition of interactive the same,
yet still allow arexx redirection.
@
text
@a114 3
     BPTR scriptdir = 0;
     BPTR savedir;
     BPTR tmp;
a116 2


d357 1
a357 1
   process->pr_HomeDir = 0;
a383 1

d391 8
a474 2
		scriptdir = -1; /* assume no script */
		savedir = 0;
d517 1
a517 1
                module=findLoad(gv,commandname+1,&seg,&scriptdir,save_pkt,0);
d529 3
a531 1
		     
d534 10
a543 4
			/* and don't CD to the directory */
                        if (scriptdir >=0 ) {
			    UnLock(scriptdir);
			    scriptdir= (-1);
d552 9
a560 2
		         else strcpy(commandname+1,"EXECUTE");

d581 2
a582 6

                     module = findLoad(gv,commandname+1, &seg, &tmp,0,TRUE);
                     if ((module > 2) || seg) {
                  	if(scriptdir >= 0)
			    savedir=CurrentDir(scriptdir);/* cd to script */
		     }
a591 5
                    if (scriptdir >=0 ) { /* if script restore dir */
		        savedir=CurrentDir(savedir); 
		        if(savedir)UnLock(savedir);
		    }

d820 1
a820 1
BPTR findLoad(gv,commandname, segment, sd, parm_pkt,status)
a823 1
BPTR *sd;
d835 1
d852 1
a852 1
   if (!module)module = load(gv,commandname,0,segment,sd, (!firsttime));
d857 5
d869 1
a869 1
           module = load(gv,commandname, p->path_Lock, segment,sd, FALSE);
d881 1
a881 1
		 module=load(gv,commandname,dp->dvp_Lock,segment,sd,(firsttime>0));
d927 1
a927 1
BPTR load(gv,file, ldir, segment, sd, qflag)
a931 1
BPTR *sd;	/* used to return where the command was found */
d972 1
a972 1
	*sd = DupLock(dir); /* save for script dir */
a977 1
      *sd = (-1);
a979 1
	/* if homedir were used instead of scriptdir, */
d983 1
d989 1
d1303 2
a1304 2
struct Segment *useseg(db,name)
struct DosLibrary *db;
a1306 1
   struct DosLibrary *DOSBase=db;
d1316 2
a1317 2
struct Segment *searchsegs(db,name,startseg)
struct DosLibrary *db;
a1320 1
    struct DosLibrary *DOSBase=db;
d1335 2
a1336 2
void __stdargs writef( db, fmt, args )
struct DosLibrary *db; 
a1338 1
   struct DosLibrary *DOSBase=db;
@


1.90
log
@fixed the shell unable to open redirection file.
when used in an alias.  The problem was that
the fillin code wasn't checking for end of alias
when it was done filling, but was assuming at least one
extra character.
@
text
@d67 7
d85 1
a85 3
/*
   struct Library *SysBase = ( *((struct Library **) 4) );
*/
a403 1
	str="0" "\x00" "\x00" "\x00" "\x00" "\x00" "\x00" "\x00";
d405 3
a407 2
        SetVar("RC",str,VARMAX,LV_VAR|GVF_LOCAL_ONLY);
	SetVar("Result2",str,VARMAX,LV_VAR|GVF_LOCAL_ONLY);
d422 1
a422 1
         SelectOutput(standardout);
d441 1
a441 1
            VFWritef( Output(), gv->alias, (LONG *)&popts );
d493 1
d530 8
a537 1
		     if(module == (-4))strcpy(commandname+1,"RX");
d591 1
a591 1

d1094 1
a1094 1
   termout = Output();
a1323 3
/*
struct Library *SysBase = ( *((struct Library **) 4) );
*/
d1340 1
a1340 1
if((gv->count > gv->cpos) || gv->fill) {
d1344 5
a1348 2
	if(gv->fill) { /* check to see if we need to reset fill */
	    if(gv->count == gv->cpos)gv->fill=0;
d1367 1
a1367 1
if(((gv->count <= gv->cpos) && (gv->fill == 0)) || (gv->fill == 2)) {
d1373 1
d1378 2
a1379 1
if((gv->count > gv->cpos) || (gv->fill == 1)) {
d1385 1
a1385 1
		if(gv->count <= gv->cpos) {
d1404 5
a1408 3
while((gv->count <= gv->cpos) && (gv->alias[gv->count] == ' '))gv->count++;
if(gv->count <= gv->cpos) {
    for(i=0; (gv->count <= gv->cpos) && (gv->alias[gv->count] != ' '); i++) {
@


1.89
log
@initialized the initial RC and Result2 properly
@
text
@d490 1
d536 3
a1225 1

d1368 6
a1373 3
		gv->fill=2; /* done filling */
		gv->alias[gv->cpos++]=ch ; /* save char	on end of alias */
		ch = gv->alias[gv->count]; /* get the next char */
d1387 3
d1406 1
a1406 3
   if(res>0) {
      gv->count +=strlen(string);
   }
@


1.88
log
@added special test for active command file during the endcli
case.  It attempts to delete it in that case. 
@
text
@d399 4
a402 2
        SetVar("RC",     "0        ",VARMAX,LV_VAR|GVF_LOCAL_ONLY);
	SetVar("Result2","0        ",VARMAX,LV_VAR|GVF_LOCAL_ONLY);
@


1.87
log
@changed the system emergency exit to handle multiple commands on a line
@
text
@d309 2
a310 3
/*	    this kludge for 1.3 newcli command is removed, 
	    now that DOS handles it for me
*/
d638 1
a638 1
		PrintFault(-122,0); /* Error in command name */
d653 1
a653 1
      	 } while (ch != END_STREAM_CH);
d661 1
a661 1
           /* endcli only if its a CLI */
d665 5
d684 4
a687 2
         if(commandfile[0])DeleteFile(commandfile+1);
         commandfile[0] = 0;
d693 1
a1241 4
/*
		SelectInput(cis);
		SelectOutput(cos);
*/
@


1.86
log
@makes sure system doesn't read from currentinput
even if one of Bill Whawes's commands does something nasty
@
text
@d650 6
a655 3
/*         if ((((LONG) fn)& 0x80000004) == 0x80000004)break; /* system exit */
      	 } while ((ch != END_STREAM_CH) && 
		(((((LONG) fn)& 0x80000004) != 0x80000004)));
@


1.85
log
@fixed the ungetc problem when reading doing an ungetc during
an alias fill.
@
text
@d650 3
a652 1
      	 } while (ch != END_STREAM_CH);
d658 1
a658 1
      if (clip->cli_CurrentInput == clip->cli_StandardInput) {
d664 1
a664 2
	}

d667 1
a667 1
       else if ((((LONG) fn)& 0x80000004) == 0x80000004) {
d670 3
a672 2
       }
      else {
@


1.84
log
@fixed no-lf on startup bug
don't let neg string values out anymore
@
text
@a1092 1

d1102 1
a1102 1
			if (getchar(gv,lastch) == '\n') c = '\n';
d1318 1
a1318 1
	(gv->count)--;
d1320 5
@


1.83
log
@needed to cat a space after an alias or it doesn't
work right.
@
text
@d596 2
a597 1
                  gv->Res2 = (rc == 0) ? 0 : gv->Res2;
a1030 3
/*
   struct Library *SysBase = ( *((struct Library **) 4) );
*/
d1170 1
a1170 1
		    if (pos >= MAXCOMMAND) {
a1184 1
		private_buffer[pos] = '\0';
d1188 1
a1189 1

a1209 12
#if 0
/* this code is moving into DOS, so RunCommand becomes cleaner */

		fh = (struct FileHandle *) BADDR(stdin); /* save old handle */
		orig_buf = fh->fh_Buf;
		orig_pos = fh->fh_Pos;
		orig_end = fh->fh_End;

		fh->fh_Buf = TOBUFFER(private_buffer);
		fh->fh_Pos = 0;
		fh->fh_End = pos;
#endif
a1212 9

#if 0
		/* fix the filehandle */
		UnGetC(stdin,-1); /* let DOS adjust the filehandle */

		if(fh->fh_Buf == TOBUFFER(private_buffer))fh->fh_Buf = orig_buf;
		fh->fh_Pos = orig_pos;
		if (fh->fh_End)fh->fh_End = orig_end;
#endif
@


1.82
log
@fixed SAS startup compatibility bug by keeping commandname
valid even during implicit commands
Also, fixed the hang during newshell with missing startup.
@
text
@d489 2
a490 1
		        gv->cpos = strlen(str); /* and set pointer */
d500 1
d518 1
d540 5
a544 3
		     	 strins(gv->alias,"\""); /* handle spaces in arg */
		         strcat(gv->alias,"\"");
			 gv->cpos++; /* allow for the quotes */
d548 1
a548 6
#if 0
		     if(gv->echo) {
			    writef(DOSBase,"%s ",commandname+1);
		  	    Flush(Output());
		     }
#endif
a549 1

a554 3
#if 0
		  else 
#endif
d1187 2
d1191 1
a1191 1
		private_buffer[pos] = '\0';
@


1.81
log
@fixed 1.3 NEWSHELL/NEWCLI crash bug
@
text
@a101 1
     UBYTE *comstr;
a199 1

d323 1
a323 1
kprintf("BOOT, fn returned is %lx\n",fn);
d326 1
d334 4
d339 8
a346 6
kprintf("delay doing the Reply\n");
#endif
		/* mark this reply to be performed after we've tried to */
		/* loadseg.  This will prevent grinding when running */
		/* commands from scripts. */
		save_pkt=parm_pkt;
d350 1
a350 1
kprintf("bailing out!\n");
d515 5
a519 1
		     if(module == (-4))comstr="RX";
d521 1
a521 1
		         if(module == (-5))comstr="CD";
d523 1
a523 1
			    comstr="PIPE";
d526 2
a527 1
		         else comstr="Execute";
d539 1
a539 1
			 gv->cpos += 2; /* allow for the quotes */
d542 2
a543 1
		     gv->cpos += commandname[0]+1; /* count space */
d545 1
a545 1
			    writef(DOSBase,"%s ",comstr);
d548 2
a549 2

                     module = findLoad(gv,comstr, &seg, &tmp,0,TRUE);
d556 4
a559 1
		  else if(gv->echo) {
d563 1
d675 1
a675 1
kprintf("commandfile, closing input\n");
d1176 1
a1176 1
		    if (pos > MAXCOMMAND) {
d1192 1
@


1.80
log
@stopped callung UnGetC to correct filehandle
@
text
@d268 1
d294 3
d354 1
a355 1
   tnum =process->pr_TaskNum;
d716 2
a726 1

a735 1

d739 3
@


1.79
log
@fixed memoration hit by moving selectoutput to
before I printfault.
@
text
@d1207 2
d1211 1
a1211 1
#if 0
@


1.78
log
@removed file handle buffer swapping code around runcommand, as this
code as migrated into dos itself.
@
text
@d559 2
d581 2
a582 1
/*                  else {	/* maybe it worked */
a583 2
                     gv->Res2 = (rc == 0) ? 0 : gv->Res2;
                     if ((rc>=0) && (rc < clip->cli_FailLevel))error = FALSE;
d585 4
a588 6
                     SelectOutput(standardout);
		     /* if we have an error, and this is a script */
		     /* tell what happened */
                     if (error && !(clip->cli_Interactive))
                        writef(DOSBase,"%s failed returncode %n\n",commandname+1,rc);
/*		  } */
d608 1
@


1.77
log
@was using the wrong buffer for expansion
and wasn't expanding variables in redirection properly.
@
text
@d668 1
d1033 1
a1034 1

d1037 1
a1175 6
		fh = (struct FileHandle *) BADDR(stdin); /* save old handle */
		orig_buf = fh->fh_Buf;
		orig_pos = fh->fh_Pos;
		orig_end = fh->fh_End;


a1184 4
		fh->fh_Buf = TOBUFFER(private_buffer);
		fh->fh_Pos = 0;
		fh->fh_End = pos;

a1188 1

d1191 13
d1209 1
d1213 1
@


1.76
log
@changed test for 2.0 run to something that doesn't upset
mungwall...now tests for a 0 segarray 4, rather than
a nonzero segarray 3
@
text
@d203 1
a203 1
 kprintf("\n----------------------\nStarting shell rev %ld\n",REVISION);
d477 1
a477 1
		    for(str=gv->buffer; *str; str++)if(*str == ' ') {
a481 1

d1241 1
@


1.75
log
@added small kludge to always give a newline on end
of strings passwd to runcommand
@
text
@d271 12
a282 4

	    /* if 1.4 run have to change its seglist */
   	    if ( (seg = ((LONG *)BADDR(process->pr_SegList))[3]) ) {
	        ((LONG *)BADDR(process->pr_SegList))[4] = seg;
d284 1
a284 2
   		}
   	    seg=0;
d580 1
a580 1
                  else {	/* maybe it worked */
d590 1
a590 1
		  }
@


1.74
log
@registered parameter switch to save space
@
text
@a26 6
#if 0
#include "clib/exec_protos.h"
#include "clib/dos_protos.h"
#include "clib/intuition_protos.h"
#endif

d105 2
a106 1
     LONG ch;
a330 2
/*		ReplyPkt(parm_pkt,parm_pkt->dp_Res1,arm_pkt->dp_Res2); */

a414 9
#if 0
              if((prompt[i+1]=='s') || (prompt[i+1]=='S'))popts[j++]=(LONG)setname+1;
	      else if((prompt[i+1]=='n') || (prompt[i+1]=='N'))popts[j++]=tnum;
	      else if((prompt[i+1]=='r') || (prompt[i+1]=='R')) {
		    popts[j++]=clip->cli_ReturnCode;
		    gv->alias[i]='n';
	      }
	      else gv->alias[i]=' ';
#endif
a469 3
#if 0
		    if(str=strchr(gv->cbuffer,' ')) { /* found a space */
#endif
a518 9
#if 0
			 while (str) {
			    if(str=strchr(str,'*')) {
				strins(str,"*");
				gv->cpos++;
				str += 2;
			    }
			 }
#endif
a605 1

d628 1
a628 2
      } while (ch != END_STREAM_CH);

d1014 3
a1016 3
   UBYTE c;
   UBYTE ch;
   UBYTE lastch = ' ';	/* initialize to space so redirection is allowed */
d1150 1
a1150 3
			/* command too long */
			if (ch == '\n' || ch == ENDSTREAMCH)
				goto endwhile2;
d1161 1
d1317 1
a1317 1
UBYTE getchar(gv,lastch)
d1319 1
a1319 1
UBYTE lastch;
d1322 1
a1322 1
UBYTE ch;
a1354 1

d1385 1
a1385 1
UBYTE ch,lastch=0;
d1483 2
a1484 2
   char ch;
   char lastch=' ';
@


1.73
log
@improved escaping code for execute files with funny characters in them
@
text
@d27 2
d30 2
a31 2
#include "proto/exec.h"
#include "proto/intuition.h"
a72 7
extern char getchar();
extern struct Segment *useseg();

extern int firstlink();
extern int secondlink();


d84 1
d86 1
d124 3
d171 3
d203 2
a204 1
(link_setenv) };
d370 1
a370 1
	for(i=0; i<30; i++)
d617 1
a617 1
		  memset((char *)gv->buffer,0,8);
a986 1

d1035 3
d1121 1
a1121 1
 		    if(readitem(gv,stdvec, NAMEMAX, FALSE) <= 0 ) {
d1148 1
a1148 1
	   	    if(readitem(gv,stdvec, NAMEMAX,FALSE) <= 0 ) {
d1260 1
a1260 1
char *name;
a1274 1
/* UBYTE *m;  */
d1289 1
a1289 1
char *name;
d1303 1
a1303 1
char *name;
d1312 1
a1312 6
/*
struct Process *ProcessID()
{
return((struct Process *)(*((struct ExecBase **)4))->ThisTask);
}
*/
d1315 1
a1315 1
int testflags(flag)
d1318 4
a1321 1
return( (SetSignal(0,flag) & flag) );
d1324 1
a1324 1
void writef( db, fmt, args )
d1326 1
a1326 1
char *fmt, *args;
d1348 1
a1348 1
char getchar(gv,lastch)
d1350 1
a1350 1
char lastch;
d1353 1
a1353 1
char ch;
d1382 1
a1382 1
char *string;
d1412 1
a1412 1
char *string;
d1417 1
a1417 1
char ch,lastch=0;
d1419 2
a1420 2
char *buf=gv->buffer;
char fname[NMAX]="T:tick$XX";
d1518 2
a1519 2
   char *string;
   char pbuffer[32];
d1529 1
a1529 1
	    string= (char *)BADDR(fh->fh_Buf);
@


1.72
log
@fixed progdir properly; previous fix had left the
error message 'not an excutable' out of the
normal returns.
@
text
@d411 8
d426 1
a467 1

a476 1

d482 1
d484 2
d489 2
d523 9
a531 1

d534 1
a534 2
			 /* check if we have to double * */
			 str=gv->alias;
d542 1
a546 1

@


1.71
log
@fixed progdir problem
@
text
@a557 1

a889 1

d905 5
a909 1
	else gv->Res2=IoErr(); /* loadseg failed */
a912 2
/* homedir could probably replace the scriptdir variable */
/*	tid->pr_HomeDir = DupLock(dir); */
d915 3
a917 1
      gv->Res2 = IoErr();
d932 2
a933 1
   else if (res == -1) { /* seg of 0 and res -1 means we tried to load */
d941 4
a944 1
   if(res == 1)	res=0; /* plain file, so we keep looking */ 
d1000 3
a1002 1
   else gv->Res2 = IoErr();
@


1.70
log
@moved strings into dos
@
text
@d890 1
a891 1
   olddir=CurrentDir(dir);
d911 2
a917 2
   CurrentDir(olddir);
   if (!qflag) tid->pr_WindowPtr = wp;
d919 9
a927 5
	dir=Lock(file,SHARED_LOCK);
	if(dir) {
	    tid->pr_HomeDir = ParentDir(dir);
	    UnLock(dir);
	}
d935 3
@


1.69
log
@changed to _pchar
@
text
@d45 3
a443 1

@


1.68
log
@changed pipechar variable to p-ch variable
@
text
@d780 2
a781 2
   if(i=pipecheck(gv,status,"p-char"))return(i);
   if(i=pipecheck(gv,status,"m-char"))return(i);
@


1.67
log
@fixed problem with multiple redirections in aliases
@
text
@d780 2
a781 1
   if(i=pipecheck(gv,status))return(i);
a1028 6

/* BPTR cis,cos;
   cis=Input();
   cos=Output();
*/

d1180 1
d1465 3
a1467 1
int pipecheck(gv,status)
d1470 1
d1486 1
a1486 1
   i=(int)GetVar("pipechar",pbuffer,NMAX,LV_VAR|GVF_LOCAL_ONLY);
@


1.66
log
@fixed memoration hit
fixed escape processing in script name
fixed backtick escaping
fixed alias/backtick processing
@
text
@a1063 1

a1081 1

d1134 1
a1134 1
		past_begin=TRUE;
@


1.65
log
@fixed error message when can't open redirection file
@
text
@d85 1
d217 1
d262 4
d417 2
a418 2
	    expand(gv,gv->alias);	/* take care of variables in prompt */
	    ticks(gv,gv->alias); /* handle a command in prompt if present */
d435 1
a435 1
	     if(!strnicmp("on",gv->buffer,2)) gv->echo = TRUE;
d439 1
a439 1
	     if(!strnicmp("on",gv->buffer,2)) gv->old_red = TRUE;
d466 6
a471 1
		expand(gv,gv->cbuffer); /* expand variables */
d485 5
a489 3

		/* to prevent recursion */
		if(current_alias)current_alias->lv_Node.ln_Type |= LVF_IGNORE;
d512 9
a541 1

d556 1
d563 2
a564 3

/*		  if (rc == -9998)rc=RETURN_ERROR; /* we printed already */
 	          else if (rc == -9999) { /* something went wrong before */
d567 1
a710 2


d740 1
d775 1
a776 3
   struct FileHandle *fh;
   char *string;
   char pbuffer[32];
a778 34
   int state = 1; /* State indicates parsing state. <0 -> in quotes, */
		  /* >0  out of quotes,    =0 -> in comment */
   int pstate=1;  /* same for parens */
   char ch;
   char lastch=' ';

   /* check for pipes if pipechar is active */
   /* and this is the first time through */
   i=1;
   pbuffer[0]='|';
/*    i=(int)GetVar("pipechar",pbuffer,NMAX,LV_VAR|GVF_LOCAL_ONLY); */

   if(!status && (i >0)) {
	/* hey, pipes are active */
	if(fh = (void *)BADDR(Input())) {
	    string= (char *)BADDR(fh->fh_Buf);
	    for(i=0; i< fh->fh_End; i++) {
		ch=string[i];
		switch ((int)ch) {
		    case ';':		/* comment character */
			if (state > 0) state = 0;
			goto nextch;
		    case '\"':		/* quoted values */
			if(lastch != '*')state = -state;
			goto nextch;
		    case '\(':
			if(lastch != '*')pstate = -1; /* in parens */
			goto nextch;
		    case '\)':
			if(lastch != '*')pstate = 1; /* and out again */
			goto nextch;
		    case '*':
			if(lastch == '*')ch=0;
			goto nextch;
d780 1
a780 13
		    default:
	            if((state>0)&&(pstate>0)&&(pbuffer[0]==ch)&&(lastch==' ')) {
		        if(!pbuffer[1] || 
			   (i < (fh->fh_End-1)) && (pbuffer[1] == string[i+1]))
		           return(-6);
		    }
		}
nextch:
		if(!state)break;
		lastch=ch;
	    }
	}
   }
a791 1

d836 1
a836 1
   if((!module) && !strnicmp("c:",commandname,2)) { /* call it in c: ? */
d950 2
a951 1
   struct DosLibrary *DOSBase;
d958 1
a958 1
   DOSBase=gv->DOSBase;
d970 1
a970 1
		    if(!strnicmp(buffer,"/*",2))res = -4; /* no, its arexx */
d1067 1
a1067 1
			if((lastch != '*') && (state > 0)) state = 0;
d1076 1
d1172 3
a1174 2
		expand(gv,private_buffer); /* expand variables */
		pos=ticks(gv,private_buffer); /* handle embedded commands */
a1243 1
/*   PrintFault(m,"SHELL error "); */
a1245 2
/*   return (-9998); */
/*   SetIoErr(m); */
d1377 1
a1377 1
LONG ticks(gv,string)
d1380 1
d1383 1
a1383 1
int i,j,k,max;
d1396 9
a1404 5
    if(!(len=strlen(string)))return(0); /* don't even bother */
    if(len > MAXCOMMAND)return(len); /* too long to handle */
    for(i=0; i<len; i++) {
      ch=string[i];
      if ((ch=='`') && (lastch !='*')) { /* start of tick sequence */
d1406 7
a1412 5
        for(j=i+1; j<strlen(string); j++) { /* find other end */
	    ch=string[j];
	    if((ch=='`') && (lastch != '*')) {
		    memcpy(buf,&string[i+1],j-i-1); /* got other end, its real */
		    buf[j-i-1]=0;
d1432 1
a1432 1
			    k=Read(file,buf,MAXCOMMAND);
d1437 1
a1437 1
			    if((max = (len-i+k+ 8 - MAXCOMMAND))>0)
d1442 2
a1443 2
			    for(k=i; k<len; k++)string[k]=string[k+j-i+1];
			    strins(&string[i],buf); /* add new one */
d1449 8
a1456 2
        if((ch == '*')&&(lastch=='*'))lastch=0;
        else lastch = ch;
d1459 8
a1466 3
    if((ch == '*')&&(lastch=='*'))lastch=0;
    else lastch = ch;
    }
d1470 4
a1473 3
/*
printmem(string)
UBYTE *string;
d1475 52
a1526 4
if(string)kprintf("%s...",string);
kprintf("Chip is %ld, Fast is %ld\n",AvailMem(MEMF_CHIP),
	AvailMem(MEMF_FAST) );
	return(0);
a1527 2
*/

@


1.64
log
@changed some error messages to PrintFaults
@
text
@a1269 1

d1273 2
a1274 1
   SetIoErr(m);
@


1.63
log
@changed strings to use dos internal strings
@
text
@d210 1
a210 1
   process = ProcessID();
d908 2
a909 1
   tid = ProcessID();
d911 1
a911 3
 

   if (!qflag)tid->pr_WindowPtr = (APTR)(-1);	/* load quietly if requested */
d1039 1
a1039 1
   struct Process *process=ProcessID();
d1270 1
a1270 1
   SetIoErr(m);
d1274 1
d1305 1
a1305 1

d1310 1
a1310 1

d1437 1
a1437 1
						(ProcessID())->pr_TaskNum));
@


1.62
log
@did additional work on low memory error messages.
turns out loadseg returns some errors
Also corrected state machine for pipechar external jumpout
@
text
@d240 1
a240 1
       	    ReplyPkt(parm_pkt,-1,-1);
a277 3
#ifdef pdebug
kprintf("fn returned is %lx\n",(ULONG)fn);		
#endif
d291 1
d294 1
d296 1
a296 1
*/
a298 3
#ifdef pdebug
kprintf("fn returned is %lx\n",(ULONG)fn);
#endif
d428 1
a428 1
	 if(GetVar("echo",gv->buffer,31,LV_VAR|GVF_LOCAL_ONLY) >0 ) {
d432 1
a432 1
	 if(GetVar("oldredirect",gv->buffer,31,LV_VAR|GVF_LOCAL_ONLY) >0) {
d452 3
a454 22
		  if(commandname[1] == '$') {
		     i=GetVar(commandname+2,gv->cbuffer,255,LV_VAR);
		     current_alias = 0;
		  }
		  else {
		     i=GetVar(commandname+1,gv->cbuffer,255,LV_ALIAS);
		     /* get pointer to alias  for recursion prevention */
		     current_alias = FindVar(commandname+1,LV_ALIAS);
		  }
		  if( i > 0 ) {
		      /* trust the alias is null terminated */
		      expand(gv,gv->cbuffer); /* expand variables */
		      if(str=strchr(gv->cbuffer,' ')) { /* found a space */
			    strcpy(gv->alias,str); /* copy string into buffer */
						   /* for use later */
			    gv->cpos = strlen(str); /* and set pointer */
		      }
		      str=gv->cbuffer;
		      for(i=1; i<31 && (*str != ' ');i++) {
				commandname[i]= *str++;
		      }
		      commandname[i]=0;	/* null terminate */
d456 26
a481 9
		      /* to prevent recursion */
		      if(current_alias)
		 	 current_alias->lv_Node.ln_Type |= LVF_IGNORE;
		  }
	   	 commandname[0] = strlen(commandname+1); /* set bstr length */

		 clip->cli_Module = 0;
                 module=findLoad(gv,commandname+1,&seg,&scriptdir,save_pkt,0);
		 save_pkt=0;
d483 4
a486 4
                 testflags(SIGBREAKF_CTRL_C);/* clear the control C signal bit */
                 if (module <  -1 ) {    /* a script needs an execute */
				 	 /* of one sort or another */	
					 /* and -1 is an error condition */
d542 1
a542 1
		  if (rc == -9998)rc=RETURN_ERROR; /* we printed already */
d770 1
a771 2
   i=(int)GetVar("pipechar",pbuffer,31,LV_VAR|GVF_LOCAL_ONLY);

d791 3
d907 1
a907 3
#if 0
   LONG ioerr=0;
#endif
d1095 1
a1095 1
			if (state > 0) state = 0;
d1177 3
a1179 1
		lastch = ch;
d1270 2
a1271 1
   PrintFault(m,"SHELL error ");
d1274 2
a1275 1
   return (-9998);
d1410 2
a1411 1
int i,j,k;
d1414 1
a1414 1
char fname[31]="T:tick$XX";
d1426 3
a1428 1
    if ((string[i]=='`') && !(i && (string[i-1]=='*'))) { /* start of tick */
d1430 3
a1432 3
	        if ((string[j]=='`') && (string[j-1] != '*')) {
		    /* got other end, its real */
		    memcpy(buf,&string[i+1],j-i-1);
d1434 2
d1441 3
a1443 1
  			if(gv->echo) {
d1453 2
a1454 1
			    k=Read(file,buf,127);
d1457 4
a1460 1
			    Close(file);
d1470 2
d1473 3
a1476 1
  }
@


1.61
log
@fixes the low memory error reporting problems
doesn't evaluate the prompt in background mode
protected pipechar external pipe callout better.
@
text
@d432 1
a432 1
	 if( (i=GetVar("echo",gv->buffer,31,LV_VAR|GVF_LOCAL_ONLY))>0 ) {
d436 1
a436 1
	 if( (i=GetVar("oldredirect",gv->buffer,31,LV_VAR|GVF_LOCAL_ONLY))>0) {
d490 3
a492 3

                  if (module <  0 ) {   /* a script needs an execute */
				 	/* of one sort or another */	
d762 1
a763 1
   char *string;
d766 5
d774 6
a779 1
   if(!status && GetVar("pipechar",pbuffer,2,LV_VAR|GVF_LOCAL_ONLY) >0) {
d783 22
a804 6

	    for(i=1; i< fh->fh_End; i++) {
	        if((pbuffer[0]==string[i]) && (string[i-1] == ' ')) {
		    if(!pbuffer[1] || 
			(i < (fh->fh_End-1)) && (pbuffer[1] == string[i+1]))
		        return(-6);
d806 3
a924 1

d927 10
a936 12
#if 0
	/* reinstall when DOS returns correct error codes */
	ioerr=IoErr();
#endif
	/* test if this is a hold and execute module */
   	if(res == (-2)) {
	    res = -1; /* we'll return same as standard excutable */
	    /* Is this name already on the resident list ? */
	    if(searchsegs(DOSBase,FilePart(file),0) == 0) { /* no... */
	        /* lets add it to the resident list as well */
		AddSegment(FilePart(file),seg,1);
 		*segment = (LONG)useseg(DOSBase,FilePart(file)); /* set the flag */
d939 1
d941 1
a941 1
   else if((res <= -3)) {
d944 4
a947 1
   else *sd = (-1);
a948 1

d958 4
a961 7
   if(res == 1 || ((res == -1) && !seg)) { /* plain file or couldn't load */
	if(!seg)gv->Res2=ERROR_FILE_NOT_OBJECT;
	else {
	    gv->Res2 = IoErr();
	    res=0; /* plain file, so we keep looking */
	}
        SetIoErr(gv->Res2);
d963 2
@


1.60
log
@new debugging message added
@
text
@d106 1
d372 2
d396 1
d401 1
d419 1
d452 1
a452 1

d486 1
a486 2

                 module=findLoad(gv,commandname+1,&seg,&scriptdir,save_pkt);
d495 1
a495 1
		     else {
d497 4
d502 1
d515 1
a515 1
                     module = findLoad(gv,comstr, &seg, &tmp,0);
d529 1
a529 1
                    if (module)rc = run(gv,module);
d540 8
d562 1
d564 2
a565 1
                     if (rc < clip->cli_FailLevel)error = FALSE;
d567 3
a569 1
                     if (error &&  !(clip->cli_Interactive))
d737 1
d743 1
d748 1
a748 1
BPTR findLoad(gv,commandname, segment, sd, parm_pkt)
d754 1
d761 3
d765 18
d858 1
d931 4
a934 1
	else gv->Res2 = IoErr();
a935 1
	res=0; /* see if this does it so we keep looking */
d996 1
a996 1
LONG run(gv,module)
d999 1
d1024 6
a1029 3
   BOOL past_begin=FALSE; /* flag to indicate whether the line processing */
			 /* has started used to handle the run redirect case */
   LONG pos=0;
d1086 3
a1088 1
			(module ==gv->set_module) || (gv->old_red)))goto nextl;
d1113 3
a1115 1
			(module ==gv->set_module) || (gv->old_red)))goto nextl;
@


1.59
log
@fixes memoration hit , as much as shell can; the rest
is in DOS, which is also being handled (dealocation of taskid)
@
text
@d42 3
a112 1
     LONG res2 = 0;
d197 1
d236 4
a239 1
    	    ReplyPkt(parm_pkt,-1,-1);
a380 1

d424 1
d427 1
a427 1
	     if(!strnicmp("on ",gv->buffer,3)) gv->echo = TRUE;
d429 4
d443 1
a443 1
		res2 = 0;
d481 1
a481 1
                 module=findLoad(gv,commandname+1,&res2,&seg,&scriptdir,save_pkt);
d505 1
a505 1
                     module = findLoad(gv,comstr,&res2, &seg, &tmp,0);
a519 2
                    getr2(gv,&res2);

d530 3
a532 2

 	          if (rc == -9999) {	/* something went wrong */
d534 3
a536 3
		      getr2(gv,&res2); /* find out why */
                      if(!res2) {
			   PrintFault(-121,commandname+1); /* unknown command */
d539 2
a540 2
		          /* "Unable to load %s: ",commandname+1); */
			  PrintFault(res2,commandname+1);/* or print -120 */
d544 1
a544 1
                     res2 = (rc == 0) ? 0 : IoErr();
d550 1
d563 1
a563 1
			stci_d(gv->buffer,res2);
d581 1
a581 1
                  clip->cli_Result2 = res2;
d724 1
a724 1
BPTR findLoad(gv,commandname, res2, segment, sd, parm_pkt)
a726 1
LONG *res2;
d751 1
a751 1
   if (!module)module = load(gv,commandname,0,segment,sd, res2, (!firsttime));
d763 1
a763 1
           module = load(gv,commandname, p->path_Lock, segment,sd, res2, FALSE);
d775 1
a775 1
		 module=load(gv,commandname,dp->dvp_Lock,segment,sd,res2,(firsttime>0));
d820 1
a820 1
BPTR load(gv,file, ldir, segment, sd, codep, qflag)
a825 1
LONG *codep;
d835 3
a837 2
 

d852 4
d883 3
a885 2
	*codep = 121; /* not an object module */
        SetIoErr(*codep);
a887 1

d941 1
d945 1
a945 9
void getr2(gv,codep)
struct Global *gv;
LONG *codep;
{
   struct DosLibrary *DOSBase=gv->DOSBase;
   LONG r2 = IoErr();
      if ((r2 != ERROR_OBJECT_NOT_FOUND)&&(r2 != ERROR_DEVICE_NOT_MOUNTED))
 	(*codep) = r2;
}
a949 1

d1030 4
a1033 3
		    if((state <= 0) || (stdout > 0) || (lastch != ' '))goto nextl;
		    if(past_begin && (module==gv->run_module) ||
			(module ==gv->set_module))goto nextl;
d1049 2
a1050 1
			return(Err(gv,-118,stdin,stdout)); 
d1055 4
a1058 3
		    if( (state <= 0) || (stdin > 0) || (lastch != ' '))goto nextl;
		    if(past_begin && (module==gv->run_module) ||
			(module ==gv->set_module))goto nextl;
d1076 2
a1077 1
		    if(stdin==0)return(Err(gv,-118,stdin,stdout)); 
d1090 2
a1091 1
			return(Err(gv,-124,stdin,stdout)); 
d1116 1
a1116 1
		/* pirvate buffer is always null-terminated */
d1136 1
d1176 1
a1176 1
   if (!s)SetIoErr(-118); /* unable to open redirection file */
d1180 2
d1189 1
a1189 1
   PrintFault(m,"SHELL error "); /*   "SHELL error: %s\n", m); */
d1192 1
a1192 1
   return (-9999);
@


1.58
log
@fixed the alias redirection problem found by BJ
Added a missing ReplyPkt so run wouldn't hang any more
@
text
@d207 3
a209 5
   gv = (struct Global *)AllocMem(sizeof(struct Global),MEMF_PUBLIC|MEMF_CLEAR);
   if(!gv) {
	CloseLibrary((struct Library *)DOSBase);
	return;	/* no memory */
   }
d212 5
a216 4
   if(process->pr_CLI) { /* for 1.4 we have a CLI process structure */
#ifdef pdebug
kprintf("we are given a CLI structure\n");
#endif
d221 3
a223 3
#ifdef pdebug
kprintf("building a CLI structure\n");
#endif
d228 1
d230 4
d285 4
d290 1
d297 1
a297 9
	else { /* we need to clean up , maybe do an alert*/
	    goto cleanup;
#ifdef oldexit
	    if(cgv)FreeMem(cgv,sizeof(struct CGlobal));
   	    FreeMem(gv,sizeof(struct Global));
	    CloseLibrary((struct Library *)DOSBase);
	    return;
#endif
	}
d316 3
a327 1

d366 3
d1379 1
@


1.57
log
@added a ReplyPkt to handle command too long bug in run
@
text
@d340 1
d342 2
a349 1

d355 1
a355 1
   /* the pipe command and the run command need special treatment */
a357 3
/* I may have to switch to a string compare, unless pipe gets built in too */
/* or else not cache these values */

d360 2
a361 5
/*
   if(thiseg=searchsegs(DOSBase,"pipe",0))
	gv->pipe_module=((struct Segment *)thiseg)->seg_Seg;
*/
   Permit();
d1020 2
a1021 1
		    if((module == gv->run_module) && past_begin)goto nextl;
d1043 2
a1044 1
		    if((module == gv->run_module) && past_begin)goto nextl;
@


1.56
log
@now depends on getvar returning a null terminated string for an alias
@
text
@d39 3
d456 3
a458 1
		      for(i=1; i<31 && (*str != ' ');i++)commandname[i]= *str++;
d477 1
a477 1
		     if(module == (-3))comstr="RX";
d479 1
a479 1
		         if(module == (-4))comstr="CD";
d575 1
a575 1
/*
d578 1
d580 1
a580 1
*/
d705 3
a707 1
/* returns	-2 or -3 for script
d728 2
d740 1
a740 1
   if (!module)module = load(gv,commandname,0,sd, res2, (!firsttime));
d752 1
a752 1
           module = load(gv,commandname, p->path_Lock, sd, res2, FALSE);
d764 1
a764 1
		 module=load(gv,commandname,dp->dvp_Lock,sd,res2,(firsttime>0));
d794 1
a794 1
if((!module) && dirfound)return(-4); /* they want an implicit cd */
d809 1
a809 1
BPTR load(gv,file, ldir, sd, codep, qflag)
d813 1
d839 14
a852 2
   if (res == (-1))seg = LoadSeg(file);
   else if((res <= -2)) {
d856 1
d865 1
a865 2
        CurrentDir(olddir);
	return(seg);
a866 2
   
   CurrentDir(olddir);
d881 3
a883 2
/*       -2 for script file
/*       -3 for Arexx script
d908 1
a908 1
		res =  - 2;	/* assume AmigaDOS script */
d912 1
a912 1
		    if(!strnicmp(buffer,"/*",2))res = -3; /* no, its arexx */
d916 6
a921 1
        else if ( (exinfo->fib_Protection & FIBF_EXECUTE) == 0)res = -1;
@


1.55
log
@limit test added on getvar
@
text
@d416 1
a416 1
	     if(!strnicmp("on",gv->buffer,i)) gv->echo = TRUE;
d445 3
a447 4
			if(i>255)i=255;
			gv->cbuffer[i]=0; /* null terminate the alias */
			expand(gv,gv->cbuffer); /* expand variables */
			if(str=strchr(gv->cbuffer,' ')) { /* found a space */
d451 4
a454 4
			}
			str=gv->cbuffer;
			for(i=1; i<31 && (*str != ' ');i++)commandname[i]= *str++;
			commandname[i]=0;	/* null terminate */
d456 3
a458 3
			/* to prevent recursion */
			if(current_alias)
			           current_alias->lv_Node.ln_Type |= LVF_IGNORE;
@


1.54
log
@fixed state machine bug (needed to set lastch to space)
@
text
@a348 2
   gv->run_module=((struct Segment *)FindSegment("run",0,TRUE))->seg_Seg;
   /* also, need to save off pipe module */
d350 12
d445 1
d571 1
d575 1
@


1.53
log
@there was a path out of findload where the msg would not get replied.
this is now fixed.  I've added an extra safety check at the
bottom of the main loop as well; this can probably be removed
after investigation
@
text
@d989 1
d1003 1
d1007 1
d1011 1
d1026 1
@


1.52
log
@put in variable expansion in prompt, fixed it so you
can use a variable as a command, straightened out
the variables in alias.

put in error checking on bad format strings for prompt.
fixed up redirection so it works anywhere on the line.
(has a special case for run)
@
text
@a366 1
/*	    current_alias = NULL; /* reset alias safety flag */
a367 1

d453 1
d556 3
a558 1
            else PrintFault(-122,0); /* Error in command name */
d560 4
d708 3
a710 11
   if(*segment = (LONG)useseg(DOSBase,commandname)) {

    if(parm_pkt) {
#ifdef pdebug
kprintf("its a run delayed reply!\n");
#endif
	ReplyPkt(parm_pkt,parm_pkt->dp_Res1,parm_pkt->dp_Res2);
    }
	return(((struct Segment *)*segment)->seg_Seg);
   }
  /* try the disk */
d712 3
a714 1
  while((--firsttime >=0) && (module==0)) {
a751 1

d754 1
a754 1
	kprintf("its a run delayed reply!\n");
d757 1
a758 1

a763 3



d765 7
@


1.51
log
@good time to checkin...redirection now works anywhere
on the line; run had to be special cased, though.
Also, run now doesn't return the packet until after
the shell makes it through the first loadseg pass
@
text
@a38 2
#define pdebug 1

a321 7
#ifdef oldexit
		FreeMem(gv,sizeof(struct Global));
		if(cgv)FreeMem(cgv,sizeof(struct CGlobal));
		CloseLibrary((struct Library *)DOSBase);
		Forbid();
		RemTask(0);
#endif
d350 1
a350 1
kprintf("run is at %lx\n",gv->run_module);
d367 1
a367 1
	    current_alias = NULL; /* reset alias safety flag */
d389 1
d392 1
d427 10
a436 2
		  if((i=GetVar(commandname+1,gv->cbuffer,255,LV_ALIAS)) >0 ) {
			current_alias = FindVar(commandname+1,LV_ALIAS);
d438 1
a438 1

d447 1
a447 1
			/* get pointer to alias */
a451 4

		 expand(gv,commandname+1); /* expand variables */
		 /* need to handle spaces and moving leftover to arguments */

a701 2
kprintf("in findload, parmpkt is %lx\n",parm_pkt);

d911 1
a911 1
   UBYTE lastch = 0;
d926 2
a927 2
   BOOL char_rest=FALSE;

d965 1
d980 1
d982 2
a983 2
		    if((state <= 0) || (stdout > 0))goto nextl;
		    if((module == gv->run_module) && char_rest)goto nextl;
d986 1
a986 1
 		    if(readitem(gv,stdvec, NAMEMAX, FALSE) <= 0 )
d988 1
d997 4
a1000 1
		    if(stdout==0)return(Err(gv,-118,stdin,stdout)); 
d1002 1
a1002 1
		    if( (state <= 0) || (stdin > 0))goto nextl;
d1005 1
a1005 1
	   	    if(readitem(gv,stdvec, NAMEMAX,FALSE) <= 0 )
d1007 1
d1020 2
d1025 1
a1025 1
		char_rest=TRUE;
a1328 1

@


1.50
log
@fixed cleanup path for unable to start shell;  It used to
just close the library and free memory, leaving the
process hanging around.  Now, I put it through the normal
cleanup code.
@
text
@d39 2
d100 1
a100 1

d203 1
d311 6
a316 1
		ReplyPkt(parm_pkt,parm_pkt->dp_Res1,parm_pkt->dp_Res2);
d358 3
d437 1
d439 4
a442 4
			    strcpy(gv->alias,str); /* copy string in buffer */
			    
			    gv->cpos = strlen(str);
				}   
d444 1
a444 2
			for(i=1; i<31 && (*str != ' ');i++)
				commandname[i]= *str++;
a445 1
	   	        commandname[0] = strlen(commandname+1); /* bstr */
a446 1

d449 1
a449 1
			    current_alias->lv_Node.ln_Type |= LVF_IGNORE;
d452 10
a461 4
		  clip->cli_Module = 0;
                  module= findLoad(gv,commandname+1,&res2,&seg,&scriptdir);
                  testflags(SIGBREAKF_CTRL_C);
                  if (module <  0 ) { /* a script needs execute */
d463 2
d482 2
a483 1
                     module = findLoad(gv,comstr,&res2, &seg, &tmp);
d493 1
a566 2
cleanup:

d633 3
d671 1
a671 1
 FreeMem(gv,sizeof(struct Global));
d690 1
a690 1
BPTR findLoad(gv,commandname, res2, segment, sd)
d696 1
d705 2
d708 8
a715 1
   if(*segment = (LONG)useseg(DOSBase,commandname))
d717 1
a717 1

d722 2
a723 1
   /* try in current directory first */
d758 8
a767 1

d771 3
d931 1
a931 1
/*   BPTR cis,cos; */
d937 3
a939 1
/*
d946 2
a948 2
      if((stdin == 0) || (stdout == 0)) return( Err(gv,IoErr(),stdin,stdout));

d950 1
a950 44
      switch ((int)ch) {
      case ' ':
      case '\t':
         continue;
      case '>':
         if (stdout > 0) break;
         ch = getchar(gv,0);
	 if (ch != '>') ungetchar(gv);
	 if(readitem(gv,stdvec, NAMEMAX, FALSE) <= 0 ) {
		break; 
	 }
         if (ch == '>') {
            stdout = openf(gv,stdvec,ACTION_FINDUPDATE);
	    if(stdout)Seek(stdout,0,1);
         }
         if(stdout <=0 ) { /* still don't have a redirect */
            stdout = openf(gv,stdvec,ACTION_FINDOUTPUT);
         }
         continue;
      case '<':
         if (stdin > 0)break;
	 ch = getchar(gv,0);
	 if (ch != '>')ungetchar(gv);
	 if(readitem(gv,stdvec, NAMEMAX,FALSE) <= 0 ) {
		break; 
	 }
	 if(ch == '>') {
		stdin=openf(gv,stdvec,ACTION_FINDINPUT);
		if(stdin) {
		    ctask=process->pr_ConsoleTask;
		    process->pr_ConsoleTask=
			(APTR)((struct FileHandle *)BADDR(stdin))->fh_Type;
		    stdout=openf(gv,"*",ACTION_FINDOUTPUT);
		    process->pr_ConsoleTask=ctask;
		}
	 }
	 else stdin = openf(gv,stdvec,ACTION_FINDINPUT);
         continue;

      default:
         goto breaklabel2;
      }
      return (Err(gv,-119, stdin, stdout)); /* changed to syntax error */
					   /* was too many > or < */
a952 3

breaklabel2:

d970 1
a970 1
		while (TRUE) {
d972 1
a972 1
			c=ch;
d974 45
a1018 11
			switch ((int)ch) {
			case ';':		/* comment character */
				if (state > 0) state = 0;
				goto nextl;
			case '"':		/* quoted values */
				if(lastch != '*')state = -state;
				goto nextl;
			case '+':		/* maybe a trailing plus */
				if (getchar(gv,lastch) == '\n') c = '\n';
				else ungetchar(gv);
			default:
d1020 2
a1021 1
			if (!state)break;
d1023 14
a1036 10
			case '\n':
			case ENDSTREAMCH:
			    private_buffer[pos++] = c;
			    if (pos > MAXCOMMAND) {
				return(Err(gv,-124,stdin,stdout)); 
			    }
				/* command too long */
				if (ch == '\n' || ch == ENDSTREAMCH)
					goto endwhile2;
			} /* switch */
a1037 3
			lastch = ch;
			ch=getchar(gv,lastch);
		}
@


1.49
log
@fixed the >31 char redirect again.  (this time for real)
found another place where nmax was used instead of namemax.
@
text
@d192 1
a192 1
/*
d194 2
a195 1
*/
d226 1
d229 1
d285 2
d291 1
d307 1
a307 1
	    if (IoErr() != (LONG)(THISPROC) ) {
d311 6
d322 1
d325 1
d428 1
d547 3
d551 1
a551 1
kprintf("in cleanup,fn is %lx\n",(LONG)fn);
d560 1
a563 3
#ifdef pdebug
kprintf("system call try to close input\n");
#endif
a605 1
       Flush(clip->cli_StandardOutput);
d609 5
a613 3
       Close(clip->cli_StandardOutput);
       Close(clip->cli_StandardInput);

@


1.48
log
@minor changes
@
text
@a898 1
	        SetIoErr(-119); /* "syntax error" */
a913 1
	        SetIoErr(-119); /* "syntax error" */
d927 1
a928 1
         continue;
d932 2
a933 1
      return (Err(gv,-125, stdin, stdout)); /* "too many > or <" */
d1002 1
a1002 1
		/* private buffer is always null-terminated */
d1187 1
a1187 1
	    res=ReadItem(&string[i], NMAX,FALSE);
d1197 1
a1197 1
   res=ReadItem(string, NMAX,FALSE);
@


1.47
log
@properly quotes implicit CD and Execute
travels path search twice
no longer checks paths for absolute specifications
@
text
@a32 1

d63 1
d353 1
d375 1
a375 1
	    ticks(gv,gv->alias); /* handle a command */
d661 1
a661 1
   LONG firsttime = 1;
a664 1
   struct Segment *seg;
d668 2
a669 11
   seg = searchsegs(DOSBase,commandname,NULL);
   if(seg) {
	if(seg->seg_UC >=0)seg->seg_UC++;

	if((seg->seg_UC >= 0) || 
	    ((seg->seg_UC <= CMD_BUILTIN) && (seg->seg_UC > CMD_DISABLED))) {
	    *segment = (LONG)seg;
	    return(seg->seg_Seg);
	}
	*segment=(LONG)0;	/* don't execute system segments */
   }
d673 1
a673 1
  while(firsttime-- >= 0) {
d676 1
a676 1
   if (!module)module = load(gv,commandname,0,sd, res2, (firsttime != 0));
a683 3
   if(FilePart(commandname) != commandname) {
	continue;
   }
d685 3
a687 2
   p = (struct Path *)BADDR(clip->cli_CommandDir);
   while (!module && p) {
d691 3
a693 3
   }
   /* try c:  */
   if (!module) {
d699 3
a701 3
		  SetFileSysTask(dp->dvp_Port);
		  module=load(gv,commandname,dp->dvp_Lock,sd,res2,firsttime==0);
		  if(module==2) module=0; /* keep looking */
a702 1
		
d707 2
a709 1

d712 4
a715 12
     seg = searchsegs(DOSBase,FilePart(commandname),0);
     if(seg) {
	if(seg->seg_UC >=0)seg->seg_UC++;
	if((seg->seg_UC >= 0) || 
	    ((seg->seg_UC <= CMD_BUILTIN) && (seg->seg_UC > CMD_DISABLED))) {
	    *segment = (LONG)seg;
	    return(seg->seg_Seg);
	}
	*segment=(LONG)0;	/* don't execute system segments */
     }
   }	
   if ( module || (IoErr() == 218))break;
a716 1

d1079 15
a1275 61

	
#ifdef myread
/* Read an item from command line
   returns -2    "=" Symbol
           -1    error
            0    *N, ;, endstreamch
            1    unquoted item
            2    quoted item
*/

*/
rditem(v, size)
char *v;
long size;
{
    int p = 0
    int pmax = ?
    char ch;
    int quoted = FALSE;

    clearvec(v,size)

    do {ch = rdch();} while (ch==' ');

    if(ch=='\"') {
       quoted = TRUE
       ch = rdch()
    }

    if((ch != '\n') && (ch != endstreamch)) {
       if (quoted) {
         if(ch=='\"')return(2);
          if(ch=='*') {
             ch = rdch();
             if(capitalch(ch)=='E') ch = '\e';
             IF capitalch(ch)='N' ch = '\n';
	  }
       }
	else
          if((ch==';') || (ch==' ') || (ch=='='))break;

       if(++p>pmax)return(-1);
       v[p] = ch
       v[0] = p
       ch = rdch()
    }

    unrdch()
    if(quoted)return(-1);
    TEST p=0 THEN {
        if (ch=='=') {
       	   rdch()
           return(-2);
	}
       return(0);
    }
	else return(1);
 }
*/
#endif
@


1.46
log
@31 limit on redirects removed
RC and Result2 properly cleared
@
text
@a244 8
#ifdef pdebug
kprintf("seg 0 is %lx,seg 1 is %lx, 2 is %lx\nseg 3 is %lx, 4 is %lx\n\n",
	((LONG *)BADDR(process->pr_SegList))[0],
	((LONG *)BADDR(process->pr_SegList))[1],
	((LONG *)BADDR(process->pr_SegList))[2],
	((LONG *)BADDR(process->pr_SegList))[3],
	((LONG *)BADDR(process->pr_SegList))[4]);
#endif
d246 1
a246 1
	    /* if 1.4 run probably have to change its seglist */
a247 3
#ifdef pdebug
	kprintf("changing seglist\n");
#endif
a311 3
#ifdef pdebug
kprintf("checking for internal commands\n");
#endif
d431 12
a442 3
		     if(module == (-4))comstr="CD";
		     else if(module == (-3))comstr="RX";
		     else comstr="Execute";
d448 1
a450 3
			strins(gv->alias,commandname+1);
			strcat(gv->alias," ");
			gv->cpos += commandname[0]+1;
d452 1
a452 1
				savedir=CurrentDir(scriptdir);/* cd to script */
a614 4
#ifdef pdebug
kprintf("path freed\n");
#endif

d682 1
a682 1
  while(firsttime--) {
d685 1
a685 1
   if (!module)module = load(gv,commandname,0,sd, res2, FALSE);
d690 1
d692 5
d700 1
a700 6

	   if(module==2) {
/*		dirfound=TRUE; */
		module=0; /* keep looking just in case */
	   }

d711 2
a712 8
		  module=load(gv,commandname,dp->dvp_Lock,sd,res2,
			firsttime==0);

		  if(module==2) {
/*		     dirfound=TRUE; */
		     module=0; /* keep looking just in case */
		  }

d714 1
a714 1
		/* repeat if multi-assign */
d716 1
a716 1
		IoErr() == ERROR_OBJECT_NOT_FOUND);
d720 4
a723 2
   if((!module) && !strnicmp("c:",commandname,2)) {
     seg = searchsegs(DOSBase,FilePart(commandname),0);/* maybe its a new builtins */
d736 2
a737 1
if((!module) && dirfound)return(-4); /* implicit cd */
d782 3
a784 1
   else if((res <= -2))*sd = DupLock(dir); /* save for script dir */
d804 1
@


1.45
log
@fixed memory corruption problem
@
text
@d38 1
a38 1
#define VARMAX 4
d356 2
a357 2
        SetVar("RC","0   ",VARMAX,LV_VAR|GVF_LOCAL_ONLY);
	SetVar("Result2","0   ",VARMAX,LV_VAR|GVF_LOCAL_ONLY);
d507 2
a508 2
		  	i=MIN(VARMAX,stci_d(gv->buffer,rc)); /* return status in process vars */
			memcpy(result_var->lv_Value,gv->buffer,i);
a509 1

d512 2
a513 2
			i=MIN(VARMAX,stci_d(gv->buffer,res2));
			memcpy(result_var->lv_Value,gv->buffer,i);
d893 1
a893 1
   UBYTE stdvec[NMAX+1];
d928 1
a928 1
	 if(readitem(gv,stdvec, NMAX,FALSE) <= 0 ) {
d944 1
a944 1
	 if(readitem(gv,stdvec, NMAX,FALSE) <= 0 ) {
d1054 1
a1054 1
		UnGetC(Input(),-1); /* let DOS adjust the filehandle */
@


1.44
log
@plugged memory leak in exit code
@
text
@d23 2
d38 1
d354 1
a354 1
	i=stci_d(gv->buffer,tnum);
d356 2
a357 2
        SetVar("RC","0  ",3,LV_VAR|GVF_LOCAL_ONLY);
	SetVar("Result2","0  ",3,LV_VAR|GVF_LOCAL_ONLY);
a502 1

d507 1
a507 1
		  	i=stci_d(gv->buffer,rc); /* return status in process vars */
d513 1
a513 1
			i=stci_d(gv->buffer,res2);
@


1.43
log
@close Input() instead of standardinput
@
text
@a266 5

	   if(process->pr_CurrentDir) {
        	parm_pkt->dp_Arg5 = process->pr_CurrentDir;
	   }

a283 4
	   if(process->pr_CurrentDir) {
        	parm_pkt->dp_Arg1 = process->pr_CurrentDir;
	   }

d549 1
a549 3
      else if ((((LONG) fn)& 0x80000006) == 0x80000006) {
	if((LONG)Input() != (LONG)clip->cli_StandardInput) {

d551 1
a551 1
kprintf("system call try to close standard input\n");
d553 3
a555 11
         	Close(Input());
/*		Close(clip->cli_StandardInput); */
	}
	break;
      }
      else if ((((LONG) fn) & 0x80000004) == 0x80000004) {
#ifdef pdebug
kprintf("fn 4 break\n");
#endif
	break;
      }
d579 1
a579 1
	Close(Input()); /* close for reading */
d585 1
a585 1
	 Close(Output()); /* close for writing */
a592 1

d595 1
a595 1
       Flush(Output());
d599 2
a600 2
       Close(Output());
       Close(Input());
a609 3
       UnLock(process->pr_CurrentDir);
       process->pr_CurrentDir=NULL;

d638 4
@


1.42
log
@memory work.
@
text
@d558 1
a558 1
      else if ((((LONG) fn) == 0x8000000C)) {
d564 2
a565 1
		Close(clip->cli_StandardInput);
@


1.41
log
@fixed memory leak
stopped memory frags with RC and Result2
@
text
@d520 1
a520 1
			stci_d(gv->buffer,res2);
@


1.40
log
@no longer tries to execute plain files
@
text
@d94 1
d362 2
d407 1
d409 1
a409 4
		if(!strnicmp("on",gv->buffer,i)) {
			gv->echo = TRUE;
		}
		else gv->echo = 0;
a410 1
	 else gv->echo = 0;
d508 15
a522 4
		  i=stci_d(gv->buffer,rc); /* return status in process vars */
		  SetVar("RC",gv->buffer,i,LV_VAR|GVF_LOCAL_ONLY);
		  i=stci_d(gv->buffer,res2);
		  SetVar("Result2", gv->buffer,i,LV_VAR|GVF_LOCAL_ONLY);
d1270 1
a1270 1
				c_echo=FindVar("echo",LV_VAR|GVF_LOCAL_ONLY);
@


1.39
log
@removed doslibrary open test to save space
@
text
@a449 1

d460 1
a460 1
                     if ((module > 1) || seg) {
d472 1
a472 1
		  if (module > 1) {
d711 1
d713 1
a713 1
		dirfound=TRUE;
d716 1
d729 1
d731 1
a731 1
		     dirfound=TRUE;
d734 1
d805 1
a805 1
   if(seg) {
d814 1
d816 1
a816 4

/*   if (res <= -3)getr2(gv,codep); */

   if(res == 1) {
d819 1
a820 1
/*   if(res == 2)return(0); /* ignore directories */
d853 1
a853 1
	if (exinfo->fib_DirEntryType > 0) res = 2;	/* directory */
d863 1
a863 1
        else if ((exinfo->fib_Protection & FIBF_EXECUTE)==0)res = -1;
@


1.38
log
@doesn't crash when fed a line longer than 255
@
text
@d1040 1
a1040 1
		expand(DOSBase,private_buffer); /* expand variables */
@


1.37
log
@printed out intrinsic name in echo mode
@
text
@d31 1
a414 1

a447 1

d1013 1
a1013 1
			    if (pos >= 512)
d1015 1
a1051 1

a1057 1

d1244 1
@


1.36
log
@fixed double echo problem with intrinsic commands
@
text
@d457 4
d470 1
a470 1
		  else if(gv->echo) { /* output command name */
d472 1
a472 1
			Flush(Output());
a473 1

@


1.35
log
@fixed hanging lock
implicit cd, rx
smaller (a bit)
aliases are non-recursive
memory loss plugged (I hope)
sets rc,result2
alias [] worked out copletely
newshell from & window spec fixed
@
text
@a450 5
		  if(gv->echo){
/*			if(module == -1)writef(DOSBase,"Execute "); else */
			writef(DOSBase,"%s ",commandname+1);
			Flush(Output());
		  }
d465 4
@


1.34
log
@fixed the alias >[] problem
changed some repeated calls into a table, saving 400 bytes
other byte saving things
@
text
@d31 5
d64 1
d92 5
a97 1
     LONG freeCLI;
a106 1
     UBYTE *str;
d187 1
a187 1
#ifdef pdebug
d189 1
a189 2
#endif

d265 5
d287 4
d316 1
a316 4
	    if (IoErr() != (LONG) FindTask(0)) {
#ifdef pdebug
kprintf("doing the queuepacket\n");
#endif
d330 1
a330 1
   if(thiseg=searchsegs(gv,"SHELL",NULL))thiseg->seg_UC =  -1;
d341 1
a341 1
   thiseg=searchsegs(gv,"alias",NULL);
d347 1
a347 1
	thiseg=searchsegs(gv,"alias",thiseg);
d367 1
d414 1
d422 1
a422 1
		scriptdir = 0;
d429 1
d434 1
a434 2
	
			}   
d440 5
d449 1
a449 1
                  module= findLoad(gv,commandname,&res2,&seg,&scriptdir);
d452 2
a453 2
			if(module == -1)writef(gv,"Execute ");
			else writef(gv,"%s ",commandname+1);
d457 7
a463 3
                  if (module ==  - 1 ) { /* a script needs execute */
                     module = findLoad(gv," execute",&res2, &seg, &tmp);
                     if ((module > 0) || seg) {
d467 2
a468 1
                  	savedir=CurrentDir(scriptdir);/* cd to script */
d471 2
a472 1
		  if (module > 0) {
d477 3
a479 6
                    if (savedir) {
			savedir=CurrentDir(savedir); /* if script restore dir */
/*			if(savedir != scriptdir)
				kprintf("ERROR CURRENTDIR\n");*/
			/* if savedir != scriptdir, who unlocked scriptdir ? */
			UnLock(savedir);
d492 1
a492 2
			   /* "Unknown command %s\n",commandname+1);*/
			   PrintFault(-121,commandname+1);
d504 1
a504 1
                        writef(gv,"%s failed returncode %n\n",commandname+1,rc);
d509 1
a509 1
		  SetVar("RC",gv->buffer, i,LV_VAR|GVF_LOCAL_ONLY);
d511 4
a514 2
		  SetVar("Result2", gv->buffer, i,LV_VAR|GVF_LOCAL_ONLY);

d516 1
d540 3
a542 1
 	   if((ch == END_STREAM_CH)&&(!clip->cli_Background))do_end(gv);
d547 1
a547 1
      else if (((((LONG) fn) & 0x8000000C) == 0x8000000C)) {
d549 1
d551 1
a551 1
kprintf("closing standard input\n");
d557 6
a562 1
      else if (((((LONG) fn) & 0x80000004) == 0x80000004))break;
d564 3
d609 1
d621 1
d632 4
a645 4
#ifdef pdebug
kprintf("path freed\n");
#endif

d663 2
a664 2
/* returns	-1 for script
/* returns	-2 for file found, execute not set
d682 1
d685 1
a685 1
   seg = searchsegs(gv,commandname+1,NULL);
d702 5
a706 2
   if (!module)module = load(gv,commandname+1,0,sd, res2, FALSE);

d710 5
a714 1
           module = load(gv,commandname+1, p->path_Lock, sd, res2, FALSE);
d725 1
a725 1
		  module=load(gv,commandname+1,dp->dvp_Lock,sd,res2,
d727 4
d738 2
a739 2
   if((!module) && !strnicmp("c:",commandname+1,2)) {
     seg = searchsegs(gv,FilePart(commandname+1),0);/* maybe its a new builtins */
d752 1
d759 3
a761 2
/* returns     -1 for script file
/* returns     -2 for file found, execute not set
a794 2
   if (res == -3) seg = LoadSeg(file);
   else if (res == -1)*sd = DupLock(dir); /* save for script dir */
d796 4
d812 3
a814 2
/*   if (res < -2)getr2(gv,codep); */
   if(res) {
d818 1
a818 1
   if(res == 1)return(0);
d824 7
a830 4
/*        1 for directory (ie keep looking)
/*       -1 for script file
/*       -2 for plain file
/*       -3 for executable	
d840 1
a840 1
   LONG res;
d842 2
a847 1
   
d851 12
a862 4
	if (exinfo->fib_DirEntryType > 0) res = 1;	/* no directories */
	else if (exinfo->fib_Protection & FIBF_SCRIPT) res =  - 1 ;
        else if ((exinfo->fib_Protection & FIBF_EXECUTE) == 0) res = -3;
        else res =  -2;	/* plain file */
a864 1
      return(res);
d866 1
d897 1
a897 1
   UBYTE stdvec[NAMEMAX+1];
d913 4
a916 3

/*   cis=Input(); /* save so we can restore proper handles */
/*   cos=Output(); */
d932 1
a932 1
	 if(readitem(gv,stdvec, NAMEMAX,FALSE) <= 0 ) {
d948 1
a948 1
	 if(readitem(gv,stdvec, NAMEMAX,FALSE) <= 0 ) {
d1038 1
a1038 1
		expand(gv,private_buffer); /* expand aliases */
d1041 1
a1041 1
		    writef(gv,"%s",private_buffer);
d1059 1
d1115 2
a1116 2
struct Segment *searchsegs(gv,name,startseg)
struct Global *gv;
d1120 1
a1120 1
    struct DosLibrary *DOSBase=gv->DOSBase;
d1140 2
a1141 2
void writef( gv, fmt, args )
struct Global *gv;
d1144 1
a1144 1
   struct DosLibrary *DOSBase=DOSBase=gv->DOSBase;
d1208 1
a1208 1
	    res=ReadItem(&string[i], NAMEMAX,FALSE);
d1218 1
a1218 1
   res=ReadItem(string, NAMEMAX,FALSE);
a1230 1
struct Process *tid;
d1236 1
d1243 2
a1244 7
  if(!(len=strlen(string)))return(0); /* don't even bother */

  tid = ProcessID();
  i=stci_d(&fname[7],tid->pr_TaskNum);
  SetVar("process",&fname[7],i,LV_VAR|GVF_LOCAL_ONLY);

  for(i=0; i<len; i++) {
d1251 2
d1256 4
d1262 2
d1268 1
d1356 1
@


1.33
log
@fixed alias [] problems
tracked down lock that wasn;t getting freed
@
text
@d56 3
d100 78
d272 2
d337 2
a338 43

	 AddSegment("Why",TO_BPTR(link_why),CMD_BUILTIN);
         AddSegment("Unsetenv",TO_BPTR(link_setenv),CMD_BUILTIN);
         AddSegment("Unset",TO_BPTR(link_setenv),CMD_BUILTIN);
         AddSegment("Unalias",TO_BPTR(link_setenv),CMD_BUILTIN);

	 AddSegment("Stack",TO_BPTR(link_stack),CMD_BUILTIN);
	 AddSegment("Skip",TO_BPTR(link_skip),CMD_BUILTIN);
         AddSegment("Setenv",TO_BPTR(link_setenv),CMD_BUILTIN);
         AddSegment("Set",TO_BPTR(link_setenv),CMD_BUILTIN);

	 AddSegment("Run",TO_BPTR(link_run),CMD_BUILTIN);
         AddSegment("Resident",TO_BPTR(link_resident),CMD_BUILTIN);

	 AddSegment("Quit",TO_BPTR(link_quit),CMD_BUILTIN);

	 AddSegment("Prompt",TO_BPTR(link_prompt),CMD_BUILTIN);
	 AddSegment("Path",TO_BPTR(link_path),CMD_BUILTIN);

	 AddSegment("NewShell",TO_BPTR(link_newshell),CMD_BUILTIN);
	 AddSegment("NewCLI",TO_BPTR(link_newshell),CMD_BUILTIN);

         AddSegment("Lab",TO_BPTR(link_endif),CMD_BUILTIN);

	 AddSegment("If",TO_BPTR(link_if),CMD_BUILTIN);

         AddSegment("Getenv",TO_BPTR(link_getenv),CMD_BUILTIN);
	 AddSegment("Get",TO_BPTR(link_getenv),CMD_BUILTIN);

	 AddSegment("Fault",TO_BPTR(link_fault),CMD_BUILTIN);
	 AddSegment("Failat",TO_BPTR(link_failat),CMD_BUILTIN);

         AddSegment("EndSkip",TO_BPTR(link_endif),CMD_BUILTIN);
         AddSegment("EndShell",TO_BPTR(link_endcli),CMD_BUILTIN);
         AddSegment("EndIf",TO_BPTR(link_endif),CMD_BUILTIN);
         AddSegment("EndCLI",TO_BPTR(link_endcli),CMD_BUILTIN);
	 AddSegment("Else",TO_BPTR(link_else),CMD_BUILTIN);
         AddSegment("Echo",TO_BPTR(link_echo),CMD_BUILTIN);

	 AddSegment("CD",TO_BPTR(link_cd),CMD_BUILTIN);

	 AddSegment("Ask",TO_BPTR(link_ask),CMD_BUILTIN);	
         AddSegment("Alias",TO_BPTR(link_setenv),CMD_BUILTIN);
d1083 1
a1083 2

if(gv->count >= gv->cpos) {
d1133 2
a1134 8
if(gv->count >= gv->cpos) {
	res=ReadItem(string, NAMEMAX,FALSE);
	if(res>0) {
	   gv->count +=strlen(string);
	}
}
else {
    for(i=0; (gv->count < gv->cpos) && (gv->alias[gv->count] != ' '); i++) {
d1136 2
a1137 2
	if((string[i] == '[') && (gv->alias[gv->count] == ']')) {
	    (gv->count)++; /* skip the close bracket */
d1139 4
a1142 1
	    if(res>0) i +=strlen(string);
d1146 6
@


1.32
log
@gives error message on attempt to execute script file without script bit set
@
text
@a82 1
   
a300 4
        i=0;
	str=gv->buffer;
	if(tnum>9)str[i++]=(tnum/10) + 48;
	str[i++]=(tnum % 10) + 48;
d302 2
a303 1
       	SetVar("process",str,i,LV_VAR|GVF_LOCAL_ONLY);
a423 1
/*                      if (module ==  -2 ) SetIoErr(121); */
d442 6
d528 2
a529 2
       Close((BPTR)Output());
       Close((BPTR)Input());
d753 1
d755 1
a755 2
      }
   return(res);
d778 1
a778 1
   BPTR cis,cos;
d797 1
d804 2
a805 2
   cis=Input(); /* save so we can restore proper handles */
   cos=Output();
d807 1
a807 1
   gv->count=0;	/* start processing the line at beginning */
a808 1

d812 1
a812 1
      ch = getchar(gv,1);
d819 1
a819 1
         ch = getchar(gv,1);
d835 1
a835 1
	 ch = getchar(gv,1);
d892 2
a893 2
				if (FGetC(Input()) == '\n') c = '\n';
				else UnGetC(Input(),-1);
d909 1
a909 1
			ch=getchar(gv,state);
d969 1
d972 1
d1043 1
a1043 1
	gv->count--;
d1047 1
a1047 1
    gv->count--;
d1053 1
a1053 1
char getchar(gv,state)
d1055 1
a1055 1
long state;
d1061 9
d1071 1
a1071 1
if((gv->count >= gv->cpos) || (gv->fill == 1)) {
d1076 1
a1076 1
		gv->alias[gv->cpos++]=ch ; /* save char	*/
d1080 1
a1080 11
	if(gv->fill != 1)gv->count++; /* keep track for unread */
}
else {
    ch=gv->alias[gv->count++];
    if(!gv->fill) {
        if((ch == '[') && (gv->alias[gv->count] == ']') && (state == 1)) {
	    gv->count++ ; /* skip the brackets */
	    gv->fill=1; /* fill in string here */
	    ch = FGetC(Input());
	}
    }
d1094 3
a1096 1
	if(res>0)gv->count +=strlen(string);
d1100 1
a1100 1
	string[i]=gv->alias[gv->count++];
d1102 1
a1102 1
	    gv->count++; /* skip the close bracket */
a1121 1
LONG tnum;
d1132 2
a1133 3
  tnum=tid->pr_TaskNum;
  if(tnum>9)fname[7]=(tnum/10) + 48;
  fname[8]=(tnum % 10) + 48;
d1156 1
a1156 1
/*			    DeleteFile(fname); */
d1179 59
@


1.31
log
@fixed lack of error message when attempting to execute non executables
@
text
@d162 1
a165 1
   	    if ( (seg = ((LONG *)BADDR(process->pr_SegList))[3]) ) {
d428 2
a429 2
/*                      if (module ==  - 2 ) SetIoErr(121); */
		      if (!module)getr2(gv,&res2); /* find out why */
d431 1
a431 1
			   /* "andy command %s\n",commandname+1);*/
d477 4
a480 1
	if((LONG)Input() != (LONG)clip->cli_StandardInput)
d482 1
d532 5
d559 5
d570 5
@


1.30
log
@fixes incorrect progdir when loadseging a command with a path
@
text
@a406 6
                  if (module ==  - 2 ) {
		     PrintFault(121,0);
                     module = 0;
                     SetIoErr(121);
                  }

d425 6
a430 5
 	     if (rc == -9999) {	/* something went wrong */
		      if (!module) {  /* could not find command */
			  rc = RETURN_ERROR; /* failure */
                          getr2(gv,&res2);
                          if(!res2) {
d432 5
a436 7
			      PrintFault(-121,commandname+1);
			  }
	          	  else {
			   /* "Unable to load %s: ",commandname+1); */
			      PrintFault(-120,commandname+1);
/*		              PrintFault(res2,0); */
			  }
@


1.29
log
@close proper filehandle on Async calls
@
text
@a688 1
   CurrentDir(olddir);
d692 6
a697 1
	tid->pr_HomeDir = DupLock(dir);
d700 2
@


1.28
log
@added seperate test for system in Interactive variable
@
text
@d474 1
a474 1
kprintf("in cleanup\n");
d483 3
a485 2
      else if (((((LONG) fn) & 0x80000004) == 0x80000004)) {
	Close(Input());
d488 1
d1132 1
a1132 1
			    for(k=0; k<strlen(buf);k++)if(buf[k]==10)buf[k]=0;
@


1.27
log
@cast fn to long before doing a signed comparison in one place more
close input properly for the System call
@
text
@d317 2
a318 1
	    (clip->cli_CurrentInput == clip->cli_StandardInput)) ?
@


1.26
log
@fixed negative return code
@
text
@d30 1
d165 1
a165 1
   	    if ( seg = ((LONG *)BADDR(process->pr_SegList))[3] ) {
d218 3
d231 3
a233 2


d482 4
a485 1
      else if (((((LONG) fn) & 0x80000004) == 0x80000004))break;
d503 3
d509 3
d515 3
d524 3
d756 1
d781 3
d788 2
a789 3
      if((stdin == 0) || (stdout == 0)) {
	return( Err(gv,IoErr(),stdin,stdout));
      }
d894 2
a895 2
		if (stdin < 0) stdin = termin;
		if (stdout < 0)stdout = termout;
d930 5
d936 3
d942 3
d947 3
a949 1
	return(rc);
@


1.25
log
@fixed argument parsing in scripts
@
text
@d360 1
a360 1
		rc = -99;	/* preset to can't find command */
d425 3
a427 2
 	     if (rc <0) {	/* something went wrong */
		      if (rc == -99) {  /* could not find command */
d436 1
a436 1
		              PrintFault(res2,0);
a441 1
                     clip->cli_ReturnCode = rc;
d447 1
a815 1

a912 1

d939 1
a939 1
   return (-2);
@


1.24
log
@*** empty log message ***
@
text
@d396 2
a397 1
			gv->cpos += commandname[0];
d1098 1
a1098 1
			    DeleteFile(fname);
@


1.23
log
@fixed stack overflow guru
@
text
@d898 1
a898 1
 	        rc=RunCommand(module,(clip->cli_DefaultStack),
@


1.22
log
@
@
text
@a59 1

d65 1
a65 1
   struct Library *SysBase = (*((struct Library **) 4));
d180 1
a180 1
	    if( (LONG)fn&8 ) { /* check for Async system call */
d239 1
d250 1
a250 1
	 Forbid();	/* add our internal commands */
a292 1
	 Permit();
d294 1
d468 5
d475 1
a475 19
      if (((((LONG) fn) & 0x80000004) == 0x80000004) ||
         (clip->cli_CurrentInput == clip->cli_StandardInput)) {

#ifdef pdebug
kprintf("FUNCTION POINTER OR NO REDIRECT, fn is %lx, %ld\n",(LONG)fn,
((LONG)fn>=0));
#endif
         /* endcli only if its a CLI */

	 if((ch == END_STREAM_CH)&&(!clip->cli_Background)) {
		do_end(gv); /* endcli */
         }
         if (clip->cli_Background) break; /* eof on RUN, EXECUTE(), SYSTEM() */
	     fh = (struct FileHandle *)BADDR(clip->cli_StandardInput);
	     if(fh) {
	     	fh->fh_End  = -1;
	     	fh->fh_Arg1 = -1;
	     }
      	 }
d498 1
a498 1
      if ( !((LONG)fn & 8) ) {
d1119 1
@


1.21
log
@fixed problem with multiple entries on resident list
@
text
@d6 3
d16 1
a24 2
#include "global.h"

a25 3
#include "pragmas/dos_pragmas.h"
#include "pragmas/dos_private_pragmas.h"

d29 1
d61 1
a61 2
void __asm startup( register __a0 struct DosPacket *parm_pkt,
 register __a1 InitA1)
d64 1
a64 1
   struct CGlobal *cgv;
d66 1
a66 1

d71 1
a71 1

d82 2
a87 1
     LONG outflag;
d96 1
a96 1
     int i;
d98 3
a100 3
/*
 kprintf("\n---------------------------------------\nStarting shell V11\n");
*/
d110 4
a113 3
   if(!gv)return;	/* no memory */


d117 3
d124 4
a127 2
	freeCLI = TRUE;
	/* need failure test here */
d130 5
a134 2

	clip = &cgv->Clip;
d150 1
a150 2
   fn = (BPTR (*)(struct DosPacket *)) 
	( (!parm_pkt) ? NULL : parm_pkt->dp_Type );
d152 8
a159 3
	if (fn) {
	    init_type = (parm_pkt->dp_Res1 == 0 ? 0 : 2) |
		    (parm_pkt->dp_Res2 == 0 ? 0 : 1);
d162 3
d171 15
a185 10
	    if (init_type == 0) { /* Cli init for c:run */
	 	fn = (BPTR (*)(struct DosPacket *))CliInitRun(parm_pkt);
		} 
	    else if (init_type == 2) { /* Cli init for c:NewCli/c:NewShell */
		fn = (BPTR (*)(struct DosPacket *))CliInitNewcli(parm_pkt);
		}
	    else { /* we need to clean up , maybe do an alert*/
   	        FreeMem(gv,sizeof(struct Global));
		CloseLibrary((struct Library *)DOSBase);
		return;
d188 8
a195 3
	else {
	    /* we are booting! (always returns 0) */
	    fn = (BPTR (*)(struct DosPacket *))CliInit(parm_pkt);
d197 15
a211 5

	if (( (LONG) fn > 0) || (!init_type && ( (LONG)fn & 8))) {

/*	if((LONG) fn > 0) { */

d217 10
a226 10
		if (IoErr() == (LONG) FindTask(0)) {
		    FreeMem(gv,sizeof(struct Global));
		    CloseLibrary((struct Library *)DOSBase);
		    Forbid();
		    RemTask(0);
		} 
		else {
		    SendPkt(parm_pkt,parm_pkt->dp_Port,&process->pr_MsgPort);

		}
a227 1
   if(thiseg=searchsegs(gv,"SHELL"))thiseg->seg_UC =  -1;
d229 3
d240 1
a240 1
   thiseg=searchsegs(gv,"setenv");
d243 1
a243 1
	    error=TRUE;
d246 1
a246 1
	thiseg=searchsegs("setenv",thiseg);
d301 1
d307 1
d309 1
a309 2
	    setname[setname[0]+1]=0;
	    commandname[0]=0;
d319 3
a321 3
            outflag = FALSE;
            FPutC(Output(),'O' - '@@');

d323 5
a327 2
              if ((prompt[i+1]=='s') || (prompt[i+1]=='S')) {
		writef(gv,prompt+1,setname+1,tnum);
a328 5
              else {
		writef(gv, prompt+1, tnum, setname+1);
	      }
              outflag = DOS_TRUE;
              break;
d330 3
a332 1
            if (!outflag)writef(gv,prompt,tnum);
d345 3
a347 1
		if(!strnicmp("on",gv->buffer,i))gv->echo = TRUE;
d365 2
a367 1
		  gv->cpos = 0;
d395 2
a396 2
			for(i=0; i<commandname[0]; i++)UnGetC(Input(),-1);
			if(clip->cli_Interactive)UnGetC(Input(),-1);
d412 5
a416 2
			CurrentDir(savedir); /* if script restore dir */
			UnLock(scriptdir);
d424 1
a424 1
		  if (rc <0) {	/* something went wrong */
d450 1
a450 1
                      if(clip->cli_Module)UnLoadSeg (clip->cli_Module);
d465 3
a467 1

a471 1
	 struct FileHandle *fh;
d473 7
a479 3
      if(ch == END_STREAM_CH) {
	/* endcli only if its a CLI */
	if( (ch == END_STREAM_CH) && (!clip->cli_Background) && (fn>=0) ) {
d481 1
a481 2
	}
      }
d483 5
a487 3
	 fh = (struct FileHandle *)BADDR(clip->cli_StandardInput);
	 fh->fh_End  = -1;
	 fh->fh_Arg1 = -1;
d498 5
a502 6
   if ((LONG)fn < 0) {
	 Flush(Output());
/*
      struct FileHandle *scb = (struct FileHandle *)BADDR(Output());
      if (scb->fh_Pos > 0) {
         scb->fh_Pos = 0;
d504 1
a504 1
*/
d511 4
a514 2
      if (( !init_type || (LONG)fn&8 == 0))
	{ ReplyPkt(parm_pkt,clip->cli_ReturnCode,clip->cli_Result2); }
d517 3
a519 3
	Flush(Output());
       	  Close((BPTR)Output());
          Close((BPTR)Input());
a520 1

d523 3
a525 1
       UnLock(CurrentDir(NULL));
d545 2
a546 4
   process->pr_Flags =0;
   process->pr_CLI = 0;
   process->pr_CurrentDir=0;
   FreeMem(cgv,sizeof(struct CGlobal));
d548 1
a548 1

a575 1
   BPTR lock;
d578 1
a578 1
   seg = searchsegs(gv,commandname+1);
d595 1
a595 3
   lock=Lock("",ACCESS_READ);
   if (!module)module = load(gv,commandname+1,lock ,sd, res2, FALSE);
   UnLock(lock);
d621 1
a621 1
     seg = searchsegs(gv,FilePart(commandname+1));/* maybe its a new builtins */
d643 2
d647 1
a647 1
BPTR load(gv,file, dir, sd, codep, qflag)
d650 1
a650 1
BPTR dir;
d660 1
d662 1
d666 1
d668 1
d670 3
a672 1
   if (!qflag)tid->pr_WindowPtr = (APTR)(-1);	/* load quietly if requested */
d676 1
a676 1
   else if (res == -1) *sd = DupLock(dir);
a683 1

d712 1
a712 2
   exinfo = &gv->ExInfo;

d760 1
a761 1
   LONG pos = 0;
d766 1
d768 2
a769 1
   struct FileHandle *fh;
a773 3
   termin = clip->cli_StandardInput;
   termout = Output();

d893 3
a895 2
		pos=expand(gv,private_buffer);

a905 1
/* maybe change console task to redirected value of output ? */
d911 3
a913 1
 	        rc=RunCommand(module,clip->cli_DefaultStack,private_buffer,pos);
d918 1
d925 1
d956 1
a956 1
struct Segment *searchsegs(gv,name)
d959 1
d963 2
a964 2
    seg=FindSegment(name,0,0);	/* additional commands first */
    if((long)seg==0)seg=FindSegment(name,0,TRUE); /* now the system stuff */
d978 1
a978 1
return( (SetSignal(0,flag) &flag) );
d1064 57
d1131 1
@


1.20
log
@fixed alias logic, added [] like in 1.3
redirection fixed as well
changed CLI logic to only allocate CLI structure if one isn't provided
@
text
@d19 1
d98 2
a99 1
/* kprintf("\n---------------------------------------\nStarting shell V11\n");
d173 3
a191 1

d202 1
a202 1
   thiseg=FindSegment("setenv",0,0);
d208 1
a208 1
	thiseg=FindSegment("setenv",thiseg,0);
d213 2
a214 1
         AddSegment("Set",TO_BPTR(link_setenv),CMD_BUILTIN);
d216 1
a216 1
         AddSegment("Alias",TO_BPTR(link_setenv),CMD_BUILTIN);
d218 2
a219 1
         AddSegment("Unalias",TO_BPTR(link_setenv),CMD_BUILTIN);
d221 1
a221 1
         AddSegment("Unsetenv",TO_BPTR(link_setenv),CMD_BUILTIN);
d223 16
a239 1
         AddSegment("Getenv",TO_BPTR(link_getenv),CMD_BUILTIN);
d241 5
a246 3
         AddSegment("EndSkip",TO_BPTR(link_endif),CMD_BUILTIN);
         AddSegment("Lab",TO_BPTR(link_endif),CMD_BUILTIN);

d248 1
a248 2
         AddSegment("EndShell",TO_BPTR(link_endcli),CMD_BUILTIN);

a249 1
         AddSegment("Resident",TO_BPTR(link_resident),CMD_BUILTIN);
d251 2
d254 1
a254 14
	 AddSegment("Else",TO_BPTR(link_else),CMD_BUILTIN);
	 AddSegment("Failat",TO_BPTR(link_failat),CMD_BUILTIN);
	 AddSegment("Fault",TO_BPTR(link_fault),CMD_BUILTIN);
	 AddSegment("If",TO_BPTR(link_if),CMD_BUILTIN);
	 AddSegment("Path",TO_BPTR(link_path),CMD_BUILTIN);
	 AddSegment("Quit",TO_BPTR(link_quit),CMD_BUILTIN);
	 AddSegment("Skip",TO_BPTR(link_skip),CMD_BUILTIN);
	 AddSegment("Why",TO_BPTR(link_why),CMD_BUILTIN);
	 AddSegment("Stack",TO_BPTR(link_stack),CMD_BUILTIN);
	 AddSegment("CD",TO_BPTR(link_cd),CMD_BUILTIN);
	 AddSegment("Prompt",TO_BPTR(link_prompt),CMD_BUILTIN);
	 AddSegment("NewShell",TO_BPTR(link_newshell),CMD_BUILTIN);
	 AddSegment("NewCLI",TO_BPTR(link_newshell),CMD_BUILTIN);
	 AddSegment("Run",TO_BPTR(link_run),CMD_BUILTIN);
d266 1
a266 1
   do {
a271 1

d382 7
a388 4
                          if(!res2)
			     writef(gv,"andy command %s\n",commandname+1);
		          else {
                              writef(gv,"Unable to load %s: ", commandname+1);
d400 1
a400 1
                  }
d414 1
a414 1
            else writef(gv,"Error in command name\n");
d461 2
a462 3
      if (( !init_type || (LONG)fn&8 == 0)) {
	ReplyPkt(parm_pkt,clip->cli_ReturnCode,clip->cli_Result2);
      }
d466 2
a467 2
      	Close((BPTR)Output());
        Close((BPTR)Input());
d490 1
a490 1
       }
d497 4
a500 3
   FreeMem(gv,sizeof(struct Global));
   CloseLibrary((struct Library *)DOSBase);
   return;
d735 1
a735 1
	        SetIoErr((LONG)"syntax error");
d751 1
a751 1
	        SetIoErr((LONG)"syntax error");
d770 1
a770 1
      return (Err(gv,"too many > or <", stdin, stdout));
d816 2
a817 1
				return(Err(gv,"Command too long",stdin,stdout));
d863 6
a868 2
	if (stdin != termin)Close(stdin);
	if (stdout != termout)Close(stdout);
a879 1

d881 1
a881 1
   if (!s)SetIoErr((LONG)"Unable to open redirection file");
d887 2
a888 1
UBYTE *m; 
d891 2
a892 3
    struct DosLibrary *DOSBase=gv->DOSBase;

   writef(gv,"SHELL error: %s\n", m);
a1015 1

@


1.19
log
@fixed Manx run problems
@
text
@d52 1
d64 1
d66 1
d71 1
d83 1
a83 1
     LONG save_CLI;
d97 1
a97 2
/*
kprintf("\n---------------------------------------\nStarting shell\n");
d101 1
d105 1
a111 5
   clip = &gv->Clip;
   prompt = gv->prompt;
   commandname= gv->commandname;
   commandfile=gv->commandfile;
   setname=gv->setname;
d113 9
a121 1
   save_CLI = process->pr_CLI;	/* save the one from createnewproc */
d123 5
a127 2
   process->pr_CLI = TO_BPTR(clip);
   process->pr_Flags &= ~PRF_FREECURRDIR;
d129 1
a129 4
   clip->cli_Prompt      = TO_BPTR(prompt);
   clip->cli_CommandName = TO_BPTR(commandname);
   clip->cli_CommandFile = TO_BPTR(commandfile);
   clip->cli_SetName     = TO_BPTR(setname);
d131 7
a138 1

d143 1
a143 5
#ifdef USE_FPTR
		fn = (BPTR (*)(struct DosPacket *))
	CallBcplFptr(parm_pkt,(LONG) fn);
#else
	init_type = (parm_pkt->dp_Res1 == 0 ? 0 : 2) |
d146 6
d153 2
a154 4
		if (init_type == 0) {
		    /* Cli init for c:run */

		    fn = (BPTR (*)(struct DosPacket *))CliInitRun(parm_pkt);
d156 5
a160 14
		else if (init_type == 2) {
		  /* Cli init for c:NewCli/c:NewShell */

		   /* if 1.4 newshell probably have to change its seglist */
   		   if ( seg = ((LONG *)BADDR(process->pr_SegList))[3] ) {
		   ((LONG *)BADDR(process->pr_SegList))[4] = seg;
		   ((LONG *)BADDR(process->pr_SegList))[3] = 0 ;
   		   }
   		   seg=0;
		    fn = (BPTR (*)(struct DosPacket *))CliInitNewcli(parm_pkt);
		} 
		else {
		/* we need to clean up , maybe do an alert*/
		FreeMem(gv,sizeof(struct Global));
d162 2
a163 3
		  return;
		}
#endif
d170 1
a170 2
/*	if (( ((LONG) fn) > 0) || ( ((LONG)fn < 0) && ( (LONG)fn & 8) )) { */
	if ( (LONG) fn > 0) {
a175 5

#ifdef USE_FPTR
		/* note that I must pass a CPTR to call_bcpl_fptr */
		CallBcplFptr((struct DosPacket *)BADDR(IoErr()),(LONG)fn);
#else
a185 1
#endif
d208 4
a211 2
/*         addseg(gv,"Set",TO_BPTR(link_setenv),CMD_BUILTIN); */
/*	 addseg(gv,"Get",TO_BPTR(link_getenv),CMD_BUILTIN); */
d213 3
a215 3
         addseg(gv,"Alias",TO_BPTR(link_setenv),CMD_BUILTIN);
         addseg(gv,"SetEnv",TO_BPTR(link_setenv),CMD_BUILTIN);
         addseg(gv,"GetEnv",TO_BPTR(link_getenv),CMD_BUILTIN);
d217 2
a218 3
         addseg(gv,"EndIf",TO_BPTR(link_endif),CMD_BUILTIN);
         addseg(gv,"EndSkip",TO_BPTR(link_endif),CMD_BUILTIN);
         addseg(gv,"Lab",TO_BPTR(link_endif),CMD_BUILTIN);
d220 3
a222 2
         addseg(gv,"EndCLI",TO_BPTR(link_endcli),CMD_BUILTIN);
         addseg(gv,"EndShell",TO_BPTR(link_endcli),CMD_BUILTIN);
d224 2
a225 2
         addseg(gv,"Echo",TO_BPTR(link_echo),CMD_BUILTIN);
         addseg(gv,"Resident",TO_BPTR(link_resident),CMD_BUILTIN);
d227 19
a245 15
	 addseg(gv,"Ask",TO_BPTR(link_ask),CMD_BUILTIN);	
	 addseg(gv,"Else",TO_BPTR(link_else),CMD_BUILTIN);
	 addseg(gv,"Failat",TO_BPTR(link_failat),CMD_BUILTIN);
	 addseg(gv,"Fault",TO_BPTR(link_fault),CMD_BUILTIN);
	 addseg(gv,"If",TO_BPTR(link_if),CMD_BUILTIN);
	 addseg(gv,"Path",TO_BPTR(link_path),CMD_BUILTIN);
	 addseg(gv,"Quit",TO_BPTR(link_quit),CMD_BUILTIN);
	 addseg(gv,"Skip",TO_BPTR(link_skip),CMD_BUILTIN);
	 addseg(gv,"Why",TO_BPTR(link_why),CMD_BUILTIN);
	 addseg(gv,"Stack",TO_BPTR(link_stack),CMD_BUILTIN);
	 addseg(gv,"CD",TO_BPTR(link_cd),CMD_BUILTIN);
	 addseg(gv,"Prompt",TO_BPTR(link_prompt),CMD_BUILTIN);
	 addseg(gv,"NewShell",TO_BPTR(link_newshell),CMD_BUILTIN);
	 addseg(gv,"NewCLI",TO_BPTR(link_newshell),CMD_BUILTIN);
/*	 addseg(gv,"Run",TO_BPTR(link_run),CMD_BUILTIN); */
a255 1

d257 1
a257 1
      do {
d262 1
d267 2
a268 2
         SelectInput (clip->cli_CurrentInput);
         SelectOutput (standardout);
a269 1

a273 1

d290 1
a290 2
/*               writef(gv,"**BREAK - SHELL\n"); */
	       PrintFault(304,"SHELL - ");
d303 2
a304 1
 	 *commandname = strlen(commandname+1); /* convert to bstr */
d314 2
a315 1
		
d328 1
a328 1
	   	        *commandname = strlen(commandname+1); /* bstr */
d344 2
a345 1
			for(i=0; i<=commandname[0]; i++)UnGetC(Input(),-1);
a354 1

a358 1
/*		    module = clip->cli_Module;	/* for Manx DB detach */
d364 1
a410 1

d415 6
a420 2
      if(ch == END_STREAM_CH)do_end(gv,clip); /* endcli */

d436 2
a439 1
	 Flush(Output());
d442 8
a449 5

      if (((LONG)fn & 2) == 0)Close(Input()); /* close for reading */
      if (((LONG)fn & 1) == 1)Close(Output()); /* close for writing */

/*      if( (LONG)fn&8 == 0) */
d451 1
d454 3
a456 2
      Close((BPTR)Output());
      Close((BPTR)Input());
a457 4
   UnLock(CurrentDir(NULL));
   p = (struct Path *)BADDR(clip->cli_CommandDir);
   while (p) {
      struct Path *next;
d459 26
a484 4
      next = (struct Path *)BADDR(p->path_Next);
      UnLock(p->path_Lock);
      FreeVec(p);
      p = next;
a485 10
    
   for(cl=(struct CliProcList *)((struct RootNode *)
	DOSBase->dl_Root)->rn_CliList.mlh_Head; cl;
        cl = (struct CliProcList *) cl->cpl_Node.mln_Succ) {
	   if (tnum <= cl->cpl_First + ((LONG) cl->cpl_Array[0]) - 1) {
		cl->cpl_Array[tnum - cl->cpl_First + 1] = NULL;
		break;
	   }
       }
   process->pr_CLI = save_CLI; /* restore original pr_CLI */
d511 1
a511 1
   struct CommandLineInterface *clip= &gv->Clip;
a682 1
   LONG count=0;
d692 1
a692 1
   struct CommandLineInterface *clip= &gv->Clip;
d703 3
d710 2
a711 2
      if ((stdin == 0) || (stdout == 0)) {
         return (err(gv, IoErr(), stdin, stdout));
d713 1
a713 1
      ch = FGetC(Input());
d720 6
a725 3
         ch = FGetC(Input());
	 if (ch != '>') UnGetC(Input(),-1);
	 if(ReadItem(stdvec, NAMEMAX,FALSE) <= 0 ) break; 
d727 1
a727 1
            stdout = openf(gv,stdvec,0,ACTION_FINDUPDATE);
d731 1
a731 1
            stdout = openf(gv,stdvec,1,ACTION_FINDOUTPUT);
d736 11
a746 9
	 ch = FGetC(Input());
	 if (ch != '>') UnGetC(Input(),-1);
	 if(ReadItem(stdvec, NAMEMAX,FALSE) <= 0 ) break; 

	 if((ch == '>') && (stdout <= 0 )){
		Forbid();
		stdin=openf(gv,stdvec,1,ACTION_FINDINPUT);
		ctask=process->pr_ConsoleTask;
		process->pr_ConsoleTask=
d748 3
a750 3
		stdout=Open("*",ACTION_FINDOUTPUT);
		process->pr_ConsoleTask=ctask;
		Permit();
d752 2
a753 3
	 else {
            stdin = openf(gv,stdvec,1,ACTION_FINDINPUT);
	 }
d758 1
a758 1
      return (err(gv,"too many > or <", stdin, stdout));
a760 1
/*   else if(qflag)SetIoErr((LONG)"syntax error"); */
d762 1
a781 4
		if(gv->cpos) {
		    gv->alias[gv->cpos++]=ch; /* process it when its time */
		    ch=gv->alias[count++];
		}
d804 1
a804 2
				return(err(gv,"Command too long",stdin,stdout));

d810 1
a810 2
			if(count >= gv->cpos) ch = FGetC(Input());
			else ch=gv->alias[count++];
a826 2


d839 2
d844 1
a844 1
	/* clear user signal bits here ?? */
a849 1

d855 1
a855 1
BPTR openf(gv,name,qflag,act)
a857 1
LONG qflag;
d865 1
a865 1
   if (!s && qflag)SetIoErr((LONG)"Unable to open redirection file");
d869 1
a869 1
LONG err(gv,m, si, so)
a882 14
addseg(gv,name,code,flag)
struct Global *gv;
char *name;
BPTR code;
LONG flag;
{
struct DosLibrary *DOSBase=gv->DOSBase;
LONG res;
Forbid();
res=AddSegment(name,code,flag);
Permit();
return(res);
}

d915 75
d1000 1
@


1.18
log
@removed CMDREV header
@
text
@a105 7
   /* if 1.4 newshell probably have to change its seglist */
   if ( seg = ((LONG *)BADDR(process->pr_SegList))[3] ) {
	((LONG *)BADDR(process->pr_SegList))[4] = seg;
	((LONG *)BADDR(process->pr_SegList))[3] = 0 ;
   }
   seg=0;

d136 1
a136 3
/*
kprintf("init type is %ld\n",init_type);
*/
d144 7
a332 1

d887 1
a887 1
    if(!seg)FindSegment(name,0,TRUE); /* now the system stuff */
@


1.17
log
@fixed redirection crash
@
text
@a100 1

d142 1
a167 4




d188 1
d214 2
a217 2

/*	 addseg(gv,"Get",TO_BPTR(link_getenv),CMD_BUILTIN); */
a305 1

d417 1
a417 3
      if(ch == END_STREAM_CH) {
	   do_end(gv,clip); /* endcli */
      }
@


1.16
log
@backed out async system call; wait for new DOS
put in a better compare for env variables
@
text
@d70 1
a70 1
   struct Process *process;   
d321 2
a322 2
		  if(GetVar(commandname+1,gv->cbuffer,255,LV_ALIAS) >0 ) {

d354 1
a354 1
                     writef(gv,"Execute permission not set\n");
d680 2
d684 1
d689 1
d709 2
d712 2
a713 2
            stdout = openf(gv,0,ACTION_FINDUPDATE);
	    Seek(stdout,0,1);
d716 1
a716 2
            UnGetC(Input(),-1);
            stdout = openf(gv,1,ACTION_FINDOUTPUT);
d722 12
a733 3
	 if((ch == '>')&& (stdout <= 0)){
		stdin=openf(gv,1,ACTION_FINDINPUT);
		stdout=OpenFromLock(DupLockFromFH(stdin),ACTION_FINDINPUT);
d736 1
a736 2
	    UnGetC(Input(),-1);
            stdin = openf(gv,1,ACTION_FINDINPUT);
d745 2
d842 1
a842 1
	if (stdout != termout) Close(stdout);
d846 1
a846 1
BPTR openf(gv,qflag,act)
d848 1
a851 3
   UBYTE stdvec[NAMEMAX+1];
   BPTR s = 0;
   struct DosLibrary *DOSBase;
d853 2
a854 1
   DOSBase=gv->DOSBase;
d856 2
a857 5
   if (ReadItem(stdvec, NAMEMAX,FALSE) > 0) {
       s= Open(stdvec,act);
       if (!s && qflag)SetIoErr((LONG)"Unable to open redirection file");
   }
   else if(qflag)SetIoErr((LONG)"syntax error");
@


1.15
log
@Added support for startup from CreateNewProc()
fixed test for commands that are now builtin
fixed allocation/deallocation of CLI structure
Added compatibility zapping of old commands
removed SET command for manx compatibility
(removed GET at same time)  Can get to local
variables through SETENV LOCAL option
Now use PrintFault for almost all messages
Switched internal return for could not find command to -99
@
text
@d122 1
d172 2
a173 1
	if ((((LONG) fn) > 0) || ((LONG)fn & 8)) {
d301 2
a302 2
	 if(GetVar("echo",gv->buffer,31,LV_VAR|GVF_LOCAL_ONLY)>0 ) {
		if(!stricmp("on",gv->buffer))gv->echo = TRUE;
d449 2
a450 1
      if(!(LONG)fn&8)ReplyPkt(parm_pkt,clip->cli_ReturnCode,clip->cli_Result2);
@


1.14
log
@removed debugging
@
text
@d69 1
a69 1

d79 1
d83 1
a83 1
     LONG seg = 0;
d92 1
d98 4
d106 8
d121 1
d123 1
a124 1

d131 1
a134 1

d142 5
d148 1
a148 4

		if (init_type == 0) {
			fn = (BPTR (*)(struct DosPacket *))
			     CliInitRun(parm_pkt);	/* Cli init for c:run */
d151 1
a152 1
		  /* Cli init for c:NewCli/c:NewShell */
d166 6
a171 1
	if (((LONG) fn) > 0) {
d204 1
a204 1
   thiseg=FindSegment("set",0,0);
d210 1
a210 1
	thiseg=FindSegment("set",thiseg,0);
d212 1
d214 1
a214 1
         addseg(gv,"Set",TO_BPTR(link_setenv),CMD_BUILTIN);
d218 1
a218 1
	 addseg(gv,"Get",TO_BPTR(link_getenv),CMD_BUILTIN);
d243 3
d261 4
a264 6
/*
kprintf("background is %lx, CurrentIn is %lx, StandardIn is %lx\n",
clip->cli_Background,clip->cli_CurrentInput,clip->cli_StandardInput);
*/
         clip->cli_Interactive =  !clip->cli_Background  && 
	    (clip->cli_CurrentInput == clip->cli_StandardInput) ?
d266 1
a266 3
/*
kprintf("interactive is %lx\n",clip->cli_Interactive);
*/
d292 2
a293 1
               writef(gv,"**BREAK - SHELL\n");
d313 1
a313 1
		rc = -1;
d374 1
a374 2
		      if (rc == -1) {  /* could not find command */

d399 1
a399 2
		      if ((((struct Segment *)seg)->seg_UC > 0) ||
			   ((struct Segment *)seg)->seg_UC >= CMD_BUILTIN)
d419 4
d427 1
a427 1
      }
d443 1
d445 3
a447 2
      else if (((LONG)fn & 1) == 1) Close (Output()); /* close for writing */
      ReplyPkt (parm_pkt, clip->cli_ReturnCode, clip->cli_Result2);
d463 10
a472 2

   process->pr_CLI = NULL;  /* really need this ? */
a473 1
   ((LONG *)BADDR(((struct RootNode *)DOSBase->dl_Root)->rn_TaskArray))[tnum]=0;
d506 3
a508 1
	if(seg->seg_UC >= 0) {
d551 2
a552 1
	if(seg->seg_UC >= 0) {
a563 2


d881 1
a881 2

    seg=FindSegment(name,0,0);	/* commands builtin first */
a882 1

d906 1
@


1.13
log
@fixed boot time reference of location $C  (and $10)
@
text
@d91 1
a91 1

d93 1
a96 1

a189 1

d230 1
d235 1
a235 1

d238 1
a238 1

d242 1
d244 1
a244 1

d873 10
@


1.12
log
@brings up requester if volume isn't connected
@
text
@d92 2
a93 2
/*kprintf("\n---------------------------------------\nStarting shell\n");
*/
d117 1
a117 1
	((!parm_pkt) ? NULL : parm_pkt->dp_Type );
a119 3
	init_type = (parm_pkt->dp_Res1 == 0 ? 0 : 2) |
		    (parm_pkt->dp_Res2 == 0 ? 0 : 1);

d125 4
d236 8
a243 2
         clip->cli_Interactive =  ~(clip->cli_Background) & 
	    (clip->cli_CurrentInput == clip->cli_StandardInput);
@


1.11
log
@fixed null termination of prompt
@
text
@a474 2


d492 1
a492 1
	      if (dp){
d494 2
a495 1
		  module=load(gv,commandname+1,dp->dvp_Lock,sd,res2,FALSE);
@


1.10
log
@No longer writes to rom (stopped using Lattice sprintf)
@
text
@d232 3
d240 1
d244 1
@


1.9
log
@fixed writes to rom
fixed problem where alias could not contain ; characters
fixed >> redirection
fixed returncode
fixed why command
@
text
@d81 1
a81 1

a106 1

a114 2
   commandfile[commandfile[0]+1]=0;	/* name sure name is null terminated */

d223 5
a227 3
	sprintf(gv->buffer,"%ld",tnum);
/*	SetVar("$","$",-1,LV_VAR|GVF_LOCAL_ONLY); */
	SetVar("process",gv->buffer,-1,LV_VAR|GVF_LOCAL_ONLY);
a229 3



a231 3
	 prompt[prompt[0]+1] = 0; /* make sure strings are null terminated */
	 setname[setname[0]+1] = 0;

d238 1
a238 2
            LONG i;
            LONG outflag = FALSE;
@


1.8
log
@fixed crash problem...alias[] on stack caused problems
@
text
@a73 1
/*   struct RootNode  *rootnode; */
d79 2
d82 10
a117 3
/*   rootnode = (struct RootNode *)DOSBase->dl_Root; */


a210 3
	 addseg(gv,"Get",TO_BPTR(link_getenv),CMD_BUILTIN);
	 addseg(gv,"GetEnv",TO_BPTR(link_getenv),CMD_BUILTIN);

d227 1
a227 1
	SetVar("$","$",-1,LV_VAR|GVF_LOCAL_ONLY);
d232 2
a234 1
      LONG ch;
a235 2
         LONG item;

d284 6
a289 10
	       LONG seg = 0;
               LONG rc =  - 1 ;
               LONG res2 = 0;
               BPTR module;
               BPTR scriptdir = 0;
               BPTR savedir=0;
               BPTR tmp;
	       UBYTE *str;
	       int i;

d291 1
a291 1
		  if(GetVar(commandname+1,gv->alias,255,LV_ALIAS) >0 ) {
d293 2
a294 2
			if(str=strchr(gv->alias,' ')) { /* found a space */
			    strcpy(gv->cbuffer,str); /* copy string in buffer */
d298 1
a298 1
			str=gv->alias;
d351 4
a355 5
		      else {
                          writef(gv,"Unable to load %s: ", commandname+1);
		          PrintFault(res2,0);
		      }
		      
a556 3
   else if (res == 1) {
	*codep = 121; /* not an object module */
   }
d564 6
a570 1
   if (!res)getr2(gv,codep); /* set result2 if file not found or script file */
d576 1
a576 1
/*        0 for directory (ie keep looking)
a615 1

d630 2
d633 5
d641 7
d665 1
d705 3
d709 3
a711 16
	{
		LONG pos = gv->cpos; /* start where the alias left off */
		BPTR orig_buf;
		LONG orig_pos,orig_end;

/* State indicates parsing state. <0 -> in quotes, >0  out of quotes,
   =0 -> in comment */
		LONG state = 1;
/*		char buffer[258];	/* assume word alignment */
		char *private_buffer = gv->cbuffer;
		struct FileHandle *fh;

		/* FIX!!! */ /* force to lword pointer!! */
/*
		if ((LONG) private_buffer & 2) {
			private_buffer += 2;
a712 2

*/
a713 2
			LONG c;			/* because of '+' */
			c = ch;
d715 2
d719 1
a719 1
				if (state >= 0) state = 0;
d722 1
a722 1
				state = -state;
d734 1
a734 1
			    if (pos >= 256)
d741 3
a743 2
			ch = FGetC(Input());

d768 1
a768 2
		/* we forced it to lword alignment */
		fh->fh_Buf = TOBUFFER(private_buffer);	/* FIX! */
d782 2
a783 2
		if (fh->fh_End != 0)fh->fh_End = orig_end;
	}
@


1.7
log
@added activation lines for CD and PROMPT
@
text
@d222 2
a223 1
	SetVar("$",gv->buffer,-1,LV_VAR|GVF_LOCAL_ONLY);
a285 1
	       UBYTE alias[32];
d291 1
a291 2
		  if(GetVar(commandname+1,alias,31,LV_ALIAS) >0 ) {
			strcpy(commandname+1,alias);
d293 1
a293 1
			if(str=strchr(commandname+1,' ')) { /* found a space */
d296 1
a296 1
			    *str = 0; /* null terminate the alias */
d298 4
@


1.6
log
@Alias arguments now end up in command line
Added additional builtin commands
@
text
@d71 1
a71 1
   LONG error = FALSE;
d74 1
a74 1
   struct RootNode  *rootnode;
d107 1
a107 1
   rootnode = (struct RootNode *)DOSBase->dl_Root;
d205 1
d216 2
d282 1
a282 1
               BPTR module = 0;
d331 1
a331 1
		    module = clip->cli_Module;	/* for Manx DB detach */
d345 1
a345 1
/*                          getr2(gv,&res2); */
d585 1
a585 1
   LONG res = 0;
a627 1
   LONG do_append = FALSE;
a646 1
            do_append = DOS_TRUE;
@


1.5
log
@fixed script bug
@
text
@d166 1
a167 2
    if(thiseg=searchsegs(gv,"SHELL"))thiseg->seg_UC =  -1;

d175 1
d184 1
d190 3
d202 13
d284 1
d287 1
d290 6
a298 4
		  if(gv->echo){
			writef(gv,"%s ",commandname+1);
			Flush(Output());
		  }
d304 6
a316 1

d502 11
d552 3
d562 1
d593 1
a593 1
	if (exinfo->fib_DirEntryType > 0) res = 0;	/* no directories */
d688 1
a688 1
		LONG pos = 0;
d695 2
a696 2
		char buffer[258];	/* assume word alignment */
		char *private_buffer = buffer;
d700 1
a700 1

d705 1
d756 4
a759 2
		if(gv->echo)writef(gv,"%s\n",private_buffer);

@


1.4
log
@removed debugging statements
@
text
@d250 1
d286 1
a286 1
			for(i=0; i<commandname[0]; i++)UnGetC(Input(),-1);
@


1.3
log
@fixed run
fixed redirection
added <> to redirect both input and output
builtin commands only put themselves on the list once
added {$$} for process number
added ECHO to echo command lines as typed for debugging
@
text
@d80 2
a81 2
/*
kprintf("\n---------------------------------------\nStarting shell\n");
d202 1
a202 1
	SetVar("$$",gv->buffer,2,LV_VAR|GVF_LOCAL_ONLY);
d277 1
d296 1
d300 1
d302 1
a302 1
                      getr2(gv,&res2);
d312 2
a313 4
		  else {
		      /* could not find command */
                      writef(gv,"andy command %s\n",commandname+1);
		  }
d315 9
a323 3
                  if (rc == -1) { /* failure during command */
                      writef(gv,"Unable to load %s: ", commandname+1);
		      PrintFault(res2,0);
d325 1
a325 1
                  else {	/* maybe guess it worked */
@


1.2
log
@fixed redirection
@
text
@d79 1
d158 1
a158 1
		    RemTask(0L);
d175 13
a187 3
     addseg(gv,"Set",TO_BPTR(link_setenv),CMD_BUILTIN);
     addseg(gv,"Alias",TO_BPTR(link_setenv),CMD_BUILTIN);
     addseg(gv,"SetEnv",TO_BPTR(link_setenv),CMD_BUILTIN);
d189 3
a191 3
     addseg(gv,"EndIf",TO_BPTR(link_endif),CMD_BUILTIN);
     addseg(gv,"EndSkip",TO_BPTR(link_endif),CMD_BUILTIN);
     addseg(gv,"Lab",TO_BPTR(link_endif),CMD_BUILTIN);
d193 2
a194 2
     addseg(gv,"EndCLI",TO_BPTR(link_endcli),CMD_BUILTIN);
     addseg(gv,"EndShell",TO_BPTR(link_endcli),CMD_BUILTIN);
d196 3
a198 2
     addseg(gv,"Echo",TO_BPTR(link_echo),CMD_BUILTIN);
     addseg(gv,"Resident",TO_BPTR(link_resident),CMD_BUILTIN);
d200 6
d246 5
d272 6
d299 5
a303 1
                    if (savedir)CurrentDir(savedir); /* if script restore dir */
d314 1
a314 2
                  if (rc < -1) { /* failure during command */
                      getr2(gv,&res2);
d316 1
a316 2
                      /* print error messsage with dos call */
		      PrintFault(res2,"Error: ");
d318 1
a318 1
                  else {	/* guess it worked */
d334 1
a334 1
			   ((struct Segment *)seg)->seg_UC > CMD_BUILTIN)
d353 1
d360 1
a360 2
 	 BPTR scb = Input();
         Close(scb);
d368 5
a372 6
   if (fn < 0) {
      struct FileHandle *fh = (struct FileHandle *)BADDR(Output());
      BPTR scb = Output();
      LONG pos = fh->fh_Pos;
      if (pos > 0) {
	 FWrite(Output(),((UBYTE *)BADDR(fh->fh_Buf)),1,pos);
d374 2
a375 3
      fh->fh_Pos = 0;
      if (((LONG)fn & 2) == 0)Close(scb); /* close for reading */
      else if (((LONG)fn & 1) == 1) Close (scb); /* close for wtiting */
d393 1
a393 1
/*   process->pr_CLI = NULL; */
d483 1
a483 1
BPTR load(gv,file, dir, cd, codep, qflag)
d487 1
a487 1
BPTR *cd;	/* used to return where the command was found */
d494 1
d503 1
a503 1
   *cd=CurrentDir(dir);
d506 2
a507 1
   CurrentDir(*cd);
d559 1
a560 2
   if ((*codep) == 0) {
      LONG r2 = IoErr();
a562 1
   }
d600 1
a600 1
            UnGetC(Input(),ch);
d606 9
a614 1
         stdin = openf(gv,1,ACTION_FINDINPUT);
d705 3
d725 1
a725 1
	if (stdin != termin) Close(stdin);
d727 1
a727 1
	return(0);	/* success */
d745 1
a745 1
   else SetIoErr((LONG)"syntax error");
@


1.1
log
@romable shell first pass
@
text
@d174 3
a176 3
     addseg(gv,"Set",TO_BPTR(link_setenv),-2);
     addseg(gv,"Alias",TO_BPTR(link_setenv),-2);
     addseg(gv,"SetEnv",TO_BPTR(link_setenv),-2);
d178 3
a180 3
     addseg(gv,"EndIf",TO_BPTR(link_endif),-2);
     addseg(gv,"EndSkip",TO_BPTR(link_endif),-2);
     addseg(gv,"Lab",TO_BPTR(link_endif),-2);
d182 2
a183 2
     addseg(gv,"EndCLI",TO_BPTR(link_endcli),-2);
     addseg(gv,"EndShell",TO_BPTR(link_endcli),-2);
d185 2
a186 2
     addseg(gv,"Echo",TO_BPTR(link_echo),-2);
     addseg(gv,"Resident",TO_BPTR(link_resident),-2);
d228 1
a228 1
         item = ReadItem(commandname+1, namemax,FALSE);
d302 3
a304 2
		      if ( ((struct Segment *)seg)->seg_UC > 0)
				((struct Segment *)seg)->seg_UC--;
d399 1
a399 1
	if((seg->seg_UC >= 0) || (seg->seg_UC == -2)) {
d556 1
a556 1
         return (err(gv,IoErr(), stdin, stdout));
d564 1
a564 2
         if (stdout > 0)
            break;
d568 1
a568 1
            stdout = openf(gv,ACTION_FINDUPDATE);
d570 3
a572 3
         else {
            UnGetC(Input(),-1);
            stdout = openf(gv,ACTION_FINDOUTPUT);
d576 2
a577 3
         if (stdin > 0)
            break;
         stdin = openf(gv,ACTION_FINDINPUT);
d690 1
a690 1
BPTR openf(gv,act)
d692 1
d695 1
a695 1
   UBYTE stdvec[namemax*4];
d701 3
a703 4
   if (ReadItem((UBYTE *)&stdvec, namemax,FALSE) > 0) {
       if(act) s= Open(stdvec,MODE_OLDFILE);
       else s = Open(stdvec,MODE_NEWFILE);
       if (!s) SetIoErr((LONG)"Unable to open redirection file");
d711 1
a711 1
UBYTE m; 
@


1.0
log
@added to rcs
@
text
@d8 5
a12 4
#include <libraries/dos.h>
#include <libraries/dosextens.h>
#include <libraries/notify.h>
#include <libraries/filehandler.h>
d19 3
a21 2
#include "proto/exec.h"
#include "proto/intuition.h"
a22 1

d26 2
a27 1
#include "global.h"
a51 5
extern void writef();
extern BPTR openf();
extern void getr2();
extern struct Process *ProcessID();
extern struct Segment *searchsegs();
a52 2


d79 5
d86 2
a87 1
   DOSBase=(struct DOSLibrary *)OpenLibrary("dos.library",0);
a89 1

d95 1
a95 1
   process = ProcessID();
a105 3
/*
kprintf("\n---------------------------------------\nStarting shell\n");
*/
a108 5
    thiseg=searchsegs(gv,"SHELL");
    if(!thiseg)return; /* we got a problem */
    else thiseg->seg_UC =  -1;


d127 1
a127 2
		    fn = (BPTR (*)(struct DosPacket *))
		    CliInitNewcli(parm_pkt);
d131 4
a134 2
		/* we need to clean up */
		return;
d154 2
a155 2
/*		    kprintf("we're leaving, remember to free stuff\n");
*/
d160 1
a160 2
		    SendPkt(parm_pkt,parm_pkt->dp_Port,
					&process->pr_MsgPort);
d164 6
d174 3
a176 5
/*     addseg(gv,"set",link_setenv,-2);
     gv->macrohead = 0;
     setmacro(gv,"$","$");
     setmacro(gv,"emacs","memacs");
*/
d178 3
d182 6
d204 1
a204 1
            WriteChar('O' - '@@');
d216 2
a217 2
            if (outflag == 0)writef(gv,prompt,tnum);
            WriteChar(bufferflush_char);
d226 1
a227 1
         error = FALSE;
a230 1

d241 1
d243 1
d245 4
d253 3
a255 3
                     module = findLoad(gv,"execute",&res2, &seg, &tmp);
                     if (module > 0) {
			UnReadChar(commandname[0]);
d271 4
d277 1
a277 1
                      getr2(gv,&res2);	/* could not find command */
d282 1
d285 1
a285 1
		      writef(gv,"Error code: %N\n",res2);
d296 1
a296 1
                  ch = UnReadChar(1) ? 0 : '\n';
d310 1
a310 1
	 while ((ch != '\n') && (ch != END_STREAM_CH))ch = ReadChar();
a312 1

d340 3
a342 1
      if (pos > 0) WriteBytes ((UBYTE *)BADDR(fh->fh_Buf), pos);
a363 1
   freemacros(gv);	/* free up the macro memory */
d392 1
d403 2
a404 1
	}
a407 1
   p = (struct Path *)clip->cli_CommandDir;
d410 1
d412 3
a414 1
   if (!module)module = load(gv,commandname+1, 0 ,sd, res2, FALSE);
d417 1
d425 7
a431 3
	do {
	    dp=GetDeviceProc("c:",dp);	/* this should bring up a requester */
	    if (dp)module=load(gv,commandname+1,dp->dvp_Lock,sd,res2,FALSE);
d433 1
a433 1
	} while (!module && dp && (dp->dvp_Flags & DVPF_ASSIGN) && 
d435 1
a435 1

d472 1
a472 1
   if(dir)*cd=CurrentDir(dir);
d475 1
a475 1
   if(dir)CurrentDir(*cd);
d478 5
a482 2
   if(seg)return(seg);
   if (res)getr2(gv,codep); /* set result2 if file not found or script file */
d513 2
a514 2
	else if (exinfo->fib_Protection & prot_script) res =  - 1 ;
        else if ((exinfo->fib_Protection & prot_execute) == 0) res = -3;
d557 1
a557 1
      ch = ReadChar();
d565 1
a565 1
         ch = ReadChar();
d571 1
a571 1
            UnReadChar(1);
d632 2
a633 2
				if (ReadChar() == '\n') c = '\n';
				else UnReadChar(1);
d648 1
a648 1
			ch = ReadChar();
a668 1

a680 1

a682 2
/*		else	kprintf("Buf mismatch\n"); */

a684 1
/*		else kprintf("Buf end mismatch\n"); */
a685 1

d715 1
a715 1
    struct DosLibrary *DOSBase;
a716 2
   DOSBase=gv->DOSBase;

d727 1
a727 1
UBYTE *code;	/* is longword aligned */
d730 2
a731 3

BPTR bcode=TO_BPTR(code);

d733 1
a733 1
Resident(name,bcode,flag);
d735 1
a735 2

return(0);
a741 2
    struct Segment *list;
    LONG len;
d743 1
d745 4
a748 14
    Forbid();
    list=(struct Segment *)BADDR(((struct DosInfo *)BADDR(((struct RootNode *)
			(DOSBase->dl_Root))->rn_Info))->di_NetHand);
    len = strlen(name);
    while (list) {
	if(len==list->seg_Name[0]&&
		!strnicmp(name,&(list->seg_Name[1]),len)) {
	    Permit();
	    return(list);
	}
	list = (struct Segment *)BADDR(list->seg_Next);
    }
    Permit();
    return(0);
d768 2
a769 3
   struct DosLibrary *DOSBase;
   DOSBase=gv->DOSBase;
   Writef( fmt, (LONG *)&args );
a770 2


@
