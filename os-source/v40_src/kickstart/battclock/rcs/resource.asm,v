head     39.3;
branch   ;
access   ;
symbols  V39_3:39.3 V39_1:39.1 V37_3:36.12 V37_2:36.11 V37_1:36.9 V36_22:36.9 V36_18:36.8 V36_17:36.8 V36_16:36.7 V36_14:36.6 V36_13:36.5 V36_10:36.4 V36_7:36.3 V36_6:36.3 V36_5:36.2 V36_4:36.1 V36_3:35.1 V36_1:35.1;
locks    ; strict;
comment  @* @;


39.3
date     92.04.20.10.24.54;  author mks;  state Exp;
branches ;
next     39.2;

39.2
date     92.02.19.09.40.14;  author mks;  state Exp;
branches ;
next     39.1;

39.1
date     92.01.20.13.16.34;  author mks;  state Exp;
branches ;
next     39.0;

39.0
date     92.01.14.13.41.57;  author mks;  state Exp;
branches ;
next     36.13;

36.13
date     91.11.05.17.26.25;  author peter;  state Exp;
branches ;
next     36.12;

36.12
date     91.03.11.18.24.31;  author rsbx;  state Exp;
branches ;
next     36.11;

36.11
date     91.02.15.13.12.44;  author rsbx;  state Exp;
branches ;
next     36.10;

36.10
date     91.02.15.13.03.40;  author rsbx;  state Exp;
branches ;
next     36.9;

36.9
date     90.05.31.13.10.07;  author rsbx;  state Exp;
branches ;
next     36.8;

36.8
date     90.03.28.16.28.31;  author rsbx;  state Exp;
branches ;
next     36.7;

36.7
date     90.02.28.11.39.03;  author rsbx;  state Exp;
branches ;
next     36.6;

36.6
date     90.02.26.15.40.43;  author rsbx;  state Exp;
branches ;
next     36.5;

36.5
date     90.02.26.15.32.34;  author rsbx;  state Exp;
branches ;
next     36.4;

36.4
date     89.11.28.22.52.09;  author rsbx;  state Exp;
branches ;
next     36.3;

36.3
date     89.10.11.15.51.45;  author rsbx;  state Exp;
branches ;
next     36.2;

36.2
date     89.10.09.10.21.19;  author rsbx;  state Exp;
branches ;
next     36.1;

36.1
date     89.10.06.13.58.00;  author rsbx;  state Exp;
branches ;
next     35.1;

35.1
date     89.10.06.11.56.30;  author rsbx;  state Exp;
branches ;
next     ;


desc
@This is the "guts" of battclock.resource.
@


39.3
log
@Changed to use TaggedOpenLibrary()
@
text
@*************************************************************************
*									*
*	Copyright (C) 1989, Commodore Amiga Inc.  All rights reserved.	*
*									*
*************************************************************************


*************************************************************************
*
* $Id: resource.asm,v 39.2 92/02/19 09:40:14 mks Exp Locker: mks $
*
* $Log:	resource.asm,v $
* Revision 39.2  92/02/19  09:40:14  mks
* Added empty 12/24 hour LVOs so that CDTV software will not crash
*
* Revision 39.1  92/01/20  13:16:34  mks
* Changed the priority to be above graphics and to not try to set
* the system time.
*
*************************************************************************

	SECTION	BattClock

	INCLUDE	'internal.i'
	INCLUDE	'exec/ables.i'
	INCLUDE	'hardware/custom.i'
	INCLUDE	'internal/librarytags.i'

*------	Imported Functions ------------------------------------------

	XSYS	InitSemaphore
	XSYS	ObtainSemaphore
	XSYS	ReleaseSemaphore
	XSYS	OpenDevice
	XSYS	DoIO
	XSYS	CloseDevice
	XSYS	MakeLibrary
	XSYS	AddResource
	XSYS	TaggedOpenLibrary
	XSYS	CloseLibrary
	XSYS	Amiga2Date
	XSYS	CheckDate

*------	Exported ----------------------------------------------------

	INT_ABLES

	XREF	_custom

*--------------------------------------------------------------------

	moveq.l	#-1,d0
	rts

initDDescrip:		     	;STRUCTURE RT,0
	dc.w	RTC_MATCHWORD	; UWORD RT_MATCHWORD
	dc.l	initDDescrip	; APTR  RT_MATCHTAG
	dc.l	BattClockEnd	; APTR  RT_ENDSKIP
	dc.b	RTF_COLDSTART	; UBYTE RT_FLAGS
	dc.b	VERSION		; UBYTE RT_VERSION
	dc.b	NT_RESOURCE	; UBYTE RT_TYPE
	dc.b	70		; BYTE  RT_PRI
	dc.l	BattClockName	; APTR  RT_NAME
	dc.l	VERSTRING	; APTR  RT_IDSTRING
	dc.l	InitCode	; APTR  RT_INIT
				; LABEL RT_SIZE



BattClockName:
		BATTCLOCKNAME

VERSTRING:	VSTRING

VERNUM:	EQU	VERSION
REVNUM:	EQU	REVISION

	ds.w	0


*------ Functions Offsets -------------------------------------

V_DEF	MACRO
	dc.W	\1\2+(*-initFunc\2)
	ENDM

initFuncOki:
	dc.w	-1
	V_DEF	ResetBattClock,Oki
	V_DEF	ReadBattClock,Oki
	V_DEF	WriteBattClock,Oki
	V_DEF	Zero,Oki
	V_DEF	Zero,Oki
	V_DEF	Zero,Oki	; Same LVO as the 12/24 hour mode in CDTV
	dc.w	-1

initFuncRicoh:
	dc.w	-1
	V_DEF	ResetBattClock,Ricoh
	V_DEF	ReadBattClock,Ricoh
	V_DEF	WriteBattClock,Ricoh
	V_DEF	ReadBattMem,Ricoh
	V_DEF	WriteBattMem,Ricoh
	V_DEF	Zero,Ricoh	; Same LVO as the 12/24 hour mode in CDTV
	dc.w	-1


*------ Initializaton Table -----------------------------------

initStruct:
	INITBYTE	LN_TYPE,NT_RESOURCE
	INITLONG	LN_NAME,BattClockName
	INITBYTE	LIB_FLAGS,LIBF_SUMUSED!LIBF_CHANGED
	INITWORD	LIB_VERSION,VERNUM
	INITWORD	LIB_REVISION,REVNUM
	INITLONG	LIB_IDSTRING,VERSTRING

	DC.L		0


RicohBuffSize	equ	14	; must be even
RicohMemSize	equ	13
RicohBitSize	equ	96	; 12*8



*****i* battclock.resource/internal/InitCode *************************
*
*   NAME
*	InitCode -- Initialize the resource from nothing.
*
*   SYNOPSIS
*	InitCode()
*
*	void InitCode( );
*
*   FUNCTION
*	This routine initializes the battclock.resource from nothing.
*
*   INPUTS
*
*   RESULTS
*
*   NOTES
*
*   SEE ALSO
*
*   BUGS
*
**********************************************************************
*
*   IMPLEMENTATION NOTES
*
*   REGISTER USAGE
*
*	A4 -- ClockBase pointer
*	A3 -- utility.library pointer
*	A2 -- battclock.resource pointer
*

InitCode:
	movem.l	a2/a3/a4/a6,-(sp)
	move.l	#0,a2		; for no resource case

	moveq.l	#OLTAG_UTILITY,d0
	CALLSYS	TaggedOpenLibrary
	tst.l	d0
	beq.s	InitEnd
	move.l	d0,a3		; utilityLib base

	move.l	#CLOCKBASE,a4	; now find the clock
	move.l	a4,a0
	bsr	GetClockType
	tst.l	d0		; is one there?
	beq.s	InitEnd		; no, no resource
	cmp.l	#OKI_CLOCK,d0	; is it an Oki?
	bne.s	NotOki		; no
; Oki
	lea	initFuncOki(pc),a0	; point to correct set of offsets
	bsr.s	MakeResource	; go make and add the resource
	move.l	a4,a0		; where was the clock?
	bsr	ReadOki		; read the time
	bra.s	InitCommon
NotOki
	cmp.l	#OKI_RESET,d0	; is it a trashed Oki?
	bne.s	NotOkiR		; no
; trashed Oki
	lea	initFuncOki(pc),a0	; point to correct set of offsets
	bsr.s	MakeResource	; go make and add the resource
	move.l	a4,a0		; where was the clock?
	bsr	ResetOki	; reset the clock chip
	moveq.l	#0,d0
	bra.s	InitCommon
NotOkiR
	cmp.l	#RICOH_CLOCK,d0	; is it a Ricoh?
	bne.s	NotRicoh	; no
; Ricoh
	lea	initFuncRicoh(pc),a0	; point to function offsets
	bsr.s	MakeResource	; go make add the resource
	move.l	a4,a0		; clock address
	bsr	ReadRicoh	; read the time
	bra.s	InitCommon
NotRicoh
	cmp.l	#RICOH_RESET,d0	; is it a trashed Ricoh?
	bne.s	InitEnd		; no
; trashed Ricoh
	lea	initFuncRicoh(pc),a0	; point to function offsets
	bsr.s	MakeResource	; go make add the resource
	move.l	a4,a0		; clock address
	bsr	ResetRicoh	; reset the clock chip
	moveq.l	#0,d0

InitCommon

InitEnd:
	move.l	a2,d0		; battclockbase or NULL
	movem.l	(sp)+,a2/a3/a4/a6
	rts


*****i* battclock.resource/internal/MakeResource *********************
*
*   NAME
*	MakeResource -- Create, initialize, and add battclock.resource
*	    to the system list.
*
*   SYNOPSIS
*	BTC = MakeResource(ClockBase, UtilBase, FuncTable)
*	A2                 A4         A3        A0
*
*	Struct BattClockResource * MakeResource( APTR, struct Library *, APTR );
*
*   FUNCTION
*	This routine creates and initializes the battclock.resource
*	    structure.
*
*   INPUTS
*	ClockBase -- Pointer to the base address of the clock chip.
*	UtilBase -- Pointer to utility.library.
*	FuncTable -- Pointer to the function pointer table for
*	    MakeLibrary()
*
*   RESULTS
*	BTC -- Pointer to BattClockResource structure.
*
*   NOTES
*	Battclock.resource properly initialized with resource pointer
*	    returned in A2 and A6. If any error occures, then the
*	    resource will not be created and A2 will be NULL and A6
*	    unchanged.
*
*   SEE ALSO
*
*   BUGS
*
**********************************************************************
*
*   IMPLEMENTATION NOTES
*
*   REGISTER USAGE
*
*	A4 -- ClockBase pointer
*	A3 -- utility.library pointer
*	A2 -- battclock.resource pointer
*

MakeResource:
	lea	initStruct,a1	; initialize the library node
	suba.l	a2,a2
	move.l	#BTC_SIZE,d0
	CALLSYS	MakeLibrary	; make us a playpen
	move.l	d0,a2		; save the base
	tst.l	d0		; was there a hitch?
	beq.s	MakeLibFailed	; damn

	move.l	#MAGIC,BTC_Magic(a2)	; for BattMem
	move.l	a6,BTC_Exec(a2)		; set our data
	move.l	a3,BTC_UtilLib(a2)
	move.l	a4,BTC_ClockBase(a2)
	lea	BTC_Semaphore(a2),a0	; to prevent conflicts
	CALLSYS	InitSemaphore
	move.l	a2,a1
	CALLSYS	AddResource	; yea! we made it
	move.l	a2,a6		; a6 now has BattClockBase
	rts

MakeLibFailed:
	move.l	a3,a1		; be nice
	CALLSYS	CloseLibrary
	move.l	(sp)+,d0	; dump return address
	bra	InitEnd		; bye


*****i* battclock.resource/internal/Zero *****************************
*
*   NAME
*	Zero -- Returns 0 in register D0.
*
*   SYNOPSIS
*	Result = Zero( )
*
*	ULONG Zero( );
*
*   FUNCTION
*	Returns 0.
*
*   INPUTS
*
*   RESULTS
*	Result -- Will be 0.
*
*   NOTES
*
*   SEE ALSO
*
*   BUGS
*
**********************************************************************
*
*   IMPLEMENTATION NOTES
*
*   REGISTER USAGE
*
*

Zero:
ZeroOki:
ZeroRicoh:
	moveq.l	#0,d0
	rts


*****i* battclock.resource/internal/GetClockType *********************
*
*   NAME
*	GetClockType -- Determine what kind of clock chip is in the
*	    system.
*
*   SYNOPSIS
*	Type = GetCLockType( ClockBase )
*	D0                   A0
*
*	ULONG GetClockType( APTR );
*
*   FUNCTION
*	This routine attempts to determine if a clock chip exists at
*	    ClockBase and what kind it is.
*
*   INPUTS
*	ClockBase -- Pointer to the base address of the clock chip.
*
*   RESULTS
*	Type -- The type of clock chip found or 0.
*
*   NOTES
*
*   SEE ALSO
*
*   BUGS
*
**********************************************************************
*
*   IMPLEMENTATION NOTES
*
*   REGISTER USAGE
*
*

GetClockType:
; first check if there are custom chip registers
; where the clock should be
	DISABLE	a1
	move.l	a0,-(sp)
	lea	_custom,a1
	move.w	intenar(a1),d1
	lea	intena(a1),a1
	lea	intenar(a0),a0
	move.w	(a0),d0
	cmp.w	d0,d1
	bne.s	NotChip
	tst.w	d1
	beq.s	NoInts
	move.w	d1,(a1)
	tst.w	(a0)
	bne.s	NotChip
NoInts
	move.w	#$aaaa,(a1)
	move.w	(a0),d0
	cmp.w	#$2aaa,d0
	bne.s	NotChip
	move.w	d0,(a1)
	tst.w	(a0)
	bne.s	NotChip
	move.w	#$9555,(a1)
	move.w	(a0),d0
	cmp.w	#$1555,d0
	bne.s	NotChip
	move.w	d0,(a1)
	tst.w	(a0)
	bne.s	NotChip
Chip
	moveq.l	#1,d0
	bra.s	FixChip
NotChip
	moveq.l	#0,d0
FixChip
	move.w	#$7fff,(a1)
	ori.w	#$8000,d1
	move.w	d1,(a1)
	move.l	(sp)+,a0
	ENABLE	a1
	tst.l	d0
	bne.s	NoClock
; it doesn't look like custom chip registers, so
; go looking for a clock we know about

	moveq.l	#$f,d1		; data mask

; on a non-trashed Oki, regf will be 4
; on a Ricoh, regf is always read as 0
	move.b	Regf(a0),d0
	and.b	d1,d0
	cmp.b	#4,d0
	beq.s	Oki

; its either a trashed Oki, a Ricoh or it isn't
	clr.b	Regf(a0)	; reset test modes
	clr.b	Rege(a0)
	move.b	#9,Regd(a0)	; try for Ricoh page 1

; on a Ricoh, page 1 regc will always read as 0
	move.b	#5,Regc(a0)
	move.b	Regc(a0),d0
	and.b	d1,d0
	beq.s	TestRicoh

; its either a trashed oki or not there
TestOki
	move.b	#4,Regd(a0)	; reset oki
	move.b	#7,Regf(a0)
	move.b	#4,Regf(a0)
	clr.b	Rege(a0)

	move.b	#1,Regf(a0)	; set 24hr mode
	move.b	#5,Regf(a0)
	move.b	#4,Regf(a0)

; if its an Oki, regf will read as 4
	move.b	Regf(a0),d0
	and.b	d1,d0
	cmp.b	#4,d0
	beq.s	TrashedOki
NoClock
	moveq.l	#NO_CLOCK,d0	; hope its a A500
	rts
TrashedOki
	moveq.l	#OKI_RESET,d0	; we found a trashed Oki
	rts
Oki
	moveq.l	#OKI_CLOCK,d0	; we found an Oki
	rts

; its either a Ricoh or it isn't there
; if its a Ricoh, regd will be 9
TestRicoh
	move.b	Regd(a0),d0
	and.b	d1,d0
	cmp.b	#9,d0
	bne.s	NoClock
; check the 24hr bit
	move.b	Rega(a0),d0
	btst	#0,d0
	bne.s	Ricoh
	moveq.l	#RICOH_RESET,d0
	rts
Ricoh
	move.b	#9,Regd(a0)
	moveq.l	#RICOH_CLOCK,d0
	rts


******* battclock.resource/ResetBattClock ****************************
*
*   NAME
*	ResetBattClock -- Reset the clock chip.  (V36)
*
*   SYNOPSIS
*	ResetBattClock( )
*
*	void ResetBattClock( void );
*
*   FUNCTION
*	This routine does whatever is neeeded to put the clock chip
*	into a working and usable state and also sets the date on the
*	clock chip to 01-Jan-1978.
*
*   INPUTS
*
*   RESULTS
*
*   NOTES
*
*   SEE ALSO
*
*   BUGS
*
**********************************************************************
*
*   IMPLEMENTATION NOTES
*
*   REGISTER USAGE
*
*

ResetBattClockOki:
	lea	BTC_Semaphore(a6),a0	; grab the semaphore
	LINKSYS	ObtainSemaphore
	move.l	BTC_ClockBase(a6),a0	; get the clock address

	bsr	ResetOki		; make it right

	lea	BTC_Semaphore(a6),a0	; release the semaphore
	LINKSYS	ReleaseSemaphore
	rts


ResetBattClockRicoh:
	lea	BTC_Semaphore(a6),a0	; grab the semaphore
	LINKSYS	ObtainSemaphore
	move.l	BTC_ClockBase(a6),a0	; get the clock address

	bsr	ResetRicoh		; make it right

	lea	BTC_Semaphore(a6),a0	; release the semaphore
	LINKSYS	ReleaseSemaphore
	rts


******* battclock.resource/ReadBattClock *****************************
*
*   NAME
*	ReadBattClock -- Read time from clock chip.  (V36)
*
*   SYNOPSIS
*	AmigaTime = ReadBattClock( )
*
*	ULONG ReadBattClock( void );
*	D0
*
*   FUNCTION
*	This routine reads the time from the clock chip and returns it
*	as the number of seconds from 01-jan-1978.
*
*   INPUTS
*
*   RESULTS
*	AmigaTime       The number of seconds from 01-Jan-1978 that
*	                    the clock chip thinks it is.
*
*   NOTES
*	If the clock chip returns an invalid date, the clock chip is
*	reset and 0 is returned.
*
*   SEE ALSO
*
*   BUGS
*
**********************************************************************
*
*   IMPLEMENTATION NOTES
*
*   REGISTER USAGE
*
*

ReadBattClockOki:
	lea	BTC_Semaphore(a6),a0	; grab the semaphore
	LINKSYS	ObtainSemaphore
	move.l	BTC_ClockBase(a6),a0	; get the clock address

	bsr	ReadOki			; get the time

	move.l	d0,-(sp)
	lea	BTC_Semaphore(a6),a0	; release the semaphore
	LINKSYS	ReleaseSemaphore
	move.l	(sp)+,d0
	rts


ReadBattClockRicoh:
	lea	BTC_Semaphore(a6),a0	; grab the semaphore
	LINKSYS	ObtainSemaphore
	move.l	BTC_ClockBase(a6),a0	; get the clock address

	bsr	ReadRicoh		; get the time

	move.l	d0,-(sp)
	lea	BTC_Semaphore(a6),a0	; release the semaphore
	LINKSYS	ReleaseSemaphore
	move.l	(sp)+,d0
	rts


******* battclock.resource/WriteBattClock ****************************
*
*   NAME
*	WriteBattClock -- Set the time on the clock chip.  (V36)
*
*   SYNOPSIS
*	WriteBattClock( AmigaTime )
*	                D0
*
*	void WriteBattClock( ULONG );
*
*   FUNCTION
*	This routine writes the time given in AmigaTime to the clock
*	chip.
*
*   INPUTS
*	AmigaTime       The number of seconds from 01-Jan-1978 to the
*	                    time that should be written to the clock
*	                    chip.
*
*   RESULTS
*
*   NOTES
*
*   SEE ALSO
*
*   BUGS
*
**********************************************************************
*
*   IMPLEMENTATION NOTES
*
*   REGISTER USAGE
*
*

WriteBattClockOki:
	move.l	d0,-(sp)
	lea	BTC_Semaphore(a6),a0	; grab the semaphore
	LINKSYS	ObtainSemaphore
	move.l	BTC_ClockBase(a6),a0	; get the clock address
	move.l	(sp)+,d0

	bsr	WriteOki		; put the time

	lea	BTC_Semaphore(a6),a0	; release the semaphore
	LINKSYS	ReleaseSemaphore
	rts


WriteBattClockRicoh:
	move.l	d0,-(sp)
	lea	BTC_Semaphore(a6),a0	; grab the semaphore
	LINKSYS	ObtainSemaphore
	move.l	BTC_ClockBase(a6),a0	; get the clock address
	move.l	(sp)+,d0

	bsr	WriteRicoh		; put the time

	lea	BTC_Semaphore(a6),a0	; release the semaphore
	LINKSYS	ReleaseSemaphore
	rts


*****i* battclock.resource/internal/WriteRawClock ********************
*
*   NAME
*	WriteRawClock -- Write precomputed data to the clock chip.
*
*   SYNOPSIS
*	WriteRawClock( ClockBase, Data )
*	               A0         A1
*
*	void WriteRawClock( APTR, struct ClockTemp * );
*
*   FUNCTION
*	Writes precomputed and formatted data to the clock chip.
*
*   INPUTS
*	ClockBase -- Pointer to the clock chip base address.
*	Data -- Pointer to the data to be written to the clock chip.
*
*   RESULTS
*
*   NOTES
*
*   SEE ALSO
*
*   BUGS
*
**********************************************************************
*
*   IMPLEMENTATION NOTES
*
*   REGISTER USAGE
*
*

WriteRawClock:
	move.b	(a1)+,Reg0(a0)	;sec	;sec
	move.b	(a1)+,Reg1(a0)
	move.b	(a1)+,Reg2(a0)	;min	;min
	move.b	(a1)+,Reg3(a0)
	move.b	(a1)+,Reg4(a0)	;hour	;hour
	move.b	(a1)+,Reg5(a0)
	move.b	(a1)+,Reg6(a0)	;mday	;wday
	move.b	(a1)+,Reg7(a0)		;mday
	move.b	(a1)+,Reg8(a0)	;month
	move.b	(a1)+,Reg9(a0)		;month
	move.b	(a1)+,Rega(a0)	;year
	move.b	(a1)+,Regb(a0)		;year
	move.b	(a1)+,Regc(a0)	;wday
	rts


*****i* battclock.resource/internal/ReadRawClock *********************
*
*   NAME
*	ReadRawClock -- Read data from the clock chip.
*
*   SYNOPSIS
*	ReadRawClock( ClockBase, Data )
*	              A0         A1
*
*	void ReadRawClock( APTR, struct ClockTemp * );
*
*   FUNCTION
*	Reads data from the clock chip.
*
*   INPUTS
*	ClockBase -- Pointer to the clock chip base address.
*	Data -- Pointer to where the data read from the clock chip
*	    should be written.
*
*   RESULTS
*
*   NOTES
*
*   SEE ALSO
*
*   BUGS
*
**********************************************************************
*
*   IMPLEMENTATION NOTES
*
*   REGISTER USAGE
*
*

ReadRawClock:
	moveq.l	#$f,d0
	move.b	Reg0(a0),(a1)	;sec	;sec
	and.b	d0,(a1)+
	move.b	Reg1(a0),(a1)
	and.b	d0,(a1)+
	move.b	Reg2(a0),(a1)	;min	;min
	and.b	d0,(a1)+
	move.b	Reg3(a0),(a1)
	and.b	d0,(a1)+
	move.b	Reg4(a0),(a1)	;hour	;hour
	and.b	d0,(a1)+
	move.b	Reg5(a0),(a1)
	and.b	d0,(a1)+
	move.b	Reg6(a0),(a1)	;mday	;wday
	and.b	d0,(a1)+
	move.b	Reg7(a0),(a1)		;mday
	and.b	d0,(a1)+
	move.b	Reg8(a0),(a1)	;month
	and.b	d0,(a1)+
	move.b	Reg9(a0),(a1)		;month
	and.b	d0,(a1)+
	move.b	Rega(a0),(a1)	;year
	and.b	d0,(a1)+
	move.b	Regb(a0),(a1)		;year
	and.b	d0,(a1)+
	move.b	Regc(a0),(a1)	;wday
	and.b	d0,(a1)+
	rts


*****i* battclock.resource/internal/Bin2Bcd **************************
*
*   NAME
*	Bin2Bcd -- Convert a binary number to 2 BCD digits.
*
*   SYNOPSIS
*	Bin2Bcd( Num, Ten, Where )
*	         D0   D1   A2
*
*	void Bin2Bcd( ULONG, UWORD, APTR );
*
*   FUNCTION
*	Converts a binary number to 2 BCD digits and stores them is
*	    separate bytes.
*
*   INPUTS
*	Num -- Binary number to convert.
*	Ten -- 10.
*	Where -- Location to write the 2 BCD digits.
*
*   RESULTS
*
*   NOTES
*
*   SEE ALSO
*
*   BUGS
*
**********************************************************************
*
*   IMPLEMENTATION NOTES
*
*   REGISTER USAGE
*
*

Bin2Bcd:
	divu.w	d1,d0
	swap.w	d0
	move.b	d0,(a2)+
	swap.w	d0
	move.b	d0,(a2)+
	rts


*****i* battclock.resource/internal/Bcd2Bin **************************
*
*   NAME
*	Bcd2Bin -- Convert a BCD number to binary.
*
*   SYNOPSIS
*	Num = Bcd2Bin( Ten, Where )
*	D0             D1   A2
*
*	ULONG Bcd2Bin( UWORD, APTR );
*
*   FUNCTION
*	Converts a BCD number stored as 2 BCD digits in separate byte
*	    to binary.
*
*   INPUTS
*	Ten -- 10.
*	Where -- Location of the 2 BCD digits.
*
*   RESULTS
*	Num -- Binary result.
*
*   NOTES
*
*   SEE ALSO
*
*   BUGS
*
**********************************************************************
*
*   IMPLEMENTATION NOTES
*
*   REGISTER USAGE
*
*

Bcd2Bin:
	moveq.l	#0,d0
	move.b	(a2)+,d2
	move.b	(a2)+,d0
	mulu.w	d1,d0
	add.b	d2,d0
	rts


*****i* battclock.resource/internal/SetOkiHold ***********************
*
*   NAME
*	SetOkiHold -- Get the Oki clock chip to stop ticking.
*
*   SYNOPSIS
*	SetOkiHold( ClockBase )
*	            A0
*
*	void SetOkiHold( APTR );
*
*   FUNCTION
*	Sets the hold bit on an Oki clock chip so that the clock data
*	    can br read or written.
*
*   INPUTS
*	ClockBase -- Base address of Oki clock chip.
*
*   RESULTS
*
*   NOTES
*	If the hold cannot be achieved in 400 tries, the chip is reset
*	    and another attempt is made. This may trash the time!
*
*   SEE ALSO
*
*   BUGS
*
**********************************************************************
*
*   IMPLEMENTATION NOTES
*
*   REGISTER USAGE
*
*

SetOkiHold:
	moveq.l	#1,d0		; for convenience
	move.l	#400,d1		; timeout
SOHls1
	move.b	d0,Regd(a0)	; set holdbit
	btst.b	d0,Regd(a0)	; still busy?
	beq.s	HaveOkiHold	; no, got it
	clr.b	Regd(a0)	; reset holdbit
	dbf	d1,SOHls1	; loop

	; if we get here then there is a problem getting the hold
	;  so we try reseting the chip (maybe trashing the time!)
	move.b	#4,Regd(a0)
	move.b	#7,Regf(a0)
	move.b	#4,Regf(a0)
	clr.b	Rege(a0)

	move.b	d0,Regf(a0)
	move.b	#5,Regf(a0)
	move.b	#4,Regf(a0)
	; and try for the hold again

	move.l	#400,d1
SOHls2
	move.b	d0,Regd(a0)	; set holdbit
	btst.b	d0,Regd(a0)	; still busy?
	beq.s	HaveOkiHold	; no, got it
	clr.b	Regd(a0)	; reset holdbit
	dbf	d1,SOHls2	; loop
	; if we fall out here, give up, hopefully the user will notice
	; that the time is wrong

HaveOkiHold
	rts


*****i* battclock.resource/internal/WriteOki *************************
*
*   NAME
*	WriteOki -- Set the time on an Oki clock chip.
*
*   SYNOPSIS
*	WriteOki( AmigaTime, ClockBase )
*	          D0         A0
*
*	void WriteOki( ULONG, APTR );
*
*   FUNCTION
*	Sets the time on an Oki clock chip to that given in AmigaTime.
*
*   INPUTS
*	AmigaTime -- The time to write to the clock chip given as the
*	    number of seconds from 01-Jan-1978.
*	ClockBase -- Base address of Oki clock chip.
*
*   RESULTS
*
*   NOTES
*	The Oki clock chip only stores the last 2 digits to the year,
*	    so valid dates are 01-Jan-1978 to 31-Dec-2077.
*
*   SEE ALSO
*
*   BUGS
*
**********************************************************************
*
*   IMPLEMENTATION NOTES
*
*   REGISTER USAGE
*
*

WriteOki:
	move.l	a2,-(sp)
	lea	-ClockTempSize-CD_SIZE(sp),sp	; get some temp areas
	move.l	sp,a2			; clocktemp struct
	move.l	a0,-(sp)		; save clockbase
	lea	ClockTempSize(a2),a0	; ClockData struct
	LINKLIB	_LVOAmiga2Date,BTC_UtilLib(a6)	; fill in ClockData from AmigaTime
	lea	ClockTempSize(a2),a1	; ClockData struct (same one)
	move.l	(sp)+,a0		; clockbase

	; convert ClockData to clocktemp (correctly formatted)
	moveq.l	#10,d1			; for convenience

	moveq.l	#0,d0
	move.w	sec(a1),d0
	bsr	Bin2Bcd

	moveq.l	#0,d0
	move.w	min(a1),d0
	bsr	Bin2Bcd

	moveq.l	#0,d0
	move.w	hour(a1),d0
	bsr	Bin2Bcd

	moveq.l	#0,d0
	move.w	mday(a1),d0
	bsr	Bin2Bcd

	moveq.l	#0,d0
	move.w	month(a1),d0
	bsr	Bin2Bcd

	moveq.l	#0,d0
	move.w	year(a1),d0
	divu.w	d1,d0
	swap.w	d0
	move.b	d0,(a2)+
	clr.w	d0
	swap.w	d0
	divu.w	d1,d0
	swap.w	d0
	move.b	d0,(a2)+

	moveq.l	#0,d0
	move.w	wday(a1),d0
	divu.w	d1,d0
	swap.w	d0
	move.b	d0,(a2)+

	move.l	sp,a2		; clocktemp (again)

	; what the hey, reset the thing
	move.b	#4,Regd(a0)
	move.b	#7,Regf(a0)
	move.b	#4,Regf(a0)
	clr.b	Rege(a0)

	move.b	#1,Regf(a0)
	move.b	#5,Regf(a0)
	move.b	#4,Regf(a0)

	bsr	SetOkiHold	; hold it
	exg.l	a2,a1
	bsr	WriteRawClock	; write the data
	exg.l	a2,a1
	clr.b	Regd(a0)	; Release Oki hold

	lea	CD_SIZE+ClockTempSize(sp),sp
	move.l	(sp)+,a2
	rts

*****i* battclock.resource/internal/ReadOki **************************
*
*   NAME
*	ReadOki -- Get the time from an Oki clock chip.
*
*   SYNOPSIS
*	AmigaTime = ReadOki( ClockBase )
*	                     A0
*
*	ULONG ReadOki( APTR );
*
*   FUNCTION
*	Returns the time from an Oki clock chip.
*
*   INPUTS
*	ClockBase -- Base address of Oki clock chip.
*
*   RESULTS
*	AmigaTime -- The time from the clock chip given as the
*	    number of seconds from 01-Jan-1978.
*
*   NOTES
*	The Oki clock chip only stores the last 2 digits to the year,
*	    so valid dates are 01-Jan-1978 to 31-Dec-2077.
*
*   SEE ALSO
*
*   BUGS
*
**********************************************************************
*
*   IMPLEMENTATION NOTES
*
*   REGISTER USAGE
*
*

ReadOki:
	movem.l	d2/a2,-(sp)
	lea	-ClockTempSize-CD_SIZE(sp),sp	; get some temp
	move.l	sp,a1			; clocktemp struct
	lea	ClockTempSize(a1),a2	; ClockData struct

	bsr	SetOkiHold	; stop ticking
	bsr	ReadRawClock	; get the data
	exg.l	a2,a1		; ClockData to a1
	clr.b	Regd(a0)	; Release Oki hold

	; convert clocktemp to ClockData
	move.l	sp,a2
	moveq.l	#10,d1

	bsr	Bcd2Bin
	move.w	d0,sec(a1)

	bsr	Bcd2Bin
	move.w	d0,min(a1)

	bsr	Bcd2Bin
	move.w	d0,hour(a1)

	bsr	Bcd2Bin
	move.w	d0,mday(a1)

	bsr	Bcd2Bin
	move.w	d0,month(a1)

	bsr	Bcd2Bin
	add.w	#1900,d0
	cmp.w	#1978,d0
	bcc.s	OkiNow
	add.w	#100,d0
OkiNow
	move.w	d0,year(a1)

	moveq.l	#0,d0
	move.b	(a2)+,d0
	move.w	d0,wday(a1)

	lea	ClockTempSize(sp),sp	; give back some temp
	move.l	a0,a2		; save clockbase
	move.l	a1,a0		; clockdata
	LINKLIB	_LVOCheckDate,BTC_UtilLib(a6)	; convert & check date
	move.l	a2,a0		; clockdata
	tst.l	d0		; good date?
	bne.s	ReadCommon	; yes

	bsr.s	ResetOki	; bad date
	moveq.l	#0,d0


ReadCommon:
	lea	CD_SIZE(sp),sp	; return temp
	movem.l	(sp)+,d2/a2
	rts


*****i* battclock.resource/internal/ResetOki *************************
*
*   NAME
*	ResetOki -- Reset the Oki clock chip.
*
*   SYNOPSIS
*	ResetOki( ClockBase )
*	          A0
*
*	void ResetOki( APTR );
*
*   FUNCTION
*	Resets the Oki clock chip to a usable state and sets the date
*	    on the chip to 01-Jan-1978.
*
*   INPUTS
*	ClockBase -- Base address of Oki clock chip.
*
*   RESULTS
*
*   NOTES
*
*   SEE ALSO
*
*   BUGS
*
**********************************************************************
*
*   IMPLEMENTATION NOTES
*
*   REGISTER USAGE
*
*

ResetOki:
	move.b	#4,Regd(a0)
	move.b	#7,Regf(a0)
	move.b	#4,Regf(a0)
	clr.b	Rege(a0)

	move.b	#1,Regf(a0)
	move.b	#5,Regf(a0)
	move.b	#4,Regf(a0)

	moveq.l	#0,d0
	bsr	WriteOki	; put the date
	rts


*****i* battclock.resource/internal/ResetRicoh ***********************
*
*   NAME
*	ResetRicoh -- Reset the Ricoh clock chip.
*
*   SYNOPSIS
*	ResetRicoh( ClockBase )
*	            A0
*
*	void ResetRicoh( APTR );
*
*   FUNCTION
*	Resets the Ricoh clock chip to a usable state and sets the date
*	    on the chip to 01-Jan-1978.
*
*   INPUTS
*	ClockBase -- Base address of Ricoh clock chip.
*
*   RESULTS
*
*   NOTES
*
*   SEE ALSO
*
*   BUGS
*
**********************************************************************
*
*   IMPLEMENTATION NOTES
*
*   REGISTER USAGE
*
*

ResetRicoh
	clr.b	Rege(a0)
	move.b	#1,Regd(a0)
	move.b	#3,Regf(a0)
	clr.b	Regf(a0)
	move.b	#1,Rega(a0)
	move.b	#9,Regd(a0)

	moveq.l	#0,d0
	bsr.s	WriteRicoh	; put the date
	rts


*****i* battclock.resource/internal/WriteRicoh ***********************
*
*   NAME
*	WriteOki -- Set the time on an Ricoh clock chip.
*
*   SYNOPSIS
*	WriteRicoh( AmigaTime, ClockBase )
*	            D0         A0
*
*	void WriteRicoh( ULONG, APTR );
*
*   FUNCTION
*	Sets the time on an Ricoh clock chip to that given in AmigaTime.
*
*   INPUTS
*	AmigaTime -- The time to write to the clock chip given as the
*	    number of seconds from 01-Jan-1978.
*	ClockBase -- Base address of Ricoh clock chip.
*
*   RESULTS
*
*   NOTES
*	The Ricoh clock chip only stores the last 2 digits to the year,
*	    so valid dates are 01-Jan-1978 to 31-Dec-2077.
*
*   SEE ALSO
*
*   BUGS
*
**********************************************************************
*
*   IMPLEMENTATION NOTES
*
*   REGISTER USAGE
*
*

WriteRicoh:
	move.l	a2,-(sp)
	lea	-ClockTempSize-CD_SIZE(sp),sp	; need some temp
	move.l	sp,a2			; clockTemp
	move.l	a0,-(sp)		; save clockbase
	lea	ClockTempSize(a2),a0	; ClockData struct
	LINKLIB	_LVOAmiga2Date,BTC_UtilLib(a6)	; fill in ClockData struct
	lea	ClockTempSize(a2),a1	; ClockData struct (again)
	move.l	(sp)+,a0	; ClockBase

	; convert ClockData to ClockTemp (formatted correctly)
	moveq.l	#10,d1

	moveq.l	#0,d0
	move.w	sec(a1),d0
	bsr	Bin2Bcd

	moveq.l	#0,d0
	move.w	min(a1),d0
	bsr	Bin2Bcd

	moveq.l	#0,d0
	move.w	hour(a1),d0
	bsr	Bin2Bcd

	moveq.l	#0,d0
	move.w	wday(a1),d0
	divu.w	d1,d0
	swap.w	d0
	move.b	d0,(a2)+

	moveq.l	#0,d0
	move.w	mday(a1),d0
	bsr	Bin2Bcd

	moveq.l	#0,d0
	move.w	month(a1),d0
	bsr	Bin2Bcd

	moveq.l	#0,d0
	move.w	year(a1),d0
	divu.w	d1,d0
	swap.w	d0
	move.b	d0,(a2)+
	clr.w	d0
	swap.w	d0
	divu.w	d1,d0
	swap.w	d0
	move.b	d0,(a2)+

	move.l	sp,a2		; ClockTemp

	clr.b	Rege(a0)
	clr.b	Regd(a0)	; set hold
	exg.l	a2,a1
	bsr	WriteRawClock	; write the data to the chip
	exg.l	a2,a1
	move.b	#1,Regd(a0)
	move.b	#1,Rega(a0)	; set 24hr mode
	move.b	1+year(a1),Regb(a0)	; set the leapyear counter
	move.b	#3,Regf(a0)	; clear intermediate counts
	clr.b	Regf(a0)
	move.b	#9,Regd(a0)	; release hold

	lea	CD_SIZE+ClockTempSize(sp),sp
	move.l	(sp)+,a2
	rts


*****i* battclock.resource/internal/ReadRicoh ************************
*
*   NAME
*	ReadRicoh -- Get the time from an Ricoh clock chip.
*
*   SYNOPSIS
*	AmigaTime = ReadRicoh( ClockBase )
*	                       A0
*
*	ULONG ReadRicoh( APTR );
*
*   FUNCTION
*	Returns the time from an Ricoh clock chip.
*
*   INPUTS
*	ClockBase -- Base address of Ricoh clock chip.
*
*   RESULTS
*	AmigaTime -- The time from the clock chip given as the
*	    number of seconds from 01-Jan-1978.
*
*   NOTES
*	The Ricoh clock chip only stores the last 2 digits to the year,
*	    so valid dates are 01-Jan-1978 to 31-Dec-2077.
*
*   SEE ALSO
*
*   BUGS
*
**********************************************************************
*
*   IMPLEMENTATION NOTES
*
*   REGISTER USAGE
*
*

ReadRicoh:
	movem.l	d2/a2,-(sp)
	lea	-ClockTempSize-CD_SIZE(sp),sp	; need temp
	move.l	sp,a1			; clocktemp struct
	lea	ClockTempSize(a1),a2	; ClockData struct

	clr.b	Regd(a0)	; set hold
	bsr	ReadRawClock	; get the raw clock data
	exg.l	a2,a1
	move.b	#9,Regd(a0)	; release hold

	move.l	sp,a2		; ClockTemp

	; convert ClockTemp into ClockData
	moveq.l	#10,d1

	bsr	Bcd2Bin
	move.w	d0,sec(a1)

	bsr	Bcd2Bin
	move.w	d0,min(a1)

	bsr	Bcd2Bin
	move.w	d0,hour(a1)

	moveq.l	#0,d0
	move.b	(a2)+,d0
	move.w	d0,wday(a1)

	bsr	Bcd2Bin
	move.w	d0,mday(a1)

	bsr	Bcd2Bin
	move.w	d0,month(a1)

	bsr	Bcd2Bin
	add.w	#1900,d0
	cmp.w	#1978,d0
	bcc.s	RicohNow
	add.w	#100,d0
RicohNow
	move.w	d0,year(a1)

	lea	ClockTempSize(sp),sp	; return some temp
	move.l	a0,a2		; clockbase
	move.l	a1,a0		; ClockData struct
	LINKLIB	_LVOCheckDate,BTC_UtilLib(a6)	; is the date good?
	move.l	a2,a0		; clockbase
	tst.l	d0		; good date?
	bne	ReadCommon	; yes

	bsr	ResetRicoh	; BZZZZZZZT, no reset the chip
	moveq.l	#0,d0
	bra	ReadCommon


*****i* battclock.resource/internal/ReadBattClockMem *****************
*
*   NAME
*	ReadBattCLockMem -- Read a bitstring from nonvolatile ram.
*
*   SYNOPSIS
*	Data = ReadBattClockMem( Offset, Len )
*	D0                       D1      D2
*
*	ULONG ReadBattCLockMem( ULONG, ULONG );
*
*   FUNCTION
*	Read a bitstring from nonvolatile ram.
*
*   INPUTS
*	Offset -- Bit offset of first bit to read.
*	Len -- Length of bitstring to read.
*
*   RESULTS
*	Data -- Bitstring read, right justified.
*
*   NOTES
*	This operation will "clip" the write to the memory available
*	    in the clock chip and return 0s for bits outside memory
*	    available.
*	Lengths greater than 32 are set to 32.
*
*   SEE ALSO
*
*   BUGS
*
**********************************************************************
*
*   IMPLEMENTATION NOTES
*
*   REGISTER USAGE
*
*

ReadBattMemRicoh:
	movem.l	d2-d4,-(sp)
	move.l	d1,d4
	lea	BTC_Semaphore(a6),a0	; grab the semaphore
	LINKSYS	ObtainSemaphore
	move.l	BTC_ClockBase(a6),a0	; get the clock address
	moveq.l	#0,d0
	move.l	d0,-(sp)
	lea	-RicohBuffSize(sp),sp
	move.l	sp,a1
	bsr	GetMemRicoh
	move.l	d4,d1
	moveq.l	#0,d0			; set the 4 bytes after the legal
	move.b	d0,RicohMemSize-1(a1)	;  memory to zero (makes my life
	move.b	d0,RicohMemSize+0(a1)	;  easier).
	move.b	d0,RicohMemSize+1(a1)
	move.b	d0,RicohMemSize+2(a1)

; at this point a1 -> Ricoh buffer (validated)
	tst.l	d2
	beq.s	RBMRexit
	cmp.l	#32,d2
	bls.s	RBMRLenOk1
	moveq.l	#32,d2
RBMRLenOk1
	moveq.l	#0,d0
	move.l	#RicohBitSize,d3	; left = 96
	sub.l	d1,d3		; left = 96 - offset
	bls.s	RBMRexit	; if (left <= 0) goto WBMRexit

; at this point offset and len are valid
	moveq.l	#-1,d3
	lsr.l	d2,d3
	not.l	d3		; data mask (left justified)

	move.l	d1,d4
	asr.l	#3,d1
	add.l	d1,a1
	and.l	#7,d4
	beq.s	RBMRNoRot1
	ror.l	d4,d3
RBMRNoRot1

	moveq.l	#3,d1
RBMRReadLoop
	rol.l	#8,d0
	move.b	(a1)+,d0
	dbf	d1,RBMRReadLoop

	and.l	d3,d0
	tst.l	d4
	beq.s	RBMRNoRot2
	rol.l	d4,d0
RBMRNoRot2

; at this point the read data is left justified
	rol.l	d2,d0		; data now right justified

RBMRexit
	move.l	d0,d3
	lea	RicohBuffSize(sp),sp
	move.l	(sp)+,d0
	lea	BTC_Semaphore(a6),a0	; release the semaphore
	LINKSYS	ReleaseSemaphore
	move.l	d3,d0
	movem.l	(sp)+,d2-d4
	rts


*****i* battclock.resource/internal/WriteBattClockMem ****************
*
*   NAME
*	WriteBattCLockMem -- Write a bitstring to nonvolatile ram.
*
*   SYNOPSIS
*	WriteBattClockMem( Data, Offset, Len )
*	                   D0    D1      D2
*
*	void WriteBattCLockMem( ULONG, ULONG, ULONG );
*
*   FUNCTION
*	Write a bitstring to the nonvolatile ram.
*
*   INPUTS
*	Data -- Bitstring to write, right justified.
*	Offset -- Bit offset of first bit to write.
*	Len -- Length of bitstring to write.
*
*   RESULTS
*
*   NOTES
*	This operation will "clip" the write to the memory available
*	    in the clock chip.
*	Lengths greater than 32 are set to 32.
*
*   SEE ALSO
*
*   BUGS
*
**********************************************************************
*
*   IMPLEMENTATION NOTES
*
*   REGISTER USAGE
*
*

WriteBattMemRicoh:
	movem.l	d2-d4,-(sp)
	move.l	d0,d3
	move.l	d1,d4
	lea	BTC_Semaphore(a6),a0	; grab the semaphore
	LINKSYS	ObtainSemaphore
	move.l	BTC_ClockBase(a6),a0	; get the clock address
	move.l	d0,-(sp)		; safty buffer
	lea	-RicohBuffSize(sp),sp
	move.l	sp,a1
	bsr.s	GetMemRicoh
	move.l	d3,d0
	move.l	d4,d1

; at this point a1 -> Ricoh buffer (validated)
	move.l	a1,-(sp)

	cmp.l	#32,d2
	bls.s	WBMRLenOk1
	moveq.l	#32,d2
WBMRLenOk1
	move.l	#RicohBitSize,d3	; left = 96
	sub.l	d1,d3		; left = 96 - offset
	bls.s	WBMRexit	; if (left <= 0) goto WBMRexit
	move.l	d2,d4		; rot = len
	sub.l	d3,d4		; rot = len - left
	bls.s	WBMRLenOk2		; if (rot <= 0) goto LenOk
	move.l	d3,d2		; len = left
	asr.l	d4,d0		; d0 >>= rot
WBMRLenOk2
	tst.l	d2
	beq.s	WBMRexit	; ignore 0 length requests

; at this point d0, offset, len are all valid

	moveq.l	#-1,d3
	asl.l	d2,d3
	not.l	d3
	and.l	d3,d0
	not.l	d3		; d3 masks out the area to write

	ror.l	d2,d0		; left justify data
	ror.l	d2,d3		; left justify mask

	move.l	d1,d4
	asr.l	#3,d1
	add.l	d1,a1		; adj data ptr to 1st modified byte
	move.l	d4,d1
	and.l	#7,d1
	beq.s	WBMRNoRot
	ror.l	d1,d0		; adjust the data & mask
	ror.l	d1,d3
WBMRNoRot

; this loop will write to 4 bytes of memory, but will not modify
;  memory past the end of the buffer (if all goes as planed)
	moveq.l	#3,d1		; 4 times through loop
WBMRWriteLoop
	rol.l	#8,d0
	rol.l	#8,d3
	and.b	d3,(a1)
	or.b	d0,(a1)+
	dbf	d1,WBMRWriteLoop

; the buffer is ready, write it
	move.l	(sp)+,a1
	bsr	PutMemRicoh

WBMRexit
	lea	RicohBuffSize(sp),sp
	move.l	(sp)+,d0
	lea	BTC_Semaphore(a6),a0	; release the semaphore
	LINKSYS	ReleaseSemaphore
	movem.l	(sp)+,d2-d4
	rts





*****i* battclock.resource/internal/GetMemRicoh **********************
*
*   NAME
*	GetMemRicoh -- Get and verify the memory from the Ricoh chip.
*
*   SYNOPSIS
*	GetMemRicoh( ClockBase, Buffer )
*	             A0         A1
*
*	void GetMemRicoh( APTR, APTR );
*
*   FUNCTION
*	Reads the memory from the Ricoh clock chip into the buffer
*	    and checks the CRC of the data. If the CRCs conflict, then
*	    zero the buffer in memory and on the chip.
*
*   INPUTS
*	ClockBase -- Pointer to the base address of the Ricoh chip.
*	Butter -- Pointer to a buffer to hold the data from the chip.
*
*   RESULTS
*
*   NOTES
*	Registers A0 and A1 are preserved.
*
*   SEE ALSO
*
*   BUGS
*
**********************************************************************
*
*   IMPLEMENTATION NOTES
*
*   REGISTER USAGE
*
*

GetMemRicoh
	move.l	a1,-(sp)
	bsr.s	RawGetMemRicoh
	move.l	(sp)+,a1
	movem.l	a0/a1,-(sp)
	move.l	a1,a0
	moveq.l	#-1,d0
	moveq.l	#RicohMemSize-1,d1
	bsr	CalcCRC8
	movem.l	(sp)+,a0/a1
	cmp.b	RicohMemSize-1(a1),d0
	beq.s	GMRok

	moveq.l	#RicohMemSize-1,d0
	move.l	a1,d1
GMRcl
	clr.b	(a1)+
	dbf	d0,GMRcl
	move.l	d1,a1
	bsr.s	PutMemRicoh
GMRok
	rts


; a0 = ClockBase
; a1 = buffer    (t)

RawGetMemRicoh:
	movem.l	d2/a2,-(sp)
	moveq.l	#$f,d1
	moveq.l	#RicohMemSize-1,d2
	move.l	a0,a2
	addq.l	#3,a2
RGMRls
	move.b	#$a,Regd(a0)
	move.b	(a2),d0
	and.b	d1,d0
	asl.b	#4,d0
	move.b	d0,(a1)
	move.b	#$b,Regd(a0)
	move.b	(a2),d0
	and.b	d1,d0
	or.b	d0,(a1)+
	addq.l	#4,a2
	dbf	d2,RGMRls

	movem.l	(sp)+,d2/a2
	move.b	#9,Regd(a0)
	rts


*****i* battclock.resource/internal/PutMemRicoh **********************
*
*   NAME
*	PutMemRicoh -- Write buffer to the Ricoh chip memory.
*
*   SYNOPSIS
*	PutMemRicoh( ClockBase, Buffer )
*	             A0         A1
*
*	void PutMemRicoh( APTR, APTR );
*
*   FUNCTION
*	Writes the buffer to the memory on the Ricoh clock chip after
*	    calculating the new CRC.
*
*   INPUTS
*	ClockBase -- Pointer to the base address of the Ricoh chip.
*	Butter -- Pointer to the buffer with the data to write.
*
*   RESULTS
*
*   NOTES
*	Registers A0 and A1 are preserved.
*
*   SEE ALSO
*
*   BUGS
*
**********************************************************************
*
*   IMPLEMENTATION NOTES
*
*   REGISTER USAGE
*
*

PutMemRicoh
	movem.l	a0/a1,-(sp)
	moveq.l	#-1,d0
	move.l	a1,a0
	moveq.l	#RicohMemSize-1,d1
	bsr.s	CalcCRC8
	movem.l	(sp)+,a0/a1
	move.b	d0,RicohMemSize-1(a1)
	move.l	a1,-(sp)
	bsr.s	RawPutMemRicoh
	move.l	(sp)+,a1
	rts


; a0 = ClockBase
; a1 = buffer    (t)

RawPutMemRicoh:
	move.l	a2,-(sp)
	moveq.l	#RicohMemSize-1,d1
	move.l	a0,a2
	addq.l	#3,a2
RPMRls
	move.b	(a1)+,d0
	move.b	#$b,Regd(a0)
	move.b	d0,(a2)
	asr.b	#4,d0
	move.b	#$a,Regd(a0)
	move.b	d0,(a2)
	addq.l	#4,a2
	dbf	d1,RPMRls

	move.l	(sp)+,a2
	move.b	#9,Regd(a0)
	rts


*****i* battclock.resource/internal/CalcCRC8 *************************
*
*   NAME
*	CalcCRC8 -- Calculates an 8 bit CRC value.
*
*   SYNOPSIS
*	Crc = CalcCRC8( InitialCrc, Data, Len )
*	D0              D0          A0    D1
*
*	BYTE CalcCRC8( BYTE, APTR, ULONG );
*
*   FUNCTION
*	Calculates an 8 bit CRC value for an area of memory.
*
*   INPUTS
*	InitialCrc -- CRC value to start with.
*	Data -- Pointer to the data to have the CRC computed for.
*	Len -- Number of bytes of date to uses in computations.
*
*   RESULTS
*	Crc -- The CRC value computed from the InitialCrc and the data.
*
*   NOTES
*
*   SEE ALSO
*
*   BUGS
*
**********************************************************************
*
*   IMPLEMENTATION NOTES
*
*   REGISTER USAGE
*
*

CalcCRC8:
	move.l	d2,-(sp)
	lea	CRCTable,a1
	move.l	d1,d2
	bra.s	CC8le
CC8ls
	move.b	(a0),d1
	bsr.s	DivNibble
	move.b	(a0)+,d1
	asl.b	#4,d1
	bsr.s	DivNibble
CC8le	dbf	d2,CC8ls

	move.l	(sp)+,d2
	rts


; Updates the CRC based on 1 nibble of data (hi nibble of lo byte)
; a1 -> CRC table
; d0 -> CRC
; d1 -> data (t)

DivNibble:
	and.b	#$f0,d1
	eor.b	d0,d1
	ror.b	#4,d1
	move.b	d1,d0
	and.b	#$f0,d0
	and.w	#$f,d1
	move.b	0(a1,d1.w),d1
	eor.b	d1,d0
	rts

; Polynomial => X^8 + X^6 + X^4 + X^2 + X + 1
CRCTable:
	dc.b	$00,$57,$ae,$f9
	dc.b	$0b,$5c,$a5,$f2
	dc.b	$16,$41,$b8,$7f
	dc.b	$1d,$4a,$b3,$e4


BattClockEnd:	; For the endskip
	end
@


39.2
log
@Added empty 12/24 hour LVOs so that CDTV software will not crash
@
text
@d10 1
a10 1
* $Id: resource.asm,v 39.1 92/01/20 13:16:34 mks Exp Locker: mks $
d13 3
d27 1
d39 1
a39 1
	XSYS	OpenLibrary
d73 1
a73 5
utilitylibName:
		dc.b	'utility.library',0

VERSTRING:
		VSTRING
d165 2
a166 3
	lea	utilitylibName,a1	; find the dateconversions
	moveq.l	#0,d0
	CALLSYS	OpenLibrary
@


39.1
log
@Changed the priority to be above graphics and to not try to set
the system time.
@
text
@d10 1
a10 1
* $Id: resource.asm,v 39.0 92/01/14 13:41:57 mks Exp Locker: mks $
d12 5
a16 1
* $Log$
d94 1
d104 1
d329 1
@


39.0
log
@Initial work on taking BattClock native for V39
@
text
@d10 1
a10 1
* asmsupp.asm
d12 1
a12 5
* Source Control
* ------ -------
*
* $Id: resource.asm,v 36.13 91/11/05 17:26:25 peter Exp Locker: mks $
*
d54 1
a54 1
	dc.b	45		; BYTE  RT_PRI
a64 3
timerName:
		TIMERNAME

a208 1
	bsr.s	SetSysTime	; set the system time
a286 70


*****i* battclock.resource/internal/SetSysTime ***********************
*
*   NAME
*	SetSysTime -- Set the system time from the clock chip.
*
*   SYNOPSIS
*	SetSysTime( AmigaTime )
*	            D0
*
*	void SetSysTime( ULONG );
*
*   FUNCTION
*	This routine takes a longword and send the timer.device a
*	TR_SETSYSTIME command with the longword as the seconds field
*	of the timerequest timeval.
*
*   INPUTS
*	AmigaTime       Longword containing the number of seconds from
*	                    01-Jan-1978 to the current time.
*
*   RESULTS
*
*   NOTES
*
*   SEE ALSO
*
*   BUGS
*
**********************************************************************
*
*   IMPLEMENTATION NOTES
*
*   REGISTER USAGE
*
*	A3 -- timerequest
*

SetSysTime:
	movem.l	d2/a3/a6,-(sp)
	move.l	BTC_Exec(a6),a6		; find exec
	move.l	d0,d2			; save the time

	lea	-IOTV_SIZE(sp),sp
	movea.l	sp,a3			; IORequest

	lea	timerName,a0
	movea.l	a3,a1			; this IORequest
	moveq.l	#0,d0			; unit doesn't matter
	moveq.l	#0,d1			; no special flags
	CALLSYS	OpenDevice
	tst.l	d0			; any errors ?
	bne.s	SSTCleanup		; yep

	movea.l	a3,a1
	move.w	#TR_SETSYSTIME,IO_COMMAND(a1)	; this command

	move.l	d2,IOTV_TIME+TV_SECS(a1)	; systime
	move.l	#0,IOTV_TIME+TV_MICRO(a1)

	CALLSYS	DoIO			; doit

	movea.l	a3,a1
	CALLSYS	CloseDevice		; close the device

SSTCleanup:
	lea.l	IOTV_SIZE(sp),sp	; clean up stack
	movem.l	(sp)+,d2/a3/a6
	rts
@


36.13
log
@Removed brackets in autodoc header lines.
@
text
@a13 2
* 
* $Id: resource.asm,v 36.12 91/03/11 18:24:31 rsbx Exp Locker: peter $
d15 2
a44 1
	XREF	EndCode
d54 1
a54 1
	dc.l	EndCode		; APTR  RT_ENDSKIP
a73 1
		ds.w	0
d86 4
d91 7
a97 6
	dc.l	ResetBattClockOki
	dc.l	ReadBattClockOki
	dc.l	WriteBattClockOki
	dc.l	Zero
	dc.l	Zero
	dc.l	-1
d100 7
a106 6
	dc.l	ResetBattClockRicoh
	dc.l	ReadBattClockRicoh
	dc.l	WriteBattClockRicoh
	dc.l	ReadBattMemRicoh
	dc.l	WriteBattMemRicoh
	dc.l	-1
d170 2
a171 2
	beq	InitEnd
	move.l	d0,a3		; utilityLib base	
d177 1
a177 1
	beq	InitEnd		; no, no resource
d179 1
a179 1
	bne	NotOki		; no
d181 2
a182 2
	lea	initFuncOki,a0	; point to correct set of offsets
	bsr	MakeResource	; go make and add the resource
d185 1
a185 1
	bra	InitCommon
d188 1
a188 1
	bne	NotOkiR		; no
d190 2
a191 2
	lea	initFuncOki,a0	; point to correct set of offsets
	bsr	MakeResource	; go make and add the resource
d195 1
a195 1
	bra	InitCommon
d198 1
a198 1
	bne	NotRicoh	; no
d200 2
a201 2
	lea	initFuncRicoh,a0	; point to function offsets
	bsr	MakeResource	; go make add the resource
d204 1
a204 1
	bra	InitCommon
d207 1
a207 1
	bne	InitEnd		; no
d209 2
a210 2
	lea	initFuncRicoh,a0	; point to function offsets
	bsr	MakeResource	; go make add the resource
d216 1
a216 1
	bsr	SetSysTime	; set the system time
d400 1
d548 1
a548 1
Ricoh	
d1213 1
a1213 1
	bne	ReadCommon	; yes
d1215 1
a1215 1
	bsr	ResetOki	; bad date
d1317 1
a1317 1
	bsr	WriteRicoh	; put the date
d1579 1
a1579 1
	beq	RBMRexit
d1587 1
a1587 1
	bls	RBMRexit	; if (left <= 0) goto WBMRexit
d1676 1
a1676 1
	bsr	GetMemRicoh
d1689 1
a1689 1
	bls	WBMRexit	; if (left <= 0) goto WBMRexit
d1692 1
a1692 1
	bls	WBMRLenOk2		; if (rot <= 0) goto LenOk
d1697 1
a1697 1
	beq	WBMRexit	; ignore 0 length requests
d1785 1
a1785 1
	bsr	RawGetMemRicoh
d1794 1
a1794 1
	beq	GMRok
d1802 1
a1802 1
	bsr	PutMemRicoh
d1875 1
a1875 1
	bsr	CalcCRC8
d1879 1
a1879 1
	bsr	RawPutMemRicoh
d1950 1
a1950 1
	bsr	DivNibble
d1953 1
a1953 1
	bsr	DivNibble
d1984 1
@


36.12
log
@Interesting that this bug lived this long before someone noticed.
@
text
@d15 1
a15 1
* $Id: resource.asm,v 36.11 91/02/15 13:12:44 rsbx Exp Locker: rsbx $
d549 1
a549 1
******* battclock.resource/ResetBattClock() **************************
d606 1
a606 1
******* battclock.resource/ReadBattClock() ***************************
d671 1
a671 1
******* battclock.resource/WriteBattClock() **************************
d1515 1
a1515 1
*****i* battclock.resource/internal/ReadBattClockMem() ***************
d1623 1
a1623 1
*****i* battclock.resource/internal/WriteBattClockMem() **************
@


36.11
log
@Autodoc changes.
@
text
@d15 1
a15 1
* $Id: resource.asm,v 36.10 91/02/15 13:03:40 rsbx Exp Locker: rsbx $
d1164 1
a1164 1
	lea	ClockTempSize(a2),a2	; ClockData struct
d1463 1
a1463 1
	lea	ClockTempSize(a2),a2	; ClockData struct
@


36.10
log
@NT_DEVICE should have been NT_RESOURCE.
@
text
@d15 1
a15 1
* $Id: resource.asm,v 36.9 90/05/31 13:10:07 rsbx Exp Locker: rsbx $
d296 1
a296 2
*	SetSysTime -- Set the system time from the time read from the
*	    clock chip.
d306 2
a307 2
*	    TR_SETSYSTIME command with the longword as the seconds
*	    field of the timerequest timeval.
d310 2
a311 2
*	AmigaTime -- Longword containing the number of seconds from
*	01-Jan-1978 to the current time.
d557 1
a557 1
*	void ResetBattClock( );
d561 2
a562 2
*	    into a working and usable state and also sets the date on
*	    the clock chip to 01-Jan-1978.
d614 1
a614 1
*	ULONG ReadBattClock( );
d618 2
a619 2
*	This routine reads the time from the clock chip and returns
*	    it as the number of seconds from 01-jan-1978.
d624 2
a625 2
*	AmigaTime -- The number of seconds from 01-Jan-1978 that the
*	    clock chip thinks it is.
d629 1
a629 1
*	    reset and 0 is returned.
d684 1
a684 1
*	    chip.
d687 3
a689 2
*	AmigaTime -- The number of seconds from 01-Jan-1978 to the
*	    time that should be written to the clock chip.
@


36.9
log
@Horrible kludge to detect chip registers where the clock should be.
@
text
@d15 1
a15 1
* $Id$
d58 1
a58 1
	dc.b	NT_DEVICE	; UBYTE RT_TYPE
@


36.8
log
@RCS version change.
@
text
@d15 1
a15 1
* $Header: /usr/professor/rsbx/battclock.resource/RCS/resource.asm,v 36.7 90/02/28 11:39:03 rsbx Exp Locker: rsbx $
a16 3
* $Locker: rsbx $
* 
*
d22 2
d42 3
d438 47
d492 1
a492 1
	beq	Oki
d503 1
a503 1
	beq	TestRicoh
d520 1
a520 1
	beq	TrashedOki
d537 1
a537 1
	bne	NoClock
d541 1
a541 1
	bne	Ricoh
@


36.7
log
@Changed to leave page 1 (alarm) showing to confuse 1.3 setclock.
@
text
@d15 1
a15 1
* $Header: resource.asm,v 36.6 90/02/26 15:40:43 rsbx Exp $
@


36.6
log
@Same fix, forgot a bra.
@
text
@d15 1
a15 1
* $Header: resource.asm,v 36.5 90/02/26 15:32:34 rsbx Exp $
d496 1
a496 1
	move.b	#8,Regd(a0)
d1260 1
a1260 1
	move.b	#8,Regd(a0)
d1366 1
a1366 1
	move.b	#8,Regd(a0)	; release hold
d1419 1
a1419 1
	move.b	#8,Regd(a0)	; release hold
d1776 1
a1776 1
	move.b	#8,Regd(a0)
d1849 1
a1849 1
	move.b	#8,Regd(a0)
@


36.5
log
@
@
text
@d15 1
a15 1
* $Header: resource.asm,v 36.4 89/11/28 22:52:09 rsbx Exp $
d198 1
a198 1

@


36.4
log
@
@
text
@d15 1
a15 1
* $Header: resource.asm,v 36.3 89/10/11 15:51:45 rsbx Exp $
d174 1
a174 1

d181 10
d192 2
a193 2
	bne	InitEnd		; no

d199 10
d476 2
a477 1
	bsr	ResetOki	; fix the Oki
d493 2
a494 1
	bsr	ResetRicoh
d1215 1
a1215 7
	lea	-CD_SIZE(sp),sp	; get temp
	move.l	sp,a1
	move.l	#0,sec(a1)	; set date to 19780101
	move.l	#1,hour(a1)
	move.w	#1,month(a1)
	move.w	#1978,year(a1)
	clr.w	wday(a1)
a1216 1
	lea	CD_SIZE(sp),sp
d1262 1
a1262 7
	lea	-CD_SIZE(sp),sp	; get temp
	move.l	sp,a1
	move.l	#0,sec(a1)	; set date to 19780101
	move.l	#1,hour(a1)
	move.w	#1,month(a1)
	move.w	#1978,year(a1)
	clr.w	wday(a1)
a1263 1
	lea	CD_SIZE(sp),sp
@


36.3
log
@Support for reading/writing the Ricoh nv memory added.
@
text
@d15 1
a15 1
* $Header: resource.asm,v 36.2 89/10/09 10:21:19 rsbx Exp $
d17 1
a17 1
* $Locker:  $
d36 4
a40 3
	XREF	Amiga2Date
	XREF	Date2Amiga

d71 3
a73 2
*$*utilitylibName:
*$*		UTILITYNAME
d160 6
a165 6
*$*	lea	utilitylibName,a1	; find the dateconversions
*$*	moveq.l	#0,d0
*$*	CALLSYS	OpenLibrary
*$*	tst.l	d0
*$*	beq	InitEnd
*$*	move.l	d0,a3		; utilityLib base	
d255 1
a255 1
*$*	move.l	a3,BTC_UtilLib(a2)
d265 2
a266 2
*$*	move.l	a3,a1		; be nice
*$*	CALLSYS	CloseLibrary
a663 70
*****i* battclock.resource/internal/CheckDate ************************
*
*   NAME
*	CheckDate -- Checks if a ClockData struct contains a leagal date.
*
*   SYNOPSIS
*	AmigaTime = CheckDate( Date )
*	D0                     a0
*
*	ULONG CheckDate( struct ClockData * );
*
*   FUNCTION
*	Determines if the Date is a legal date and returns the number
*	    of seconds to Date from 01-Jan-1978 if it is.
*
*   INPUTS
*	Date -- pointer to a ClockData structure.
*
*   RESULTS
*	AmigaTime -- 0 if Date invalid; otherwise, the number of seconds
*	    to Date from 01-Jan-1978.
*
*   NOTES
*
*   SEE ALSO
*
*   BUGS
*
**********************************************************************
*
*   IMPLEMENTATION NOTES
*
*   REGISTER USAGE
*
*

CheckDate:
	lea	-CD_SIZE(sp),sp
	move.l	a0,-(sp)	; save it
*$* Date2Amiga
	bsr	Date2Amiga	; get AmigaTime
	move.l	(sp)+,a1	; ClockData
	move.l	sp,a0		; temp ClockData
	movem.l	d0/a1,-(sp)
*$* Amiga2Date
	bsr	Amiga2Date	; convert back
	movem.l	(sp)+,d0/a1
	move.l	sp,a0

; a1 -> ClockData struct passed in
; a0 -> ClockData struct created by converting the passed CD to AmigaTime
;	then converting back to CD
; d0 AmigaTime from passed ClockData struct

; if they are both the same, then the date/time/wday are legal

	move.l	#CD_SIZE-3,d1	; check the date (but not wday field)
CDls
	cmp.b	(a0)+,(a1)+
	bne.s	BadDate		; BZZZZZZZZT, you loose!
	dbf	d1,CDls
CDe
	lea	CD_SIZE(sp),sp
	rts

BadDate
	moveq.l	#0,d0
	bra.s	CDe


d986 1
a986 2
*$* Amiga2Date
	bsr	Amiga2Date		; fill in ClockData from AmigaTime
d1134 1
a1134 2
*$* CheckDate
	bsr	CheckDate	; convert & check date
d1302 1
a1302 2
*$* Amiga2Date
	bsr	Amiga2Date		; fill in ClockData struct
d1448 1
a1448 2
*$* CheckDate
	bsr	CheckDate	; is the date good?
@


36.2
log
@CheckDate nolonger checks that the wday field read from the clock chip
is correct.
@
text
@d15 1
a15 1
* $Header: resource.asm,v 36.1 89/10/06 13:58:00 rsbx Exp $
d17 1
a17 1
* $Locker: rsbx $
d96 2
a97 2
	dc.l	Zero
	dc.l	Zero
d114 6
d1528 464
@


36.1
log
@Fixed revision number.
@
text
@d15 1
a15 1
* $Header: resource.asm,v 35.1 89/10/06 11:56:30 rsbx Exp $
d712 1
a712 1
	move.l	#CD_SIZE-1,d1	; CD_SIZE bytes to check
d1197 1
d1513 1
@


35.1
log
@Initial checkin.
@
text
@d15 1
a15 1
* $Header$
d17 1
a17 1
* $Locker$
@
