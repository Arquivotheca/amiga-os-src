head     39.11;
branch   ;
access   ;
symbols  ;
locks    spence:39.11; strict;
comment  @ * @;


39.11
date     92.04.10.12.06.56;  author spence;  state Exp;
branches ;
next     39.10;

39.10
date     92.04.07.17.19.03;  author spence;  state Exp;
branches ;
next     39.9;

39.9
date     92.04.06.12.23.18;  author spence;  state Exp;
branches ;
next     39.8;

39.8
date     92.03.06.10.49.40;  author spence;  state Exp;
branches ;
next     39.7;

39.7
date     92.02.05.11.44.40;  author spence;  state Exp;
branches ;
next     39.6;

39.6
date     92.01.21.12.10.38;  author spence;  state Exp;
branches ;
next     39.5;

39.5
date     92.01.13.10.54.14;  author spence;  state Exp;
branches ;
next     39.4;

39.4
date     92.01.10.18.23.25;  author spence;  state Exp;
branches ;
next     39.3;

39.3
date     92.01.10.14.46.36;  author spence;  state Exp;
branches ;
next     39.2;

39.2
date     92.01.10.13.31.07;  author spence;  state Exp;
branches ;
next     39.1;

39.1
date     92.01.09.14.32.57;  author spence;  state Exp;
branches ;
next     39.0;

39.0
date     92.01.08.11.57.06;  author spence;  state Exp;
branches ;
next     37.1;

37.1
date     91.05.09.02.10.35;  author jesup;  state Exp;
branches ;
next     ;


desc
@main bootmenu code
@


39.11
log
@Uses the private graphics SetDefaultMonitor() call when switching
PAL <-> NTSC instead of changing GfxBase itself.
@
text
@/******************************************************************************
*
*	$Id: bootmenu.c,v 39.10 92/04/07 17:19:03 spence Exp Locker: spence $
*
******************************************************************************/

#include "support.h"
#include <string.h>

USHORT GhostPattern[] = {
      0x8888,
      0x2222
   };


extern LONG __asm MyBltBitMapRastPort(
                                    register __a6 struct GfxBase *GfxBase,
                                    register __a0 struct BitMap *srcbm,
                                    register __d0 SHORT srcx,
                                    register __d1 SHORT srcy,
                                    register __a1 struct RastPort *destrp,
                                    register __d2 SHORT destx,
                                    register __d3 SHORT desty,
                                    register __d4 SHORT sizex,
                                    register __d5 SHORT sizey,
                                    register __d6 UBYTE minterm);

#define VANILLA_COPY  0xC0
#define NWAYBMWIDTH   11
#define NWAYBMHEIGHT   9

UWORD NWayGlyphData[] =
    {
    0x7F00,   /* 0111 1111 0000 0000 */
    0xC180,   /* 1100 0001 1000 0000 */
    0xC180,   /* 1100 0001 1000 0000 */
    0xC7E0,   /* 1100 0111 1110 0000 */
    0xC3C0,   /* 1100 0011 1100 0000 */
    0xC180,   /* 1100 0001 1000 0000 */
    0xC000,   /* 1100 0000 0000 0000 */
    0xC180,   /* 1100 0001 1000 0000 */
    0x7F00,   /* 0111 1111 0000 0000 */
    };

#define G0W       102                  /* gadget 0 width */
#define G1W       254                  /* gadget 1 width */
#define G2W       45                   /* gadget 2 width */
#define G3W       45                   /* gadget 3 width */
#define G4W       93                   /* gadget 3 width */
#define G5W       36                   /* gadget 3 width */

#define T0W       64                   /* gadget 0 width */
#define T1W       240                  /* gadget 1 width */
#define T2W       32                   /* gadget 2 width */
#define T3W       32                   /* gadget 3 width */
#define T4W       80                   /* gadget 3 width */
#define T5W       24                   /* gadget 3 width */

#define GYS       30                   /* gadget y start   */
#define GYSP      15                   /* gadget y spacing */
#define GXSP      10                   /* gadget x spacing */
#define GH        13                   /* gadget height    */
#define TH        8                    /* text height      */
#define TYS       (GYS+((GH-TH)>>1)+TH-1)/* text   y start   */

#define C0GX      ((WIDTH-1-(G0W+GXSP+G1W+GXSP+G2W+GXSP+G3W+GXSP+G4W+GXSP+G5W))>>1)
#define C0TX      (C0GX+((G0W-T0W)>>1))

#define C1GX      (C0GX+G0W+GXSP)      
#define C1TX      (C1GX+((G1W-T1W)>>1))

#define C2GX      (C1GX+G1W+GXSP)      
#define C2TX      (C2GX+((G2W-T2W)>>1))

#define C3GX      (C2GX+G2W+GXSP)      
#define C3TX      (C3GX+((G3W-T3W)>>1))

#define C4GX      (C3GX+G3W+GXSP)      
#define C4TX      (C4GX+((G4W-T4W)>>1))

#define C5GX      (C4GX+G4W+GXSP)      
#define C5TX      (C5GX+((G5W-T5W)>>1))

#define LY        27                   /* Label y pos */

/************************************/
/* First Page main button constants */
/************************************/
#define FP0GX      ((WIDTH-1-(G1W))>>1)
#define FP0TX      (FP0GX+((G1W-T1W)>>1))

/**************************************************************************/
/*																		  */
/* Position and size definitions for Advanced Options Page command buttons*/
/*																		  */
/* TW = Text Width in pixels											  */
/* TH = Text Height in pixels											  */
/* GW = Gadget Width in pixels											  */
/* GH = Gadget Height in pixels											  */
/* GX = Gadget X location in pixels										  */
/* GY = Gadget Y location in pixels										  */
/* TX = Text X location in pixels										  */
/* TY = Text Y location in pixels										  */
/* GN = Gadget Number, internal gadget identification number returned by  */
/*	    GadgetHit();													  */
/*																		  */
/**************************************************************************/

#define WWIDTH 620

/***************/
/* NTSC button */
/***************/

#define GONTTW    32
#define GONTTH    8
#define GONTGW    120
#define GONTGH    13
#define GONTGX    ((WWIDTH - GONTGW) >> 1)
#define GONTGY    30
#define GONTTX    (GONTGX+((GONTGW-GONTTW)>>1))
#define GONTTY    (GONTGY+GONTTH+((GONTGH-GONTTH)>>1)-1)
#define GONTGN    (108)

/**************/
/* PAL button */
/**************/

#define GOPATW    24
#define GOPATH    8
#define GOPAGW    GONTGW
#define GOPAGH    13
#define GOPAGX    ((WWIDTH - GOPAGW) >> 1)
#define GOPAGY    (GONTGY + GONTGH + 2)
#define GOPATX    (GOPAGX+((GOPAGW-GOPATW)>>1))
#define GOPATY    (GOPAGY+GOPATH+((GOPAGH-GOPATH)>>1)-1)
#define GOPAGN    (109)

/*******************/
/* ORIGINAL button */
/*******************/

#define GOORTW    64
#define GOORTH    8
#define GOORGW    GONTGW
#define GOORGH    13
#define GOORGX    ((WWIDTH - GOORGW) >> 1)
#define GOORGY    (GOPAGY + GOPAGH + 16)
#define GOORTX    (GOORGX+((GOORGW-GOORTW)>>1))
#define GOORTY    (GOORGY+GOORTH+((GOORGH-GOORTH)>>1)-1)
#define GOORGN    (113)

/**************/
/* ECS button */
/**************/

#define GOECTW    24
#define GOECTH    8
#define GOECGW    GONTGW
#define GOECGH    13
#define GOECGX    ((WWIDTH - GOECGW) >> 1)
#define GOECGY    (GOORGY + GOORGH + 2)
#define GOECTX    (GOECGX+((GOECGW-GOECTW)>>1))
#define GOECTY    (GOECGY+GOECTH+((GOECGH-GOECTH)>>1)-1)
#define GOECGN    (114)

/***************/
/* BEST button */
/***************/

#define GOBETW    32
#define GOBETH    8
#define GOBEGW    GONTGW
#define GOBEGH    13
#define GOBEGX    ((WWIDTH - GOBEGW) >> 1)
#define GOBEGY    (GOECGY + GOECGH + 2)
#define GOBETX    (GOBEGX+((GOBEGW-GOBETW)>>1))
#define GOBETY    (GOBEGY+GOBETH+((GOBEGH-GOBETH)>>1)-1)
#define GOBEGN    (115)

/***************/
/* Save button */
/***************/

#define GOSATW    32
#define GOSATH    8
#define GOSAGW    80
#define GOSAGH    13
#define GOSAGX    180
#define GOSAGY    185
#define GOSATX    (GOSAGX+((GOSAGW-GOSATW)>>1))
#define GOSATY    (GOSAGY+GOSATH+((GOSAGH-GOSATH)>>1)-1)
#define GOSAGN    (111)

/***************/
/* Use button */
/***************/

#define GOUSTW    24
#define GOUSTH    8
#define GOUSGW    GOSAGW
#define GOUSGH    13
#define GOUSGX    (GOSAGX + GOSAGW + 10)
#define GOUSGY    185
#define GOUSTX    (GOUSGX+((GOUSGW-GOUSTW)>>1))
#define GOUSTY    (GOUSGY+GOUSTH+((GOUSGH-GOUSTH)>>1)-1)
#define GOUSGN    (112)

/*****************/
/* Cancel button */
/*****************/

#define GOCATW    48
#define GOCATH    8
#define GOCAGW    GOSAGW
#define GOCAGH    13
#define GOCAGX    (GOUSGX + GOUSGW + 10)
#define GOCAGY    185
#define GOCATX    (GOCAGX+((GOCAGW-GOCATW)>>1))
#define GOCATY    (GOCAGY+GOCATH+((GOCAGH-GOCATH)>>1)-1)
#define GOCAGN    (110)


/**************************************************************************/
/*																		  */
/* Position and size definitions for Advanced Options Page command buttons*/
/*																		  */
/* TW = Text Width in pixels											  */
/* TH = Text Height in pixels											  */
/* GW = Gadget Width in pixels											  */
/* GH = Gadget Height in pixels											  */
/* GX = Gadget X location in pixels										  */
/* GY = Gadget Y location in pixels										  */
/* TX = Text X location in pixels										  */
/* TY = Text Y location in pixels										  */
/* GN = Gadget Number, internal gadget identification number returned by  */
/*	    GadgetHit();													  */
/*																		  */
/**************************************************************************/

/***********************************************/
/* Startup Sequence Enable/Disable NWay button */
/***********************************************/
#define DATW      64
#define DATH      8 
#define DAGW      (DATW+14+24)
#define DAGH      13  
#define DAGX      176
#define DAGY      185  
#define DATX      (DAGX+((DAGW-DATW)>>1))
#define DATY      (DAGY+DATH+((DAGH-DATH)>>1)-1)
#define DAGN      (101) 

#define STARTX    DAGX-136-10
#define STARTY    185+8+((13-8)>>1)-1

/**************/
/* USE button */
/**************/
#define GOTW      24  
#define GOTH      8
#define GOGW      82 
#define GOGH      13 
#define GOGX      DAGX+DAGW+10
#define GOGY      185    
#define GOTX      (GOGX+((GOGW-GOTW)>>1))
#define GOTY      (GOGY+GOTH+((GOGH-GOTH)>>1)-1)
#define GOGN      (102) 

/********************/
/* NEXT PAGE button */
/********************/
#define NPTW      72  
#define NPTH      8  
#define NPGW      (NPTW+10) 
#define NPGH      13   
#define NPGX      GOGX+GOGW+10
#define NPGY      185  
#define NPTX      (NPGX+((NPGW-NPTW)>>1))
#define NPTY      (NPGY+NPTH+((NPGH-NPTH)>>1)-1)
#define NPGN      (103) 

/**************************************************************************/
/*																		  */
/* Position and size definitions for First Page command buttons			  */
/*																		  */
/* TW = Text Width in pixels											  */
/* TH = Text Height in pixels											  */
/* GW = Gadget Width in pixels											  */
/* GH = Gadget Height in pixels											  */
/* GX = Gadget X location in pixels										  */
/* GY = Gadget Y location in pixels										  */
/* TX = Text X location in pixels										  */
/* TY = Text Y location in pixels										  */
/* GN = Gadget Number, internal gadget identification number returned by  */
/*	    GadgetHit();													  */
/*																		  */
/**************************************************************************/

/****************************/
/* First Page CANCEL button */
/****************************/
#define FPCBTW    48 
#define FPCBTH    8  
#define FPCBGW    82 
#define FPCBGH    13 
#define FPCBGX    61
#define FPCBGY    185    
#define FPCBTX    (FPCBGX+((FPCBGW-FPCBTW)>>1))
#define FPCBTY    (FPCBGY+FPCBTH+((FPCBGH-FPCBTH)>>1)-1)
#define FPCBGN    (104) 

/**************************************/
/* First Page Advanced Options button */
/**************************************/
#define FPAOTW    152  
#define FPAOTH    8    
#define FPAOGW    (FPAOTW+10)  
#define FPAOGH    13 
#define FPAOGX    FPCBGX+FPCBGW+10   /*(((WIDTH-1-CBGW)>>1)+74)*/
#define FPAOGY    185 
#define FPAOTX    (FPAOGX+((FPAOGW-FPAOTW)>>1))
#define FPAOTY    (FPAOGY+FPAOTH+((FPAOGH-FPAOTH)>>1)-1)
#define FPAOGN    (105) 

/**************************************/
/* First Page Graphics Options button */
/**************************************/
#define FPGOTW    152
#define FPGOTH    8
#define FPGOGW    (FPGOTW+10)
#define FPGOGH    13
#define FPGOGX    FPAOGX+FPAOGW+10
#define FPGOGY    185
#define FPGOTX    (FPGOGX+((FPGOGW-FPGOTW)>>1))
#define FPGOTY    (FPGOGY+FPGOTH+((FPGOGH-FPGOTH)>>1)-1)
#define FPGOGN    (107)

/*******************************/
/* First Page NEXT PAGE button */
/*******************************/
#define FPNPTW    72 
#define FPNPTH    8  
#define FPNPGW    (FPNPTW+10)  
#define FPNPGH    13      
#define FPNPGX    FPGOGX+FPGOGW+10 
#define FPNPGY    185  
#define FPNPTX    (FPNPGX+((FPNPGW-FPNPTW)>>1))
#define FPNPTY    (FPNPGY+FPNPTH+((FPNPGH-FPNPTH)>>1)-1)
#define FPNPGN    (106)  


/**************************************/
/* SysCheck Continue button constants */
/**************************************/
#define CBTW      64    
#define CBTH      8    
#define CBGW      (CBTW+10)  
#define CBGH      13     
#define CBGX      ((WIDTH-1-CBGW)>>1)  
#define CBGY      185     
#define CBTX      (CBGX+((CBGW-CBTW)>>1))
#define CBTY      (CBGY+CBTH+((CBGH-CBTH)>>1)-1)
#define CBGN      (116)  

/* Put all the gadget bounding rectangles in here */
struct GRect
{
	SHORT MinX;
	SHORT MinY;
	SHORT Width;
	SHORT Height;
};

struct GRect gadgets[] =
{
   {DAGX, DAGY, DAGW, DAGH},   /* s/s enable/disable */
   {GOGX, GOGY, GOGW, GOGH},   /* use */
   {NPGX, NPGY, NPGW, NPGH},   /* next page */
   {FPCBGX, FPCBGY, FPCBGW, FPCBGH}, /* first page cancel */
   {FPAOGX, FPAOGY, FPAOGW, FPAOGH}, /* first page adv opt */
   {FPNPGX, FPNPGY, FPNPGW, FPNPGH}, /* first page next page */
   {FPGOGX, FPGOGY, FPGOGW, FPGOGH}, /* first page gfx opt */
   {GONTGX, GONTGY, GONTGW, GONTGH}, /* gfx NTSC */
   {GOPAGX, GOPAGY, GOPAGW, GOPAGH}, /* gfx PAL */
   {GOCAGX, GOCAGY, GOCAGW, GOCAGH}, /* gfx CANCEL */
   {GOSAGX, GOSAGY, GOSAGW, GOSAGH}, /* gfx SAVE */
   {GOUSGX, GOUSGY, GOUSGW, GOUSGH}, /* gfx USE */
   {GOORGX, GOORGY, GOORGW, GOORGH}, /* gfx ORIGINAL */
   {GOECGX, GOECGY, GOECGW, GOECGH}, /* gfx ECS */
   {GOBEGX, GOBEGY, GOBEGW, GOBEGH}, /* gfx BEST */
   {CBGX, CBGY, CBGW, CBGH},  /* syscheck Continue */
};

#define FIRSTGADGETAM DAGN
#define FIRSTGADGETFP FPCBGN
#define FIRSTGADGETGO GONTGN
#define FIRSTGADGETSC CBGN
#define AMGADENTRY 0
#define AMMAXGAD 2
#define FPGADENTRY 3
#define FPMAXGAD 6
#define GOGADENTRY 7
#define GOMAXGAD 14
#define SCGADENTRY 15
#define SCMAXGAD 15
#define FIRSTGADGET DAGN

#define UP_DELAY  15    /* 60ths of a second after a gadget is released */
                        /* and before the screen closes                 */

#define PAGE_SIZE 9    /* Number of nodes per page                     */

/*************************************/
/* Location for 'Page xx of nn' text */
/*************************************/
#define PAGEX     268
#define PAGEY     17    

/***********/
/* Strings */
/***********/

STRPTR string[] =
{
    "ORIGINAL",
    "ECS     ",
    "BEST    ",
};

#define CHIP_ORIGINAL 0
#define CHIP_ECS 1
#define CHIP_BEST 2

/**************************************************************************/
/*																		  */
/* Function Prototypes													  */
/*																		  */
/**************************************************************************/
int    MyInit(void);
D( void   printbstr(BSTR); )
void   DoImagery(struct World *);
struct InputEvent * __asm HandlerInterface(
                             register __a0 struct InputEvent *ev,
                             register __a1 struct World *world);
void   GadgetUpAction(struct World *);
void   GetData(struct World *);
struct MyNode *GetNode(struct World *world,SHORT num);
struct MyNode *GetBootableNode(struct World *world,SHORT num);
/* void   FreeData(struct World *);  */
void   DrawBSTR(struct World *,BSTR,SHORT,SHORT,LONG);
SHORT  GadgetHit(struct World *);
void   ComplementGadget(struct World *,SHORT);
void   MakeChanges(struct World *world);
BOOL   DrawEntry(struct World *world,SHORT x);
BOOL   DrawFPEntry(struct World *world,SHORT x);
VOID   DrawNWay(struct World *world,SHORT x,SHORT y,BOOL enabled,BOOL sunken);
void   DrawByte(struct World *,SHORT,SHORT,UBYTE);
void   MyDelay(struct World *world,SHORT n);
void   UpdateBattMem(struct World *world);
ULONG  SetChipRev(ULONG want);
BOOL   SetDefaultMonitor(UWORD mon);

int MyInit()
{
   struct Library *library;
   struct World   *world;
   struct World   myworld;
   struct Node    *n;
   UBYTE crb;

   D( kprintf("###################\n") );
   D( kprintf("bootmenu Init Begins\n") );

   world=&myworld;
   world->GfxBase=NULL;
   world->ExpansionBase=NULL;
   world->signal=-1;
   world->AdvancedMode = world->GraphicsMode = world->SysCheck = FALSE;

   /* our presence is requested so open the view */
   library = OpenLibrary("graphics.library",0);
   if(library==0)
   {
      D( kprintf("No graphics.library\n") );
      goto out;
   }
   world->GfxBase=(struct GfxBase *)library;

   library = OpenLibrary("expansion.library",0);
   if(library==0)
   {
      D( kprintf("No expansion.library\n") );
      goto out;
   }
   world->ExpansionBase=(struct ExpansionBase *)library;
   world->BattMemBase = OpenResource(BATTMEMNAME);

   /* if( ! MouseActivated(world) ) goto out; */

   /* Is our magic mouse/key sequence being pressed ? */
   /* if not then just exit */
   if( (1<<6) & *((char *)0xBFE001) )
   {
      D( kprintf("No Left button. Exiting\n") );
      goto out;
   }

   *((UWORD *)0xDFF034) = 0xffff;   /* set up port to read RMB */
   MyDelay(world,2);
   /*
   WaitTOF();
   WaitTOF();
   */
   if( (1<<10) & *((UWORD *)0xDFF016) )
   {
      D( kprintf("No Right button. Exiting\n") );
      goto out;
   }

   world->signal=AllocSignal(-1);
   world->maintask=FindTask(0);

   /* For Bootmenu, make the system single-A. If we are ECS, then copinit will
    * be set as such, and it's harder to set it back up for A mode.
    */
   crb = world->GfxBase->ChipRevBits0;
   world->GfxBase->ChipRevBits0 = SETCHIPREV_A;
   DisplayOn(world);
   D( kprintf("After DisplayOn()\n") );

   GetData(world);
   world->Cancel=FALSE;

   DoImagery(world);
   D( kprintf("After DoImagery()\n") );

   OpenSprite(world);
   D( kprintf("After OpenSprite()\n") );

   OpenIH(world,HandlerInterface);
   D( kprintf("After OpenIH()\n") );

   Wait(1<<world->signal);

   world->GfxBase->ChipRevBits0 = crb;
   if( ! world->Cancel)
   {
      MakeChanges(world);
   }
   else
   {
      world->IsNTSC = world->OriginalNTSC;
      world->ChipRev = world->OriginalChipRev;
      UpdateBattMem(world);   /* might have saved it already */
   }

   /* FreeData(world);  */

   while(n=RemHead(&(world->NodeList)))
      FreeVec((char *)n);

   CloseIH(world);
   D( kprintf("After CloseIH()\n") );

   CloseSprite(world);
   D( kprintf("After CloseSprite()\n") );

   DisplayOff(world);

out:
   D( kprintf("Bootmenu exiting\n") );
   if(world->signal != -1) FreeSignal(world->signal);
   if(world->ExpansionBase) CloseLibrary((struct Library *)
                                            world->ExpansionBase);
   if(world->GfxBase) CloseLibrary((struct Library *)world->GfxBase);
   return(0);
}

#define GfxBase       (world->GfxBase)
#define ExpansionBase (world->ExpansionBase)
#define BattMemBase   (world->BattMemBase)

D( void printbstr(bp)
BSTR bp;
{
   int x;
   UBYTE count;
   UBYTE *p;

   p=(UBYTE *)(bp << 2);
   count=*p;
   /* D( kprintf("count = %ld ",count) ); */
   for(x=1;x<=count;x++)
      printf("%lc",(ULONG)p[x]);
} )
void DoImagery(world)
struct World *world;
{
   struct Custom *io = &custom;
   SHORT x;
   int first, last;
   char buf[20];

   D( printf("init.c: DoImagery(world=0x%lx) enter AdvancedMode=%lx\n",
              world,world->AdvancedMode); )

   SetRast(&world->display.rp,0); 
   SetAPen(&world->display.rp,3);
   SetAfPt(&world->display.rp,GhostPattern,1);
   SetFont(&world->display.rp,world->display.font9);
   if(world->AdvancedMode)
   {
      /*********/
      /* Title */
      /*********/
      Move(&world->display.rp,179,8);
      Text(&world->display.rp,"Boot Menu - Advanced Options",28);

      SetFont(&world->display.rp,world->display.font8);

      /**********/
      /* Labels */
      /**********/
      Move(&world->display.rp,C0GX,LY);
      Text(&world->display.rp,
          "Status        Partition Name                   Type   Pri    Device       Unit", 78);

      /****************/
      /* Page Display */
      /****************/
      D( printf("init.c: DoImagery() CurrentPage=%ld MaxPage=%ld\n",
	            world->CurrentPage,world->MaxPage); )

      Move(&world->display.rp,PAGEX,PAGEY);
      sprintf(buf,"Page %2ld of %2ld",world->CurrentPage,world->MaxPage);
      Text(&world->display.rp,buf,13);

      /*******************/
      /* Command Buttons */
      /*******************/
      SetAPen(&world->display.rp,2);

      Move(&world->display.rp,GOTX,GOTY);
      Text(&world->display.rp,"USE",3);

      Move(&world->display.rp,NPTX,NPTY);
      Text(&world->display.rp,"NEXT PAGE",9);

      if(world->MaxPage==1)
         RectFill(&world->display.rp,NPGX+2,NPGY+1,NPGX+NPGW-4,NPGY+NPGH-2);

      SetAfPt(&world->display.rp,NULL,0);

      Move(&world->display.rp,STARTX,STARTY);
      Text(&world->display.rp,"Startup-Sequence:",17);
      DrawNWay(world,DAGX,DAGY,(BOOL)(! world->SS_Disable),FALSE);

      first = 1;
      last = 2;

      /****************/
      /* Main Gadgets */
      /****************/
      world->MaxGad=0;
      for(x=0;x<PAGE_SIZE;x++)
      {
         if(DrawEntry(world,x))
            world->MaxGad++;
      }
   }
   else 
   {

      if (world->GraphicsMode)
      {
          /*********/
          /* Title */
          /*********/

          Move(&world->display.rp, 248,8);
          Text(&world->display.rp, "Graphics Menu", 13);

          SetFont(&world->display.rp,world->display.font8);

          Move(&world->display.rp, 264, (GONTTY - 14));
          Text(&world->display.rp, "Display Mode", 12);

          Move(&world->display.rp, 282, (GOORTY - 14));
          Text(&world->display.rp, "Chip Set", 8);


          /*****************************/
          /* Currently selected option */
          /*****************************/

          Move(&world->display.rp, 192, (GOBEGY + GOBEGH + 20));
          Text(&world->display.rp, "Current Setting - ", 18);
          Text(&world->display.rp, (world->IsNTSC ? "NTSC & " : "PAL  & "), 7);
          Text(&world->display.rp, string[world->ChipRev], 8);

          /****************/
          /* Mode Buttons */
          /****************/
          SetAPen(&world->display.rp,2);
          Move(&world->display.rp,GONTTX,GONTTY);
          Text(&world->display.rp,"NTSC",4);

          Move(&world->display.rp,GOPATX,GOPATY);
          Text(&world->display.rp,"PAL",3);

          Move(&world->display.rp,GOORTX,GOORTY);
          Text(&world->display.rp,"ORIGINAL",8);

          Move(&world->display.rp,GOECTX,GOECTY);
          Text(&world->display.rp,"ECS",3);

          Move(&world->display.rp,GOBETX,GOBETY);
          Text(&world->display.rp,"BEST",4);

          /*******************/
          /* Command Buttons */
          /*******************/

          Move(&world->display.rp,GOCATX,GOCATY);
          Text(&world->display.rp,"CANCEL",6);

          Move(&world->display.rp,GOSATX,GOSATY);
          Text(&world->display.rp,"SAVE",4);

          Move(&world->display.rp,GOUSTX,GOUSTY);
          Text(&world->display.rp,"USE",3);

          first = GOGADENTRY;
          last = GOMAXGAD;
          if (BattMemBase == NULL)
          {
              /* Ghost out SAVE */
              SetAPen(&world->display.rp,2);
    
              RectFill(&world->display.rp,GOSAGX+2,GOSAGY+1,
    		                             GOSAGX+GOSAGW-4,GOSAGY+GOSAGH-2);
          }
          SetAfPt(&world->display.rp,NULL,0);
      }
      else
      {
          /*********/
          /* Title */
          /*********/
          Move(&world->display.rp,274,8);
          Text(&world->display.rp,"Boot Menu",9);

          Move(&world->display.rp, 216, ((PAGE_SIZE * GYSP)+TYS));
          Text(&world->display.rp, "(F1 selects PAL/NTSC)", 21);

          SetFont(&world->display.rp,world->display.font8);
    
          /**********/
          /* Labels */
          /**********/
          Move(&world->display.rp,FP0GX,LY);
          Text(&world->display.rp,"Select Boot Partition",21);
    
          /****************/
          /* Page Display */
          /****************/
          D( printf("init.c: DoImagery() CurrentPage=%ld MaxBootPage=%ld\n",
    	            world->CurrentPage,world->MaxBootPage); )
    
          Move(&world->display.rp,PAGEX,PAGEY);
          sprintf(buf,"Page %2ld of %2ld",world->CurrentPage,world->MaxBootPage);
          Text(&world->display.rp,buf,13);
    
          /*******************/
          /* Command Buttons */
          /*******************/
          SetAPen(&world->display.rp,2);
          Move(&world->display.rp,FPCBTX,FPCBTY);
          Text(&world->display.rp,"CANCEL",6);
    
          Move(&world->display.rp,FPAOTX,FPAOTY);
          Text(&world->display.rp,"Advanced Options...",19);
    
          Move(&world->display.rp,FPGOTX,FPGOTY);
          Text(&world->display.rp,"Graphics Options...",19);
    
          Move(&world->display.rp,FPNPTX,FPNPTY);
          Text(&world->display.rp,"NEXT PAGE",9);
    
          if(world->MaxBootPage==1)
             RectFill(&world->display.rp,FPNPGX+2,FPNPGY+1,
    		                             FPNPGX+FPNPGW-4,FPNPGY+FPNPGH-2);
    
          if (world->GfxEnabled == FALSE)	/* Single A - no options */
             RectFill(&world->display.rp,FPGOGX+2,FPGOGY+1,
    		                             FPGOGX+FPGOGW-4,FPGOGY+FPGOGH-2);
    
          SetAfPt(&world->display.rp,NULL,0);

          first = FPGADENTRY;
          last = FPMAXGAD;

          /****************/
          /* Main Gadgets */
          /****************/
          world->MaxGad=0;
          for(x=0;x<PAGE_SIZE;x++)
          {
             if(DrawFPEntry(world,x))
                world->MaxGad++;
          }
      }

   }

   io->beamcon0 = (world->IsNTSC ? 0x0 : 0x0020);

   for (x = first; x <= last; x++)
   {
       DrawBox(world, gadgets[x].MinX,
                      gadgets[x].MinY,
                      gadgets[x].Width,
                      gadgets[x].Height, 1);
   }

   D( printf("init.c: DoImagery() returns\n"); )
}
struct InputEvent * __asm HandlerInterface(
                        register __a0 struct InputEvent *ev,
                        register __a1 struct World *world)
{
   if(ev->ie_Class==IECLASS_RAWMOUSE)
   {
      UpdateMouse(world,ev);
      /* if world->gad and GadgetHit != world->gad comp world->gad =0 */
      /* if something was selected and mouse is no longer over same gad */
      if(world->gad && (GadgetHit(world)!=world->gad))
      {
         ComplementGadget(world,world->gad);
         world->gad=0;
      }
      switch(ev->ie_Code)
      {
         /*
         case IECODE_RBUTTON:
               D( kprintf("Right Button\n") );
               break;
         */
         case IECODE_LBUTTON:
               D( kprintf("Left Button\n") );
               if (world->gad = GadgetHit(world))
               {
                  ComplementGadget(world,world->gad);
               }
               break;
         case IECODE_LBUTTON|IECODE_UP_PREFIX:
               D( kprintf("Left Button UP\n") );
               GadgetUpAction(world);
               break;
         /*
         case IECODE_NOBUTTON:
               D( kprintf("No Button x = %ld, y = %ld\n",ev->ie_X,ev->ie_Y));
               break;
         default:
               D( kprintf("Default\n") );
               break;
         */
      }
   }
   if ((ev->ie_Class==IECLASS_RAWKEY) && (ev->ie_Code == (IECODE_UP_PREFIX | 0x50)))
   {
	/* Toggle display between PAL and NTSC */
	if (world->gad)
	{
            /* Disable a currently selected gadget */
	    ComplementGadget(world,world->gad);
	    world->gad = 0;
	}
	world->IsNTSC = !world->IsNTSC;
	DoImagery(world);
   }

   return(ev);
}
void GadgetUpAction(world)
struct World *world;
{
   SHORT gad;
   SHORT i;
   struct MyNode *mn;

   if( ! world->gad) return;     /* nothing was down */
   gad=GadgetHit(world);
   if(world->gad!=gad)           /* down on one up on another or none */
   {                             /* Un highlite world->gad            */
      ComplementGadget(world,world->gad);
      world->gad=0;
      return;
   }
   if (gad >= FIRSTGADGET)
   {
      ComplementGadget(world,world->gad);
   }
       
   switch(gad)                   /* down on one and up on same, HIT! */
   {
      /*
      case 0:
            break;
      */
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
      case 6:
      case 7:
      case 8:
      case 9:
      case 10:
            for(mn=(struct MyNode *)world->NodeList.lh_Head;
                mn->Node.ln_Succ;
                mn=(struct MyNode *)mn->Node.ln_Succ)
            {
               if(mn->Highlited)
               {
                  mn->Highlited=FALSE;
                  break;
               }
            }
            mn=GetBootableNode(world,(SHORT)(world->FirstGad+gad-1));
            mn->Highlited=TRUE;
			MyDelay(world,UP_DELAY);
            Signal(world->maintask,1<<world->signal);
            break;
      case 11:
      case 12:
      case 13:
      case 14:
      case 15:
      case 16:
      case 17:
      case 18:
      case 19:
      case 20:
            mn=GetNode(world,(SHORT)(world->FirstGad+gad-10-1));
            if((! mn->Enabled) && mn->Highlited)
            {
               mn->Highlited=FALSE;
               for(i=0;i<world->Nodes;i++)
               {
                  mn=GetNode(world,i);
                  if(((mn->Enabled && mn->Bootable)||
				      (mn->NoEnable && mn->Bootable)))
                  {
                     mn->Highlited=TRUE;
                     break;
                  }
               }
            }
            DrawEntry(world,(SHORT)(gad-10-1)); 
            /* world->gad=0; */
            break;
      case CBGN:
            world->SysCheck = FALSE;
            goto alldone;
      case DAGN:
            (world->SS_Disable) ? (world->SS_Disable=FALSE) : (world->SS_Disable=TRUE);
            SetAPen(&world->display.rp,0);
            RectFill(&world->display.rp,DAGX,DAGY,DAGX+DAGW-1,DAGY+DAGH-1);
            DrawNWay(world,DAGX,DAGY,(BOOL)(! world->SS_Disable),FALSE);
            /* world->gad=0; */
            break;
      case GOGN:
            world->AdvancedMode=FALSE;
            world->CurrentPage =1;
            goto doim;
      case NPGN:
            world->CurrentPage +=1;
            if(world->CurrentPage > world->MaxPage)
               world->CurrentPage = 1;
            goto doim;
      case FPCBGN:
            world->Cancel=TRUE;
alldone:
            MyDelay(world,UP_DELAY);
            Signal(world->maintask,1<<world->signal);
            break;
      case FPAOGN:
            world->AdvancedMode=TRUE;
            world->CurrentPage =1;
            goto doim;
      case FPNPGN:
            world->CurrentPage +=1;
            if(world->CurrentPage > world->MaxBootPage)
               world->CurrentPage = 1;
            goto doim;
      case FPGOGN:
            world->GraphicsMode = TRUE;
            goto doim;
      case GOPAGN:
            world->IsNTSC = FALSE;
            goto doim;
      case GONTGN:
            world->IsNTSC = TRUE;
            goto doim;
      case GOSAGN:
            UpdateBattMem(world);
      case GOUSGN:
            world->WasNTSC = world->IsNTSC;
            world->WasChipRev = world->ChipRev;
      case GOCAGN:
            world->IsNTSC = world->WasNTSC;	/* restore */
            world->ChipRev = world->WasChipRev;
            world->GraphicsMode = FALSE;
            goto doim;
      case GOORGN:
            world->ChipRev = CHIP_ORIGINAL;
            goto doim;
      case GOECGN:
            world->ChipRev = CHIP_ECS;
            goto doim;
      case GOBEGN:
            world->ChipRev = CHIP_BEST;
doim:
            DoImagery(world);
            break;
      /*
      default:
            break;
      */
   }
   world->gad=0; 
   return;
}
void GetData(world)
struct World *world;
{
   struct BootNode *bn;
   struct DeviceNode *dn;
   struct MyNode     *mn;
   struct Custom *io = &custom;
   WORD vposr;
   UBYTE battbits = 0;
   D( struct FileSysStartupMsg *fssm );
   D( struct DosEnvec          *ev   );

   world->SS_Disable = (ExpansionBase->Flags & EBF_DOSFLAG)?TRUE:FALSE;

   world->Nodes=0;
   world->BootNodes=0;
   world->CurrentPage=1;
   NewList(&world->NodeList);

   D( kprintf("Begin MountList Search\n") );
   for(bn=(struct BootNode *)ExpansionBase->MountList.lh_Head;
       bn->bn_Node.ln_Succ;
       bn=(struct BootNode *)bn->bn_Node.ln_Succ)
   {
      D( printf("Node: ") );
      if(bn->bn_DeviceNode)
      {
         dn=(struct DeviceNode *)bn->bn_DeviceNode;
         D( fssm=(struct FileSysStartupMsg *)(((ULONG)dn->dn_Startup) << 2); )
         D( ev=(struct DosEnvec *)(((ULONG)fssm->fssm_Environ) << 2); )

         mn=(struct MyNode *)AllocVec(sizeof(struct MyNode),MEMF_CLEAR);

         world->Nodes+=1;
         mn->node=bn;
         mn->Enabled=(dn->dn_Handler & 0x80000000)?FALSE:TRUE;
         if( ! mn->Enabled) mn->NoEnable=TRUE;
         mn->Bootable=(bn->bn_Node.ln_Type & NT_BOOTNODE)?TRUE:FALSE;

         if(((mn->Bootable)&&(mn->Enabled))||((mn->NoEnable)&&(mn->Bootable)) )
         {
            world->BootNodes+=1;
         }

         AddTail(&world->NodeList,(struct Node *)mn);

         D( printbstr(dn->dn_Name) );
         D( printf(" Pri=%ld",bn->bn_Node.ln_Pri) );
         D( printf(" Node=%lx ",mn) );
         D( printf(" fssm=%lx ",(ULONG)fssm) );
         D( printf(" ev=%lx ",(ULONG)ev) );
         D( printf(" DOSType=%lx",(ULONG)ev->de_DosType) );
         D( printf(" BP=%ld",ev->de_BootPri) );
         D( printf(" TS=%ld",(ULONG)ev->de_TableSize) );
         D( if(bn->bn_Node.ln_Type & NT_BOOTNODE) printf(" BOOTABLE"); )
      }
      D( printf("\n") );
   }
   mn=(struct MyNode *)world->NodeList.lh_Head;
   if(mn->Bootable && mn->Enabled)
      mn->Highlited=TRUE;

   world->MaxPage=(world->Nodes+PAGE_SIZE-1)/PAGE_SIZE;
   world->MaxBootPage=(world->BootNodes+PAGE_SIZE-1)/PAGE_SIZE;
   D( kprintf("MaxPage=%ld, MaxBootPage=%ld, BootNodes=%ld\n",
      world->MaxPage,world->MaxBootPage,world->BootNodes); )
   D( kprintf("End MountList Search\n") );

   world->GfxEnabled = ((vposr = io->vposr) & 0x2000);  /* disable for non HR-Agnus */

   if (BattMemBase)
   {
       UBYTE batt = 0;
       ULONG err;
       ObtainBattSemaphore();
       ReadBattMem(&batt, BATTMEM_MONITOR_MODE_ADDR, BATTMEM_MONITOR_MODE_LEN);
       battbits = batt;
       err = ReadBattMem(&batt, BATTMEM_CHIP_REV_ADDR, BATTMEM_CHIP_REV_LEN);
       if (err == NULL)
       {
           battbits |= ((batt ? batt : (CHIP_BEST + 1)) << 2);
       }
       else
       {
           battbits = 0;
       }     
       ReleaseBattSemaphore();
   }
   if (battbits)	/* at least one bit is set for validity */
   {
       world->IsNTSC = ((battbits & 0x3) == BATTMEM_MONITOR_MODE_NTSC);
       world->ChipRev = (((battbits & 0xc) >> 2) - 1);
   }
   else
   {
       world->IsNTSC = (vposr & 0x1000);
       world->ChipRev = CHIP_BEST;
   }
   world->OriginalNTSC = world->WasNTSC = world->IsNTSC;
   world->OriginalChipRev = world->WasChipRev = world->ChipRev;
   world->GraphicsMode = FALSE;

}
struct MyNode *GetNode(world,num)
struct World *world;
SHORT num;
{
   SHORT x;
   struct Node *n;

   D( printf("init.c: GetNode(world=0x%lx,num=%ld) enter\n",world,num); )

   if(num >= world->Nodes)
   {
      /* n=0L; */
      D( printf("init.c: GetNode() returns MyNode=0\n"); )
      return((struct MyNode *)0L);
   }

   n=world->NodeList.lh_Head;
   for(x=0;x<num;x++)
      n=n->ln_Succ;

   D( printf("init.c: GetNode() returns MyNode=0x%lx\n",n); )
   return((struct MyNode *)n);
}
struct MyNode *GetBootableNode(world,num)
struct World *world;
SHORT num;
{
   SHORT x;
   signed short y = -1;
   struct Node *n;
   struct MyNode *mn;

   D( printf("init.c: GetBootableNode(world=0x%lx,num=%ld) enter\n",world,num); )

   if(num >= world->BootNodes)
   {
      D( printf("init.c: GetBootableNode() returns MyNode=0\n"); )
      return((struct MyNode *)0L);
   }

   n=world->NodeList.lh_Head;
   for(x=0;x<world->Nodes;x++)
   {
	  mn=(struct MyNode *)n;
      if(((mn->Enabled && mn->Bootable)||
	      (mn->NoEnable && mn->Bootable)))
	  {
	     y=y+1;
		 if(y==num)
		 {
            D( printf("init.c: GetBootableNode() returns MyNode=0x%lx\n",n); )
		    return((struct MyNode *)n);
         }
	  }
      n=n->ln_Succ;
   }

   D( printf("init.c: GetBootableNode() returns 0\n"); )
   return((struct MyNode *)0L);
}
#if 0
void FreeData(world)
struct World *world;
{
   struct Node *n;

   while(n=RemHead(&world->NodeList))
      FreeVec((char *)n);
}
#endif
void DrawBSTR(world,name,x,y,maxlen)
struct World *world;
BPTR name;
SHORT x,y;
LONG maxlen;
{
   UBYTE count;
   UBYTE *p;

   p=(UBYTE *)(name << 2);
   count=*p;

   if((count>7)&&maxlen)
   {
      /* kprintf("count=%ld, %7s\n",count,&p[count-7+1]); */
      if(stricmp(".device",&p[count-7])==0)
      {
   	     count -= 8;
      }
   }

   if((maxlen!=0)&&(count>maxlen))
      count=maxlen;
   /* D( kprintf("count = %ld ",count) ); */
   Move(&world->display.rp,x,y);
   Text(&world->display.rp,&p[1],count);
}
SHORT GadgetHit(world)
struct World *world;
{
   SHORT i, start, end, diff;
   SHORT retval=0;
   struct MyNode *mn;

   if(world->AdvancedMode)
   {  
      if((world->sprite.x >= (C0GX))&&(world->sprite.x <= (C0GX+G0W-1)))
      {
         for(i=0;i<world->MaxGad;i++)
         {
            if((world->sprite.y >= ((i * GYSP)+GYS)) &&
               (world->sprite.y <= ((i * GYSP)+GYS+GH-1)) )
            {
               mn=GetNode(world,(SHORT)(world->FirstGad+i));
               if( ! mn->NoEnable)
                  retval=((SHORT)(i+1+10));
               break;
            }
         }
      }
      if (retval)
      {
          return(retval);
      }
      else
      {
          start = AMGADENTRY;
          end = AMMAXGAD;
          diff = FIRSTGADGETAM;
      }

   } 
   else
   {
      if (world->SysCheck)
      {
          start = SCGADENTRY;
          end = SCMAXGAD;
          diff = FIRSTGADGETSC;
      }
      else
      {
          if (world->GraphicsMode)
          {
              start = GOGADENTRY;
              end = GOMAXGAD;
              diff = FIRSTGADGETGO;
          }
          else
          {
              if((world->sprite.x >= (FP0GX))&&(world->sprite.x <= (FP0GX+G1W-1)))
              {
                 for(i=0;i<world->MaxGad;i++)
                 {
                    /*D( kprintf("i=%ld, min=%ld, max=%ld, sprite.y=%ld\n",(LONG)i,
       		                   (LONG)((i*GYSP)+GYS),(LONG)((i*GYSP)+GYS+GH),
       			     		  (LONG)world->sprite.y) );*/
                    if((world->sprite.y >= ((i * GYSP)+GYS)) &&
                       (world->sprite.y <= ((i * GYSP)+GYS+GH-1)) )
                    {
                       mn=GetBootableNode(world,(SHORT)(world->FirstGad+i));
                       if(((mn->Enabled  && mn->Bootable)||
    	   		       (mn->NoEnable && mn->Bootable)))
                          retval=((SHORT)(i+1));
                       break;
                    }
                 }
              }
    
              if (retval)
              {
                  return(retval);
              }
              else
              {
                  start = FPGADENTRY;
                  end = FPMAXGAD;
                  diff = FIRSTGADGETFP;
              }
          }
       }
   }
   for (i=start; i<=end; i++)
   {
       if((world->sprite.x <= (gadgets[i].MinX + gadgets[i].Width)) && (world->sprite.x >= gadgets[i].MinX) &&
          (world->sprite.y <= (gadgets[i].MinY + gadgets[i].Height)) && (world->sprite.y >= gadgets[i].MinY) )
       {
          retval = (i - start + diff);
          break;
       }
   }

   /* special cases */
   if (((retval == NPGN) && (world->MaxPage == 1)) ||
       ((retval == GOSAGN) && (BattMemBase == NULL)) ||
       (((retval == FPGOGN) && (world->GfxEnabled == FALSE)) ||
        ((retval == FPNPGN) && (world->MaxBootPage == 1))) )
   {
        retval = 0;
   }

   D( printf("init.c: GadgetHit() returns %ld\n",retval); )

   return(retval);
}
void ComplementGadget(world,gad)
struct World *world;
SHORT gad;
{
   SHORT y;
   struct MyNode *mn;

   D( printf("init.c: ComplementGadget(world=0x%lx,gad=%ld) enter\n",world,gad); )

   SetDrMd(&world->display.rp,COMPLEMENT);
   switch(gad)
   {
      case DAGN:
      case GOGN:
      case NPGN:
      case FPCBGN:
      case FPAOGN:
      case FPNPGN:
      case FPGOGN:
      case GONTGN:
      case GOPAGN:
      case GOSAGN:
      case GOUSGN:
      case GOCAGN:
      case GOORGN:
      case GOECGN:
      case GOBEGN:
      case CBGN:
	    RectFill(&world->display.rp, gadgets[gad - FIRSTGADGET].MinX,
                                         gadgets[gad - FIRSTGADGET].MinY,
                                         (gadgets[gad - FIRSTGADGET].MinX + gadgets[gad - FIRSTGADGET].Width - 1),
                                         (gadgets[gad - FIRSTGADGET].MinY + gadgets[gad - FIRSTGADGET].Height - 1));
            break;
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
      case 6:
      case 7:
      case 8:
      case 9:
      case 10:
	  /*
            y=(SHORT)(((gad-1)*GYSP)+GYS);
	        if(world->AdvancedMode)
			{
               RectFill(&world->display.rp,C1GX,y,C1GX+G1W-1,y+GH-1);
			} else {
               RectFill(&world->display.rp,FP0GX,y,FP0GX+G1W-1,y+GH-1);
			}
	  */
            y=(SHORT)(((gad-1)*GYSP)+GYS);
            RectFill(&world->display.rp,FP0GX,y,FP0GX+G1W-1,y+GH-1);
            break;
      case 11:
      case 12:
      case 13:
      case 14:
      case 15:
      case 16:
      case 17:
      case 18:
      case 19:
      case 20:
            D( printf("init.c: ComplementGadget() FirstGad=%ld\n",
			          world->FirstGad); )
            mn=GetNode(world,(SHORT)(world->FirstGad+gad-11));
            if(mn->Enabled)
            {
               if(mn->Bootable)
               {
                  if(world->BootNodes > 1)
                  {
                     mn->Enabled=FALSE;
                     world->BootNodes-=1;
                  }
               } else {
                  mn->Enabled=FALSE;
               }
            } else {
               mn->Enabled=TRUE;
               if(mn->Bootable)
                  world->BootNodes+=1;
            }
            RectFill(&world->display.rp,C0GX,(SHORT)(((gad-11)*GYSP)+GYS),
			         C0GX+G0W-1,(SHORT)(((gad-11)*GYSP)+GYS)+GH-1);
            break;
      /*
      default:
            break;
      */
   }
   SetDrMd(&world->display.rp,JAM1);
   D( printf("init.c: ComplementGadget() returns\n",world,gad); )
}
void MakeChanges(world)
struct World *world;
{
   struct BootNode *bn;
   struct DeviceNode *dn;
   struct MyNode *mn;

   D( printf("init.c: MakeChanges() enter\n"); )

   /***********************************/
   /* Startup-Sequence Enable/Disable */
   /***********************************/
   if(world->SS_Disable)
      ExpansionBase->Flags |= EBF_DOSFLAG;
   else
      ExpansionBase->Flags &= (~EBF_DOSFLAG);

   /****************************/
   /* Partition Enable/Disable */
   /****************************/
   for(mn=(struct MyNode *)world->NodeList.lh_Head;
       mn->Node.ln_Succ;
       mn=(struct MyNode *)mn->Node.ln_Succ)
   {
      bn=mn->node;
      dn=(struct DeviceNode *)bn->bn_DeviceNode;

      if(mn->Enabled)
         dn->dn_Handler &= (~0x80000000);
      else
         dn->dn_Handler |= 0x80000000;
   }

   /****************************/
   /* Boot Partition Selection */
   /****************************/
   if( ! ((struct MyNode *)(world->NodeList.lh_Head))->Highlited)/*Bootdef*/
      for(mn=(struct MyNode *)world->NodeList.lh_Head;
          mn->Node.ln_Succ;
          mn=(struct MyNode *)mn->Node.ln_Succ)
      {
         /* if highlited then do pri swizzle and break */
         if(mn->Highlited)
         {
            Remove((struct Node *)mn->node);
            mn->node->bn_Node.ln_Pri=127;
            AddHead(&ExpansionBase->MountList,(struct Node *)mn->node);
         }
      }

   /********************/
   /* Graphics options */
   /********************/

    if (world->OriginalNTSC != world->IsNTSC) /* there has been a change */
    {
#pragma libcall GfxBase SetDefaultMonitor 390 001	
        SetDefaultMonitor(world->IsNTSC ? (NTSC_MONITOR_ID >> 16) : (PAL_MONITOR_ID >> 16));
    }
    switch (world->ChipRev)
    {
    	case CHIP_ORIGINAL : GfxBase->WantChips = SETCHIPREV_A; break;
    	case CHIP_ECS : GfxBase->WantChips = SETCHIPREV_ECS; break;
    	case CHIP_BEST : GfxBase->WantChips = SETCHIPREV_BEST; break;
    };

#pragma libcall world->GfxBase SetChipRev 378 1
    SetChipRev(GfxBase->WantChips);

   D( printf("init.c: MakeChanges() returns\n"); )
}
BOOL DrawEntry(world,x)
struct World *world;
SHORT x;
{
   struct MyNode *mn;
   struct BootNode *bn;
   struct DeviceNode *dn;
   struct FileSysStartupMsg *fssm;
   struct DosEnvec          *ev; 
   char buf[5];

   /**************/
   /* Clear slot */
   /**************/
   SetAPen(&world->display.rp,0);

   RectFill(&world->display.rp,C0GX,(x*GYSP)+GYS,
                            C5GX+G5W-1,(x*GYSP)+GYS+GH-1);

   /********************/
   /* Does node exist? */
   /********************/
   world->FirstGad=((world->CurrentPage-1)*PAGE_SIZE);
   mn=GetNode(world,(SHORT)(x+world->FirstGad));
   if( ! mn)
   {
      return(FALSE);
   }

   /****************/
   /* Get Pointers */
   /****************/
   bn=mn->node;
   dn=(struct DeviceNode *)bn->bn_DeviceNode;
   fssm=(struct FileSysStartupMsg *)(((ULONG)dn->dn_Startup) << 2);
   ev=(struct DosEnvec *)(((ULONG)fssm->fssm_Environ) << 2); 

   /**************/
   /* Draw Boxes */
   /**************/
   DrawBox(world,C1GX,(SHORT)((x*GYSP)+GYS),G1W,GH,0);
   DrawBox(world,C2GX,(SHORT)((x*GYSP)+GYS),G2W,GH,0);
   DrawBox(world,C3GX,(SHORT)((x*GYSP)+GYS),G3W,GH,0);
   DrawBox(world,C4GX,(SHORT)((x*GYSP)+GYS),G4W,GH,0);
   DrawBox(world,C5GX,(SHORT)((x*GYSP)+GYS),G5W,GH,0);

   /********/
   /* NWay */
   /********/
   DrawNWay(world,C0GX,(SHORT)((x*GYSP)+GYS),mn->Enabled,mn->NoEnable);

   /***************/
   /* Device Name */
   /***************/
   SetAPen(&world->display.rp,2);
   DrawBSTR(world,dn->dn_Name,C1TX,(SHORT)((x*GYSP)+TYS),0);

   /***********/
   /* BootPri */
   /***********/
   Move(&world->display.rp,C3TX,(SHORT)((x*GYSP)+TYS));
   if(mn->Bootable)
   {
      sprintf(buf,"%4ld",(LONG)bn->bn_Node.ln_Pri);
      Text(&world->display.rp,buf,4);
   } else {
      Text(&world->display.rp," N/A",4);
   }

   /**********/
   /* Device */
   /**********/
   DrawBSTR(world,fssm->fssm_Device,C4TX,(SHORT)(((x)*GYSP)+TYS),10);

   /********/
   /* Unit */
   /********/
   sprintf(buf,"%3ld",(LONG)fssm->fssm_Unit);
   Move(&world->display.rp,C5TX,(SHORT)((x*GYSP)+TYS));
   Text(&world->display.rp,buf,3);


   /***********/
   /* DosType */
   /***********/
   if(ev->de_TableSize < DE_DOSTYPE)
   {
      Move(&world->display.rp,C2TX,(SHORT)((x*GYSP)+TYS));
      Text(&world->display.rp,"DOS",3);
      SetAPen(&world->display.rp,1);
      Text(&world->display.rp,"0",1);
   } else {
      DrawByte(world,(SHORT)C2TX,     (SHORT)((x*GYSP)+TYS),
	                                  (UBYTE)((ev->de_DosType>>24)&0xff));
      DrawByte(world,(SHORT)(C2TX+8), (SHORT)((x*GYSP)+TYS),
	                                  (UBYTE)((ev->de_DosType>>16)&0xff));
      DrawByte(world,(SHORT)(C2TX+16),(SHORT)((x*GYSP)+TYS),
	                                  (UBYTE)((ev->de_DosType>>8) &0xff));
      DrawByte(world,(SHORT)(C2TX+24),(SHORT)((x*GYSP)+TYS),
	                                  (UBYTE)((ev->de_DosType)    &0xff));
   }


   return(TRUE);
}
BOOL DrawFPEntry(world,x)
struct World *world;
SHORT x;
{
   struct MyNode *mn;
   struct BootNode *bn;
   struct DeviceNode *dn;

   /**************/
   /* Clear slot */
   /**************/
   SetAPen(&world->display.rp,0);

   RectFill(&world->display.rp,FP0GX,(SHORT)((x*GYSP)+GYS),
                            FP0GX+G1W-1,((x*GYSP)+GYS)+GH-1);

   /********************/
   /* Does node exist? */
   /********************/
   world->FirstGad=((world->CurrentPage-1)*PAGE_SIZE);
   mn=GetBootableNode(world,(SHORT)(x+world->FirstGad));
   if((!mn)||(!mn->Bootable))
   {
      return(FALSE);
   }

   /****************/
   /* Get Pointers */
   /****************/
   bn=mn->node;
   dn=(struct DeviceNode *)bn->bn_DeviceNode;

   /************/
   /* Draw Box */
   /************/
   DrawBox(world,FP0GX,(SHORT)((x*GYSP)+GYS),G1W,GH,(SHORT)(
      ((mn->Enabled && mn->Bootable)||(mn->NoEnable && mn->Bootable))?1:0));

   /***************/
   /* Device Name */
   /***************/
   SetAPen(&world->display.rp,2);
   DrawBSTR(world,dn->dn_Name,FP0TX,(SHORT)(((x)*GYSP)+TYS),0);

   return(TRUE);
}
VOID DrawNWay(struct World *world,SHORT x,SHORT y,BOOL enabled,BOOL sunken)
{
   struct BitMap mybitmap;
   SHORT place;

   /*******/
   /* Box */
   /*******/
   DrawBox(world,x,y,DAGW,DAGH,(BOOL)(! sunken));
   /* DrawGlyph(world,x,y); */

   /*********/
   /* Glyph */
   /*********/
   InitBitMap(&mybitmap, 8, NWAYBMWIDTH, NWAYBMHEIGHT);

   if (!(mybitmap.Planes[0] =
   AllocVec(sizeof(NWayGlyphData), MEMF_CHIP)))
   {
      return;
   }
   CopyMem((char *)NWayGlyphData, (char *)mybitmap.Planes[0],
   sizeof(NWayGlyphData));
   for (place = 1; place < 8; place++)
   {
      mybitmap.Planes[place] = mybitmap.Planes[0];
   }
   SetWrMsk(&world->display.rp,0x02);
   MyBltBitMapRastPort(GfxBase,&mybitmap, 0, 0,&world->display.rp,
                      (SHORT)(x+5),(SHORT)(y+2),
                      NWAYBMWIDTH, NWAYBMHEIGHT,
                      VANILLA_COPY);
   SetWrMsk(&world->display.rp,0xFF);

   FreeVec((char *)mybitmap.Planes[0]);

   /*****************/
   /* Vertical line */
   /*****************/
   SetAPen(&world->display.rp,1);
   Move(&world->display.rp,x+20,y+2);
   Draw(&world->display.rp,x+20,y+10);

   SetAPen(&world->display.rp,2);
   Move(&world->display.rp,x+19,y+2);
   Draw(&world->display.rp,x+19,y+10);

   /********/
   /* Text */
   /********/
   if(! enabled)
   {
      Move(&world->display.rp,x+19+9,y+9);
      Text(&world->display.rp,"DISABLED",8);
   } else {
      Move(&world->display.rp,x+19+9+4,y+9);
      Text(&world->display.rp,"ENABLED",7);
   }
}
void DrawByte(world,x,y,value)
struct World *world;
SHORT x,y;
UBYTE value;
{
   Move(&world->display.rp,x,y);
   if (((value>=0x20)&&(value<=0x7f)) || ((value>=0xa0)&&(value<=0xff)))
   {
      SetAPen(&world->display.rp,2);
   } else {
      SetAPen(&world->display.rp,1);
      if((value>=0x00)&&(value<=0x09))
      {
         value += '0';
      } else
         if((value>=0x0a)&&(value<=0x1f))
         {
            value = value - 0x0a + 'a';
         } else
            if((value>=0x80)&&(value<=0x9f))
            {
               value = value - 0x80 + '@@';
            }
   }
   Text(&world->display.rp,&value,1);
}
void MyDelay(struct World *world,SHORT n)
{
	SHORT x;

	for(x=0;x<n;x++)
	   WaitTOF();
}
void UpdateBattMem(struct World *world)
{
    UBYTE battmem;

    if (BattMemBase)
    {
        ObtainBattSemaphore();
        battmem = (world->IsNTSC ? BATTMEM_MONITOR_MODE_NTSC : BATTMEM_MONITOR_MODE_PAL);
        WriteBattMem(&battmem, BATTMEM_MONITOR_MODE_ADDR, BATTMEM_MONITOR_MODE_LEN);
        battmem = (world->ChipRev + 1);
        WriteBattMem(&battmem, BATTMEM_CHIP_REV_ADDR, BATTMEM_CHIP_REV_LEN);
        ReleaseBattSemaphore();
    }
}
@


39.10
log
@Changes GfxBase->NormalDPMX/Y, and GfxBase->MaxDisplayRow
@
text
@d3 1
a3 1
*	$Id: bootmenu.c,v 39.9 92/04/06 12:23:18 spence Exp Locker: spence $
d462 1
d1497 2
a1498 26
	#include <exec/execbase.h>
	struct ExecBase *SysBase = (*((struct ExecBase **) 4));

        if (world->IsNTSC)
        {
            GfxBase->DisplayFlags &= ~PAL;
            GfxBase->DisplayFlags |= NTSC;
            GfxBase->MaxDisplayRow = (STANDARD_NTSC_ROWS - 1);
            GfxBase->NormalDisplayRows = 200;
            GfxBase->monitor_id = (NTSC_MONITOR_ID >> 16);
            GfxBase->NormalDPMX = 1280;	/* 320 X 1000/250mm */
            GfxBase->NormalDPMY = 1098;	/* 200 X 1000/182mm */
            SysBase->VBlankFrequency = 60;

        }
        else
        {
            GfxBase->DisplayFlags &= ~NTSC;
            GfxBase->DisplayFlags |= PAL;
            GfxBase->MaxDisplayRow = (STANDARD_PAL_ROWS - 1);
            GfxBase->NormalDisplayRows = 256;
            GfxBase->monitor_id = (PAL_MONITOR_ID >> 16);
            GfxBase->NormalDPMX = 1226;	/* 320 X 1000/261mm */
            GfxBase->NormalDPMY = 1299;	/* 200 X 1000/197mm */
            SysBase->VBlankFrequency = 50;
        }
@


39.9
log
@Graphics Options page uses topaz.8 for gadgets.
Fixed bug where hitting the F1 key for PAL/NTSC whilst selecting a
gadget would confuse the gadget rendering state.
@
text
@d3 1
a3 1
*	$Id: bootmenu.c,v 39.8 92/03/06 10:49:40 spence Exp Locker: spence $
d1503 1
d1506 2
d1515 1
d1518 2
@


39.8
log
@F1 PAL/NTSC key now operates on all screens.
Graphics Options expanded for Chip Rev setting.
@
text
@d3 1
a3 1
*	$Id: bootmenu.c,v 39.7 92/02/05 11:44:40 spence Exp Locker: spence $
d219 1
a219 1
#define GOCATX    (GOCAGX+((GOCAGW-GOCATW)>>1))-3
d683 3
a685 1
          Move(&world->display.rp, 252, (GONTTY - 14));
d688 1
a688 1
          Move(&world->display.rp, 268, (GOORTY - 14));
d696 1
a696 1
          Move(&world->display.rp, 164, (GOBEGY + GOBEGH + 20));
d851 1
a851 2
               world->gad=GadgetHit(world);
               if(world->gad)
d873 6
@


39.7
log
@Sets GfxBase->NormalDisplayRows, and SysBase->VBlankFrequency
@
text
@d3 1
a3 1
*	$Id: bootmenu.c,v 39.6 92/01/21 12:10:38 spence Exp Locker: spence $
d117 1
a117 1
#define GONTGW    100
d139 42
d364 1
a364 1
#define CBGN      (113)  
d389 3
d404 3
a406 3
#define GOMAXGAD 11
#define SCGADENTRY 12
#define SCMAXGAD 12
d412 1
a412 1
#define PAGE_SIZE 10    /* Number of nodes per page                     */
d420 15
d461 1
d469 1
d523 5
d545 1
d553 1
d683 6
a688 2
          Move(&world->display.rp, 212, (GOPAGY + GOPAGH + 20));
          Text(&world->display.rp, "Current Setting - ", 18);
d694 4
a697 4
          Text(&world->display.rp, (world->IsNTSC ? "NTSC" : "PAL "), 4);

          Move(&world->display.rp, 216, (GOPAGY + GOPAGH + 40));
          Text(&world->display.rp, "(F1 selects PAL/NTSC)", 21);
d709 9
d751 3
d869 1
a869 1
   if ((world->GraphicsMode) && (ev->ie_Class==IECLASS_RAWKEY) && (ev->ie_Code == (IECODE_UP_PREFIX | 0x50)))
d1004 1
d1007 1
d1009 9
d1101 2
d1104 11
a1114 1
       ReadBattMem(&battbits, BATTMEM_MONITOR_MODE_ADDR, BATTMEM_MONITOR_MODE_LEN);
d1119 2
a1120 1
       world->IsNTSC = (battbits == BATTMEM_MONITOR_MODE_NTSC);
d1125 1
d1128 1
d1361 3
d1510 9
d1774 2
@


39.6
log
@F1 key toggles PAL/NTSC in GraphicsOption screen
@
text
@d3 1
a3 1
*	$Id: bootmenu.c,v 39.5 92/01/13 10:54:14 spence Exp Locker: spence $
d1375 3
d1382 1
d1384 2
d1391 1
d1393 1
@


39.5
log
@Centered graphics text.
@
text
@d3 1
a3 1
*	$Id: bootmenu.c,v 39.4 92/01/10 18:23:25 spence Exp Locker: spence $
d530 1
d623 3
d729 2
d784 7
d941 1
a1004 1
       UBYTE battbits = 0;
d1006 1
a1006 4
       if (ReadBattMem(&battbits, BATTMEM_MONITOR_MODE_ADDR, BATTMEM_MONITOR_MODE_LEN) == 0)
       {
           world->IsNTSC = (battbits == BATTMEM_MONITOR_MODE_NTSC);
       }
d1008 4
@


39.4
log
@support for syscheck module.
@
text
@d3 1
a3 1
*	$Id: bootmenu.c,v 39.3 92/01/10 14:46:36 spence Exp Locker: spence $
d109 2
d119 1
a119 1
#define GONTGX    ((WIDTH - GONTGW) >> 1)
d133 1
a133 1
#define GOPAGX    ((WIDTH - GOPAGW) >> 1)
d147 1
a147 1
#define GOSAGX    187
d177 1
a177 1
#define GOCATX    (GOCAGX+((GOCAGW-GOCATW)>>1))
d610 1
a610 1
          Move(&world->display.rp, 268,8);
d613 1
a613 1
          Move(&world->display.rp, 232, (GOPAGY + GOPAGH + 20));
@


39.3
log
@More space optimisations
@
text
@d3 1
a3 1
*	$Id: bootmenu.c,v 39.1 92/01/09 14:32:57 spence Exp Locker: spence $
a9 37
struct MyNode {
   struct Node Node;
   BOOL  Highlited;
   BOOL  Enabled;
   BOOL  NoEnable;
   BOOL  Bootable;
   struct BootNode *node;
   };

struct World {
   struct GfxBase       *GfxBase;
   struct ExpansionBase *ExpansionBase;
   struct Display       display;
   struct IH            ih;
   struct Sprite        sprite;
   struct Task          *maintask;
   LONG                 signal;
   SHORT                gad;     /* gad currently depressed or 0 */
   SHORT                CurrentPage; /* 1 - MaxPage */
   SHORT                MaxPage;     /* Max Page number */
   SHORT				MaxBootPage; /* Max page number for bootable nodes*/
   struct List          NodeList;
   SHORT                Nodes;      /* Number of EB_Mounlist nodes */
   SHORT                MaxGad;     /* current Max Gadgets on screen */
   SHORT                FirstGad;   /* node number of first displayed node*/
   SHORT                SS_Disable;
   BOOL                 Cancel;
   SHORT                BootNodes; /* total number of bootable nodes */
   BOOL			AdvancedMode; /* TRUE if advanvced options */
   BOOL			GraphicsMode; /* TRUE if in Graphics Options */
   BOOL			GfxEnabled;   /* TRUE if Graphics Options is enabled */
   APTR                 BattMemBase;  /* BattMem resource */
   BOOL                 IsNTSC;       /* True if gfxmode == NTSC */
   BOOL                 WasNTSC;      /* For CANCEL */
   BOOL                 OriginalNTSC; /* starting value */
   };

d47 3
a49 3
#define G2W       44                   /* gadget 2 width */
#define G3W       44                   /* gadget 3 width */
#define G4W       92                   /* gadget 3 width */
d309 13
d345 1
d351 1
d358 2
d414 1
a414 1
   world->AdvancedMode=FALSE;
d857 3
d877 2
a879 1
            world->Cancel=TRUE;
d1139 1
a1139 1
      if (world->GraphicsMode)
d1141 3
a1143 3
          start = GOGADENTRY;
          end = GOMAXGAD;
          diff = FIRSTGADGETGO;
d1147 1
a1147 20
          if((world->sprite.x >= (FP0GX))&&(world->sprite.x <= (FP0GX+G1W-1)))
          {
             for(i=0;i<world->MaxGad;i++)
             {
                /*D( kprintf("i=%ld, min=%ld, max=%ld, sprite.y=%ld\n",(LONG)i,
   		                   (LONG)((i*GYSP)+GYS),(LONG)((i*GYSP)+GYS+GH),
   			     		  (LONG)world->sprite.y) );*/
                if((world->sprite.y >= ((i * GYSP)+GYS)) &&
                   (world->sprite.y <= ((i * GYSP)+GYS+GH-1)) )
                {
                   mn=GetBootableNode(world,(SHORT)(world->FirstGad+i));
                   if(((mn->Enabled  && mn->Bootable)||
	   		       (mn->NoEnable && mn->Bootable)))
                      retval=((SHORT)(i+1));
                   break;
                }
             }
          }

          if (retval)
d1149 3
a1151 1
              return(retval);
d1155 29
a1183 3
              start = FPGADENTRY;
              end = FPMAXGAD;
              diff = FIRSTGADGETFP;
d1185 1
a1185 1
      }
a1186 1

d1207 1
d1234 1
@


39.2
log
@More space optimisations.
Also, clicking CANCEL on main screen will unsave saved graphics option.
@
text
@d347 1
a347 1
struct Rectangle gadgets[] =
d349 4
a352 12
   {DAGX, DAGY, (DAGX + DAGW - 1), (DAGY + DAGH -1)},	/* s/s enable/disable */
   {GOGX, GOGY, (GOGX + GOGW - 1), (GOGY + GOGH -1)},   /* use */
   {NPGX, NPGY, (NPGX + NPGW - 1), (NPGY + NPGH -1)},   /* next page */
   {FPCBGX, FPCBGY, (FPCBGX + FPCBGW - 1), (FPCBGY + FPCBGH -1)}, /* first page cancel */
   {FPAOGX, FPAOGY, (FPAOGX + FPAOGW - 1), (FPAOGY + FPAOGH -1)}, /* first page adv opt */
   {FPNPGX, FPNPGY, (FPNPGX + FPNPGW - 1), (FPNPGY + FPNPGH -1)}, /* first page next page */
   {FPGOGX, FPGOGY, (FPGOGX + FPGOGW - 1), (FPGOGY + FPGOGH -1)}, /* first page gfx opt */
   {GONTGX, GONTGY, (GONTGX + GONTGW - 1), (GONTGY + GONTGH -1)}, /* gfx NTSC */
   {GOPAGX, GOPAGY, (GOPAGX + GOPAGW - 1), (GOPAGY + GOPAGH -1)}, /* gfx PAL */
   {GOCAGX, GOCAGY, (GOCAGX + GOCAGW - 1), (GOCAGY + GOCAGH -1)}, /* gfx CANCEL */
   {GOSAGX, GOSAGY, (GOSAGX + GOSAGW - 1), (GOSAGY + GOSAGH -1)}, /* gfx SAVE */
   {GOUSGX, GOUSGY, (GOUSGX + GOUSGW - 1), (GOUSGY + GOUSGH -1)}, /* gfx USE */
d355 16
d549 1
d573 2
a574 13
      Text(&world->display.rp,"Status",6);

      Move(&world->display.rp,C1GX,LY);
      Text(&world->display.rp,"Partition Name",14);

      Move(&world->display.rp,C2GX,LY);
      Text(&world->display.rp,"Type",4);

      Move(&world->display.rp,C3GX,LY);
      Text(&world->display.rp,"Pri",3);

      Move(&world->display.rp,C4GX,LY);
      Text(&world->display.rp,"Device",6);
a575 3
      Move(&world->display.rp,C5GX,LY);
      Text(&world->display.rp,"Unit",4);

a592 1
      DrawBox(world,GOGX,GOGY,GOGW,GOGH,1);
a595 3
      DrawBox(world,NPGX,NPGY,NPGW,NPGH,1);

      SetAPen(&world->display.rp,2);
d606 3
d621 1
a645 1
          DrawBox(world,GONTGX,GONTGY,GONTGW,GONTGH,1);
a648 1
          DrawBox(world,GOPAGX,GOPAGY,GOPAGW,GOPAGH,1);
a655 1
          DrawBox(world,GOCAGX,GOCAGY,GOCAGW,GOCAGH,1);
a658 1
          DrawBox(world,GOSAGX,GOSAGY,GOSAGW,GOSAGH,1);
a661 1
          DrawBox(world,GOUSGX,GOUSGY,GOUSGW,GOUSGH,1);
d663 2
a706 1
          DrawBox(world,FPCBGX,FPCBGY,FPCBGW,FPCBGH,1);
a709 1
          DrawBox(world,FPAOGX,FPAOGY,FPAOGW,FPAOGH,1);
a712 1
          DrawBox(world,FPGOGX,FPGOGY,FPGOGW,FPGOGH,1);
a715 3
          DrawBox(world,FPNPGX,FPNPGY,FPNPGW,FPNPGH,1);
    
          SetAPen(&world->display.rp,2);
d726 4
a729 1
    
d740 9
d750 1
d887 1
a887 2
            DoImagery(world);
	    break;
d892 1
a892 2
            DoImagery(world);
            break;
d901 1
a901 2
            DoImagery(world);
            break;
d906 1
a906 2
            DoImagery(world);
            break;
d909 1
a909 2
            DoImagery(world);
            break;
d912 1
a912 2
            DoImagery(world);
            break;
d915 1
a915 2
            DoImagery(world);
            break;
d923 1
d1197 2
a1198 2
       if((world->sprite.x <= gadgets[i].MaxX) && (world->sprite.x >= gadgets[i].MinX) &&
          (world->sprite.y <= gadgets[i].MaxY) && (world->sprite.y >= gadgets[i].MinY) )
d1243 2
a1244 2
                                         gadgets[gad - FIRSTGADGET].MaxX,
                                         gadgets[gad - FIRSTGADGET].MaxY);
@


39.1
log
@Graphics options in. Does everything except call MakeGfxGreat().
@
text
@d3 1
a3 1
*	$Id: bootmenu.c,v 39.0 92/01/08 11:57:06 spence Exp Locker: spence $
a6 1
#include <graphics/text.h>
d410 1
a411 2
#pragma libcall GfxBase MakeGfxGreat 378 0

a415 1
   struct Resident *bmr;
a443 4
   if (bmr = FindResident(BATTMEMNAME)
   {
       InitResident(bmr, NULL);
   }
d471 1
a471 1
   DisplayOn(world,0xaaa,0xfff,0x000,0xec4);
d489 1
d491 6
d501 1
a501 1
      FreeMem((char *)n,sizeof(struct MyNode));
a642 11
          if (BattMemBase)
          {
              UWORD battbits;
              ObtainBattSemaphore();
              if (ReadBattMem(&battbits, BATTMEM_MONITOR_MODE_ADDR, BATTMEM_MONITOR_MODE_LEN) == 0)
              {
                  world->IsNTSC = (battbits == BATTMEM_MONITOR_MODE_NTSC);
              }
              ReleaseBattSemaphore();
          }

d925 1
a925 7
            {
                WORD battmem;
                ObtainBattSemaphore();
                battmem = (world->IsNTSC ? BATTMEM_MONITOR_MODE_NTSC : BATTMEM_MONITOR_MODE_PAL);
                WriteBattMem(&battmem, BATTMEM_MONITOR_MODE_ADDR, BATTMEM_MONITOR_MODE_LEN);
                ReleaseBattSemaphore();
            }
d971 1
a971 1
         mn=(struct MyNode *)AllocMem(sizeof(struct MyNode),MEMF_CLEAR);
d1009 16
a1024 1
   world->OriginalNTSC = world->IsNTSC = (vposr & 0x1000);
d1026 1
d1095 1
a1095 1
      FreeMem((char *)n,sizeof(struct MyNode));
d1128 1
a1128 1
   SHORT i;
d1152 1
a1152 2

      for (i=AMGADENTRY; i<=AMMAXGAD; i++)
d1154 3
a1156 6
          if((world->sprite.x <= gadgets[i].MaxX) && (world->sprite.x >= gadgets[i].MinX) &&
             (world->sprite.y <= gadgets[i].MaxY) && (world->sprite.y >= gadgets[i].MinY) )
         {
             retval = (i + FIRSTGADGETAM);
             break;
         }
a1158 4
      if ((retval == NPGN) && (world->MaxPage == 1))
      {
            retval = 0;
      }
d1164 3
a1166 13
          for (i=GOGADENTRY; i<=GOMAXGAD; i++)
          {
              if((world->sprite.x <= gadgets[i].MaxX) && (world->sprite.x >= gadgets[i].MinX) &&
                 (world->sprite.y <= gadgets[i].MaxY) && (world->sprite.y >= gadgets[i].MinY) )
             {
                 retval = (i - GOGADENTRY + FIRSTGADGETGO);
                 break;
             }
          }
          if ((retval == GOSAGN) && (BattMemBase == NULL))
          {
              retval = 0;
          }
d1193 1
a1193 13

          for (i=FPGADENTRY; i<=FPMAXGAD; i++)
          {
              if((world->sprite.x <= gadgets[i].MaxX) && (world->sprite.x >= gadgets[i].MinX) &&
                 (world->sprite.y <= gadgets[i].MaxY) && (world->sprite.y >= gadgets[i].MinY) )
              {
                 retval = (i - FPGADENTRY + FIRSTGADGETFP);
                 break;
              }
          }

          if (((retval == FPGOGN) && (world->GfxEnabled == FALSE)) ||
              ((retval == FPNPGN) && (world->MaxBootPage == 1)))
d1195 24
a1218 3
             retval = 0;
          }
      }
d1376 1
d1382 1
a1383 1
        /* makegfxgreat() */
d1556 1
a1556 1
   AllocMem(sizeof(NWayGlyphData), MEMF_CHIP)))
d1573 1
a1573 1
   FreeMem((char *)mybitmap.Planes[0],sizeof(NWayGlyphData));
d1630 12
@


39.0
log
@First V39 pass. Graphics Option gadget and added to list
(doesn't do anything yet).
@
text
@d3 1
a3 1
*	$Id: Exp $
d42 4
d147 88
d346 29
d412 2
d418 1
d447 5
d522 1
d624 8
a631 6
   } else {
      /*********/
      /* Title */
      /*********/
      Move(&world->display.rp,274,8);
      Text(&world->display.rp,"Boot Menu",9);
d633 9
a641 1
      SetFont(&world->display.rp,world->display.font8);
d643 10
a652 5
      /**********/
      /* Labels */
      /**********/
      Move(&world->display.rp,FP0GX,LY);
      Text(&world->display.rp,"Select Boot Partition",21);
d654 1
a654 5
      /****************/
      /* Page Display */
      /****************/
      D( printf("init.c: DoImagery() CurrentPage=%ld MaxBootPage=%ld\n",
	            world->CurrentPage,world->MaxBootPage); )
d656 27
a682 3
      Move(&world->display.rp,PAGEX,PAGEY);
      sprintf(buf,"Page %2ld of %2ld",world->CurrentPage,world->MaxBootPage);
      Text(&world->display.rp,buf,13);
d684 11
a694 37
      /*******************/
      /* Command Buttons */
      /*******************/
      SetAPen(&world->display.rp,2);
      Move(&world->display.rp,FPCBTX,FPCBTY);
      Text(&world->display.rp,"CANCEL",6);
      DrawBox(world,FPCBGX,FPCBGY,FPCBGW,FPCBGH,1);

      Move(&world->display.rp,FPAOTX,FPAOTY);
      Text(&world->display.rp,"Advanced Options...",19);
      DrawBox(world,FPAOGX,FPAOGY,FPAOGW,FPAOGH,1);

      Move(&world->display.rp,FPGOTX,FPGOTY);
      Text(&world->display.rp,"Graphics Options...",19);
      DrawBox(world,FPGOGX,FPGOGY,FPGOGW,FPGOGH,1);

      Move(&world->display.rp,FPNPTX,FPNPTY);
      Text(&world->display.rp,"NEXT PAGE",9);
      DrawBox(world,FPNPGX,FPNPGY,FPNPGW,FPNPGH,1);

      SetAPen(&world->display.rp,2);

      if(world->MaxBootPage==1)
         RectFill(&world->display.rp,FPNPGX+2,FPNPGY+1,
		                             FPNPGX+FPNPGW-4,FPNPGY+FPNPGH-2);

      if (GfxBase->ChipRevBits0 == 0)	/* Single A - no options */
         RectFill(&world->display.rp,FPGOGX+2,FPGOGY+1,
		                             FPGOGX+FPGOGW-4,FPGOGY+FPGOGH-2);

      SetAfPt(&world->display.rp,NULL,0);

      /****************/
      /* Main Gadgets */
      /****************/
      world->MaxGad=0;
      for(x=0;x<PAGE_SIZE;x++)
d696 65
a760 2
         if(DrawFPEntry(world,x))
            world->MaxGad++;
d825 5
a889 1
            ComplementGadget(world,world->gad);
d897 1
a897 3
            ComplementGadget(world,world->gad);
            /* world->gad=0; */
			world->AdvancedMode=FALSE;
d900 1
a900 1
			break;
a901 2
            ComplementGadget(world,world->gad);
            /* world->gad=0; */
d908 1
a908 1
	        MyDelay(world,UP_DELAY);
d913 1
a913 3
            ComplementGadget(world,world->gad);
            /* world->gad=0; */
			world->AdvancedMode=TRUE;
a917 2
            ComplementGadget(world,world->gad);
            /* world->gad=0; */
d924 24
a947 2
            ComplementGadget(world,world->gad);
            /* world->gad=0; */
d964 2
d1025 2
a1026 1
   world->GfxEnabled = (GfxBase->ChipRevBits0);	/* disable for single-A */
a1134 24
      if((world->sprite.x <= DAGX+DAGW-1) && (world->sprite.x >= DAGX) &&
         (world->sprite.y <= DAGY+DAGH-1) && (world->sprite.y >= DAGY) )
      {
         retval=DAGN;
         goto exit;
      }

      if((world->sprite.x <= GOGX+GOGW-1) && (world->sprite.x >= GOGX) &&
         (world->sprite.y <= GOGY+GOGH-1) && (world->sprite.y >= GOGY) )
      {
         retval=GOGN;
         goto exit;
      }

      if(world->MaxPage > 1)
      {
         if((world->sprite.x <= NPGX+NPGW-1) && (world->sprite.x >= NPGX) &&
            (world->sprite.y <= NPGY+NPGH-1) && (world->sprite.y >= NPGY) )
         {
            retval=NPGN;
            goto exit;
         }
      }

a1138 3
            /*D( kprintf("i=%ld, min=%ld, max=%ld, sprite.y=%ld\n",(LONG)i,
   		              (LONG)((i*GYSP)+GYS),(LONG)((i*GYSP)+GYS+GH),
   					  (LONG)world->sprite.y) );*/
d1145 1
a1145 1
               goto exit;
d1149 19
d1173 1
a1173 16
      }
      else
      {
          if((world->sprite.x <= FPCBGX+FPCBGW-1) && (world->sprite.x>=FPCBGX) &&
             (world->sprite.y <= FPCBGY+FPCBGH-1) && (world->sprite.y>=FPCBGY) )
          {
            retval=FPCBGN;
            goto exit;
          }
          if((world->sprite.x <= FPAOGX+FPAOGW-1) && (world->sprite.x>=FPAOGX) &&
             (world->sprite.y <= FPAOGY+FPAOGH-1) && (world->sprite.y>=FPAOGY) )
          {
             retval=FPAOGN;
             goto exit;
          }
          if (world->GfxEnabled)
d1175 2
a1176 2
             if((world->sprite.x<=FPGOGX+FPGOGW-1)&&(world->sprite.x>=FPGOGX) &&
                (world->sprite.y<=FPGOGY+FPGOGH-1)&&(world->sprite.y>=FPGOGY) )
d1178 2
a1179 2
                retval=FPGOGN;
                goto exit;
d1182 1
a1182 1
          if(world->MaxBootPage > 1)
d1184 1
a1184 6
             if((world->sprite.x<=FPNPGX+FPNPGW-1)&&(world->sprite.x>=FPNPGX) &&
                (world->sprite.y<=FPNPGY+FPNPGH-1)&&(world->sprite.y>=FPNPGY) )
             {
                retval=FPNPGN;
                goto exit;
             }
d1186 3
d1203 1
a1203 1
                   goto exit;
d1207 21
d1230 1
a1230 1
exit:
a1246 2
            RectFill(&world->display.rp,DAGX,DAGY,DAGX+DAGW-1,DAGY+DAGH-1);
            break;
a1247 2
            RectFill(&world->display.rp,GOGX,GOGY,GOGX+GOGW-1,GOGY+GOGH-1);
            break;
a1248 2
            RectFill(&world->display.rp,NPGX,NPGY,NPGX+NPGW-1,NPGY+NPGH-1);
            break;
a1249 3
            RectFill(&world->display.rp,FPCBGX,FPCBGY,FPCBGX+FPCBGW-1,
			                            FPCBGY+FPCBGH-1);
            break;
a1250 3
            RectFill(&world->display.rp,FPAOGX,FPAOGY,FPAOGX+FPAOGW-1,
			                            FPAOGY+FPAOGH-1);
            break;
a1251 3
            RectFill(&world->display.rp,FPNPGX,FPNPGY,FPNPGX+FPNPGW-1,
			                            FPNPGY+FPNPGH-1);
            break;
d1253 9
a1261 2
            RectFill(&world->display.rp,FPGOGX,FPGOGY,FPGOGX+FPGOGW-1,
			                            FPGOGY+FPGOGH-1);
d1375 20
@


37.1
log
@initial checkin
@
text
@d1 7
d39 3
a41 1
   BOOL					AdvancedMode; /* TRUE if advanvced options */
d209 1
a209 1
#define FPCBGX    151 
d222 1
a222 1
#define FPAOGX    FPCBGX+FPCBGW+10/*(((WIDTH-1-CBGW)>>1)+74)*/
d228 13
d248 1
a248 1
#define FPNPGX    FPAOGX+FPAOGW+10 
d418 1
a474 1
      SetAfPt(&world->display.rp,GhostPattern,1);
d531 4
a539 1
      SetAfPt(&world->display.rp,GhostPattern,1);
d545 4
d725 5
d802 3
d953 4
a956 3
   } else {
      if((world->sprite.x <= FPCBGX+FPCBGW-1) && (world->sprite.x>=FPCBGX) &&
         (world->sprite.y <= FPCBGY+FPCBGH-1) && (world->sprite.y>=FPCBGY) )
d958 2
a959 10
         retval=FPCBGN;
         goto exit;
      }
      if((world->sprite.x <= FPAOGX+FPAOGW-1) && (world->sprite.x>=FPAOGX) &&
         (world->sprite.y <= FPAOGY+FPAOGH-1) && (world->sprite.y>=FPAOGY) )
      {
         retval=FPAOGN;
         goto exit;
      }
      if(world->MaxBootPage > 1)
d961 4
a964 4
         if((world->sprite.x<=FPNPGX+FPNPGW-1)&&(world->sprite.x>=FPNPGX) &&
            (world->sprite.y<=FPNPGY+FPNPGH-1)&&(world->sprite.y>=FPNPGY) )
         {
            retval=FPNPGN;
d966 43
a1008 19
         }
      }
      if((world->sprite.x >= (FP0GX))&&(world->sprite.x <= (FP0GX+G1W-1)))
      {
         for(i=0;i<world->MaxGad;i++)
         {
            /*D( kprintf("i=%ld, min=%ld, max=%ld, sprite.y=%ld\n",(LONG)i,
   		              (LONG)((i*GYSP)+GYS),(LONG)((i*GYSP)+GYS+GH),
   					  (LONG)world->sprite.y) );*/
            if((world->sprite.y >= ((i * GYSP)+GYS)) &&
               (world->sprite.y <= ((i * GYSP)+GYS+GH-1)) )
            {
               mn=GetBootableNode(world,(SHORT)(world->FirstGad+i));
               if(((mn->Enabled  && mn->Bootable)||
			       (mn->NoEnable && mn->Bootable)))
                  retval=((SHORT)(i+1));
               goto exit;
            }
         }
d1047 4
@
