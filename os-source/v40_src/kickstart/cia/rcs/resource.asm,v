head     36.23;
branch   ;
access   ;
symbols  V39_1:36.23 V37_11:36.20 V37_8:36.19 V37_4:36.18 V37_3:36.17 V37_2:36.15 V37_1:36.14 V36_31:36.14 V36_29:36.13 V36_28:36.12 V36_14:36.11 V36_12:36.10 V36_11:36.10 V36_10:36.9 V36_9:36.8 V36_6:36.7 V36_5:36.6 V36_3:36.5 V36_2:36.1 V36_1:36.4 L33_22:33.2 L33_19:33.1 L33_15:1.3 L32_6:1.1 L32_5:1.1 L31_4:1.1 L1_3:1.1 L1_1:1.0;
locks    ; strict;
comment  @*	@;


36.23
date     92.03.10.14.36.08;  author mks;  state Exp;
branches ;
next     36.22;

36.22
date     91.11.05.17.46.23;  author darren;  state Exp;
branches ;
next     36.21;

36.21
date     91.11.04.09.48.34;  author darren;  state Exp;
branches ;
next     36.20;

36.20
date     91.04.17.17.50.41;  author darren;  state Exp;
branches ;
next     36.19;

36.19
date     91.04.05.15.01.10;  author darren;  state Exp;
branches ;
next     36.18;

36.18
date     91.03.15.12.01.48;  author darren;  state Exp;
branches ;
next     36.17;

36.17
date     91.03.14.17.17.26;  author darren;  state Exp;
branches ;
next     36.16;

36.16
date     91.02.12.15.08.12;  author rsbx;  state Exp;
branches ;
next     36.15;

36.15
date     91.01.26.09.23.45;  author rsbx;  state Exp;
branches ;
next     36.14;

36.14
date     90.07.31.10.59.44;  author rsbx;  state Exp;
branches ;
next     36.13;

36.13
date     90.06.01.12.31.16;  author rsbx;  state Exp;
branches ;
next     36.12;

36.12
date     90.05.16.13.38.38;  author rsbx;  state Exp;
branches ;
next     36.11;

36.11
date     90.05.11.23.49.47;  author rsbx;  state Exp;
branches ;
next     36.10;

36.10
date     90.04.01.19.32.42;  author rsbx;  state Exp;
branches ;
next     36.9;

36.9
date     90.03.19.14.09.13;  author rsbx;  state Exp;
branches ;
next     36.8;

36.8
date     90.03.15.14.36.31;  author rsbx;  state Exp;
branches ;
next     36.7;

36.7
date     90.03.09.12.08.58;  author rsbx;  state Exp;
branches ;
next     36.6;

36.6
date     89.11.16.15.43.22;  author rsbx;  state Exp;
branches ;
next     36.5;

36.5
date     89.11.16.15.07.10;  author rsbx;  state Exp;
branches ;
next     36.4;

36.4
date     89.08.09.14.58.41;  author rsbx;  state Exp;
branches ;
next     36.3;

36.3
date     89.08.09.14.54.54;  author rsbx;  state Exp;
branches ;
next     36.2;

36.2
date     89.08.09.14.52.44;  author rsbx;  state Exp;
branches ;
next     36.1;

36.1
date     89.08.08.22.46.00;  author rsbx;  state Exp;
branches ;
next     33.2;

33.2
date     86.03.29.19.06.46;  author neil;  state Exp;
branches ;
next     33.1;

33.1
date     86.03.25.20.01.00;  author neil;  state Exp;
branches ;
next     1.3;

1.3
date     86.02.10.13.15.57;  author kodiak;  state Exp;
branches ;
next     1.2;

1.2
date     85.01.29.11.23.45;  author kodiak;  state Exp;
branches ;
next     1.1;

1.1
date     85.10.10.17.22.32;  author carl;  state Exp;
branches ;
next     1.0;

1.0
date     85.08.28.15.19.41;  author carl;  state Exp;
branches ;
next     ;


desc
@CIA resource RCS source file.
@


36.23
log
@Changed the priority of the handler to 120.
Also cleaned out the change log.
@
text
@**********************************************************************
*                                                                    *
*   Copyright 1984-1992 Commodore Amiga Inc. All rights reserved.    *
*                                                                    *
**********************************************************************


**********************************************************************
*
* $Id$
*
* $Log$
**********************************************************************

	SECTION		cia

*------	Included Files -----------------------------------------------

	INCLUDE	'assembly.i'

	INCLUDE	'exec/types.i'
	INCLUDE	'exec/nodes.i'
	INCLUDE	'exec/lists.i'
	INCLUDE	'exec/ables.i'
	INCLUDE	'exec/memory.i'
	INCLUDE	'exec/interrupts.i'
	INCLUDE	'exec/libraries.i'
	INCLUDE	'exec/tasks.i'
	INCLUDE	'exec/execbase.i'

	INCLUDE	'hardware/cia.i'
	INCLUDE	'hardware/intbits.i'

	INCLUDE	'internal.i'

*------	Imported Globals ---------------------------------------------

	INT_ABLES

	EXTERN_DATA	_ciaa
	EXTERN_DATA	_ciab
	EXTERN_DATA	_intreq
	EXTERN_DATA	_intena
	EXTERN_DATA	_ciaaicr
	EXTERN_DATA	_ciabicr
	EXTERN_DATA	_ciabddra
	EXTERN_DATA	_ciabpra
	EXTERN_DATA	_custom

	EXTERN_DATA	CIAName
	EXTERN_DATA	CIAAName
	EXTERN_DATA	CIABName

*------	Imported Functions ------------------------------------------

	EXTERN_SYS	MakeLibrary
	EXTERN_SYS	AddResource
	EXTERN_SYS	FreeMem
	EXTERN_SYS	AddIntServer
	EXTERN_SYS	AllocMem
	EXTERN_SYS	OpenResource


*------	Exported ----------------------------------------------------

	XDEF	InitCode
	XDEF	EndMarker



*------ Bit Definitions (These need to be included from somewhere!!!)

CALLSYS	MACRO
	JSR	_LVO\1(A6)
	ENDM


*------ special macros:

CIA_DISABLE	MACRO	scratch,from
		move.l	\2,\1
		DISABLE	\1,NOFETCH
		ENDM


CIA_ENABLE	MACRO	scratch,from
		move.l	\2,\1
		ENABLE	\1,NOFETCH
		ENDM

SAVEREGS	MACRO
		movem.l	d0-d3/a0-a3/a6,-(sp)	;a3 used by timer.device
		ENDM

RESTREGS	MACRO
		movem.l	(sp)+,d0-d3/a0-a3/a6
		ENDM

*------ Assumptions -------------------------------------------

	IFNE	CIAICRB_TA
	FAIL	"CIAICRB_TA not 0 - recode"
	ENDC

	IFNE	CIAICRB_TB-1
	FAIL	"CIAICRB_TB not 1 - recode"
	ENDC

	IFNE	cs_TimerCode-cs_TimerBase-4
	FAIL	"cs_TimerCode does not follow cs_TimerBase - recode"
	ENDC

	IFNE	cs_CIAA-cs_CIAB-4
	FAIL	"cs_CIAA does not follow cs_CIAB - recode"
	ENDC

*------ Functions Offsets -------------------------------------

CIAFUN	MACRO
	DC.W	\1-initialFunctions
	ENDM


initialFunctions:
		DC.W	-1
		CIAFUN	AddICRVector
		CIAFUN	RemICRVector
		CIAFUN	AbleICR
		CIAFUN	SetICR
		DC.W	-1


*------ Initial Code ------------------------------------------
*
*
InitCode:
		MOVEM.L	A2/A3,-(SP)

;------ Allocate memory for shared data (assumed to succeed for such
;------ a small chunk of memory early on in the system - note that
;------ there has been no error checking for MakeLibrary() calls below.

		moveq	#cs_SIZEOF,d0
		move.l	#MEMF_PUBLIC!MEMF_CLEAR,d1
		CALLSYS	AllocMem
		move.l	d0,a3		;cache

	;------	make resource for _ciaa
		BSR	makeCIA

	;------ cache ptr to CIAABase

		move.l	a2,cs_CIAA(a3)

	;------ cache ptr to CIABBase, bit number, and index used by
	;------ the timer.device (MOVEM these always in order of
	;------ Dx-Dy/An where x > y - this guarantees that the
	;------ values are moved to/from memory in the same order)

		moveq	#CIAICRB_TA,d0
		moveq	#PREFSCOUNT,d1
		movem.l	d0-d1/a2,cs_TimerUsage(a3)
		bset	d0,CR_TimerAlloc(a2)


		MOVE.L	#_ciaa,CR_HWADDR(A2)
		move.l	a6,CR_EXECBASE(a2)

		;------	finish connecting the interrupt handler
		MOVE.W	#INTF_PORTS,CR_IntMask(A2)
		MOVE.L	#intrHandler2,IS_CODE(A1)
		MOVEQ	#INTB_PORTS,D0
		CALLSYS	AddIntServer

*****		MOVE.W	#(INTF_SETCLR+INTF_PORTS),_intena

		LEA	CIAAName(PC),A0
		BSR.S	addCIA


	;------	make resource for _ciab
		BSR.S	makeCIA

	;------ cache ptr to CIABBase

		move.l	a2,cs_CIAB(a3)

	;
	;
	;

		LEA	_ciab,A0
		MOVE.L	A0,CR_HWADDR(A2)
		move.l	a6,CR_EXECBASE(a2)

		MOVEQ	#$FFFFFF00!(CIAF_COMDTR!CIAF_COMRTS),D0
		OR.B	D0,ciaddra(A0)		; initialize serial stuff
		OR.B	D0,ciapra(A0)		;

		;------	finish connecting the interrupt handler
		MOVE.W	#INTF_EXTER,CR_IntMask(A2)
		MOVE.L	#intrHandler6,IS_CODE(A1)
		MOVEQ	#INTB_EXTER,D0
		CALLSYS	AddIntServer

*****		MOVE.W	#(INTF_SETCLR+INTF_EXTER),_intena

		LEA	CIABName(PC),A0
		BSR.s	addCIA

		MOVEM.L	(SP)+,A2/A3
		RTS

addCIA:
		MOVE.L	A0,LN_NAME(A1)		; put name in intr handler
		MOVE.L	A0,LN_NAME(A2)		;   and resource
		;------	tell system about resource:
		MOVE.L	A2,A1
		CALLSYS	AddResource
		RTS

makeCIA:
		LEA	initialFunctions(PC),A0
		SUB.L	A1,A1		* no initial data
		SUB.L	A2,A2		* no initializer
		move.l	#CR_SIZE,D0
		CALLSYS	MakeLibrary
		MOVE.L	D0,A2
		MOVE.B	#NT_RESOURCE,LN_TYPE(A2)
		CLR.B	LN_PRI(A2)

		;------	connect the interrupt handler
		LEA	CR_INTNODE(A2),A1
		MOVE.B	#NT_INTERRUPT,LN_TYPE(A1)
		move.b	#120,LN_PRI(A1)
		MOVE.L	A2,IS_DATA(A1)

		;------ Ptr to shared data
		move.l	a3,CR_SharedData(a2)

		RTS


*-----------------------------------------------------------------------
*
*	CIA Interrupt Handlers
*
*	CIA-A Level 2 interrupts
*
*-----------------------------------------------------------------------


intrHandler2:
		movem.l	d2/a2,-(sp)

		move.l	a1,a2				;cache

	;-- Loops back, and checks for new interrupts before
	;-- returning to exec (useful for parallel.device, and
	;-- other frequent level 2 interrupts)
	;

Dispatcher:

	;-- Check to see if the timer.device generated this
	;-- interrupt.  The bit will only be set if the timer
	;-- device is using CIAB, which sets this bit in CIAA.

		bclr	#TIMERINT,CR_TimerINT(a2)	;atomic test/clear
		beq.s	ctcheck_port			;only please!

		move.l	CR_SharedData(a2),a1
		MOVEM.L	cs_TimerBase(a1),A1/A5
		JSR	(A5)

ctcheck_port:


	;-- Set CPU interrupt mask to level 7 (NMI) - this is a faster
	;-- way to DISABLE (faster than hitting Paula's interrupt master
	;-- interrupt enable/disable bit), and gets rid of the spurious
	;-- interrupt problem.
	;
	;-- This trick works here because we KNOW we are in supervisor mode.

		move.w		SR,d0		; save SR
		ori.w		#$0700,SR	; Raise I0,I1,I2 to level 7

		move.b	_ciaaicr,d2

		BCLR	#7,D2			; never store upper bit

		OR.B	CR_IActive(A2),D2
		MOVE.B	D2,CR_IActive(A2)

		AND.B	CR_IEnable(A2),D2
		move.b	d2,CR_IProcessing(A2)	; for setICR
		BEQ.S	ct_done

		eor.b	d2,CR_IActive(a2)	; clear what we'll process

		move.w		d0,SR		; ENABLE

	;
	; Setup A6=Execbase.   While not necessarily documented as
	; having a ptr to execbase, we anticipate that many 1.3
	; programmers expected A6 to have execbase in it.  V36
	; and V37 timer.device EClock_Int traditionally has trashed
	; A6 (I plan on fixing that), but the point to note here is
	; that cia under V36/V37 loops back up, and checks for fresh
	; interrupts before going back to exec.
	;
	; The implication is that someone using TIMER A could be
	; hosed if an interrupt routine trashes A6, and cia
	; catches the TIMER A interrupt on the second pass.
	;
	; If you read page 310 of the RKM Libs & Devices, its
	; pretty easy to see why programmers got confused, and
	; they even would have worked under 1.3.  And if thats not
	; enough, A0 wasn't being used by the old 1.3 cia code either,
	; so programmers could have worked if they thought A0 contained
	; _custom.
	;

		move.l		CR_EXECBASE(a2),a6

	;
	; lea _custom,a0 here for 1.3 compatability
	;


		lea	_custom,a0

		;------	we will test each bit in turn.  LSR shifts bit zero
		;------	out into the carry bit.  if the carry is clear
		;------	then there is no int for this level

		;------	This code has been optimized for the case of
		;------	sparse interrupts.

		LSR.B	#1,D2
		BCS.S	ctdo_ta

ctcheck_tb:
		LSR.B	#1,D2
		BCS.S	ctdo_tb
		BEQ.S	Dispatcher

ctcheck_alrm:
		LSR.B	#1,D2
		BCS.S	ctdo_alrm
		BEQ.S	Dispatcher

ctcheck_sp:
		LSR.B	#1,D2
		BCS.S	ctdo_sp
		BEQ.S	Dispatcher

ctcheck_flg:
		LSR.B	#1,D2
		BCS.S	ctdo_flg
                BRA.s	Dispatcher

ct_done:
		move.w	d0,SR			; ENABLE
		movem.l	(sp)+,d2/a2
		moveq.l	#0,d0
		rts


ctdo_ta:
		;------	test timer A
		MOVEM.L	CR_IVTA(A2),A1/A5
		JSR	(A5)
		BRA.S	ctcheck_tb

ctdo_tb:
		;------	test timer B
		MOVEM.L	CR_IVTB(A2),A1/A5
		JSR	(A5)
		BRA.S	ctcheck_alrm

ctdo_alrm:
		;------	test Alarm
		MOVEM.L	CR_IVALRM(A2),A1/A5
		JSR	(A5)
		BRA.S	ctcheck_sp

ctdo_sp:
		;------	test serial
		MOVEM.L	CR_IVSP(A2),A1/A5
		JSR	(A5)
		BRA.S	ctcheck_flg

ctdo_flg:
		;------	test flag register
		MOVEM.L	CR_IVFLG(A2),A1/A5
		JSR	(A5)
		BRA	Dispatcher


*-----------------------------------------------------------------------
*
*	CIA Interrupt Handlers
*
*	CIA-A Level 6 interrupts
*
*-----------------------------------------------------------------------

intrHandler6:
		movem.l	d2/a2,-(sp)

	; Disable is implied here - we are already running at level 6.
	; Nothing short of an NMI can interrupt us here

		move.b	_ciabicr,d2

		BCLR	#7,D2			; never store upper bit

		OR.B	CR_IActive(A1),D2
		MOVE.B	D2,CR_IActive(A1)

		AND.B	CR_IEnable(A1),D2
		BEQ.S	ctb_none		; exit ASAP if nothing

		move.b	d2,CR_IProcessing(A1)	; for setICR

		move.l	a1,a2
		eor.b	d2,CR_IActive(a2)	; clear what we'll process

		LSR.B	#1,D2
		BCS.S	ctbdo_ta

ctbcheck_tb:
		LSR.B	#1,D2
		BCS.S	ctbdo_tb
		BEQ.S	ctb_done

ctbcheck_alrm:
		LSR.B	#1,D2
		BCS.S	ctbdo_alrm
		BEQ.S	ctb_done

ctbcheck_sp:
		LSR.B	#1,D2
		BCS.S	ctbdo_sp
		BEQ.S	ctb_done

ctbcheck_flg:
		LSR.B	#1,D2
		BCS.S	ctbdo_flg

ctb_done:
		clr.b	CR_IProcessing(a2)	; done processing
ctb_none:
		movem.l	(sp)+,d2/a2
		moveq.l	#0,d0
		rts


ctbdo_ta:
		;------	test timer A
		MOVEM.L	CR_IVTA(A2),A1/A5
		JSR	(A5)
		BRA.S	ctbcheck_tb

ctbdo_tb:
		;------	test timer B
		MOVEM.L	CR_IVTB(A2),A1/A5
		JSR	(A5)
		BRA.S	ctbcheck_alrm

ctbdo_alrm:
		;------	test Alarm
		MOVEM.L	CR_IVALRM(A2),A1/A5
		JSR	(A5)
		BRA.S	ctbcheck_sp

ctbdo_sp:
		;------	test serial
		MOVEM.L	CR_IVSP(A2),A1/A5
		JSR	(A5)
		BRA.S	ctbcheck_flg

ctbdo_flg:
		;------	test flag register
		MOVEM.L	CR_IVFLG(A2),A1/A5
		JSR	(A5)
		BRA.S	ctb_done


******* cia.resource/SetICR ******************************************
*
*   NAME
*	SetICR -- Cause, clear, and sample ICR interrupts.
*
*   SYNOPSIS
*	oldMask = SetICR( Resource, mask )
*	D0                A6        D0
*
*	WORD SetICR( struct Library *, WORD );
*
*   FUNCTION
*	This function provides a means of reseting, causing, and
*	sampling 8520 CIA interrupt control registers.
*
*   INPUTS
*	mask            A bit mask indicating which interrupts to be
*	                    effected. If bit 7 is clear the mask
*	                    indicates interrupts to be reset.  If bit
*	                    7 is set, the mask indicates interrupts to
*	                    be caused. Bit positions are identical to
*	                    those in 8520 ICR.
*
*   RESULTS
*	oldMask         The previous interrupt register status before
*	                    making the requested changes.  To sample
*	                    current status without making changes,
*	                    call the function with a null parameter.
*
*   EXAMPLES
*	Get the interrupt mask:
*	    mask = SetICR(0)
*	Clear serial port interrupt:
*	    SetICR(0x08)
*
*   NOTE
*	The CIA resources are special in that there is more than one
*	of them in the system. Because of this, the C language stubs
*	in amiga.lib for the CIA resources require an extra parameter
*	to specify which CIA resource to use. The synopsys for the
*	amiga.lib stubs is as follows:
*
*	oldMask = SetICR( Resource, mask )
*	D0                A6        D0
*
*	WORD SetICR( struct Library *, WORD );
*
*	***WARNING***
*
*	Never read the contents of the CIA interrupt control registers
*	directly.  Reading the contents of one of the CIA interrupt
*	control registers clears the register.  This can result in
*	interrupts being missed by critical operating system code, and
*	other applications.
*
*   EXCEPTIONS
*	Setting an interrupt bit for an enabled interrupt will cause
*	an immediate interrupt.
*
*   SEE ALSO
*	cia.resource/AbleICR()
*
**********************************************************************

SetICR:
		CIA_DISABLE	A0,CR_EXECBASE(a6)

		MOVE.L	CR_HWADDR(A6),A0
		MOVE.B	ciaicr(A0),D1
		BCLR	#7,D1
		OR.B	D1,CR_IActive(A6)
		CLEAR	D1
		MOVE.B	CR_IActive(a6),D1		; old value
		or.b	CR_IProcessing(a6),d1
		TST.B	D0
		BEQ.S	ICR_Common

; -------	reflect new setting in mirror register:
		BCLR	#7,D0
		BNE.S	sI_add

		NOT.B	D0
		AND.B	D0,CR_IActive(a6)
		and.b	d0,CR_IProcessing(a6)
		BRA.S	ICR_Common

sI_add:		OR.B	D0,CR_IActive(a6)

ICR_Common:
; -------	cause an interrupt if necessary:
		MOVE.B	CR_IEnable(A6),D0
		AND.B	CR_IActive(A6),D0
		BEQ.S	pi_noIntr

		MOVE.W	CR_IntMask(A6),D0
		OR.W	#INTF_SETCLR,D0
		MOVE.W	D0,_intreq

pi_noIntr:
		CIA_ENABLE	A0,CR_EXECBASE(a6)
		MOVE.L	D1,D0
		RTS

******* cia.resource/AbleICR *****************************************
*
*   NAME
*	AbleICR -- Enable/disable ICR interrupts.
*
*   SYNOPSIS
*	oldMask = AbleICR( Resource, mask )
*	D0                 A6        D0
*
*	WORD AbleICR( struct Library *, WORD );
*
*   FUNCTION
*	This function provides a means of enabling and disabling 8520
*	CIA interrupt control registers. In addition it returns the
*	previous enable mask.
*
*   INPUTS
*	mask            A bit mask indicating which interrupts to be
*	                    modified. If bit 7 is clear the mask
*	                    indicates interrupts to be disabled. If
*	                    bit 7 is set, the mask indicates
*	                    interrupts to be enabled. Bit positions
*	                    are identical to those in 8520 ICR.
*
*   RESULTS
*	oldMask         The previous enable mask before the requested
*	                    changes. To get the current mask without
*	                    making changes, call the function with a
*	                    null parameter.
*
*   EXAMPLES
*	Get the current mask:
*	    mask = AbleICR(0)
*	Enable both timer interrupts:
*	    AbleICR(0x83)
*	Disable serial port interrupt:
*	    AbleICR(0x08)
*
*   EXCEPTIONS
*	Enabling the mask for a pending interrupt will cause an
*	immediate processor interrupt (that is if everything else is
*	enabled). You may want to clear the pending interrupts with
*	SetICR() prior to enabling them.
*
*   NOTE
*	The CIA resources are special in that there is more than one
*	of them in the system. Because of this, the C language stubs
*	in amiga.lib for the CIA resources require an extra parameter
*	to specify which CIA resource to use. The synopsys for the
*	amiga.lib stubs is as follows:
*
*	oldMask = AbleICR( Resource, mask )
*	D0                 A6        D0
*
*	WORD AbleICR( struct Library *, WORD );
*
*   SEE ALSO
*	cia.resource/SetICR()
*
**********************************************************************

AbleICR:
		CIA_DISABLE	A0,CR_EXECBASE(a6)

		MOVE.L	CR_HWADDR(A6),A0
		MOVE.B	D0,ciaicr(A0)
		CLEAR	D1
		MOVE.B	CR_IEnable(a6),D1		; old value
		TST.B	D0
		BEQ.S	ICR_Common

; -------	reflect new setting in mirror register:
		BCLR	#7,D0
		BNE.S	aI_add

		NOT.B	D0
		AND.B	D0,CR_IEnable(a6)
		BRA.S	ICR_Common

aI_add:		OR.B	D0,CR_IEnable(a6)
		bra.s	ICR_Common

******* cia.resource/AddICRVector ************************************
*
*   NAME
*	AddICRVector -- attach an interrupt handler to a CIA bit.
*
*   SYNOPSIS
*	interrupt = AddICRVector( Resource, iCRBit, interrupt )
*	D0                        A6        D0      A1
*
*	struct Interrupt *AddICRVector( struct Library *, WORD,
*		struct Interrupt * );
*
*   FUNCTION
*	Assign interrupt processing code to a particular interrupt bit
*	of the CIA ICR.  If the interrupt bit has already been
*	assigned, this function will fail, and return a pointer to the
*	owner interrupt.  If it succeeds, a null is returned.
*
*	This function will also enable the CIA interrupt for the given
*	ICR bit.
*
*   INPUTS
*	iCRBit          Bit number to set (0..4).
*	interrupt       Pointer to interrupt structure.
*
*   RESULT
*	interrupt       Zero if successful, otherwise returns a
*	                    pointer to the current owner interrupt
*	                    structure.
*
*   NOTE
*	A processor interrupt may be generated immediatly if this call
*	is successful.
*
*	In general, it is probably best to only call this function
*	while DISABLED so that the resource to which the interrupt
*	handler is being attached may be set to a known state before
*	the handler is called. You MUST NOT change the state of the
*	resource before attaching your handler to it.
*
*	The CIA resources are special in that there is more than one
*	of them in the system. Because of this, the C language stubs
*	in amiga.lib for the CIA resources require an extra parameter
*	to specify which CIA resource to use. The synopsys for the
*	amiga.lib stubs is as follows:
*
*	interrupt = AddICRVector( Resource, iCRBit, interrupt )
*	D0                        A6        D0      A1
*
*	struct Interrupt *AddICRVector( struct Library *, WORD,
*		struct Interrupt *);
*
*	***WARNING***
*
*	Never assume that any of the CIA hardware is free for use.
*	Always use the AddICRVector() function to obtain ownership
*	of the CIA hardware registers your code will use.
*
*	Note that there are two (2) interval timers per CIA.  If
*	your application needs one of the interval timers, you
*	can try to obtain any one of the four (4) until AddICRVector()
*	succeeds.  If all four interval timers are in-use, your
*	application should exit cleanly.
*
*	If you just want ownership of a CIA hardware timer, or register,
*	but do not want interrupts generated, use the AddICRVector()
*	function to obtain ownership, and use the AbleICR() function
*	to turn off (or on) interrupts as needed.
*
*	Note that CIA-B generates level 6 interrupts (which can degrade
*	system performance by blocking lower priority interrupts).  As
*	usual, interrupt handling code should be optimized for speed.
*
*	Always call RemICRVector() when your code exits to release
*	ownership of any CIA hardware obtained with AddICRVector().
*
*   SEE ALSO
*	cia.resource/RemICRVector(), cia.resource/AbleICR()
*
**********************************************************************

AddICRVector:

		CLEAR	D1
		MOVE.B	D0,D1
		MULU	#IV_SIZE,D1

		CIA_DISABLE	A0,CR_EXECBASE(a6)

		LEA	CR_IVTA(A6,D1.W),A0
		MOVE.L	IV_NODE(A0),D1
		BNE.S	vi_error

	;-- come back to here if able to swap timer.device's
	;-- cia.  all registers had been saved, and restored
	;-- if we got back here.

AddICRAvailable:

		MOVE.L	A1,IV_NODE(A0)
		MOVE.L	IS_CODE(A1),IV_CODE(A0)
		MOVE.L	IS_DATA(A1),IV_DATA(A0)

	;-- track allocation of TA/TB bits

		BSET	D0,CR_Allocated(a6)

		MOVE.W	#$80,D1		* enable

		BSR.S	vi_able
vi_enable:
		CIA_ENABLE	A0,CR_EXECBASE(a6)
		RTS

vi_noalloc:
		MOVE.L	D1,D0
		BRA.S	vi_enable


;
;  1.) See if they want the CIA that the timer.device is using.
;      If not, we are done.
;
;  2.) Find a free timer; if none, we are done.
;
;  3.) If one is free, call-back timer hook, and give the requested
;      ICRVector to the caller.
;

vi_error:
		btst	d0,CR_TimerAlloc(a6)
		beq.s	vi_noalloc

		SAVEREGS
		bsr.s	FindFreeVec
		bne.s	vi_done
		bsr.s	CallTimer

		RESTREGS
		bra.s	AddICRAvailable


******* cia.resource/RemICRVector ************************************
*
*   NAME
*	RemICRVector -- Detach an interrupt handler from a CIA bit.
*
*   SYNOPSIS
*	RemICRVector( Resource, iCRBit, interrupt )
*	              A6        D0      A1
*
*	void RemICRVector( struct Library *, WORD, struct Interrupt *);
*
*   FUNCTION
*	Disconnect interrupt processing code for a particular
*	interrupt bit of the CIA ICR.
*
*	This function will also disable the CIA interrupt for the
*	given ICR bit.
*
*   INPUTS
*	iCRBit          Bit number to set (0..4).
*	interrupt       Pointer to interrupt structure.
*
*   RESULT
*
*   NOTE
*	The CIA resources are special in that there is more than one
*	of them in the system. Because of this, the C language stubs
*	in amiga.lib for the CIA resources require an extra parameter
*	to specify which CIA resource to use. The synopsys for the
*	amiga.lib stubs is as follows:
*
*	RemICRVector( Resource, iCRBit, interrupt )
*	              A6        D0      A1
*
*	void RemICRVector( struct Library *, WORD, struct Interrupt *);
*
*   SEE ALSO
*	cia.resource/AddICRVector()
*
**********************************************************************

RemICRVector:
		CIA_DISABLE	A0,CR_EXECBASE(a6)

;  1.) Free the interrupt vector passed in by the caller
;
;  2.) Check to see if there is now something free which the
;      timer.device could use (better than what the timer.device
;      has already).  An index number is used (3..0) to make
;      this determination.
;
;  3.) If so, free what the timer.device is using, and reassign it.
;
;  4.) Note that this is all done within DISABLE()/ENABLE()
;

		bsr.s	rm_icrvec

	;-- check to see if we can jump the timer

		SAVEREGS
		bsr.s	FindFreeVec
		movem.l	cs_TimerUsage(a1),d0-d1/a6

                cmp.b	d1,d3		; d1 (3..0) d3 (3..-1)
		ble.s	vi_done		;signed branch

		bsr.s	rm_icrvec	;release what timer.device has
		bsr.s	CallTimer	;and reassign timer.device

vi_done:
		RESTREGS
		bra.s	vi_noalloc

********************************************************************
**
** Clears interrupt node for bit/CIA specified in D0/a6
** Also marks interrupt bit as free.
**

rm_icrvec:
		CLEAR	D1
		MOVE.B	D0,D1

		MULU	#IV_SIZE,D1

		LEA	CR_IVTA(A6,D1.W),A0
		CLR.L	IV_NODE(A0)
		CLEAR	D1

	;-- Mark as free

		BCLR	D0,CR_Allocated(a6)

	;-- disable/enable ICR bit
vi_able:
		BSET	D0,D1
		MOVE.W	D1,D0
		BSR	AbleICR
		CLEAR	D0
		RTS


**********************************************************************
**
** Support routines used by jumpy timer.device/cia
**
*********************************************************************
**
**********************************************************************
**
** Find a free interrupt vector.
**
** Search count down timers on CIAA, and CIAB in order of:
**
**   3         2
** CIAA A -> CIAB B   CIAA A is checked twice - this was done
**         /          to make the code SMALLER.  It works out fine.
**        /
** CIAA A -> CIAB A   preference order is 3, 2, 0
**   1         0
**
**
** In:
** a6 -- ptr to either CIA Base
**
** Out:
** CC -- EQUAL if a free one found; NOT EQUAL otherwise
** a1 -- ptr to SharedData
** a2 -- ptr to CIABase with free interval timer
** a3 -- ptr to other CIABase
** d2 -- bit number of free interval timer (lower 3 bits)
** d3 -- index number (3..0 or -1)
**
**
** WARNING -
**
**	Becareful about changing this code (e.g., make sure you
**	understand what it returns, and how it works).  This
**	code tests the 3 possible interval timers that the
**	timer.device might use to find the next free one, and
**	tests them in a specific order.
**
**	Note that when this loop is done, we have the following info:
**
**	CC - EQUAL if a free interval timer was found.
**
**	a1 - pts to the shared data area which is used
**	     by both CIA's, and the timer.device to store
**	     shared data.
**
**	a2 - pts to the CIABase with the free interval timer.
**	     This is the interval timer that we MIGHT reassign
**	     the timer.device to use.
**
**	a3 - pts to the OTHER CIABase (there are two CIA libraries)
**	     This pointer MIGHT be used later if we reassign the
**	     the timer.device.
**
**	d2 - The bit number of the free interval timer.  This is
**	     the interval timer that we MIGHT reassign the
**	     timer.device to use.  Only the lower 3 bits are valid.
**
**	d3 - An index number (3, 2, 1, 0, -1) where the only
**	     valid numbers are 3, 2, and 0.  -1 means no free
**	     interval timer.  1 is impossible.
**
**	     The index number is used to compare the free
**	     timer found by this routine with the what the
**	     timer.device is already using.  If the index
**	     number returned by this routine is less than
**	     what the timer.device is already using, it means
**	     we don't need to reassign the timer.device.
**

FindFreeVec:
		move.l	CR_SharedData(a6),a1
		movem.l	cs_CIAB(a1),a2/a3	;a2==CIAB a3==CIAA
		moveq	#PREFSCOUNT,d3
		moveq	#%01000000,d2
	;
	; bit mask in d2 where only bits 0-2 are used for the BTST
	;
	; D3	CIA	D2 (bits 2-0)
	;
	; 3	CIAA	000		interval timer A
	; 2	CIAB	001		interval timer B
	; 1	CIAA	000		interval timer A again
	; 0	CIAB	000		interval timer A
	;
	;
	; note - an initial EXG, and LSR instruction is done BEFORE
	; the BTST.
	;

findfreevec:
		exg	a3,a2
		lsr.b	#3,d2
		btst	d2,CR_Allocated(a2)
		dbeq	d3,findfreevec
		rts

**********************************************************************
**
** Call timer hook - reassign timer.device to use a new count-down timer
**
** Caches ptr to CIABase, timer bit, and index which will be used
** by the timer.device.  Also mark which interval timer the timer.device
** is using in the CIA libraries.
**
** In:
**
** a1 -- ptr to SharedData
** a2 -- ptr to CIABase to use
** a3 -- ptr to other CIA Base
** d2 -- bit number (CIAICRB_TA or CIAICRB_TB) to use
** d3 -- index number (3..0)
**
CallTimer:
		and.b	#$01,d2
		movem.l	d2-d3/a2,cs_TimerUsage(a1)
		clr.b	CR_TimerAlloc(a3)
		clr.b	CR_TimerAlloc(a2)
		bset	d2,CR_TimerAlloc(a2)
		move.l	cs_TimerCall(a1),a0
		jmp	(a0)
EndMarker:


	END
@


36.22
log
@Autodoc change
@
text
@d3 1
a3 8
*   Copyright 1984,1985,1990 Commodore Amiga Inc. All rights reserved.  *
*   No part of this program may be reproduced, transmitted,          *
*   transcribed, stored in retrieval system, or translated into      *
*   any language or computer language, in any form or by any         *
*   means, electronic, mechanical, magnetic, optical, chemical,      *
*   manual or otherwise, without the prior written permission of     *
*   Commodore Amiga, Incorporated, 3350 Scott Blvd, Bld #7,          *
*   Santa Clara, CA 95054                                            *
d10 1
a10 1
*   Source Control:
d12 1
a12 120
*	$Id: resource.asm,v 36.23 91/11/05 17:40:56 darren Exp $
*
*	$Log:	resource.asm,v $
*	Revision 36.23  91/11/05  17:40:56  darren
*	Autodoc changes only.  Remove parenthesis from function names.
*	Apparently this was a preference of the previous module owner.
*	
*	Revision 36.22  91/11/04  09:35:19  darren
*	Autodoc changes only.  Identify library base in calling arguments
*	which was documented within the text.  This is needed because there are
*	two (2) cia bases, and both have the same functions - atypical for our
*	libraries/resources.
*	
*	Revision 36.21  91/10/23  09:43:47  darren
*	Move priority of servers back to 0.  ARGHHH!!! cia can miss interrupts
*	if someone calls SetICR() for any reason.  The source of the hardware
*	interrupt is cleared, and if another high priority server terminates
*	the chain, the cia generated interrupt can be missed.  Putting it back to
*	0 is at least no worse than 1.3, though it does not fix the problem
*	completely.
*	
*	Revision 36.20  91/04/17  17:50:41  darren
*	This is a test version of resource.asm which has a separate code
*	path for level 6, and level 2 interrupts - the goal being to speed up
*	processing of level 6 interrupts, and return to exec ASAP so that
*	other pending interrupts can be handled sooner.  So far the code
*	is performing flawlessly - this change is being considered for
*	inclusion in the 2.0 ROMS.
*	
*	Revision 36.19  91/04/05  15:01:10  darren
*	lea _custom,a0 for 1.3 compatability, and use A6 for Disable (execbase,
*	once again for compatability).
*	
*	Revision 36.18  91/03/15  12:01:48  darren
*	Warnings added to autodocs regarding use of CIA functions - how to
*	properly obtain ownership of CIA hardware, CIA-B generates level
*	6 interrupts, and never read the CIA interrupt control register
*	directly.
*	
*	Revision 36.17  91/03/14  17:17:26  darren
*	Major changes - some speed optimizations in the interrupt handler, and
*	more important, a new ability which works with the timer.device - if
*	someone AddICRVector()s the counter that timer.device is using, timer.device
*	may move to use a different counter.  When RemICRVector() is called,
*	timer.device can also jump back.
*	
*	Revision 36.16  91/02/12  15:08:12  rsbx
*	Autodoc changes.
*	
*	Revision 36.15  91/01/26  09:23:45  rsbx
*	Changed SYNOPSYS to SYNOPSIS.
*	
*	
*	Revision 36.14  90/07/31  10:59:44  rsbx
*	Autodoc changes.
*	
*	Revision 36.13  90/06/01  12:31:16  rsbx
*	Fixed .sfd fiction and lack of autodocs.
*	
*	Revision 36.12  90/05/16  13:38:38  rsbx
*	Changed to reflect that resource.asm in INCLUDEd by absolute.asm.
*	
*	Revision 36.11  90/05/11  23:49:47  rsbx
*	Changed ciabase.i to internal.i.
*	
*	Revision 36.10  90/04/01  19:32:42  rsbx
*	RCS version change
*	
*	Revision 36.9  90/03/19  14:09:13  rsbx
*	Changed SHORT to WORD in teh docs.
*	
*	Revision 36.8  90/03/15  14:36:31  rsbx
*	Changed DISABLE/ENABLE macros to hit location 4 less often.
*	
*	Revision 36.7  90/03/09  12:08:58  rsbx
*	Autodoc changes.
*	
*	Revision 36.6  89/11/16  15:43:22  rsbx
*	Change the cia interupt priority to -100 per Bryce's request.
*	
*	Revision 36.5  89/11/16  15:07:10  rsbx
*	No longer terminates interrupt chain.
*	
*	Revision 36.4  89/08/09  14:58:41  rsbx
*	*** empty log message ***
*	
*	Revision 36.3  89/08/09  14:54:54  rsbx
*	*** empty log message ***
*	
*	Revision 36.2  89/08/09  14:52:44  rsbx
*	checkin from correct place
*	
*	Revision 36.1  89/08/08  22:46:00  rsbx
*	Interrupt processing code will now check the CR_IActive bits
*	for any new interrupts to process before returning to exec.
*	SetICR now sets cia interrupts now being processed as pending
*	and will also maintain the CR_IProcessing field as needed.
*	
*	Revision 33.2  86/03/29  19:06:46  neil
*	more cia speedups.  Went from (microseconds before/after) 43/19 to
*	30/12.  I knew I could do something about this code...
*	
*	Revision 33.1  86/03/25  20:01:00  neil
*	deleted some ancient code that duplicated code in the interrupt
*	server chain.  This code had the effect of claiming all interrupts,
*	even when no cia interrupts were present.
*	
*	Revision 1.3  86/02/10  13:15:57  kodiak
*	shrink
*	
*	Revision 1.2  85/01/29  11:23:45  kodiak
*	fix autodoc headers
*	
*	Revision 1.1  85/10/10  17:22:32  carl
*	Setup of DTR and RTS defaults.
*	
*	Revision 1.0  85/08/28  15:19:41  carl
*	Placed under source control for Version 1.
*	
*
d128 2
a129 2
		CIAFUN	AbleICR 
		CIAFUN	SetICR 
d235 1
a235 2
	;;	move.b	#-100,LN_PRI(A1)
		clr.b	LN_PRI(A1)
d278 1
a278 1
 
d329 1
a329 1
	; 
d454 1
a454 1
		clr.b	CR_IProcessing(a2)	; done processing	
d781 1
a781 1
		
d799 1
a799 1
; 
d801 1
a801 1
; 
d804 1
a804 1
; 
d937 1
a937 1
**        / 
d979 1
a979 1
**	     the interval timer that we MIGHT reassign the 
d994 1
a994 1
FindFreeVec:	
d997 1
a997 1
		moveq	#PREFSCOUNT,d3			
d1037 1
a1037 1
CallTimer:	
@


36.21
log
@Autodoc changes; ack, V39 was copied from V37.  Official changes
made in V37, and then copied to V39 directory.
@
text
@d19 1
a19 1
*	$Id: resource.asm,v 36.22 91/11/04 09:35:19 darren Exp $
d22 4
d619 1
a619 1
******* cia.resource/SetICR() ****************************************
d722 1
a722 1
******* cia.resource/AbleICR() ***************************************
d804 1
a804 1
******* cia.resource/AddICRVector() **********************************
d946 1
a946 1
******* cia.resource/RemICRVector() **********************************
@


36.20
log
@This is a test version of resource.asm which has a separate code
path for level 6, and level 2 interrupts - the goal being to speed up
processing of level 6 interrupts, and return to exec ASAP so that
other pending interrupts can be handled sooner.  So far the code
is performing flawlessly - this change is being considered for
inclusion in the 2.0 ROMS.
@
text
@d19 1
a19 1
*	$Id: resource.asm,v 36.19 91/04/05 15:01:10 darren Exp Locker: darren $
d22 22
d357 2
a358 1
		move.b	#-100,LN_PRI(A1)
d621 2
a622 2
*	oldMask = SetICR( mask )
*	D0                D0
d624 1
a624 1
*	WORD SetICR( WORD );
d724 2
a725 2
*	oldMask = AbleICR( mask )
*	D0                 D0
d727 1
a727 1
*	WORD AbleICR( WORD );
d806 2
a807 2
*	interrupt = AddICRVector( iCRBit, interrupt )
*	D0                        D0      A1
d809 2
a810 1
*	struct Interrupt *AddICRVector( WORD, struct Interrupt *);
d948 2
a949 2
*	RemICRVector( iCRBit, interrupt )
*	              D0      A1
d951 1
a951 1
*	void RemICRVector( WORD, struct Interrupt *);
@


36.19
log
@lea _custom,a0 for 1.3 compatability, and use A6 for Disable (execbase,
once again for compatability).
@
text
@d19 1
a19 1
*	$Id: resource.asm,v 36.18 91/03/15 12:01:48 darren Exp Locker: darren $
d22 4
d348 2
d354 1
a354 3
		movem.l	d2/a2-a3,-(sp)
		move.l	#_ciaaicr,a3
		bra.s	intrDispatcher
d356 1
a356 3
intrHandler6:
		movem.l	d2/a2-a3,-(sp)
		move.l	#_ciabicr,a3
d358 4
a361 1
		;------	fall through
a362 5

intrDispatcher:

		MOVE.L	A1,A2				;cache

a367 3
	;-- Therefore its always CLR in CIAB (hence this code
	;-- falls through if we are handling a level 6 INT).
 
d378 5
d384 22
a405 1
	; Use A6 for DISABLE.  While not necessarily documented as
a423 2
 
		CIA_DISABLE	A6,CR_EXECBASE(a2)
d425 1
a425 4
		move.b	(a3),d2
		BCLR	#7,D2			; never store upper bit
		OR.B	CR_IActive(A2),D2
		MOVE.B	D2,CR_IActive(A2)
a426 8
		AND.B	CR_IEnable(A2),D2
		move.b	d2,CR_IProcessing(A2)	; for setICR
		BEQ.S	ct_done

		eor.b	d2,CR_IActive(a2)	; clear what we'll process

		ENABLE		a6,NOFETCH

d429 1
a429 1
	;
d431 1
d465 2
a466 2
		CIA_ENABLE	A1,CR_EXECBASE(a2)
		movem.l	(sp)+,d2/a2-a3
d501 89
@


36.18
log
@Warnings added to autodocs regarding use of CIA functions - how to
properly obtain ownership of CIA hardware, CIA-B generates level
6 interrupts, and never read the CIA interrupt control register
directly.
@
text
@d19 1
a19 1
*	$Id: resource.asm,v 36.17 91/03/14 17:17:26 darren Exp Locker: darren $
d22 6
d144 1
d360 1
d364 6
a369 5
		;-- Check to see if the timer.device generated this
		;-- interrupt.  The bit will only be set if the timer
		;-- device is using CIAB, which sets this bit in CIAA.
		;-- Therefore its always CLR in CIAB (hence this code
		;-- falls through if we are handling a level 6 INT).
d375 2
a376 2
		move.l	CR_SharedData(a2),a0
		MOVEM.L	cs_TimerBase(a0),A1/A5
d381 22
a402 1
		CIA_DISABLE	A0,CR_EXECBASE(a2)
d405 1
a405 1
		BCLR	#7,D2		; never store upper bit
a407 1
ct_loop_top:
d413 1
a413 1
		eor.b	d2,CR_IActive(a2)		; clear what we'll process
d415 1
a415 1
		CIA_ENABLE	A0,CR_EXECBASE(a2)
d417 3
d421 2
d454 1
a454 1
		CIA_ENABLE	A0,CR_EXECBASE(a2)
@


36.17
log
@Major changes - some speed optimizations in the interrupt handler, and
more important, a new ability which works with the timer.device - if
someone AddICRVector()s the counter that timer.device is using, timer.device
may move to use a different counter.  When RemICRVector() is called,
timer.device can also jump back.
@
text
@d19 1
a19 1
*	$Id: resource.asm,v 36.16 91/02/12 15:08:12 rsbx Exp Locker: darren $
d22 7
d505 8
d694 24
d719 1
a719 1
*	cia.resource/RemICRVector()
d923 3
a925 2
**	code tests the 4 possible interval timers to find
**	the next free one, and tests them in a specific order.
@


36.16
log
@Autodoc changes.
@
text
@d19 1
a19 1
*	$Id: resource.asm,v 36.15 91/01/26 09:23:45 rsbx Exp Locker: rsbx $
d22 3
d108 1
a118 1

d142 1
a142 1

d173 3
d177 22
d205 1
d219 1
a219 1
		MOVE.L	A2,-(SP)
d221 27
a247 2
;------	make resource for _ciaa
		BSR.S	makeCIA
d263 1
a263 1
;------	make resource for _ciab
d265 9
d293 1
a293 1
		MOVE.L	(SP)+,A2
d319 4
d333 5
a340 1
		bra.s	intrDispatcher
a341 3
intrHandler2:
		movem.l	d2/a2-a3,-(sp)
		move.l	#_ciaaicr,a3
d344 1
d346 21
a366 1
		CIA_DISABLE	A0,CR_EXECBASE(a1)
d369 2
a370 2
		OR.B	CR_IActive(A1),D2
		MOVE.B	D2,CR_IActive(A1)
d372 3
a374 2
		AND.B	CR_IEnable(A1),D2
		move.b	d2,CR_IProcessing(a1)	; for setICR
d377 1
a377 1
		eor.b	d2,CR_IActive(a1)		; clear what we'll process
d379 1
a379 1
		CIA_ENABLE	A0,CR_EXECBASE(a1)
a380 1
		MOVE.L	A1,A2
d395 1
a395 1
		BEQ.S	ct_loop_end
d400 1
a400 1
		BEQ.S	ct_loop_end
d405 1
a405 1
		BEQ.S	ct_loop_end
d410 1
a411 4
ct_loop_end:
		move.l	a2,a1
		bra.s	intrDispatcher

d413 1
a413 1
		CIA_ENABLE	A0,CR_EXECBASE(a1)
d447 1
a447 1
		BRA.S	ct_loop_end
d451 1
a451 1
******* cia.resource/AddICRVector() **********************************
d454 1
a454 1
*	AddICRVector -- attach an interrupt handler to a CIA bit.
d457 2
a458 2
*	interrupt = AddICRVector( iCRBit, interrupt )
*	D0                        D0      A1
d460 1
a460 1
*	struct Interrupt *AddICRVector( WORD, struct Interrupt *);
d463 2
a464 4
*	Assign interrupt processing code to a particular interrupt bit
*	of the CIA ICR.  If the interrupt bit has already been
*	assigned, this function will fail, and return a pointer to the
*	owner interrupt.  If it succeeds, a null is returned.
a465 3
*	This function will also enable the CIA interrupt for the given
*	ICR bit.
*
d467 6
a472 2
*	iCRBit          Bit number to set (0..4).
*	interrupt       Pointer to interrupt structure.
d474 5
a478 4
*   RESULT
*	interrupt       Zero if successful, otherwise returns a
*	                    pointer to the current owner interrupt
*	                    structure.
d480 6
a486 9
*	A processor interrupt may be generated immediatly if this call
*	is successful.
*
*	In general, it is probably best to only call this function
*	while DISABLED so that the resource to which the interrupt
*	handler is being attached may be set to a known state before
*	the handler is called. You MUST NOT change the state of the
*	resource before attaching your handler to it.
*
d493 2
a494 2
*	interrupt = AddICRVector( Resource, iCRBit, interrupt )
*	D0                        A6        D0      A1
d496 1
a496 2
*	struct Interrupt *AddICRVector( struct Library *, WORD,
*		struct Interrupt *);
d498 4
d503 1
a503 1
*	cia.resource/RemICRVector()
d507 1
a507 4
AddICRVector:
		CLEAR	D1
		MOVE.B	D0,D1
		MULU	#IV_SIZE,D1
a508 1
		LEA	CR_IVTA(A6,D1.W),A0
d510 9
a518 2
		MOVE.L	IV_NODE(A0),D1
		BNE.S	vi_error
d520 3
a522 3
		MOVE.L	A1,IV_NODE(A0)
		MOVE.L	IS_CODE(A1),IV_CODE(A0)
		MOVE.L	IS_DATA(A1),IV_DATA(A0)
d524 4
a527 9
		MOVE.W	#$80,D1		* enable
vi_able:
		BSET	D0,D1
		MOVE.W	D1,D0
		BSR.S	AbleICR
		CLEAR	D0
vi_enable:
		CIA_ENABLE	A0,CR_EXECBASE(a6)
		RTS
d529 1
a529 3
vi_error:
		MOVE.L	D1,D0
		BRA.S	vi_enable
d531 5
d537 3
a539 40
******* cia.resource/RemICRVector() **********************************
*
*   NAME
*	RemICRVector -- Detach an interrupt handler from a CIA bit.
*
*   SYNOPSIS
*	RemICRVector( iCRBit, interrupt )
*	              D0      A1
*
*	void RemICRVector( WORD, struct Interrupt *);
*
*   FUNCTION
*	Disconnect interrupt processing code for a particular
*	interrupt bit of the CIA ICR.
*
*	This function will also disable the CIA interrupt for the
*	given ICR bit.
*
*   INPUTS
*	iCRBit          Bit number to set (0..4).
*	interrupt       Pointer to interrupt structure.
*
*   RESULT
*
*   NOTE
*	The CIA resources are special in that there is more than one
*	of them in the system. Because of this, the C language stubs
*	in amiga.lib for the CIA resources require an extra parameter
*	to specify which CIA resource to use. The synopsys for the
*	amiga.lib stubs is as follows:
*
*	RemICRVector( Resource, iCRBit, interrupt )
*	              A6        D0      A1
*
*	void RemICRVector( struct Library *, WORD, struct Interrupt *);
*
*   SEE ALSO
*	cia.resource/AddICRVector()
*
**********************************************************************
d541 4
a544 9
RemICRVector:
		CLEAR	D1
		MOVE.B	D0,D1
		MULU	#IV_SIZE,D1
		CIA_DISABLE	A0,CR_EXECBASE(a6)
		LEA	CR_IVTA(A6,D1.W),A0
		CLR.L	IV_NODE(A0)
		CLEAR	D1
		BRA.S	vi_able
a545 1

d609 1
d628 1
a628 2

******* cia.resource/SetICR() ****************************************
d631 1
a631 1
*	SetICR -- Cause, clear, and sample ICR interrupts.
d634 2
a635 2
*	oldMask = SetICR( mask )
*	D0                D0
d637 1
a637 1
*	WORD SetICR( WORD );
d640 4
a643 2
*	This function provides a means of reseting, causing, and
*	sampling 8520 CIA interrupt control registers.
d645 3
d649 2
a650 6
*	mask            A bit mask indicating which interrupts to be
*	                    effected. If bit 7 is clear the mask
*	                    indicates interrupts to be reset.  If bit
*	                    7 is set, the mask indicates interrupts to
*	                    be caused. Bit positions are identical to
*	                    those in 8520 ICR.
d652 4
a655 5
*   RESULTS
*	oldMask         The previous interrupt register status before
*	                    making the requested changes.  To sample
*	                    current status without making changes,
*	                    call the function with a null parameter.
d657 3
a659 5
*   EXAMPLES
*	Get the interrupt mask:
*	    mask = SetICR(0)
*	Clear serial port interrupt:
*	    SetICR(0x08)
d661 6
a666 1
*   NOTE
d673 2
a674 2
*	oldMask = SetICR( Resource, mask )
*	D0                A6        D0
d676 2
a677 1
*	WORD SetICR( struct Library *, WORD );
a678 4
*   EXCEPTIONS
*	Setting an interrupt bit for an enabled interrupt will cause
*	an immediate interrupt.
*
d680 1
a680 1
*	cia.resource/AbleICR()
d684 2
a685 6
SetICR:
		CIA_DISABLE	A0,CR_EXECBASE(a6)
		MOVE.L	CR_HWADDR(A6),A0
		MOVE.B	ciaicr(A0),D1
		BCLR	#7,D1
		OR.B	D1,CR_IActive(A6)
d687 2
a688 4
		MOVE.B	CR_IActive(a6),D1		; old value
		or.b	CR_IProcessing(a6),d1
		TST.B	D0
		BEQ.S	ICR_Common
d690 1
a690 3
; -------	reflect new setting in mirror register:
		BCLR	#7,D0
		BNE.S	sI_add
d692 3
a694 4
		NOT.B	D0
		AND.B	D0,CR_IActive(a6)
		and.b	d0,CR_IProcessing(a6)
		BRA.S	ICR_Common
d696 3
a698 1
sI_add:		OR.B	D0,CR_IActive(a6)
d700 1
a700 5
ICR_Common:
; -------	cause an interrupt if necessary:
		MOVE.B	CR_IEnable(A6),D0
		AND.B	CR_IActive(A6),D0
		BEQ.S	pi_noIntr
d702 3
a704 3
		MOVE.W	CR_IntMask(A6),D0
		OR.W	#INTF_SETCLR,D0
		MOVE.W	D0,_intreq
d706 8
a713 1
pi_noIntr:
d715 3
d719 126
d847 124
a970 1
EndMarker
@


36.15
log
@Changed SYNOPSYS to SYNOPSIS.

@
text
@d19 1
a19 1
*	$Id: resource.asm,v 36.14 90/07/31 10:59:44 rsbx Exp Locker: rsbx $
d22 4
d365 1
a365 1
******* cia.resource/AddICRVector *************************************
d368 1
a368 1
*	AddICRVector -- attach an interrupt handler to a CIA bit
d377 4
a380 4
*	Assign interrupt processing code to a particular interrupt
*	bit of the CIA ICR.  If the interrupt bit has already been
*	assigned, this function will fail, and return a pointer
*	to the owner interrupt.  If it succeeds, a null is returned.
d386 2
a387 2
*	iCRBit - bit number to set (0..4)
*	interrupt - pointer to interrupt structure
d390 3
a392 2
*	interrupt - zero if successful, otherwise returns a pointer
*	            to the current owner interrupt structure.
d395 2
a396 2
*	A processor interrupt may be generated immediatly if this
*	call is successful.
d417 1
a417 1
*	RemICRVector
d419 1
a419 1
********************************************************************
d450 1
a450 1
******* cia.resource/RemICRVector *************************************
d453 1
a453 1
*	RemICRVector -- detach an interrupt handler from a CIA bit
d462 2
a463 2
*	Disconnect interrupt processing code for a particular interrupt
*	bit of the CIA ICR.
d465 2
a466 2
*	This function will also disable the CIA interrupt for the given
*	ICR bit.
d469 2
a470 2
*	iCRBit - bit number to set (0..4)
*	interrupt - pointer to interrupt structure
d487 1
a487 1
*	AddICRVector
d489 1
a489 1
********************************************************************
d502 1
a502 1
******* cia.resource/AbleICR ***************************************
d505 1
a505 1
*	AbleICR -- enable/disable ICR interrupts
d514 3
a516 3
*	This function provides a means of enabling and disabling
*	8520 CIA interrupt control registers.
*	In addition it returns the previous enable mask.
d519 6
a524 5
*	mask - a bit mask indicating which interrupts to be
*	    modified.  If bit 7 is clear the mask indicates
*	    interrupts to be disabled.  If bit 7 is set, the
*	    mask indicates interrupts to be enabled.
*	    Bit positions are identical to those in 8520 ICR.
d527 4
a530 3
*	oldMask - the previous enable mask before the requested
*	    changes.  To get the current mask without making
*	    changes, call the function with a null parameter.
d541 4
a544 4
*	Enabling the mask for a pending interrupt will cause
*	an immediate processor interrupt (that is if everything
*	else is enabled).  You may want to clear the pending
*	interrupts with SetICR prior to enabling them.
d559 1
a559 1
*	SetICR
d584 1
a584 1
******* cia.resource/SetICR ***************************************
d587 1
a587 1
*	SetICR -- cause, clear, and sample ICR interrupts
d600 6
a605 5
*	mask - a bit mask indicating which interrupts to be
*	    effected.  If bit 7 is clear the mask indicates
*	    interrupts to be reset.  If bit 7 is set, the
*	    mask indicates interrupts to be caused.
*	    Bit positions are identical to those in 8520 ICR.
d608 4
a611 4
*	oldMask - the previous interrupt register status before
*	    making the requested changes.  To sample current
*	    status without making changes,  call the function
*	    with a null parameter.
d636 1
a636 1
*	AbleICR
@


36.14
log
@Autodoc changes.
@
text
@d19 1
a19 1
*	$Id: resource.asm,v 36.13 90/06/01 12:31:16 rsbx Exp Locker: rsbx $
d22 3
d366 1
a366 1
*   SYNOPSYS
d450 1
a450 1
*   SYNOPSYS
@


36.13
log
@Fixed .sfd fiction and lack of autodocs.
@
text
@d19 1
a19 1
*	$Id: resource.asm,v 36.12 90/05/16 13:38:38 rsbx Exp Locker: rsbx $
d22 3
d396 12
d466 12
d536 12
d607 12
@


36.12
log
@Changed to reflect that resource.asm in INCLUDEd by absolute.asm.
@
text
@d19 1
a19 1
*	$Id: resource.asm,v 36.11 90/05/11 23:49:47 rsbx Exp Locker: rsbx $
d22 3
d89 2
d119 3
d488 1
a488 1
*	    Bit positions are identical to those in 6526 ICR.
d555 1
a555 1
*	    Bit positions are identical to those in 6526 ICR.
d617 3
@


36.11
log
@Changed ciabase.i to internal.i.
@
text
@a0 10

*          ************************************************
*          **                                            **
*          **     ----------------------------------     **
*          **     COMPLEX INTERFACE ADAPTER RESOURCE     **
*          **     ----------------------------------     **
*          **                                            **
*          ************************************************


d3 1
a3 1
*   Copyright 1984, 1985, Commodore Amiga Inc. All rights reserved.  *
d19 1
a19 1
*	$Id$
a20 2
*	$Locker: rsbx $
*
d22 3
a85 2
	INCLUDE	'assembly.i'

a113 3
	EXTERN_DATA	CIAName
	EXTERN_DATA	CIAAName
	EXTERN_DATA	CIABName
a114 1

d249 3
a251 4
		MOVEM.L	D2/A2,-(SP)
		CIA_DISABLE	A0,CR_EXECBASE(a1)
		MOVE.B	_ciabicr,D2
		BRA.S	intrDispatcher
d254 2
a255 3
		MOVEM.L	D2/A2,-(SP)
		CIA_DISABLE	A0,CR_EXECBASE(a1)
		MOVE.B	_ciaaicr,D2
d259 2
d306 1
a306 3
		CIA_DISABLE	a0,CR_EXECBASE(a1)
		move.b	CR_IActive(a1),d2
		bra.s	ct_loop_top
d310 1
a310 1
		MOVEM.L	(SP)+,D2/A2
d312 1
a312 1
		RTS
a608 2

		END
@


36.10
log
@RCS version change
@
text
@d29 1
a29 1
*	$Header: /usr/professor/rsbx/cia.resource/RCS/resource.asm,v 36.9 90/03/19 14:09:13 rsbx Exp Locker: rsbx $
d34 3
d109 1
a109 1
	INCLUDE	'ciabase.i'
@


36.9
log
@Changed SHORT to WORD in teh docs.
@
text
@d29 1
a29 1
*	$Header: resource.asm,v 36.8 90/03/15 14:36:31 rsbx Exp $
d34 3
@


36.8
log
@Changed DISABLE/ENABLE macros to hit location 4 less often.
@
text
@d29 1
a29 1
*	$Header: resource.asm,v 36.7 90/03/09 12:08:58 rsbx Exp $
d34 3
d367 1
a367 1
*	struct Interrupt *AddICRVector( SHORT, struct Interrupt *);
d439 1
a439 1
*	void RemICRVector( SHORT, struct Interrupt *);
d479 1
a479 1
*	SHORT AbleICR( SHORT );
d547 1
a547 1
*	SHORT SetICR( SHORT );
@


36.7
log
@Autodoc changes.
@
text
@d29 1
a29 1
*	$Header: resource.asm,v 36.6 89/11/16 15:43:22 rsbx Exp $
d34 3
d86 1
a86 1
    INCLUDE	'assembly.i'
d88 8
a95 8
    INCLUDE	'exec/types.i'
    INCLUDE	'exec/nodes.i'
    INCLUDE	'exec/lists.i'
    INCLUDE	'exec/ables.i'
    INCLUDE	'exec/interrupts.i'
    INCLUDE	'exec/libraries.i'
    INCLUDE	'exec/tasks.i'
    INCLUDE	'exec/execbase.i'
d97 2
a98 2
    INCLUDE	'hardware/cia.i'
    INCLUDE	'hardware/intbits.i'
d100 1
a100 1
    INCLUDE     'ciabase.i'
d105 1
a105 1
    INT_ABLES
d107 8
a114 8
    EXTERN_DATA	_ciaa
    EXTERN_DATA	_ciab
    EXTERN_DATA	_intreq
    EXTERN_DATA	_intena
    EXTERN_DATA	_ciaaicr
    EXTERN_DATA	_ciabicr
    EXTERN_DATA	_ciabddra
    EXTERN_DATA	_ciabpra
d116 3
a118 3
    EXTERN_DATA	CIAName
    EXTERN_DATA	CIAAName
    EXTERN_DATA	CIABName
d123 4
a126 4
    EXTERN_SYS  MakeLibrary
    EXTERN_SYS  AddResource
    EXTERN_SYS  FreeMem
    EXTERN_SYS  AddIntServer
d128 1
a128 1
    EXTERN_SYS	OpenResource
d133 2
a134 2
    XDEF	InitCode
    XDEF	EndMarker
d141 1
a141 1
		JSR	    _LVO\1(A6)
d145 14
d162 1
a162 1
		DC.W    \1-initialFunctions
d166 6
a171 6
		DC.W    -1
		CIAFUN  AddICRVector
		CIAFUN  RemICRVector
		CIAFUN  AbleICR 
		CIAFUN  SetICR 
		DC.W    -1
d178 1
a178 1
		MOVE.L  A2,-(SP)
d182 2
a183 1
		MOVE.L  #_ciaa,CR_HWADDR(A2)
d185 5
a189 5
		;------ finish connecting the interrupt handler
		MOVE.W  #INTF_PORTS,CR_IntMask(A2)
		MOVE.L  #intrHandler2,IS_CODE(A1)
		MOVEQ   #INTB_PORTS,D0
		CALLSYS AddIntServer
d191 1
a191 1
*****		MOVE.W  #(INTF_SETCLR+INTF_PORTS),_intena
d200 2
a201 1
		MOVE.L  A0,CR_HWADDR(A2)
d204 2
a205 2
		OR.B    D0,ciaddra(A0)		; initialize serial stuff
		OR.B    D0,ciapra(A0)		;
d207 5
a211 5
		;------ finish connecting the interrupt handler
		MOVE.W  #INTF_EXTER,CR_IntMask(A2)
		MOVE.L  #intrHandler6,IS_CODE(A1)
		MOVEQ   #INTB_EXTER,D0
		CALLSYS AddIntServer
d213 1
a213 1
*****		MOVE.W  #(INTF_SETCLR+INTF_EXTER),_intena
d216 1
a216 1
		BSR.S	addCIA
d218 1
a218 1
		MOVE.L  (SP)+,A2
d222 5
a226 5
		MOVE.L  A0,LN_NAME(A1)		; put name in intr handler
		MOVE.L  A0,LN_NAME(A2)		;   and resource
		;------ tell system about resource:
		MOVE.L  A2,A1
		CALLSYS AddResource
d230 8
a237 8
		LEA     initialFunctions(PC),A0
		SUB.L   A1,A1		* no initial data
		SUB.L   A2,A2		* no initializer
		MOVEQ.L #CR_SIZE,D0
		CALLSYS MakeLibrary
		MOVE.L  D0,A2
		MOVE.B  #NT_RESOURCE,LN_TYPE(A2)
		CLR.B   LN_PRI(A2)
d239 5
a243 5
		;------ connect the interrupt handler
		LEA     CR_INTNODE(A2),A1
		MOVE.B  #NT_INTERRUPT,LN_TYPE(A1)
		move.b  #-100,LN_PRI(A1)
		MOVE.L  A2,IS_DATA(A1)
d255 4
a258 4
	    MOVEM.L D2/A2,-(SP)
	    DISABLE A0
	    MOVE.B  _ciabicr,D2
	    BRA.S   intrDispatcher
d261 4
a264 4
	    MOVEM.L D2/A2,-(SP)
	    DISABLE A0
	    MOVE.B  _ciaaicr,D2
	    ;------ fall through
d267 3
a269 3
	    BCLR    #7,D2		; never store upper bit
	    OR.B    CR_IActive(A1),D2
	    MOVE.B  D2,CR_IActive(A1)
d271 3
a273 3
	    AND.B   CR_IEnable(A1),D2
	    move.b  d2,CR_IProcessing(a1)	; for setICR
	    BEQ.S   ct_done
d275 1
a275 1
	    eor.b   d2,CR_IActive(a1)		; clear what we'll process
d277 1
a277 1
	    ENABLE  A0
d279 1
a279 1
	    MOVE.L  A1,A2
d281 3
a283 3
	    ;------ we will test each bit in turn.  LSR shifts bit zero
	    ;------ out into the carry bit.  if the carry is clear
	    ;------ then there is no int for this level
d285 2
a286 2
	    ;------ This code has been optimized for the case of
	    ;------ sparse interrupts.
d288 2
a289 2
	    LSR.B   #1,D2
	    BCS.S   ctdo_ta
d292 3
a294 3
	    LSR.B   #1,D2
	    BCS.S   ctdo_tb
	    BEQ.S   ct_loop_end
d297 3
a299 3
	    LSR.B   #1,D2
	    BCS.S   ctdo_alrm
	    BEQ.S   ct_loop_end
d302 3
a304 3
	    LSR.B   #1,D2
	    BCS.S   ctdo_sp
	    BEQ.S   ct_loop_end
d307 2
a308 2
	    LSR.B   #1,D2
	    BCS.S   ctdo_flg
d311 4
a314 4
	    move.l  a2,a1
	    DISABLE a0
	    move.b  CR_IActive(a1),d2
	    bra.s   ct_loop_top
d317 4
a320 4
	    ENABLE  A0
	    MOVEM.L (SP)+,D2/A2
	    moveq.l #0,d0
	    RTS
d324 4
a327 4
	    ;------ test timer A
	    MOVEM.L CR_IVTA(A2),A1/A5
	    JSR     (A5)
	    BRA.S   ctcheck_tb
d330 4
a333 4
	    ;------ test timer B
	    MOVEM.L CR_IVTB(A2),A1/A5
	    JSR     (A5)
	    BRA.S   ctcheck_alrm
d336 4
a339 4
	    ;------ test Alarm
	    MOVEM.L CR_IVALRM(A2),A1/A5
	    JSR     (A5)
	    BRA.S   ctcheck_sp
d342 4
a345 4
	    ;------ test serial
	    MOVEM.L CR_IVSP(A2),A1/A5
	    JSR     (A5)
	    BRA.S   ctcheck_flg
d348 4
a351 4
	    ;------ test flag register
	    MOVEM.L CR_IVFLG(A2),A1/A5
	    JSR     (A5)
	    BRA.S   ct_loop_end
d383 10
d399 5
a403 5
	    CLEAR   D1
	    MOVE.B  D0,D1
	    MULU    #IV_SIZE,D1
	    DISABLE A0
	    LEA	    CR_IVTA(A6,D1.W),A0
d405 2
a406 2
	    MOVE.L  IV_NODE(A0),D1
	    BNE.S   vi_error
d408 3
a410 3
	    MOVE.L  A1,IV_NODE(A0)
	    MOVE.L  IS_CODE(A1),IV_CODE(A0)
	    MOVE.L  IS_DATA(A1),IV_DATA(A0)
d412 1
a412 1
	    MOVE.W  #$80,D1		* enable
d414 4
a417 4
	    BSET    D0,D1
	    MOVE.W  D1,D0
	    BSR.S   AbleICR
	    CLEAR   D0
d419 2
a420 2
	    ENABLE  A0
	    RTS
d423 2
a424 2
	    MOVE.L  D1,D0
	    BRA.S   vi_enable
d457 8
a464 8
	    CLEAR   D1
	    MOVE.B  D0,D1
	    MULU    #IV_SIZE,D1
	    DISABLE A0
	    LEA	    CR_IVTA(A6,D1.W),A0
	    CLR.L   IV_NODE(A0)
	    CLEAR   D1
	    BRA.S   vi_able
d507 1
a507 1
*	interrupts with SetICRx prior to enabling them.
d515 7
a521 7
            DISABLE A0
	    MOVE.L  CR_HWADDR(A6),A0
	    MOVE.B  D0,ciaicr(A0)
            CLEAR   D1
            MOVE.B  CR_IEnable(a6),D1		; old value
	    TST.B   D0
	    BEQ.S   ICR_Common
d523 3
a525 3
;           ------- reflect new setting in mirror register:
            BCLR    #7,D0
            BNE.S   aI_add
d527 3
a529 3
            NOT.B   D0
            AND.B   D0,CR_IEnable(a6)
            BRA.S   ICR_Common
d531 2
a532 2
aI_add:     OR.B    D0,CR_IEnable(a6)
	    bra.s   ICR_Common
d579 10
a588 10
            DISABLE A0
	    MOVE.L  CR_HWADDR(A6),A0
	    MOVE.B  ciaicr(A0),D1
	    BCLR    #7,D1
	    OR.B    D1,CR_IActive(A6)
            CLEAR   D1
            MOVE.B  CR_IActive(a6),D1		; old value
	    or.b    CR_IProcessing(a6),d1
	    TST.B   D0
	    BEQ.S   ICR_Common
d590 3
a592 3
;           ------- reflect new setting in mirror register:
            BCLR    #7,D0
            BNE.S   sI_add
d594 4
a597 4
            NOT.B   D0
            AND.B   D0,CR_IActive(a6)
	    and.b   d0,CR_IProcessing(a6)
            BRA.S   ICR_Common
d599 1
a599 1
sI_add:     OR.B    D0,CR_IActive(a6)
d602 4
a605 4
;           ------- cause an interrupt if necessary:
            MOVE.B  CR_IEnable(A6),D0
            AND.B   CR_IActive(A6),D0
            BEQ.S   pi_noIntr
d607 3
a609 3
	    MOVE.W  CR_IntMask(A6),D0
	    OR.W    #INTF_SETCLR,D0
            MOVE.W  D0,_intreq
d612 3
a614 3
            ENABLE  A0
	    MOVE.L  D1,D0
            RTS
d618 1
a618 1
    END
@


36.6
log
@Change the cia interupt priority to -100 per Bryce's request.
@
text
@d29 1
a29 1
*	$Header: resource.asm,v 36.5 89/11/16 15:07:10 rsbx Exp $
d34 3
d342 2
a343 2
*	interrupt = AddICRVector(iCRBit, interrupt), resource
*	D0	                 D0      A1          A6
d345 2
d362 1
a362 1
*		to the current owner interrupt structure.
d404 2
a405 2
*	RemICRVector(iCRBit, interrupt), resource
*	             D0      A1          A6
d407 2
d441 1
a441 1
*       AbleICR -- enable/disable ICR interrupts
d444 2
a445 2
*       oldMask = AbleICR(mask),  Resource
*       D0                D0      A6
d447 2
d450 3
a452 3
*       This function provides a means of enabling and disabling
*       6526 CIA interrupt control registers.
*       In addition it returns the previous enable mask.
d455 5
a459 5
*       mask - a bit mask indicating which interrupts to be
*           modified.  If bit 7 is clear the mask indicates
*           interrupts to be disabled.  If bit 7 is set, the
*           mask indicates interrupts to be enabled.
*           Bit positions are identical to those in 6526 ICR.
d462 3
a464 3
*       oldMask - the previous enable mask before the requested
*           changes.  To get the current mask without making
*           changes, call the function with a null parameter.
d467 6
a472 6
*       Get the current mask:
*           mask = AbleICR(0)
*       Enable both timer interrupts:
*           AbleICR(0x83)
*       Disable serial port interrupt:
*           AbleICR(0x08)
d475 4
a478 4
*       Enabling the mask for a pending interrupt will cause
*       an immediate processor interrupt (that is if everything
*       else is enabled).  You may want to clear the pending
*       interrupts with SetICRx prior to enabling them.
d481 1
a481 1
*       SetICR
d509 1
a509 1
*       SetICR -- cause, clear, and sample ICR interrupts
d512 2
a513 2
*       oldMask = SetICR(mask), Resource
*       D0               D0     A6
d515 2
d518 2
a519 2
*       This function provides a means of reseting, causing, and
*       sampling 6526 CIA interrupt control registers.
d522 5
a526 5
*       mask - a bit mask indicating which interrupts to be
*           effected.  If bit 7 is clear the mask indicates
*           interrupts to be reset.  If bit 7 is set, the
*           mask indicates interrupts to be caused.
*           Bit positions are identical to those in 6526 ICR.
d529 4
a532 4
*       oldMask - the previous interrupt register status before
*           making the requested changes.  To sample current
*           status without making changes,  call the function
*           with a null parameter.
d535 4
a538 4
*       Get the interrupt mask:
*           mask = SetICR(0)
*       Clear serial port interrupt:
*           SetICR(0x08)
d541 1
a541 1
*       Setting an interrupt bit for an enabled interrupt will cause
d545 1
a545 1
*       AbleICR
@


36.5
log
@No longer terminates interrupt chain.
@
text
@d29 1
a29 1
*	$Header: resource.asm,v 36.4 89/08/09 14:58:41 rsbx Exp $
d31 1
a31 1
*	$Locker:  $
d34 3
d220 1
a220 1
		CLR.B   LN_PRI(A1)
@


36.4
log
@*** empty log message ***
@
text
@d29 1
a29 1
*	$Header: /usr/commodore/amiga/V36/src/kickstart/cia/RCS/resource.asm,v 36.3 89/08/09 14:54:54 rsbx Exp $
d34 3
d294 1
@


36.3
log
@*** empty log message ***
@
text
@d29 1
a29 1
*	$Header: /usr/commodore/amiga/V36/src/kickstart/cia/RCS/resource.asm,v 36.2 89/08/09 14:52:44 rsbx Exp $
d34 3
@


36.2
log
@checkin from correct place
@
text
@d29 1
a29 1
*	$Header: /usr.MC68010/machines/professor/professor/rsbx/cia/RCS/resource.asm,v 36.1 89/08/08 22:46:00 rsbx Exp $
d34 3
@


36.1
log
@Interrupt processing code will now check the CR_IActive bits
for any new interrupts to process before returning to exec.
SetICR now sets cia interrupts now being processed as pending
and will also maintain the CR_IProcessing field as needed.
@
text
@d29 1
a29 1
*	$Header: resource.asm,v 33.2 86/03/29 19:06:46 neil Exp $
d34 6
@


33.2
log
@more cia speedups.  Went from (microseconds before/after) 43/19 to
30/12.  I knew I could do something about this code...
@
text
@d29 1
a29 1
*	$Header: resource.asm,v 33.1 86/03/25 20:01:00 neil Exp $
d31 1
a31 1
*	$Locker: neil $
d34 4
d216 1
d222 1
d227 1
a227 1
	    BCLR    #7,D2		* never store upper bit
d230 1
d232 1
d235 4
a238 1
	    ;------ unset pending interrupts
a239 1
	    EOR.B   D2,CR_IActive(A2)
d254 1
a254 1
	    BEQ.S   ct_done
d259 1
a259 1
	    BEQ.S   ct_done
d264 1
a264 1
	    BEQ.S   ct_done
d270 6
d277 1
d310 1
a310 1
	    BRA.S   ct_done
d461 4
a464 2
	    LEA	    CR_IEnable(A6),A1
            BRA.S   postICR
d466 3
d470 8
a524 9
	    LEA	    CR_IActive(A6),A1


*----------------------------------------------------------------
*
*
*----------------------------------------------------------------

postICR:
d526 2
a527 1
            MOVE.B  (A1),D1		* old value
d529 1
a529 1
	    BEQ.S   pi_eval
d531 1
a531 1
*           ------- reflect new setting in mirror register:
d533 2
a534 1
            BNE.S   pi_add
d536 3
a538 4
            AND.B   D0,(A1)
            BRA.S   pi_eval
pi_add:     OR.B    D0,(A1)
pi_eval:
d540 4
a543 1
*           ------- cause an interrupt if necessary:
d547 1
@


33.1
log
@deleted some ancient code that duplicated code in the interrupt
server chain.  This code had the effect of claiming all interrupts,
even when no cia interrupts were present.
@
text
@d29 1
a29 1
*	$Header: resource.asm,v 1.3 86/02/10 13:15:57 kodiak Exp $
d34 5
a208 7
intrHandler2:
	    MOVEM.L D2/A2,-(SP)
	    MOVE.B  _ciaaicr,D2
	    BSR.S   intrDispatcher
*****       MOVE.W  #INTF_PORTS,_intreq
	    MOVEM.L (SP)+,D2/A2
	    RTS
d213 1
a213 4
	    BSR.S   intrDispatcher
*****       MOVE.W  #INTF_EXTER,_intreq
	    MOVEM.L (SP)+,D2/A2
	    RTS
d215 4
d222 2
a223 2
	    OR.B    D2,CR_IActive(A1)
	    MOVE.B  CR_IActive(A1),D2
d227 1
d229 38
a266 7
	    BTST    #CIAICRB_SP,D2
	    BEQ.S   ct_tst1
	    MOVEM.L CR_IVSP(A2),A1/A5
	    JSR	    (A5)
ct_tst1:
	    BTST    #CIAICRB_TA,D2
	    BEQ.S   ct_tst2
d268 5
a272 4
	    JSR	    (A5)
ct_tst2:
	    BTST    #CIAICRB_TB,D2
	    BEQ.S   ct_tst3
d274 5
a278 9
	    JSR	    (A5)
ct_tst3:
	    BTST    #CIAICRB_FLG,D2
	    BEQ.S   ct_tst4
	    MOVEM.L CR_IVFLG(A2),A1/A5
	    JSR	    (A5)
ct_tst4:
	    BTST    #CIAICRB_ALRM,D2
	    BEQ.S   ct_clear
d280 2
a281 1
	    JSR	    (A5)
d283 5
a287 1
ct_clear:   EOR.B   D2,CR_IActive(A2)
d289 6
a294 2
ct_done:
	    RTS
@


1.3
log
@shrink
@
text
@d29 1
a29 1
*	$Header: resource.asm,v 1.2 85/01/29 11:23:45 kodiak Exp $
d31 1
a31 1
*	$Locker: kodiak $
d34 3
d143 1
a143 1
		MOVE.W  #(INTF_SETCLR+INTF_PORTS),_intena
d164 1
a164 1
		MOVE.W  #(INTF_SETCLR+INTF_EXTER),_intena
d208 1
a208 1
            MOVE.W  #INTF_PORTS,_intreq
d216 1
a216 1
            MOVE.W  #INTF_EXTER,_intreq
@


1.2
log
@fix autodoc headers
@
text
@d29 1
a29 1
*	$Header: resource.asm,v 1.1 85/10/10 17:22:32 carl Exp $
d34 3
d46 1
d104 3
a106 3
CALLSYS	    MACRO
	    JSR	    _LVO\1(A6)
	    ENDM
d111 3
a113 3
CIAFUN	    MACRO
	    DC.W    \1-initialFunctions
	    ENDM
d116 6
a121 6
	    DC.W    -1
	    CIAFUN  AddICRVector
	    CIAFUN  RemICRVector
	    CIAFUN  AbleICR 
	    CIAFUN  SetICR 
	    DC.W    -1
a125 1
*				!!! GARBAGE COLLECT THIS CODE !!!
d128 1
a128 1
            MOVE.L  A2,-(SP)
d130 3
a132 12
*	    ------- make resource for _ciaa
            LEA     initialFunctions(PC),A0
*	    MOVEQ.L #0,D1
	    SUB.L   A1,A1		* no initial data
            SUB.L   A2,A2		* no initializer
            MOVEQ.L #CR_SIZE,D0
            CALLSYS MakeLibrary
            MOVE.L  D0,A2
	    MOVE.B  #NT_RESOURCE,LN_TYPE(A2)
	    CLR.B   LN_PRI(A2)
	    MOVE.L  #CIAAName,LN_NAME(A2)
	    MOVE.L  #_ciaa,CR_HWADDR(A2)
d134 5
a138 10
*	    ------- connect their interrupt handler:
	    LEA     CR_INTNODE(A2),A1
	    MOVE.W  #INTF_PORTS,CR_IntMask(A2)
	    MOVE.L  #CIAAName,LN_NAME(A1)
	    MOVE.B  #NT_INTERRUPT,LN_TYPE(A1)
	    CLR.B   LN_PRI(A1)
	    MOVE.L  #intrHandler2,IS_CODE(A1)
	    MOVE.L  A2,IS_DATA(A1)
	    MOVEQ   #INTB_PORTS,D0
	    CALLSYS AddIntServer
d140 1
a140 1
            MOVE.W  #(INTF_SETCLR+INTF_PORTS),_intena
d142 2
a143 3
*	    ------- tell system about resource:
            MOVE.L  A2,A1
            CALLSYS AddResource
a144 14
*	    ------- make resource for _ciab
            LEA     initialFunctions(PC),A0
*	    MOVEQ.L #0,D1
	    SUB.L   A1,A1		* no initial data
            SUB.L   A2,A2		* no initializer
            MOVEQ.L #CR_SIZE,D0
            CALLSYS MakeLibrary
            MOVE.L  D0,A2
	    MOVE.B  #NT_RESOURCE,LN_TYPE(A2)
	    CLR.B   LN_PRI(A2)
	    MOVE.L  #CIABName,LN_NAME(A2)
	    MOVE.L  #_ciab,CR_HWADDR(A2)
	    OR.W    #(CIAF_COMDTR!CIAF_COMRTS),_ciabddra
	    OR.W    #(CIAF_COMDTR!CIAF_COMRTS),_ciabpra
d146 4
a149 10
*	    ------- connect their interrupt handler:
	    LEA     CR_INTNODE(A2),A1
	    MOVE.W  #INTF_EXTER,CR_IntMask(A2)
	    MOVE.L  #CIABName,LN_NAME(A1)
	    MOVE.B  #NT_INTERRUPT,LN_TYPE(A1)
	    CLR.B   LN_PRI(A1)
	    MOVE.L  #intrHandler6,IS_CODE(A1)
	    MOVE.L  A2,IS_DATA(A1)
	    MOVEQ   #INTB_EXTER,D0
	    CALLSYS AddIntServer
d151 3
a153 1
            MOVE.W  #(INTF_SETCLR+INTF_EXTER),_intena
d155 5
a159 3
*	    ------- tell system about resource:
            MOVE.L  A2,A1
            CALLSYS AddResource
d161 1
a161 2
            MOVE.L  (SP)+,A2
            RTS
d163 32
d203 1
a203 2
	    LEA	    _ciaaicr,A0
	    MOVE.L  A1,A2
d211 1
a211 2
	    LEA	    _ciabicr,A0
	    MOVE.L  A1,A2
a218 1
            MOVE.B  (A0),D2
d220 3
a222 3
	    OR.B    D2,CR_IActive(A2)
	    MOVE.B  CR_IActive(A2),D2
	    AND.B   CR_IEnable(A2),D2
d225 1
@


1.1
log
@Setup of DTR and RTS defaults.
@
text
@d29 1
a29 1
*	$Header: resource.asm,v 1.0 85/08/28 15:19:41 carl Exp $
d31 1
a31 1
*	$Locker: carl $
d34 3
d44 1
a44 1
******* Included Files ***********************************************
d63 1
a63 1
******* Imported Globals *********************************************
d81 1
a81 1
******* Imported Functions *******************************************
d91 1
a91 1
******* Exported ****************************************************
d256 1
a256 1
******* Resource/CIA/AddICRVector *************************************
d316 1
a316 1
******* Resource/CIA/RemICRVector *************************************
d354 1
a354 1
******* Resource/CIA/AbleICR ***************************************
d407 1
a407 1
******* Resource/CIA/SetICR ***************************************
@


1.0
log
@Placed under source control for Version 1.
@
text
@d29 1
a29 1
*	$Header: resource.asm,v 29.0 85/08/07 15:13:02 carl Exp $
d31 1
a31 1
*	$Locker:  $
d34 3
d70 2
d166 2
@
