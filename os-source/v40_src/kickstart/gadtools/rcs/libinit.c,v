head     38.1;
branch   ;
access   ;
symbols  ;
locks    vertex:38.1; strict;
comment  @ * @;


38.1
date     92.01.28.08.27.47;  author peter;  state Exp;
branches ;
next     38.0;

38.0
date     91.07.11.12.33.11;  author peter;  state Exp;
branches ;
next     ;


desc
@@


38.1
log
@No longer using magic library stuff.  File retired.
@
text
@/* libinit.c
 *
 * No longer using Lattice magic library stuff.
 * 
 * File retired 23-Jan-92 by Peter.
 *
 */
@


38.0
log
@ Initial V38 check-in (matches V37 release).
@
text
@d1 7
a7 196
/*** libinit.c ************************************************************
*
*   libinit.c	- Modified standard Lattice library init
*
*   Copyright 1989, 1990, Commodore-Amiga, Inc.
*
*   $Id: libinit.c,v 36.6 91/02/02 00:43:19 peter Exp $
*
*   $Log:	libinit.c,v $
*   Revision 36.6  91/02/02  00:43:19  peter
*   Spoofed declarations of LibClose, LibOpen, LibExpunge so that the
*   functions would get stack-style names (i.e. '_', not '@@').
*   
*   Revision 36.5  90/12/03  17:38:16  peter
*   Change declaration of VERSTRING to __far.  (Can't use near references
*   to globals in libinit.c).  Reference to it has to be &VERSTRING.
*   
*   Revision 36.4  90/11/19  12:55:00  peter
*   Now gets VERSTRING from libent.asm, instead of a second copy from _rev.h.
*   
*   Revision 36.3  90/05/18  18:30:47  peter
*   Put space immediately before '(' in prototypes to avoid confusing ctags.
*   
*   Revision 36.2  90/04/06  00:55:06  peter
*   Now uses our protos and pragmas.
*   
*   Revision 36.1  90/03/16  14:01:47  peter
*   RCS Clean up.
*   
*
**************************************************************************/

#include <exec/types.h>
#include <exec/nodes.h>
#include <exec/resident.h>
#include <exec/libraries.h>
#include <libraries/dos.h>

#include <clib/exec_protos.h>
#include <string.h>

/*  Since we can't reference any of our globals inside libinit.c,
    we have to use AbsExecBase for SysBase in this module: */

#define SysBase ((struct Library *) (*((ULONG *)4)))
#include <pragmas/exec_pragmas.h>

BOOL __asm __saveds
CustomLibInit (register __a6 struct Library *libbase);
void __saveds __asm
CustomLibExpunge (register __a6 struct Library *libbase);

/* Peter: Pull in the version file */
#include "gadtools_rev.h"

struct MyLibrary {
        struct       Library ml_Lib;
        ULONG        ml_SegList;
        ULONG        ml_Flags;
        APTR         ml_ExecBase;        /* pointer to exec base */
        LONG         ml_Data;                /* Global data */
        };

typedef LONG (*PFL)();   /* pointer to function returning 32-bit int        */

/* library initialization table, used for AUTOINIT libraries                */
struct InitTable {
        ULONG        *it_DataSize;        /* library data space size         */
        PFL          *it_FuncTable;      /* table of entry points           */
        APTR         it_DataInit;        /* table of data initializers      */
        PFL          it_InitFunc;        /* initialization function to run  */
};

extern PFL _LibFuncTab[];      /* my function table (Generated by Blink) */

extern char __far RESLEN;
extern long __far NEWDATAL; /* Generated by BLINK */
#define DATAWORDS ((long)&NEWDATAL)

ULONG __asm __stdargs _LibExpunge ( register __a6 struct MyLibrary *libbase );
ULONG __asm _LibInit ( register __a0 APTR seglist,
                                register __d0 struct MyLibrary *libbase );

struct InitTable __far _LibInitTab =  {
        (long *)(&RESLEN+sizeof(struct MyLibrary)),
        _LibFuncTab,
        NULL,                        /* will initialize my own data */
        _LibInit,
};
extern long far _Libmergeddata;    /* Need this to determine start of MERGED DATA */


/* This is defined by blink */
extern char __far _LibName[];
/* (Peter:  We supply VSTRING from _rev.i, via libent.asm/VERSTRING) */
extern STRPTR __far VERSTRING;

/* (Peter:  We supply REVISION from _rev.h) 
#define MYREVISION 0*/

__asm
ULONG _LibInit( register __a0 APTR seglist,
        register __d0 struct MyLibrary *libbase )
{
	long *sdata, *reloc;
	char *ddata;
	long nrelocs;
		
        libbase->ml_SegList = (ULONG) seglist;

        /* init. library structure (since I don't do automatic data init.) */
        libbase->ml_Lib.lib_Node.ln_Type = NT_LIBRARY;
        libbase->ml_Lib.lib_Node.ln_Name =  _LibName;
        libbase->ml_Lib.lib_Flags = LIBF_SUMUSED | LIBF_CHANGED;
        libbase->ml_Lib.lib_Version = VERSION;
        libbase->ml_Lib.lib_Revision = REVISION;
        libbase->ml_Lib.lib_IdString = (APTR) &VERSTRING;
	ddata = (char *)&libbase->ml_Data+4;   /* The +4 is a wasted long word,
						  where _Libmergeddata is. */

	sdata = (long *)&_Libmergeddata;
	memcpy(ddata, (char *)sdata, DATAWORDS*4);

	sdata = sdata + DATAWORDS;
	nrelocs = *sdata++;
	while (nrelocs > 0)
	{
		reloc = (long *)((long)ddata + *sdata++);
		*reloc += (long)ddata;
		nrelocs--;
	}

        /* ----- Do library specific public initialization here ----- */
	if (CustomLibInit((struct Library *)libbase))
	    return ( (ULONG) libbase );
	else
	    return ( NULL );
}

LONG __asm __stdargs
_LibOpen( register __a6 struct        MyLibrary *libbase )
{
        /* mark us as having another customer */
        libbase->ml_Lib.lib_OpenCnt++;

        /* clear delayed expunges (standard procedure)                */
        libbase->ml_Lib.lib_Flags &= ~LIBF_DELEXP;

	/* if (CustomLibOpen((struct Library *)libbase)) */
        return ( (LONG) libbase );
	/* else return(NULL) */
}

ULONG __asm __stdargs
_LibClose( register __a6 struct MyLibrary *libbase )
{
        ULONG retval = 0;

	/*  CustomLibClose((struct Library *)libbase); */
        if (( --libbase->ml_Lib.lib_OpenCnt == 0 ) &&
                        ( libbase->ml_Lib.lib_Flags & LIBF_DELEXP ))
        {
                /* no more people have me open,
                 * and I have a delayed expunge pending
                 */
                retval = _LibExpunge( libbase ); /* return segment list        */
        }

        return (retval);
}

ULONG __asm __stdargs
_LibExpunge( register __a6 struct MyLibrary *libbase )
{
        ULONG seglist = 0;
        LONG  libsize;

        libbase->ml_Lib.lib_Flags |= LIBF_DELEXP;
        if ( libbase->ml_Lib.lib_OpenCnt == 0 )
        {
		CustomLibExpunge((struct Library *)libbase);

                /* really expunge: remove libbase and freemem        */

                seglist = libbase->ml_SegList;

                Remove( (struct Node *) libbase);

                libsize = libbase->ml_Lib.lib_NegSize + libbase->ml_Lib.lib_PosSize;
                FreeMem( (char *) libbase - libbase->ml_Lib.lib_NegSize,(LONG) libsize );
        }

        /* return NULL or real seglist                                */
        return ( (ULONG) seglist );
}

@
