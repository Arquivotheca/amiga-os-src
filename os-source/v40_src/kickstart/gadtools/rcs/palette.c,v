head     39.14;
branch   ;
access   ;
symbols  ;
locks    ; strict;
comment  @ * @;


39.14
date     92.10.16.18.22.38;  author vertex;  state Exp;
branches ;
next     39.13;

39.13
date     92.07.24.10.28.42;  author vertex;  state Exp;
branches ;
next     39.12;

39.12
date     92.07.16.10.55.27;  author vertex;  state Exp;
branches ;
next     39.11;

39.11
date     92.06.16.13.48.10;  author vertex;  state Exp;
branches ;
next     39.10;

39.10
date     92.05.29.15.42.36;  author vertex;  state Exp;
branches ;
next     39.9;

39.9
date     92.04.15.11.35.43;  author vertex;  state Exp;
branches ;
next     39.8;

39.8
date     92.04.13.14.10.00;  author vertex;  state Exp;
branches ;
next     39.7;

39.7
date     92.04.07.13.55.00;  author vertex;  state Exp;
branches ;
next     39.6;

39.6
date     92.03.26.15.16.45;  author peter;  state Exp;
branches ;
next     39.5;

39.5
date     92.03.25.14.38.17;  author peter;  state Exp;
branches ;
next     39.4;

39.4
date     92.03.24.15.15.36;  author peter;  state Exp;
branches ;
next     39.3;

39.3
date     92.02.20.11.50.47;  author peter;  state Exp;
branches ;
next     39.2;

39.2
date     92.02.03.15.49.31;  author peter;  state Exp;
branches ;
next     39.1;

39.1
date     92.01.30.19.54.20;  author peter;  state Exp;
branches ;
next     38.4;

38.4
date     92.01.30.18.09.31;  author peter;  state Exp;
branches ;
next     38.3;

38.3
date     92.01.28.08.28.24;  author peter;  state Exp;
branches ;
next     38.2;

38.2
date     91.11.27.13.17.46;  author peter;  state Exp;
branches ;
next     38.1;

38.1
date     91.09.24.18.11.23;  author peter;  state Exp;
branches ;
next     38.0;

38.0
date     91.07.11.12.32.55;  author peter;  state Exp;
branches ;
next     ;


desc
@@


39.14
log
@Changes for SAS/C 6.0
@
text
@/*** palette.c ************************************************************
*
*   palette.c	- Palette gadget routines
*
*   Copyright 1989, 1990, Commodore-Amiga, Inc.
*
*   $Id: palette.c,v 39.13 92/07/24 10:28:42 vertex Exp Locker: vertex $
*
**************************************************************************/

/*------------------------------------------------------------------------*/

#include "gtinclude.h"

/*------------------------------------------------------------------------*/

/* Function Prototypes: */

/* Internal: */
struct ExtGadget *CreatePaletteA (struct ExtGadget *gad, struct NewGadget *ng,
    struct TagItem *taglist);
BOOL HandlePalette (struct ExtGadget *gad, struct IntuiMessage *imsg);
void SetPaletteAttrsA (struct ExtGadget *gad, struct Window *win,
    struct TagItem *taglist);


#define MINCOLORWIDTH  4
#define MINCOLORHEIGHT 3
/*
#define abs(x) (((x)<0)? -(x): (x))
*/

/*****************************************************************************/


static UWORD GetColorIndex(struct ExtGadget *gad, UWORD boxNum)
{
    if (PAID(gad)->paid_ColorTable)
        return((UWORD)PAID(gad)->paid_ColorTable[boxNum]);

    return((UWORD)(boxNum + PAID(gad)->paid_ColorOffset));
}


/*****************************************************************************/


static UWORD GetBoxNum(struct ExtGadget *gad, UWORD colorIndex)
{
UWORD result;

    if (PAID(gad)->paid_ColorTable)
    {
        result = 0;
        while (PAID(gad)->paid_ColorTable[result] != colorIndex)
            result++;
        return(result);
    }

    return((UWORD)(colorIndex - PAID(gad)->paid_ColorOffset));
}


/*****************************************************************************/


/* Determine which color-box the mouse is over.  Returns the color
 * number
 */
static ULONG WhichBoxNum(struct ExtGadget *gad, struct gpInput *msg)
{
WORD x;
WORD y;

    if ((x = msg->gpi_Mouse.X - 3) < 0)
        x = 0;

    if (x > gad->Width - 6)
        x = gad->Width - 6;

    if ((y = msg->gpi_Mouse.Y - 2) < 0)
        y = 0;

    if (y > gad->Height - 4)
        y = gad->Height - 4;

    return((ULONG)( (x / PAID(gad)->paid_EachWidth) + PAID(gad)->paid_XCount
             * (y / PAID(gad)->paid_EachHeight)));
}


/*****************************************************************************/


static VOID SelectBox(struct RastPort *rp, struct ExtGadget *gad, UWORD boxNum,
                      BOOL selected, BOOL drawSquare)
{
UWORD         x0,y0,x1,y1,w,h;
struct Image *bevelImage;

    if (boxNum == ~0)
        return;

    w  = PAID(gad)->paid_EachWidth;
    h  = PAID(gad)->paid_EachHeight;
    x0 = gad->LeftEdge + w * (boxNum % PAID(gad)->paid_XCount) + 2;
    y0 = gad->TopEdge + h * (boxNum / PAID(gad)->paid_XCount) + 1;
    x1 = x0 + w;
    y1 = y0 + h;

    if (selected)
    {
        PAID(gad)->paid_SelectedBox = boxNum;
        if (bevelImage = getBevelImage(0,0,w+1,h+1,FRAME_BUTTON))
        {
            DrawImageState(rp,bevelImage,x0,y0,IDS_SELECTED,PAID(gad)->paid_DrawInfo);
            DisposeObject(bevelImage);
        }

        if ((x1 - x0 > MINCOLORWIDTH+6) && (y1 - y0 > MINCOLORHEIGHT+4))
        {
            EraseRect(rp,x0+2,y0+1,x1-2,y0+1);
            EraseRect(rp,x0+2,y0+1,x0+2,y1-1);
            EraseRect(rp,x1-2,y0+1,x1-2,y1-1);
            EraseRect(rp,x0+2,y1-1,x1-2,y1-1);
        }
    }
    else
    {
        EraseRect(rp,x0,y0,x1,y0);
        EraseRect(rp,x0,y0,x0+1,y1);
        EraseRect(rp,x1-1,y0,x1,y1);
        EraseRect(rp,x0,y1,x1,y1);
        drawSquare = TRUE;
    }

    if (drawSquare)
    {
        setAPen(rp,GetColorIndex(gad,boxNum));
        RectFill(rp, x0+2, y0+1, x1-2, y1-1);
    }
}


/*****************************************************************************/


static VOID RenderPalette(struct RastPort *rp, struct ExtGadget *gad)
{
WORD count;
WORD selected;

    DrawImageState(rp,gad->GadgetRender,gad->LeftEdge,gad->TopEdge,IDS_NORMAL,PAID(gad)->paid_DrawInfo);
    PrintIText(rp,gad->GadgetText,gad->LeftEdge,gad->TopEdge);

    selected = -1;
    if (PAID(gad)->paid_Indicator)
        selected = GetBoxNum(gad,PAID(gad)->paid_Color);

    for (count = 0; count < PAID(gad)->paid_Count; count++)
        SelectBox(rp,gad,count,FALSE,TRUE);
    SelectBox(rp,gad,selected,TRUE,FALSE);

    if (gad->Flags & GADGDISABLED)
        Ghost(rp,PAID(gad)->paid_DrawInfo->dri_Pens[BLOCKPEN],
              gad->LeftEdge,
              gad->TopEdge,
              gad->LeftEdge+gad->Width-1,
              gad->TopEdge+gad->Height-1);
}


/*****************************************************************************/


static ULONG HandlePaletteInput(struct ExtGadget *gad, struct gpInput *msg)
{
ULONG              newBox, oldBox;
struct RastPort   *rp;
struct InputEvent *ie = msg->gpi_IEvent;
ULONG              result = GMR_MEACTIVE;
UWORD              icode;

    if (ie->ie_Class == IECLASS_RAWMOUSE)
    {
        icode = ie->ie_Code;

	oldBox = PAID(gad)->paid_SelectedBox;
        newBox = WhichBoxNum(gad,msg);

	if (!PAID(gad)->paid_Indicator && (icode == ( IECODE_LBUTTON | IECODE_UP_PREFIX)))
            newBox = ~0;

        if (icode == IECODE_RBUTTON)
            newBox = PAID(gad)->paid_BoxBackup;

	if (newBox != oldBox)
	{
	    if (rp = ObtainGIRPort(msg->gpi_GInfo))
	    {
                if (newBox != ~0)
                    PAID(gad)->paid_Color = GetColorIndex(gad,newBox);

                SelectBox(rp,gad,oldBox,FALSE,FALSE);
                SelectBox(rp,gad,newBox,TRUE,FALSE);

                PAID(gad)->paid_SelectedBox = newBox;

                ReleaseGIRPort(rp);
            }
	}

	if (icode == ( IECODE_LBUTTON | IECODE_UP_PREFIX))
	    result = GMR_NOREUSE | GMR_VERIFY;

        if (icode == IECODE_RBUTTON)
            result = GMR_NOREUSE;
    }

    return(result);
}


/*****************************************************************************/


ULONG ASM DispatchPalette(REG(a0) struct Hook *hook,
                          REG(a2) struct ExtGadget *gad,
                          REG(a1) ULONG *msg)
{
ULONG result;

    switch (*msg)
    {
        case GM_HELPTEST   : result = GMR_HELPHIT;
                             break;

	case GM_HITTEST    : result = GMR_GADGETHIT;
                             break;

	case GM_GOACTIVE   : PAID(gad)->paid_BoxBackup = PAID(gad)->paid_SelectedBox;
	case GM_HANDLEINPUT: result = HandlePaletteInput(gad,(struct gpInput *)msg);
                             break;

	case GM_RENDER     : RenderPalette(((struct gpRender *)msg)->gpr_RPort,gad);

        default            : result = 0;
                             break;
    }

    return(result);
}


/*****************************************************************************/


struct ExtGadget *CreatePaletteA(struct ExtGadget *gad, struct NewGadget *ng,
                                 struct TagItem *taglist)
{
struct NewGadget   mod_ng;
LONG               colorWidth, colorHeight;
UWORD              depth  = getGTTagData(GTPA_Depth, 1, taglist);
UWORD              colors = getGTTagData(GTPA_NumColors, 1 << depth, taglist);
UWORD              indicatorwidth = getGTTagData(GTPA_IndicatorWidth, 0, taglist);
UWORD              columns, rows;
UWORD              bestcolumns, bestrows;
UWORD              availWidth, availHeight;
UWORD              divisor;
LONG               ratio;
LONG               bestratio;
ULONG              resX, resY;
struct DrawInfo   *di;

    di          = VI(ng->ng_VisualInfo)->vi_DrawInfo;
    resX        = di->dri_Resolution.X * 256;
    resY        = di->dri_Resolution.Y;
    availWidth  = ng->ng_Width - 5;
    availHeight = ng->ng_Height - 3;
    bestrows    = 0;
    bestcolumns = 0;
    bestratio   = 0x00800000;      /* a big positive number... */

    while (colors > 0)
    {
        divisor = 1;
        do
        {
            if (colors % divisor == 0)
            {
                columns = colors / divisor;
                rows    = divisor;

                colorWidth  = availWidth / columns - 3;
                colorHeight = availHeight / rows - 1;
                if ((colorWidth >= MINCOLORWIDTH) && (colorHeight >= MINCOLORHEIGHT))
                {
                    ratio = (colorWidth*resX) / (colorHeight*resY);
                    if (abs(256-ratio) < abs(256-bestratio))
                    {
                        /* if aspect ratio better than current best */
                        bestcolumns = columns;
                        bestrows    = rows;
                        bestratio   = ratio;
                    }
                }
            }

            divisor++;
        }
        while (divisor <= colors);

        if (bestcolumns > 0)
            break;

        colors--;
    }

    if (bestcolumns <= 0)
        return(NULL);

    colorWidth  = availWidth / bestcolumns;
    colorHeight = availHeight / bestrows;

    mod_ng           = *ng;
    mod_ng.ng_Width  = colorWidth * bestcolumns + 5;
    mod_ng.ng_Height = colorHeight * bestrows + 3;

    if (gad = CreateGenericBase(gad, &mod_ng, PALETTE_IDATA_SIZE, taglist))
    {
        gad->Flags        |= GADGIMAGE | GADGHNONE;
        gad->Activation    = GADGIMMEDIATE | RELVERIFY;
        gad->GadgetType   |= CUSTOMGADGET;
        gad->MutualExclude = (ULONG)&GadToolsBase->gtb_PaletteGHook;

        placeGadgetText(gad, ng->ng_Flags, indicatorwidth ? PLACETEXT_LEFT : PLACETEXT_ABOVE,NULL);

        SGAD(gad)->sg_SetAttrs     = SetPaletteAttrsA;
        SGAD(gad)->sg_GetTable     = Palette_GetTable;
        SGAD(gad)->sg_EventHandler = HandlePalette;
        SGAD(gad)->sg_Flags        = SG_EXTRAFREE_DISPOSE;

        if (!(gad->GadgetRender = getBevelImage(0,0,gad->Width,gad->Height,FRAME_BUTTON)))
            return(NULL);

        PAID(gad)->paid_XCount      = bestcolumns;
        PAID(gad)->paid_EachWidth   = colorWidth;
        PAID(gad)->paid_EachHeight  = colorHeight;
        PAID(gad)->paid_Count       = bestcolumns * bestrows;
        PAID(gad)->paid_Color       = 1;
        PAID(gad)->paid_DrawInfo    = di;
        PAID(gad)->paid_SelectedBox = (UWORD)~0;

        if (indicatorwidth || findGTTagItem(GTPA_IndicatorHeight,taglist))
            PAID(gad)->paid_Indicator = TRUE;

        SetPaletteAttrsA(gad,NULL,taglist);
    }

    return(gad);
}


/*****************************************************************************/


VOID SetPaletteAttrsA(struct ExtGadget *gad, struct Window *win,
                      struct TagItem *taglist)
{
struct RastPort  crp;
struct TagItem  *tag;
BOOL             render;
BOOL             active;
ULONG            lock;
UWORD            i;
UWORD            newBox, oldBox;

    render = FALSE;

    lock = LockIBase(0);

    if (tag = findGTTagItem(GTPA_ColorTable,taglist))
    {
        PAID(gad)->paid_ColorTable = (UBYTE *)tag->ti_Data;
        render = TRUE;
    }

    if (tag = findGTTagItem(GTPA_ColorOffset,taglist))
    {
        PAID(gad)->paid_ColorOffset = tag->ti_Data;
        render = TRUE;
    }

    if (tag = findTagItem(GA_Disabled,taglist))
    {
        active = (gad->Flags & GFLG_DISABLED);
        if (!tag->ti_Data)
        {
            if (active)
            {
                gad->Flags &= ~(GFLG_DISABLED);
                render = TRUE;
            }
        }
        else
        {
            if (!active)
            {
                gad->Flags |= GFLG_DISABLED;
                render = TRUE;
            }
        }
    }

    PAID(gad)->paid_Color = getGTTagData(GTPA_Color,PAID(gad)->paid_Color,taglist);

    /* bounds check the color number */
    if (PAID(gad)->paid_ColorTable)
    {
        i = 0;
        while (i < PAID(gad)->paid_Count)
        {
            if (PAID(gad)->paid_Color == PAID(gad)->paid_ColorTable[i])
                break;

            i++;
        }

        if (i == PAID(gad)->paid_Count)  /* didn't find the color in the table */
            PAID(gad)->paid_Color = PAID(gad)->paid_ColorTable[0];
    }
    else if (PAID(gad)->paid_Color >= PAID(gad)->paid_ColorOffset + PAID(gad)->paid_Count)
    {
        PAID(gad)->paid_Color = PAID(gad)->paid_Count - PAID(gad)->paid_ColorOffset - 1;
    }

    if (win)
    {
        cloneRastPort(&crp,GetRP(gad,win));

        oldBox = PAID(gad)->paid_SelectedBox;
        newBox = GetBoxNum(gad,PAID(gad)->paid_Color);

        if (render || (oldBox != newBox))
        {
            if (render || (gad->Flags & GFLG_DISABLED))
            {
                RenderPalette(&crp,gad);
            }
            else
            {
                SelectBox(&crp,gad,oldBox,FALSE,FALSE);
                SelectBox(&crp,gad,newBox,TRUE,FALSE);
            }
        }
    }

    UnlockIBase(lock);
}


/*****************************************************************************/


BOOL HandlePalette(struct ExtGadget *gad, struct IntuiMessage *imsg)
{
    if (imsg->Class == IDCMP_GADGETUP)
    {
	imsg->Code = PAID(gad)->paid_Color;
	return(TRUE);
    }

    return(FALSE);
}
@


39.13
log
@Fixed problem with bad rendering when a tag causing a complete redraw was passed
  to SetGadgetAttrs()
@
text
@d7 1
a7 1
*   $Id: palette.c,v 39.12 92/07/16 10:55:27 vertex Exp Locker: vertex $
d29 1
d31 1
a32 1

d41 1
a41 1
    return(boxNum + PAID(gad)->paid_ColorOffset);
d60 1
a60 1
    return(colorIndex - PAID(gad)->paid_ColorOffset);
d352 1
a352 1
        PAID(gad)->paid_SelectedBox = ~0;
@


39.12
log
@Fixed bug with palette gadgets in 2 bit-plane mode not showing top border
Fixed bug when switching selected color while palette gadget is ghosted.
Improved rendering of the selected color in palette gadgets
Fixed bug with clicking twice on the same color in a palette gadget that
  doesn't show the selected item. The second click would not highlight the
  color as the mouse button was pressed.
@
text
@d7 1
a7 1
*   $Id: palette.c,v 39.11 92/06/16 13:48:10 vertex Exp Locker: vertex $
d160 2
a161 1
        SelectBox(rp,gad,count,count == selected,TRUE);
@


39.11
log
@Fixed incorrect unghosting
@
text
@d7 1
a7 1
*   $Id: palette.c,v 39.10 92/05/29 15:42:36 vertex Exp Locker: vertex $
d118 8
d133 1
d152 1
a152 1
    DrawImage(rp,gad->GadgetRender,gad->LeftEdge,gad->TopEdge);
d205 2
d444 1
a444 1
            if (render || (!gad->Flags & GFLG_DISABLED))
@


39.10
log
@Improved strumming
Removed requester support
Code optimizations
No longer renders a highlight box if the application didn't ask for a sample
  area
@
text
@d7 1
a7 1
*   $Id: palette.c,v 39.9 92/04/15 11:35:43 vertex Exp Locker: vertex $
d95 1
a95 1
                      BOOL selected)
d126 6
d141 1
a141 1
WORD x,y,w,h,maxX;
d146 4
a149 6
    /* Draw each color-box */
    x     = gad->LeftEdge + 3;
    y     = gad->TopEdge + 2;
    w     = PAID(gad)->paid_EachWidth;
    h     = PAID(gad)->paid_EachHeight;
    maxX  = x + PAID(gad)->paid_EachWidth * PAID(gad)->paid_XCount;
d151 1
a151 14
    {
        setAPen(rp,GetColorIndex(gad,count));
        RectFill(rp, x+1, y, x+w-3, y+h-2);

        x += w;
        if (x >= maxX)
        {
            x  = gad->LeftEdge + 3;
            y += h;
        }
    }

    if (PAID(gad)->paid_Indicator)
        SelectBox(rp,gad,GetBoxNum(gad,PAID(gad)->paid_Color),TRUE);
d193 2
a194 2
                SelectBox(rp,gad,oldBox,FALSE);
                SelectBox(rp,gad,newBox,TRUE);
d439 2
a440 2
                SelectBox(&crp,gad,oldBox,FALSE);
                SelectBox(&crp,gad,newBox,TRUE);
@


39.9
log
@Fully implemented gadget help
Optimized code for space
@
text
@d7 1
a7 1
*   $Id: palette.c,v 39.8 92/04/13 14:10:00 vertex Exp Locker: vertex $
d20 1
a20 1
struct Gadget *CreatePaletteA (struct Gadget *gad, struct NewGadget *ng,
d22 3
a24 3
BOOL HandlePalette (struct Gadget *gad, struct IntuiMessage *imsg);
void SetPaletteAttrsA (struct Gadget *gad, struct Window *win,
    struct Requester *req, struct TagItem *taglist);
d35 1
a35 11
static USHORT GhostPattern[2] =
{
     0x4444,
     0x1111,
};


/*****************************************************************************/


static UWORD GetColorIndex(struct Gadget *gad, UWORD boxNum)
d47 1
a47 1
static UWORD GetBoxNum(struct Gadget *gad, UWORD colorIndex)
d67 1
a67 1
 * number, or ~0 if not over any box.
d69 1
a69 1
static ULONG WhichBoxNum(struct Gadget *gad, struct gpInput *msg)
d71 2
a72 9
WORD  x      = msg->gpi_Mouse.X;
WORD  y      = msg->gpi_Mouse.Y;
ULONG boxNum = ~0;

    if ((x >= 3) && (y >= 2) && (x < gad->Width-2) && (y < gad->Height-1))
    {
        boxNum = ( (x-3) / PAID(gad)->paid_EachWidth ) + PAID(gad)->paid_XCount
                 * ( (y-2) / PAID(gad)->paid_EachHeight );
    }
d74 16
a89 3
    return(boxNum);
}

d94 1
a94 1
static VOID SelectBox(struct RastPort *rp, struct Gadget *gad, UWORD boxNum,
d97 2
a98 9
UWORD pen;
UWORD x0,y0,x1,y1,w,h;

    pen = PAID(gad)->paid_VI->vi_DrawInfo->dri_Pens[BACKGROUNDPEN];
    if (selected)
    {
        pen = PAID(gad)->paid_VI->vi_DrawInfo->dri_Pens[SHINEPEN];
        PAID(gad)->paid_SelectedBox = boxNum;
    }
d100 2
a101 1
    setAPen(rp,pen);
d110 16
a125 4
    RectFill(rp,x0,y0,x1,y0);
    RectFill(rp,x0,y0,x0+1,y1);
    RectFill(rp,x1-1,y0,x1,y1);
    RectFill(rp,x0,y1,x1,y1);
d127 2
a128 2


d132 1
a132 1
static VOID RenderPalette(struct RastPort *rp, struct Gadget *gad)
d159 2
a160 1
    SelectBox(rp,gad,PAID(gad)->paid_SelectedBox,TRUE);
d163 8
a170 10
    {
	SetABPenDrMd(rp,1,0,JAM1);
	SetAfPt(rp,GhostPattern, 1);
	RectFill(rp, gad->LeftEdge, gad->TopEdge,
                     gad->LeftEdge + gad->Width - 1, gad->TopEdge + gad->Height - 1 );
	SetAfPt(rp,NULL,0);
    }
}


d174 1
a174 1
static ULONG HandlePaletteInput(struct Gadget *gad, struct gpInput *msg)
d179 1
a179 1
ULONG              result = 0;
d189 3
d195 1
a195 1
	if ((newBox != ~0) && (newBox != oldBox))
d199 2
a200 1
                PAID(gad)->paid_Color = GetColorIndex(gad,newBox);
d211 2
a212 1
        else if (icode == IECODE_RBUTTON)
d223 3
a225 3
ULONG __asm DispatchPalette(register __a0 struct Hook *hook,
                            register __a2 struct Gadget *gad,
                            register __a1 ULONG *msg )
d254 2
a255 2
struct Gadget *CreatePaletteA(struct Gadget *gad, struct NewGadget *ng,
                              struct TagItem *taglist)
d347 5
a351 1
        PAID(gad)->paid_VI          = VI(ng->ng_VisualInfo);
d353 1
a353 1
        SetPaletteAttrsA(gad,NULL,NULL,taglist);
d363 2
a364 2
VOID SetPaletteAttrsA(struct Gadget *gad, struct Window *win,
                      struct Requester *req, struct TagItem *taglist)
d425 1
a425 1
        if (i == PAID(gad)->paid_Count)
d461 1
a461 1
BOOL HandlePalette(struct Gadget *gad, struct IntuiMessage *imsg)
d463 1
a463 1
    if (imsg->Class == GADGETUP)
@


39.8
log
@Added GTPA_ColorTable
Added GTPA_NumColors
Removed GTPA_ColorColumns/Rows
Now cancels a selection when the right button is tapped
Does better looking highlighting of the selected color
Prints label of gadget
Does smart layout of color squares based on the screen's aspect ratio
Renders much faster
@
text
@d7 1
a7 1
*   $Id: palette.c,v 39.7 92/04/07 13:55:00 vertex Exp Locker: vertex $
d111 1
a111 1
    SetAPen(rp,pen);
d146 1
a146 1
        SetAPen(rp,GetColorIndex(gad,count));
d179 1
d183 2
d188 1
a188 1
        if (ie->ie_Code == IECODE_RBUTTON)
d204 1
a204 1
	if (ie->ie_Code == ( IECODE_LBUTTON | IECODE_UP_PREFIX))
d206 1
a206 1
        else if (ie->ie_Code == IECODE_RBUTTON)
a222 1
    result = 0;
d225 1
a225 1
	case GM_HITTEST    : result = GMR_GADGETHIT;
d228 1
a228 1
	case GM_RENDER     : RenderPalette(((struct gpRender *)msg)->gpr_RPort,gad);
d234 5
d251 13
a263 12
struct NewGadget mod_ng;
LONG             colorWidth, colorHeight;
UWORD            depth  = getGTTagData(GTPA_Depth, 1, taglist);
UWORD            colors = getGTTagData(GTPA_NumColors, 1 << depth, taglist);
UWORD            indicatorwidth = getGTTagData(GTPA_IndicatorWidth, 0, taglist);
UWORD            columns, rows;
UWORD            bestcolumns, bestrows;
UWORD            availWidth, availHeight;
UWORD            divisor;
LONG             ratio;
LONG             bestratio;
ULONG            resX, resY;
d265 3
a267 2
    resX        = VI(ng->ng_VisualInfo)->vi_DrawInfo->dri_Resolution.X * 256;
    resY        = VI(ng->ng_VisualInfo)->vi_DrawInfo->dri_Resolution.Y;
d272 1
a272 1
    bestratio   = 10000000;
d341 1
a341 1
        PAID(gad)->paid_VI          = ng->ng_VisualInfo;
a358 1
BOOL             full;
d364 1
a364 3
    render  = FALSE;
    full    = FALSE;
    active  = (gad->Flags & GFLG_DISABLED);
d371 1
a371 1
        full = TRUE;
d377 1
a377 1
        full = TRUE;
d382 2
a383 1
        if (!tag->ti_Data && active)
d385 5
a389 2
            gad->Flags &= ~(GFLG_DISABLED);
            full = TRUE;
d391 1
a391 1
        else if (tag->ti_Data && !active)
d393 5
a397 2
            gad->Flags |= GFLG_DISABLED;
            full = TRUE;
a415 1
        {
a416 3
            render = TRUE;
            full   = (full || (!(gad->Flags & GFLG_DISABLED)));
        }
a420 2
        render = TRUE;
        full   = (full || (!(gad->Flags & GFLG_DISABLED)));
d425 2
a428 5
        if (newBox != oldBox)
        {
            render = TRUE;
            full   = (full || (!(gad->Flags & GFLG_DISABLED)));
        }
d430 1
a430 2
        cloneRastPort(&crp,GetRP(gad,win));
        if (full)
d432 9
a440 6
            RenderPalette(&crp,gad);
        }
        else if (render)
        {
            SelectBox(&crp,gad,oldBox,FALSE);
            SelectBox(&crp,gad,newBox,TRUE);
@


39.7
log
@SetXX() now safe even with no current window
@
text
@d7 1
a7 1
*   $Id: palette.c,v 39.6 92/03/26 15:16:45 peter Exp Locker: vertex $
a25 9
ULONG __asm dispatchPaletteG(  register __a0 struct Hook *hook,
    register __a2 struct Gadget *gad,
    register __a1 ULONG *msg );
ULONG renderPaletteG ( struct Gadget *gad, struct gpRender *msg );
ULONG whichColorBox ( struct Gadget *gad, struct gpInput *msg );
VOID drawColorBox ( struct Gadget *gad, struct RastPort *rp,
    UWORD color );
void FillBox ( struct RastPort *rp, UWORD color, struct IBox *box );
ULONG inputPaletteG ( struct Gadget *gad, struct gpInput *msg );
d27 3
a29 1
/*------------------------------------------------------------------------*/
a30 28
ULONG __asm dispatchPaletteG( register __a0 struct Hook *hook,
    register __a2 struct Gadget *gad,
    register __a1 ULONG *msg )
{
    ULONG retval = 0;

    switch ( *msg )	/* Method */
    {
	case GM_HITTEST:
	    /* We only get this if the hit is in the select-box,
	     * so we have no work here.
	     */
	    retval = GMR_GADGETHIT;
	    break;

	case GM_RENDER:
	    retval = renderPaletteG( gad, (struct gpRender *)msg );
	    break;

	case GM_GOINACTIVE:
	    retval = 0;
	    break;

	case GM_GOACTIVE:	/* First input */
	case GM_HANDLEINPUT:	/* Subsequent input */
	    retval = inputPaletteG( gad, (struct gpInput *)msg );
	    break;
    }
d32 1
a32 2
    return( retval );
}
a33 1
/*------------------------------------------------------------------------*/
d41 3
a43 1
/*------------------------------------------------------------------------*/
d45 1
a45 1
ULONG renderPaletteG( struct Gadget *gad, struct gpRender *msg )
d47 2
a48 2
    WORD count;
    struct RastPort *rp = msg->gpr_RPort;
d50 1
a50 18
    DrawImage( rp, gad->GadgetRender, gad->LeftEdge, gad->TopEdge );

    /* Draw each color-box */
    for (count = 0; count < PAID(gad)->paid_Count; count++)
    {
	drawColorBox( gad, rp, count + PAID(gad)->paid_ColorOffset );
    }
    if ( gad->Flags & GADGDISABLED )
    {
	SetABPenDrMd( rp, 1, 0, JAM1 );
	SetAfPt( rp, GhostPattern, 1);
	RectFill( rp, gad->LeftEdge,
	    gad->TopEdge,
	    gad->LeftEdge + gad->Width - 1,
	    gad->TopEdge + gad->Height - 1 );
	SetAfPt( rp, NULL, 0);
    }
    return( 0 );
a52 1
/*------------------------------------------------------------------------*/
d54 1
a54 18
/* Determine which color-box the mouse is over.  Returns the color
 * number, or ~0 if not over any box.
 */
ULONG whichColorBox( struct Gadget *gad, struct gpInput *msg )
{
    WORD x = msg->gpi_Mouse.X;
    WORD y = msg->gpi_Mouse.Y;
    /* Default to no color hit */
    ULONG color = ~0;


    if ( ( x >= 0 ) && ( y >= 0 ) && ( x < gad->Width ) && ( y < gad->Height ) )
    {
	color = PAID(gad)->paid_ColorOffset + ( x / PAID(gad)->paid_EachWidth ) +
		PAID(gad)->paid_XCount * ( y / PAID(gad)->paid_EachHeight );
    }
    return( color );
}
a55 1
/*------------------------------------------------------------------------*/
d57 1
a57 4
/* Given a color number, draw the rectangle for that color.
 */
VOID drawColorBox( struct Gadget *gad, struct RastPort *rp,
    UWORD color )
d59 8
a66 86
    UWORD x, y;
    struct IBox box;

    y = ( ( color - PAID(gad)->paid_ColorOffset ) / PAID(gad)->paid_XCount ) * PAID(gad)->paid_EachHeight;
    x = ( ( color - PAID(gad)->paid_ColorOffset ) % PAID(gad)->paid_XCount ) * PAID(gad)->paid_EachWidth;

    box.Left = gad->LeftEdge + x;
    box.Top = gad->TopEdge + y;
    box.Width = PAID(gad)->paid_EachWidth;
    box.Height = PAID(gad)->paid_EachHeight;

    /* Draw the box in the appropriate color */
#if 1
    /* Just inside the box, leaving a bit of room */
    SetAPen( rp, color );
    RectFill(  rp, box.Left+2, box.Top+2,
	box.Left + box.Width - 3, box.Top + box.Height - 3 );
#endif
#if 0
    /* The whole box */
    SetAPen( rp, color );
    RectFill(  rp, box.Left, box.Top,
	box.Left + box.Width - 1, box.Top + box.Height - 1 );
#endif



#if 1
    /* Draw or erase a little 3d recessed box around the color */
    SetAPen( rp, 0 );
    /* Highlight the selected color: */
    if ( color == PAID(gad)->paid_Color )
    {
	SetAPen( rp, 1 );
    }
    Move( rp, box.Left+box.Width-1, box.Top );
    Draw( rp, box.Left, box.Top );
    Draw( rp, box.Left, box.Top+box.Height-1 );
    if ( color == PAID(gad)->paid_Color )
    {
	SetAPen( rp, 2 );
    }
    Draw( rp, box.Left+box.Width-1, box.Top+box.Height-1 );
    Draw( rp, box.Left+box.Width-1, box.Top );
#endif

#if 0
    /* Draw a black box around the color */
    SetAPen( rp, 0 );
    /* Highlight the selected color: */
    if ( color == PAID(gad)->paid_Color )
    {
	SetAPen( rp, 1 );
    }
    Move( rp, box.Left, box.Top );
    Draw( rp, box.Left+box.Width-1, box.Top );
    Draw( rp, box.Left+box.Width-1, box.Top+box.Height-1 );
    Draw( rp, box.Left, box.Top+box.Height-1 );
    Draw( rp, box.Left, box.Top );
#endif

#if 0
    /* Put a bevelbox around the color */
    /* Highlight the selected color: */
    if ( color == PAID(gad)->paid_Color )
    {
	/* Recessed box */
	DrawBevelBox( rp, box.Left, box.Top, box.Width, box.Height,
	    GTBB_Recessed, TRUE,
	    GT_VisualInfo, PAID(gad)->paid_VisualInfo,
	    TAG_DONE );
    }
#endif
#if 0
    /* Put a large lame dot inside the color square */
    /* Highlight the selected color: */
    if ( color == PAID(gad)->paid_Color )
    {
	/* Complemented half-sized box-marker inside */
	box.Left += box.Width >> 2;
	box.Width >>= 1;
	box.Top += box.Height >> 2;
	box.Height >>= 1;

	/* Complement-highlight (for now) */
	FillBox( rp, ~color, &box );
d68 2
a69 1
#endif
d72 2
a73 1
/*------------------------------------------------------------------------*/
a74 2
#if 0
/* Fill the supplied IBox with the supplied color */
d76 4
a79 1
void FillBox( struct RastPort *rp, UWORD color, struct IBox *box )
d81 53
a133 5
    SetAPen( rp, color );
    RectFill(  rp, box->Left, box->Top,
	box->Left + box->Width - 1, box->Top + box->Height - 1 );
}
#endif
d135 2
a136 1
/*------------------------------------------------------------------------*/
d138 7
a144 8
ULONG inputPaletteG( struct Gadget *gad, struct gpInput *msg )
{
    ULONG color, oldcolor;
    struct RastPort *rp;
    struct InputEvent *ie = msg->gpi_IEvent;
    ULONG retval = 0;

    if ( ie->ie_Class == IECLASS_RAWMOUSE )
d146 38
a183 1
	oldcolor = PAID(gad)->paid_Color;
d185 2
a186 10
	if ( ( ( color = whichColorBox( gad, msg ) ) != ~0 ) &&
	    ( color != oldcolor ) )
	{
	    DP(( "Color changed!\n" ));
	    rp = ObtainGIRPort( msg->gpi_GInfo );
	    PAID(gad)->paid_Color = color;
	    drawColorBox( gad, rp, oldcolor );
	    drawColorBox( gad, rp, color );
	    ReleaseGIRPort( rp );
	}
d188 1
a188 1
	if ( ie->ie_Code == ( IECODE_LBUTTON | IECODE_UP_PREFIX ) )
d190 3
a192 6
	    DP(( "input sending GADGETUP\n" ));
	    retval = GMR_NOREUSE | GMR_VERIFY;
	}
    }
    return( retval );
}
d194 2
a195 1
/*------------------------------------------------------------------------*/
d197 3
a199 1
/* CreatePaletteA() */
d201 4
a204 42
struct Gadget *CreatePaletteA( struct Gadget *gad, struct NewGadget *ng,
    struct TagItem *taglist )
{
    WORD count;
    struct NewGadget mod_ng;
    UWORD EachWidth, EachHeight;
    UWORD depth = getGTTagData(GTPA_Depth, 1, taglist);
    UWORD XCount = getGTTagData(GTPA_ColorColumns, 1, taglist);
    UWORD YCount = getGTTagData(GTPA_ColorRows, 1, taglist);

    UWORD indicatorwidth = getGTTagData(GTPA_IndicatorWidth, 0, taglist);

    mod_ng = *ng;
    mod_ng.ng_LeftEdge += LEFTTRIM;
    mod_ng.ng_TopEdge += TOPTRIM;

    /* Start with total available width and height: */
    EachWidth = ng->ng_Width - LRTRIM;
    EachHeight = ng->ng_Height - TBTRIM;

    if ( ( XCount == 1 ) && ( YCount == 1 ) )
    {
	/* We know how big they want the whole area.  For each bit plane,
	 * the size of each gadget must be halved, so we halve it along
	 * whichever dimension is greatest:
	 */
	for (count = depth; count > 0; count--)
	{
	    /* !!!Minor evil kludge:  assuming pixels are 2* as tall as they
	     * are high, for purposes of subdivision.  Works well for
	     * med-res.  Suffers at other resolutions
	     */
	    if (2*EachHeight > EachWidth)
	    {
		/* Subdivide vertically: */
		YCount *= 2;
	    }
	    else
	    {
		XCount *= 2;
	    }
	}
d206 127
a332 2
    EachWidth /= XCount;
    EachHeight /= YCount;
d334 2
a335 36
    DP(( "CPAL: %ld by %ld boxes of size (%ld,%ld)\n",
	XCount, YCount, EachWidth, EachHeight ));
    mod_ng.ng_Width = EachWidth * XCount;
    mod_ng.ng_Height = EachHeight * YCount;

    gad = CreateGenericBase(gad, &mod_ng, PALETTE_IDATA_SIZE,
	taglist);
    if (!gad)
    	return(NULL);
    gad->Flags |= GADGIMAGE | GADGHNONE;
    gad->Activation = GADGIMMEDIATE | RELVERIFY;
    gad->GadgetType |= CUSTOMGADGET;
    gad->MutualExclude = (ULONG) &GadToolsBase->gtb_PaletteGHook;

    placeGadgetText(gad, ng->ng_Flags,
	indicatorwidth ? PLACETEXT_LEFT : PLACETEXT_ABOVE, NULL );

    SGAD(gad)->sg_SetAttrs = SetPaletteAttrsA;
    SGAD(gad)->sg_GetTable = Palette_GetTable;
    SGAD(gad)->sg_EventHandler = HandlePalette;
    SGAD(gad)->sg_Flags = SG_EXTRAFREE_DISPOSE;

    if ( !( gad->GadgetRender = getBevelImage( -LEFTTRIM, -TOPTRIM,
	gad->Width + LRTRIM, gad->Height + TBTRIM, FRAME_BUTTON ) ) )
    {
	return(NULL);
    }

    /* Fill out the instance data: */

    PAID(gad)->paid_XCount      = XCount;
    PAID(gad)->paid_EachWidth   = EachWidth;
    PAID(gad)->paid_EachHeight  = EachHeight;
    PAID(gad)->paid_Count       = XCount*YCount;
    PAID(gad)->paid_Color       = getGTTagData(GTPA_Color, 1, taglist);
    PAID(gad)->paid_ColorOffset = getGTTagData(GTPA_ColorOffset, 0, taglist);
a339 14
/*------------------------------------------------------------------------*/

void SetPaletteAttrsA( struct Gadget *gad, struct Window *win,
    struct Requester *req, struct TagItem *taglist )
{
    struct TagItem *ti;
    WORD pos;

    if (ti = findGTTagItem(GTPA_Color, taglist))
    {
	pos = removeGList( win, gad, 1 );
	PAID(gad)->paid_Color = (UBYTE)ti->ti_Data;
	AddRefreshGadget( win, gad, pos);
    }
d341 1
a341 3
    /* Test for GA_Disabled, set GADGDISABLED and refresh accordingly */
    TagAbleGadget(gad, win, req, taglist);
}
a342 1
/*------------------------------------------------------------------------*/
d344 100
a443 8
/*/ HandlePalette()
 *
 * Function to handle IDCMP messages for gadgets in the palette.
 *
 * Created:  05-Jun-89, Peter Cherna
 * Modified: 14-Dec-89, Peter Cherna
 *
 */
d445 1
a445 1
BOOL HandlePalette( struct Gadget *gad, struct IntuiMessage *imsg )
d447 1
a447 1
    if ( imsg->Class == GADGETUP )
a448 1
	DP((" HandlePalette() returning color %ld\n", PAID(gad)->paid_Color ));
d452 2
a453 5
    else
    {
	DP(( "HandlePalette skipping event\n" ));
	return(FALSE);
    }
a454 3


/*------------------------------------------------------------------------*/
@


39.6
log
@Uses getBevelImage() instead of DrawBevelBox().
@
text
@d7 1
a7 1
*   $Id: palette.c,v 39.5 92/03/25 14:38:17 peter Exp Locker: peter $
d138 1
a138 1
 
d282 1
a282 1
    
d349 5
a353 5
    PAID(gad)->paid_XCount = XCount;
    PAID(gad)->paid_EachWidth = EachWidth;
    PAID(gad)->paid_EachHeight = EachHeight;
    PAID(gad)->paid_Count =  XCount*YCount;
    PAID(gad)->paid_Color = getGTTagData(GTPA_Color, 1, taglist);
d355 1
a355 1
    
d369 1
a369 1
	pos = RemoveGList( win, gad, 1 );
d371 1
a371 1
	AddRefreshGList( win, gad, pos, 1, NULL );
@


39.5
log
@Added GTPA_ColorRows and GTPA_ColorColumns.
@
text
@d7 1
a7 1
*   $Id: palette.c,v 39.4 92/03/24 15:15:36 peter Exp Locker: peter $
d83 1
d85 1
a85 4
    DrawBevelBox( msg->gpr_RPort, gad->LeftEdge-LEFTTRIM, gad->TopEdge-TOPTRIM,
	gad->Width + LRTRIM, gad->Height + TBTRIM,
	GT_VisualInfo, PAID(gad)->paid_VisualInfo,
	TAG_DONE );
d90 1
a90 1
	drawColorBox( gad, msg->gpr_RPort, count + PAID(gad)->paid_ColorOffset );
d94 3
a96 3
	SetAPen( msg->gpr_RPort, 1 );
	SetAfPt( msg->gpr_RPort, GhostPattern, 1);
	RectFill( msg->gpr_RPort, gad->LeftEdge,
d100 1
d328 1
a328 1
    gad->Flags |= GADGHNONE;
d339 1
d341 6
a348 1
    PAID(gad)->paid_VisualInfo = ng->ng_VisualInfo;
@


39.4
log
@Supports GetAttrs of GTPA_Color and GA_Disabled.
@
text
@d7 1
a7 1
*   $Id: palette.c,v 39.3 92/02/20 11:50:47 peter Exp Locker: peter $
d279 1
a279 1
    WORD XCount, YCount, EachWidth, EachHeight;
d281 3
d294 1
a294 8
    XCount = 1;
    YCount = 1;
    /* We know how big they want the whole area.  For each bit plane,
     * the size of each gadget must be halved, so we halve it along
     * whichever dimension is greatest:
     */

    for (count = depth; count > 0; count--)
d296 3
a298 3
	/* !!!Minor evil kludge:  assuming pixels are 2* as tall as they
	 * are high, for purposes of subdivision.  Works well for
	 * med-res.  Suffers at other resolutions
d300 1
a300 1
	if (2*EachHeight > EachWidth)
d302 13
a314 8
	    /* Subdivide vertically: */
	    EachHeight >>= 1;
	    YCount *= 2;
	}
	else
	{
	    EachWidth >>= 1;
	    XCount *= 2;
d317 2
d347 1
a347 1
    PAID(gad)->paid_Count =  (1 << depth);
@


39.3
log
@Now use SGAD() instead of SG_FROM_GAD().
@
text
@d7 1
a7 1
*   $Id: palette.c,v 39.2 92/02/03 15:49:31 peter Exp Locker: peter $
d335 1
@


39.2
log
@Deleted obsolete internal autodocs.
@
text
@d7 1
a7 1
*   $Id: palette.c,v 39.1 92/01/30 19:54:20 peter Exp Locker: peter $
d334 2
a335 2
    SG_FROM_GAD(gad)->sg_SetAttrs = SetPaletteAttrsA;
    SG_FROM_GAD(gad)->sg_EventHandler = HandlePalette;
@


39.1
log
@Removed RCS log Re-did function headers and comments.
Bumped to V39.
@
text
@d7 1
a7 1
*   $Id: palette.c,v 38.4 92/01/30 18:09:31 peter Exp Locker: peter $
d139 1
a139 1

d147 1
d153 1
d162 1
d181 1
d196 1
d208 1
d250 2
a251 15
	if ( ie->ie_Code == IECODE_LBUTTON )
	{
	    /* Remember the initial color upon SELECTDOWN: */
	    PAID(gad)->paid_UndoColor = oldcolor;
	}

	if ( ( color = whichColorBox( gad, msg ) ) == ~0 )
	{
	    /* If we're off the gadget, then revert the the initial
	     * color.
	     */
	    color = PAID(gad)->paid_UndoColor;
	}
	DP(( "Mouse over color %ld\n", color ));
	if ( color != oldcolor )
d272 1
a272 53
/*i**** gadtools.library/CreatePaletteA **************************************
*
*   NAME
*	CreatePaletteA -- Create a palette selector gadget. (V36)
*
*   SYNOPSIS
*	gad = CreatePaletteA(previous, ng, taglist)
*
*	struct Gadget *CreatePaletteA(struct Gadget *, struct NewGadget *,
*	    struct TagList *);
*
*   FUNCTION
*	CreatePaletteA() allocates and initializes a palette selector gadget
*	(containing 2^n colored squares) based on the supplied NewGadget
*	structure and tags.
*
*   INPUTS
*	previous - Pointer to the previous gadget.
*	ng - Pointer to an initialized NewGadget structure.
*	taglist - Pointer to a TagItem list.
*
*   TAGS
*	GTPA_Depth (UWORD) - Number of bitplanes in the palette
*	    (defaults to 1).
*	GTPA_Color (UBYTE) - Initially selected color (defaults to 1).
*	GTPA_ColorOffset (UBYTE) - First color to use in palette
*	    (defaults to zero).
*	GTPA_IndicatorWidth (UWORD) - The desired width of the current-color
*	    indicator, if you want one above the palette.
*	GTPA_IndicatorHeight (UWORD) - The desired height of the current-color
*	    indicator, if you want one to the left of the palette.
*
*   RESULT
*	gad - Pointer to the resulting palette gadget if successful, or NULL
*	    if failure or if previous was NULL.
*
*   EXAMPLE
*
*   NOTES
*	These attributes may be changed by calling GT_SetGadgetAttrsA():
*	GTPA_Color (UBYTE) - Selected color.
*
*   BUGS
*
*   SEE ALSO
*	CreateGadgetA(), GT_SetGadgetAttrsA()
*
******************************************************************************
*
* Created:  05-Jun-89, Peter Cherna
* Modified:  8-Jan-90, Peter Cherna
*
*/
@


38.4
log
@Uses new space-saving placeGadgetText() function.
@
text
@d7 1
a7 1
*   $Id: palette.c,v 38.3 92/01/28 08:28:24 peter Exp Locker: peter $
a8 46
*   $Log:	palette.c,v $
 * Revision 38.3  92/01/28  08:28:24  peter
 * initPaletteGHook taken in-line assembly.
 * Removed __saveds.
 * PaletteGHook now referenced off GadToolsBase.
 * 
 * Revision 38.2  91/11/27  13:17:46  peter
 * All-new palette code that uses a single gadget.
 * Optimized extraction of instance data.
 * 
 * Revision 38.1  91/09/24  18:11:23  peter
 * Took some easy optimizations.
 * 
 * Revision 38.0  91/07/11  12:32:55  peter
 *  Initial V38 check-in (matches V37 release).
 * 
*   Revision 36.8  91/04/08  13:26:06  peter
*   Where appropriate uses getGTTagData(), getSTRINGTagData(),
*   findGTTagItem(), and findGATagItem() macros/stubs to save space.
*   
*   Revision 36.7  91/03/14  16:06:52  peter
*   Now uses stack-based tags instead of array-based ones when it calls
*   tag-based functions.
*   
*   Revision 36.6  90/10/12  19:42:43  peter
*   Replaced initializer of an automatic by some assignments to save space.
*   Calls internal findTagItem() and getTagData() to save space.
*   
*   Revision 36.5  90/05/18  18:32:04  peter
*   Put space immediately before '(' in prototypes to avoid confusing ctags.
*   
*   Revision 36.4  90/04/06  00:56:07  peter
*   No longer uses user's RastPort.
*   
*   Revision 36.3  90/04/02  16:11:40  peter
*   Warnings due to new clib/#?_protos.h eliminated.
*   No longer masks against GADTOOLMASK.
*   GadgetType is now OR'd in.
*   
*   Revision 36.2  90/03/31  06:41:09  peter
*   Now use CreateGadgetA() instead of specific Create[xxx]GadgetA().
*   
*   Revision 36.1  90/03/16  14:01:25  peter
*   RCS Clean up.
*   
*
d17 1
a17 1
/*  Function Prototypes: */
d19 1
a19 1
/*  Internal: */
d36 2
d78 2
d333 2
a334 3
struct Gadget *CreatePaletteA(struct Gadget *gad, struct NewGadget *ng,
    struct TagItem *taglist)

d346 1
a346 1
    /*  Start with total available width and height: */
d352 4
a355 3
    /*  We know how big they want the whole area.  For each bit plane,
	the size of each gadget must be halved, so we halve it along
	whichever dimension is greatest: */
d359 4
a362 3
	/*  !!!Minor evil kludge:  assuming pixels are 2* as tall as they
	    are high, for purposes of subdivision.  Works well for
	    med-res.  Suffers at other resolutions */
d365 1
a365 1
	    /*  Subdivide vertically: */
d396 1
a396 1
    /*  Fill out the instance data: */
d411 2
a412 2
void SetPaletteAttrsA(struct Gadget *gad, struct Window *win,
    struct Requester *req, struct TagItem *taglist)
d424 1
a424 1
    /*  Test for GA_Disabled, set GADGDISABLED and refresh accordingly */
d439 1
a439 5
BOOL HandlePalette(gad, imsg)

struct Gadget *gad;
struct IntuiMessage *imsg;

@


38.3
log
@initPaletteGHook taken in-line assembly.
Removed __saveds.
PaletteGHook now referenced off GadToolsBase.
@
text
@d7 1
a7 1
*   $Id: palette.c,v 38.2 91/11/27 13:17:46 peter Exp Locker: peter $
d10 5
a381 2
    struct Rectangle rect;
    ULONG place;
d431 2
a432 8
    rect.MinX = 0;
    rect.MaxX = ng->ng_Width - 1;
    rect.MinY = 0;
    rect.MaxY = ng->ng_Height - 1;

    if (!(place = (ng->ng_Flags & PLACETEXT_MASK)))
	place = indicatorwidth ? PLACETEXT_LEFT : PLACETEXT_ABOVE;
    PlaceIntuiText(gad->GadgetText, &rect, place);
@


38.2
log
@All-new palette code that uses a single gadget.
Optimized extraction of instance data.
@
text
@d7 1
a7 1
*   $Id: palette.c,v 38.1 91/09/24 18:11:23 peter Exp Locker: peter $
d10 4
d67 1
a67 1
ULONG __asm __saveds dispatchPaletteG(  register __a0 struct Hook *hook,
d77 1
a77 15
/*------------------------------------------------------------------------*/

VOID initPaletteGHook( struct Hook *hook )

    {
    /* Dispatch routine */
    hook->h_SubEntry = dispatchPaletteG;
    hook->h_Entry = callCHook;
    /* Stuff our context */
    hook->h_Data = GadToolsBase;
    }

/*------------------------------------------------------------------------*/

ULONG __asm __saveds dispatchPaletteG( register __a0 struct Hook *hook,
d426 1
a426 1
    gad->MutualExclude = (ULONG) &PaletteGHook;
@


38.1
log
@Took some easy optimizations.
@
text
@d7 1
a7 1
*   $Id: palette.c,v 38.0 91/07/11 12:32:55 peter Exp Locker: peter $
d10 3
a58 1
void RefreshPalette (struct Window *win, struct Gadget *pal, BOOL refresh);
d63 260
a322 2
void RefreshIndicator (struct Window *win, struct Gadget *pal,
    BOOL FullRefresh);
d383 1
a383 4
    {
    struct PaletteIData *paid;
    struct Gadget *pal;
    struct Gadget *prePAL;
a384 1
    struct Image *paletteimage;
a385 1
    struct SpecialGadget *sg;
d389 1
a390 2
    UWORD indicatorheight = getGTTagData(GTPA_IndicatorHeight, 0, taglist);
    UWORD depth = getGTTagData(GTPA_Depth, 1, taglist);
a391 7
    /*  We must create the dummy-gadget first, but we would like to
	return it from CreatePalette(), so later we move it to last
	in this piece of gadget-list.  We have to save the value of
	gad before the palette was allocated: */
    prePAL = gad;

    /*  Create the dummy gadget with the instance data: */
d393 2
a394 27
    mod_ng.ng_Width = 0;
    mod_ng.ng_Height = 0;

    pal = gad = CreateGenericBase(gad, &mod_ng, sizeof(struct PaletteIData),
	taglist);
    if (!gad)
    	return(NULL);
    gad->Flags = GADGHNONE;

    rect.MinX = 0;
    rect.MaxX = ng->ng_Width - 1;
    rect.MinY = 0;
    rect.MaxY = ng->ng_Height - 1;

    if (!(place = (ng->ng_Flags & PLACETEXT_MASK)))
	place = indicatorwidth ? PLACETEXT_LEFT : PLACETEXT_ABOVE;
    PlaceIntuiText(gad->GadgetText, &rect, place);

    sg = SG_FROM_GAD(gad);
    DP(("CPAL:  Dummy gadget sg(%lx) ID %ld at $%lx\n", sizeof(*sg),
	ng->ng_GadgetID, sg));
    sg->sg_Refresh = RefreshPalette;
    sg->sg_SetAttrs = SetPaletteAttrsA;

    paid = PAID(gad);
    /*  Fill out the instance data: */
    DP(("CPAL:  PaletteIData(%lx) at $%lx\n", sizeof(*paid), paid));
a395 4
    paid->paid_Color = getGTTagData(GTPA_Color, 1, taglist);
    paid->paid_ColorOffset = getGTTagData(GTPA_ColorOffset, 0, taglist);
    paid->paid_VisualInfo = ng->ng_VisualInfo;

a399 7
    /*  If the caller wanted an indicator box, make space for it
	along the desired axis: */
    if (indicatorwidth)
	EachWidth -= indicatorwidth + INTERWIDTH;
    else if (indicatorheight)
	EachHeight -= indicatorheight + INTERHEIGHT;

d407 1
a407 1
	{
d412 1
a412 1
	    {
d416 1
a416 1
	    }
d418 1
a418 1
	    {
a420 1
	    }
d422 1
d424 4
a427 82
    /*  Determine sizes of select area and indicator area: */
    /*  The indicator (if any) begins at the top left corner: */
    paid->paid_IndicLeft = ng->ng_LeftEdge;
    paid->paid_IndicTop = ng->ng_TopEdge;

    paid->paid_SelectLeft = ng->ng_LeftEdge;
    paid->paid_SelectTop = ng->ng_TopEdge;
    if (indicatorwidth)
	{
	/*  Move over to make room for the indicator: */
	paid->paid_SelectLeft += indicatorwidth + INTERWIDTH;
	/*  Indicator size is noted here: */
	paid->paid_IndicWidth = indicatorwidth;
	paid->paid_IndicHeight =  TBTRIM + YCount * EachHeight;
	}
    else if (indicatorheight)
	{
	/*  Move down to make room for the indicator: */
	paid->paid_SelectTop += indicatorheight + INTERHEIGHT;
	/*  Indicator size is noted here: */
	paid->paid_IndicWidth = LRTRIM + XCount * EachWidth;
	paid->paid_IndicHeight = indicatorheight;
	}

    paid->paid_SelectWidth = LRTRIM + XCount * EachWidth;
    paid->paid_SelectHeight = TBTRIM + YCount * EachHeight;

    mod_ng.ng_GadgetID = 0;
    mod_ng.ng_LeftEdge = paid->paid_SelectLeft + LEFTTRIM;
    mod_ng.ng_TopEdge = paid->paid_SelectTop + TOPTRIM;
    mod_ng.ng_Width = EachWidth;
    mod_ng.ng_Height = EachHeight;
    mod_ng.ng_GadgetText = NULL;

    paid->paid_Count =  (1 << depth);
    for (count = 0; count < paid->paid_Count; count++)
	{
	/*  Create a gadget with space for an Image structure: */
	/*  !!! probably shouldn't pass taglist! */
	gad = CreateGenericBase(gad, &mod_ng, sizeof(struct Image), taglist);
	if (!gad)
	    return(NULL);
	if (count == 0)
	    {
	    paid->paid_FirstGadget = gad;
	    }
	gad->Flags |= GADGIMAGE | GADGHCOMP;
	gad->Activation = RELVERIFY;
	gad->GadgetType |= BOOLGADGET;

	paletteimage = (struct Image *) MEMORY_FOLLOWING(gad);
	paletteimage->Width = EachWidth;
	paletteimage->Height = EachHeight;
	paletteimage->PlaneOnOff = count + paid->paid_ColorOffset;
	gad->GadgetRender = (APTR) paletteimage;

	sg = SG_FROM_GAD(gad);
	/*  Identify the group the gadget belongs to, and set up
	    the handler routine: */
	sg->sg_Parent = pal;
	sg->sg_EventHandler = HandlePalette;

	mod_ng.ng_GadgetID++;

	/*  Normally, next gadget is on the same row, one over to the right: */
	mod_ng.ng_LeftEdge += EachWidth;

	if (((count+1) % XCount) == 0)
	    {
	    /*  Next gadget is one row down, and back to the left: */
	    mod_ng.ng_LeftEdge = paid->paid_SelectLeft + LEFTTRIM;
	    mod_ng.ng_TopEdge += EachHeight;
	    }
	}
    /*  Move the dummy-gadget to the end of this list, so that
	it is the one that is returned: */
    prePAL->NextGadget = pal->NextGadget;
    gad->NextGadget = pal;
    pal->NextGadget = NULL;
    return(pal);
    }

d429 8
a436 1
/*------------------------------------------------------------------------*/
d438 4
a441 37
/*i**** gadtools.lib/SetPaletteAttrs *****************************************
*
*   NAME
*	SetPaletteAttrs - Modify the attributes of a palette gadget. (V36)
*
*   SYNOPSIS
*	SetPaletteAttrs(win, gad, newcolor)
*
*	void SetPaletteAttrs(struct Window *, struct Gadget *, UBYTE);
*
*   FUNCTION
*	SetPaletteAttrs() allows the attribute (i.e. currently selected
*	color) of a palette to be changed.  The gadget will be refreshed.
*
*   INPUTS
*	win - Pointer to the Window containing the palette gadget.
*	gad - Pointer to the palette gadget returned by CreatePalette.
*	newcolor - The desired new color.
*
*   RESULT
*	None.
*
*   EXAMPLE
*
*   NOTES
*
*   BUGS
*
*   SEE ALSO
*	CreatePalette()
*
******************************************************************************
*
* Created:  24-Oct-89, Peter Cherna
* Modified:  8-Jan-90, Peter Cherna
*
*/
d443 3
a445 2
void SetPaletteAttrsA(struct Gadget *gad, struct Window *win,
    struct Requester *req, struct TagItem *taglist)
d447 2
a448 3
    {
    struct PaletteIData *paid = PAID(gad);
    struct TagItem *ti;
d450 1
a450 5
    if (ti = findGTTagItem(GTPA_Color, taglist))
	{
	paid->paid_Color = (UBYTE)ti->ti_Data;
	RefreshIndicator(win, gad, (BOOL)FALSE);
	}
d452 7
a458 7
    if (ti = findGATagItem(GA_DISABLED, taglist))
	{
	/*  Do regular enables/disables: */
	AbleGadget(paid->paid_FirstGadget, win, req, paid->paid_Count, (BOOL)ti->ti_Data);
	}
    }

d460 2
a461 54
/*------------------------------------------------------------------------*/

/*/ RefreshIndicator()
 *
 * Function to refresh the current color indicator, if any.  Specify
 * FullRefresh = TRUE to get the frame refreshed as well as the color
 * rectangle.
 *
 * Created:  28-Aug-89, Peter Cherna
 * Modified:  4-Apr-90, Peter Cherna
 *
 * Bugs:  None
 *
 * Returns:  None (void)
 *
 */

void RefreshIndicator(win, pal, FullRefresh)

    struct Window *win;
    struct Gadget *pal;
    BOOL FullRefresh;

    {
    struct PaletteIData *paid = PAID(pal);
    struct RastPort cloneRP;

    /*  IndicWidth (and IndicHeight) are non-zero if we have an indicator
	up: */
    if (paid->paid_IndicWidth)
	{
	if (FullRefresh)
	    {
	    /*  Turns out to be cheaper to assign these guys here, rather than
		with a structure initializer: */
	    /*  Draw the box around the indicator */
	    DrawBevelBox(win->RPort,
		paid->paid_IndicLeft, paid->paid_IndicTop,
		paid->paid_IndicWidth, paid->paid_IndicHeight,
		GTBB_Recessed, TRUE,
		GT_VisualInfo, paid->paid_VisualInfo,
		TAG_DONE);
	    }

	/*  Color in the indicator.  Prepare a copy of the RastPort
	    with the correct color set:  */
	PrepareCloneRP(&cloneRP, win->RPort, paid->paid_Color);
	RectFill(&cloneRP,
	    (WORD) (paid->paid_IndicLeft + LEFTTRIM),
	    (WORD) (paid->paid_IndicTop + TOPTRIM),
	    (WORD) (paid->paid_IndicLeft + paid->paid_IndicWidth - (LEFTTRIM + 1)),
	    (WORD) (paid->paid_IndicTop + paid->paid_IndicHeight - (TOPTRIM + 1)));
	}
    }
a462 1

d465 5
a469 12
/*/ RefreshPalette()
 *
 * Function to refresh the palette gadgets.
 *
 * Created:  02-Jun-89, Peter Cherna
 * Modified: 14-Feb-90, Peter Cherna
 *
 * Bugs:  None
 *
 * Returns:  None (void)
 *
 */
d471 6
a476 1
void RefreshPalette(win, pal, refresh)
d478 3
a480 17
    struct Window *win;
    struct Gadget *pal;
    BOOL refresh;

    {
    struct PaletteIData *paid = PAID(pal);

    /*  Refresh the indicator (if any), complete with its border: */
    RefreshIndicator(win, pal, (BOOL) TRUE);

    /*  Draw the border around the palette */
    DrawBevelBox(win->RPort,
	paid->paid_SelectLeft, paid->paid_SelectTop,
	paid->paid_SelectWidth, paid->paid_SelectHeight,
	GT_VisualInfo, paid->paid_VisualInfo,
	TAG_DONE);
    }
d495 2
a496 2
    struct Gadget *gad;
    struct IntuiMessage *imsg;
d498 8
d507 2
a508 14
    struct Gadget *pal = SG_FROM_GAD(gad)->sg_Parent;
    struct PaletteIData *paid = PAID(pal);
    UBYTE newcolor;

    newcolor = gad->GadgetID + paid->paid_ColorOffset;
    if (paid->paid_Color != newcolor)
	{
	/*  We only refresh when the color changes: */
    	paid->paid_Color = newcolor;
	RefreshIndicator(imsg->IDCMPWindow, pal, (BOOL)FALSE);
	}
    imsg->IAddress = (APTR) pal;
    imsg->Code = newcolor;
    return(TRUE);
d510 1
@


38.0
log
@ Initial V38 check-in (matches V37 release).
@
text
@d7 1
a7 1
*   $Id: palette.c,v 36.8 91/04/08 13:26:06 peter Exp $
d10 3
d242 1
a242 1
    mod_ng.ng_TopEdge =+ paid->paid_SelectTop + TOPTRIM;
d276 4
d283 1
a283 3
	    mod_ng.ng_LeftEdge = ng->ng_LeftEdge + LEFTTRIM;
	    if (indicatorwidth)
		mod_ng.ng_LeftEdge += indicatorwidth + INTERWIDTH;
a284 5
	    }
	else
	    {
	    /*  Next gadget is on the same row, one over to the right: */
	    mod_ng.ng_LeftEdge += EachWidth;
@
