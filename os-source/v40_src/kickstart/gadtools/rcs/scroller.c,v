head     39.13;
branch   ;
access   ;
symbols  ;
locks    ; strict;
comment  @ * @;


39.13
date     93.05.06.17.05.39;  author vertex;  state Exp;
branches ;
next     39.12;

39.12
date     92.10.16.18.31.21;  author vertex;  state Exp;
branches ;
next     39.11;

39.11
date     92.05.29.15.30.27;  author vertex;  state Exp;
branches ;
next     39.10;

39.10
date     92.04.15.11.33.47;  author vertex;  state Exp;
branches ;
next     39.9;

39.9
date     92.04.13.14.01.56;  author vertex;  state Exp;
branches ;
next     39.8;

39.8
date     92.04.07.13.47.34;  author vertex;  state Exp;
branches ;
next     39.7;

39.7
date     92.03.26.15.15.52;  author peter;  state Exp;
branches ;
next     39.6;

39.6
date     92.03.24.15.15.46;  author peter;  state Exp;
branches ;
next     39.5;

39.5
date     92.03.20.12.47.06;  author peter;  state Exp;
branches ;
next     39.4;

39.4
date     92.02.20.13.56.09;  author peter;  state Exp;
branches ;
next     39.3;

39.3
date     92.02.20.11.50.56;  author peter;  state Exp;
branches ;
next     39.2;

39.2
date     92.02.03.15.49.50;  author peter;  state Exp;
branches ;
next     39.1;

39.1
date     92.01.30.19.53.42;  author peter;  state Exp;
branches ;
next     38.3;

38.3
date     92.01.30.18.09.41;  author peter;  state Exp;
branches ;
next     38.2;

38.2
date     92.01.28.08.30.04;  author peter;  state Exp;
branches ;
next     38.1;

38.1
date     91.11.27.13.19.19;  author peter;  state Exp;
branches ;
next     38.0;

38.0
date     91.07.11.12.34.32;  author peter;  state Exp;
branches ;
next     ;


desc
@@


39.13
log
@Fixed handling of GA_Disabled
@
text
@/*** scroller.c ***********************************************************
*
*   scroller.c	- Scroll Bar/Arrows routines
*
*   Copyright 1989, 1990, Commodore-Amiga, Inc.
*
*   $Id: scroller.c,v 39.12 92/10/16 18:31:21 vertex Exp Locker: vertex $
*
**************************************************************************/

/*------------------------------------------------------------------------*/

#include "gtinclude.h"

/*------------------------------------------------------------------------*/

/* Function Prototypes: */

/* Internal: */
struct ExtGadget *CreateScrollerA (struct ExtGadget *gad, struct NewGadget *ng,
    struct TagItem *taglist);
BOOL HandleScroller (struct ExtGadget *gad, struct IntuiMessage *imsg);
void SetScrollerAttrsA (struct ExtGadget *gad, struct Window *win,
    struct TagItem *taglist);

static void FindScrollerValues (UWORD total, UWORD displayable, UWORD top,
    UWORD *body, UWORD *pot);
static UWORD FindScrollerTop (UWORD total, UWORD displayable, UWORD pot);


static struct ExtGadget *createArrowButtonA ( struct ExtGadget *gad, struct NewGadget *ng,
    struct ExtGadget *scgad, LONG direction, struct TagItem *taglist );


/*****************************************************************************/


/* CreateScrollerA() */

struct ExtGadget *CreateScrollerA(struct ExtGadget *gad, struct NewGadget *ng,
                                  struct TagItem *taglist)
{
struct NewGadget  mod_ng, arrow_ng;
UWORD             arrowsize;
struct ExtGadget *scgad, *preSC;
BOOL              vertical;

extern struct TagItem to_prop_map[];

    /* We must create the dummy-gadget first, but we would like to
     * use it as the return value, so later we move it to last
     * in this piece of gadget-list.  We have to save the value of
     * gad before the scroller was allocated:
     */
    preSC = gad;

    /* Create the dummy gadget with the instance data: */
    mod_ng = *ng;
    if (!(scgad = CreateGenericBase(gad, ng, SCROLLER_IDATA_SIZE,taglist)))
    	return(NULL);

    scgad->Flags |= GADGIMAGE|GADGHNONE;
    SGAD(scgad)->sg_SetAttrs  = SetScrollerAttrsA;
    SGAD(scgad)->sg_Flags     = SG_EXTRAFREE_DISPOSE;
    SGAD(scgad)->sg_GetTable  = Scroller_GetTable;
    SCID(scgad)->scid_Visible = 2;
    SCID(scgad)->scid_Flags   = PackBoolTags(NULL, taglist, to_prop_map);

    placeGadgetText(scgad,ng->ng_Flags,PLACETEXT_LEFT,NULL);

    vertical = FALSE;
    if (getTagData(PGA_FREEDOM,0,taglist) == LORIENT_VERT)
	vertical = TRUE;

    arrowsize = getGTTagData(GTSC_Arrows, 0, taglist);

    /* Make changes to NewGadget */
    mod_ng.ng_GadgetText = NULL;
    arrow_ng = mod_ng;

    /* Calculate dimension/position information based on
     * existence of arrows.
     */
    if (arrowsize)
    {
	if ( vertical )
	{
	    /* Remove height of arrows from scroller height */
	    mod_ng.ng_Height -= 2*arrowsize;
	    /* Move the arrow to past the bottom of the whole
	     * scroller package, and then back up by 2*arrowsize
	     */
	    arrow_ng.ng_TopEdge += arrow_ng.ng_Height - 2*arrowsize;
	    arrow_ng.ng_Height = arrowsize;
	}
	else
	{
	    mod_ng.ng_Width -= 2*arrowsize;
	    arrow_ng.ng_LeftEdge += arrow_ng.ng_Width - 2*arrowsize;
	    arrow_ng.ng_Width = arrowsize;
	}
    }

    /* Note well: Imagery is hanging off the underlay gadget
     * (scgad) though its size depends on the scroller gadget,
     * since above we adjusted that for arrows.
     */
    if (!(scgad->GadgetRender = getBevelImage(0,0,mod_ng.ng_Width,mod_ng.ng_Height,FRAME_BUTTON)))
	return(NULL);

    /* Recall that the scroller actually has to fit nicely inside
     * the border.   Here's that offset:
     */
    mod_ng.ng_LeftEdge += LEFTTRIM;
    mod_ng.ng_TopEdge  += TOPTRIM;
    mod_ng.ng_Width    -= LRTRIM;
    mod_ng.ng_Height   -= TBTRIM;

    if (!(SCID(scgad)->scid_Prop = gad = CreateGenericBase(scgad,&mod_ng,0,taglist)))
        return(NULL);

    MP(("CSC: gadget at $%lx\n", prop));
    MP(("CSC: Filling out gadget structure\n"));

    /* Install required blank image structure: */
    gad->GadgetRender  = (APTR)&SCID(scgad)->scid_PropImage;
    gad->Flags         = GADGHNONE | GADGIMAGE;  /* clears away GFLG_EXTENDED */
    gad->Activation    = GADGIMMEDIATE | RELVERIFY | FOLLOWMOUSE;
    gad->GadgetType   |= PROPGADGET;
    gad->SpecialInfo   = (APTR)&SCID(scgad)->scid_PropInfo;

    /* Initialize handlers in the SpecialGadget: */
    SGAD(gad)->sg_Parent       = scgad;
    SGAD(gad)->sg_EventHandler = HandleScroller;
    SGAD(gad)->sg_Flags        = SG_MOUSEMOVE;

    if (vertical)
    {
        MP(("CSC: Initialing as vertical scroller\n"));
        SCID(scgad)->scid_PropInfo.Flags = AUTOKNOB | PROPBORDERLESS | FREEVERT;
        SCID(scgad)->scid_Pot            = &SCID(scgad)->scid_PropInfo.VertPot;
        SCID(scgad)->scid_Body           = &SCID(scgad)->scid_PropInfo.VertBody;
    }
    else
    {
        MP(("CSC: Initialing as horizontal scroller\n"));
        SCID(scgad)->scid_PropInfo.Flags = AUTOKNOB | PROPBORDERLESS | FREEHORIZ;
        SCID(scgad)->scid_Pot            = &SCID(scgad)->scid_PropInfo.HorizPot;
        SCID(scgad)->scid_Body           = &SCID(scgad)->scid_PropInfo.HorizBody;
    }

    if (arrowsize)
    {
	LONG direction;

	SCID(scgad)->scid_Flags |= SC_ARROWS;
	/* Yep, we're getting arrows! */
	arrow_ng.ng_GadgetText = NULL;

	direction = ARROW_UP;
	if ( !vertical )
	{
	    direction = ARROW_LEFT;
	}

	SCID(scgad)->scid_Up = gad = createArrowButtonA( gad, &arrow_ng,
	    scgad, direction, taglist );
	/* Wherein ARROW_UP becomes ARROW_DOWN or
	 * ARROW_LEFT becomes ARROW_RIGHT
	 */
	direction++;
	if ( vertical )
	{
	    arrow_ng.ng_TopEdge += arrowsize;
	}
	else
	{
	    arrow_ng.ng_LeftEdge += arrowsize;
	}
	SCID(scgad)->scid_Down = gad = createArrowButtonA(gad, &arrow_ng,
	                                                  scgad, direction, taglist );

        if (!gad)
            return(NULL);
    }

    SetScrollerAttrsA(scgad,NULL,taglist);

    /* Move the dummy-gadget to the end of this list, so that
     * it is the one that is returned:
     */
    preSC->NextGadget = scgad->NextGadget;
    gad->NextGadget = scgad;
    scgad->NextGadget = NULL;
    MP(("CSC: Done.\n"));
    return(scgad);
}


/*------------------------------------------------------------------------*/

VOID SetScrollerAttrsA(struct ExtGadget *gad, struct Window *win,
                       struct TagItem *taglist)
{
struct TagItem *tag;

    SCID(gad)->scid_Total   = getGTTagData(GTSC_Total, SCID(gad)->scid_Total, taglist);
    SCID(gad)->scid_Visible = getGTTagData(GTSC_Visible, SCID(gad)->scid_Visible, taglist);
    SCID(gad)->scid_Top     = getGTTagData(GTSC_Top, SCID(gad)->scid_Top, taglist);

    DP(("SSAA:  Total %ld, Visible %ld, Top %ld\n", (LONG)SCID(gad)->scid_Total,
	(LONG)SCID(gad)->scid_Visible, (LONG)SCID(gad)->scid_Top));
    FindScrollerValues(SCID(gad)->scid_Total, SCID(gad)->scid_Visible, SCID(gad)->scid_Top,
	               SCID(gad)->scid_Body, SCID(gad)->scid_Pot);
    DP(("SSAA:  Body %ld, Pot %ld\n", (LONG)(*SCID(gad)->scid_Body),
	(LONG)(*SCID(gad)->scid_Pot)));

    if (win)
    {
        DP(("SSAA:  Calling NMP on gad $%lx, win $%lx, Flags $%lx\n",
            SCID(gad)->scid_Prop, win, (LONG)pi->Flags));
        DP(("SSAA:  HPot %ld VPot %ld HBody %ld VBody %ld\n",
            (LONG)pi->HorizPot, (LONG)pi->VertPot,
            (LONG)pi->HorizBody, (LONG)pi->VertBody));

        NewModifyProp(SCID(gad)->scid_Prop,win,NULL,
                      SCID(gad)->scid_PropInfo.Flags,
                      SCID(gad)->scid_PropInfo.HorizPot,
                      SCID(gad)->scid_PropInfo.VertPot,
                      SCID(gad)->scid_PropInfo.HorizBody,
                      SCID(gad)->scid_PropInfo.VertBody, 1);
    }

    /* Test for GA_Disabled, set GADGDISABLED and refresh accordingly */
    if (tag = TagAbleGadget(SCID(gad)->scid_Prop,win,taglist))
    {
        if (SCID(gad)->scid_Flags & SC_ARROWS)
        {
            TagAbleGadget(SCID(gad)->scid_Up,win,taglist);
            TagAbleGadget(SCID(gad)->scid_Down,win,taglist);
        }
    }
}


/*------------------------------------------------------------------------*/


/*/ HandleScroller()
 *
 * Function to handle IntuiMessages that relate to scrollers.
 *
 * Created:  30-Aug-89, Peter Cherna
 * Modified: 16-Mar-90, Peter Cherna
 *
 */

BOOL HandleScroller( struct ExtGadget *gad, struct IntuiMessage *imsg )
{
    struct ExtGadget *scgad = SGAD(gad)->sg_Parent;
    WORD newtop = SCID(scgad)->scid_Top;
    BOOL hearupdown = FALSE;
    WORD hidden;

    MP(("HS: Gadget at $%lx\n", gad));

    if (gad == SCID(scgad)->scid_Prop)
    {
	/* User hit the prop gadget, so find a new value of top based on
	 * the new value of Pot:
	 */
	newtop = FindScrollerTop(SCID(scgad)->scid_Total, SCID(scgad)->scid_Visible,
	    *SCID(scgad)->scid_Pot);
    }
    else
    {
	/* User hit one of the buttons */
	if (imsg->Class != IDCMP_GADGETUP)
	{
	    /* On the upstroke of a button, all we'd ever do is
	     * notify the app, never scroll.
	     */

	    if (imsg->Class == IDCMP_GADGETDOWN)
	    {
		/* Reset tick counter: */
		MP(("HSC:  Got IDCMP_GADGETDOWN, starting TickCount\n"));
		SCID(scgad)->scid_TickCount = 0;
	    }
	    else /* (imsg->Class == IDCMP_INTUITICKS) */
	    {
		MP(("HSC:  New TickCount %ld, ", SCID(scgad)->scid_TickCount+1));
		if (++SCID(scgad)->scid_TickCount <= ARROW_SKIPTICKS)
		{
		    /* Too early for the first repeat: */
		    MP(("too early.\n"));
		    return(FALSE);
		}
		else if (!(gad->Flags & SELECTED))
		{
		    /* The user rolled the mouse off the gadget */
		    MP(("Mouse no longer over gadget\n"));
		    return(FALSE);
		}
		MP(("going to repeat.\n"));
	    }

	    /* User hit up or down gadget: */
	    if (gad == SCID(scgad)->scid_Up)
	    {
		/* User hit up gadget: */
		if (--newtop < 0)
		{
		    newtop = 0;
		}
	    }
	    else /* if (gad == SCID(scgad)->scid_Down) */
	    {
		/* User hit down gadget: */
		hidden = max(SCID(scgad)->scid_Total - SCID(scgad)->scid_Visible, 0);
		/* If newtop is so great that the remainder of the list won't even
		 * fill the displayable area, reduce it:
		 */
		if (++newtop > hidden)
		   newtop = hidden;
	    }
	    DP(("HSC:  Vis %ld, newtop %ld, oldtop: %ld\n",
		(LONG) SCID(scgad)->scid_Visible, (LONG)newtop, (LONG)SCID(scgad)->scid_Top));
	    /* Figure out new scroller values, and refresh: */
	    FindScrollerValues(SCID(scgad)->scid_Total, SCID(scgad)->scid_Visible, newtop,
		SCID(scgad)->scid_Body, SCID(scgad)->scid_Pot);
	    DP(("HSC:  Body %ld, Pot %ld\n", (LONG)(*SCID(scgad)->scid_Body),
		(LONG)(*SCID(scgad)->scid_Pot)));
	    DP(("HSC:  HPot %ld VPot %ld HBody %ld VBody %ld\n",
		(LONG)pi->HorizPot, (LONG)pi->VertPot,
		(LONG)pi->HorizBody, (LONG)pi->VertBody));
	    NewModifyProp(SCID(scgad)->scid_Prop,imsg->IDCMPWindow,NULL,
                          SCID(scgad)->scid_PropInfo.Flags,
                          SCID(scgad)->scid_PropInfo.HorizPot,
                          SCID(scgad)->scid_PropInfo.VertPot,
                          SCID(scgad)->scid_PropInfo.HorizBody,
                          SCID(scgad)->scid_PropInfo.VertBody, 1);
	}
    }

    if (imsg->Class == GADGETDOWN)
    {
	MP(("HS:  ScrollGadget GADGETDOWN\n"));
	if (SCID(scgad)->scid_Flags & GTPROP_GADGETDOWN)
	{
	    /* The client wants to hear this always: */
	    hearupdown = TRUE;
	}
    }
    else if (imsg->Class == IDCMP_GADGETUP)
    {
	MP(("HS:  ScrollGadget IDCMP_GADGETUP\n"));
	if (SCID(scgad)->scid_Flags & GTPROP_GADGETUP)
	{
	    /* The client wants to hear this always: */
	    hearupdown = TRUE;
	}
    }
    D(else
    {
	MP(("HS: ScrollGadget IDCMP_MOUSEMOVE\n"));
    });

    /* If we cause a message, we want the code field equal to the
     * new level, with the IAddress of the scroller gadget dummy
     */
    imsg->Code = newtop;
    imsg->IAddress = (APTR) scgad;

    /* Only react if the value of top actually changed: */
    MP(("HS:  Old top %ld, new top %ld\n", ((LONG)SCID(scgad)->scid_Top),
	((LONG)newtop)));

    if (newtop != SCID(scgad)->scid_Top)
    {
	SCID(scgad)->scid_Top = newtop;
	MP(("HS:  New Top Set %ld\n", ((LONG)SCID(scgad)->scid_Top)));

	/* This will end up being a proper interconnection to
	 * the ListView, but for now we call SetListViewAttrs()
	 * if this Scroller is part of one:
	 */
	if (SCID(scgad)->scid_ListView)
	{
	    MP(("HS:  Calling ISLVA(): win $%lx, lv $%lx, new top %ld\n",
		imsg->IDCMPWindow, SCID(scgad)->scid_ListView, ((ULONG)newtop)));
	    SetListViewTop(SCID(scgad)->scid_ListView,imsg->IDCMPWindow,newtop);
	    return(FALSE);
	}
	else
	{
	    /* If this is a IDCMP_GADGETUP or IDCMP_GADGETDOWN and our client doesn't
	     * want to hear this type, we satisfy him by converting it
	     * to a IDCMP_MOUSEMOVE, since he MUST hear of every event in which
	     * the level changed:
	     */
	    if (!hearupdown)
		imsg->Class = IDCMP_MOUSEMOVE;
	    MP(("HS: Level Changed\n"));
	    return(TRUE);
	}
    }

    /* The level did not change, so only let the message reach
     * the client if it was a IDCMP_GADGETUP or IDCMP_GADGETDOWN and the client
     * was interested in that - this condition is reflected by
     * the value of hearupdown:
     */
    MP((hearupdown ? "HS: Sending message even though level unchanged\n" :
	"HS: Message dropped since level unchanged.\n"));
    return(hearupdown);
}


/*------------------------------------------------------------------------*/

/*/ FindScrollerValues()
 *
 * Function to calculate the Body and Pot values of a proportional gadget
 * given the three values total, displayable, and top, representing the
 * total number of items in a list, the number of items displayable at one
 * time, and the top item to be displayed.  For example, a file requester
 * may be able to display 10 entries at a time.  The directory has 20
 * entries in it, and the top one displayed is number 3 (the fourth one,
 * counting from zero), then total = 20, displayable = 10, and top = 3.
 *
 */

static void FindScrollerValues( UWORD total, UWORD displayable, UWORD top,
    UWORD *body, UWORD *pot )
{
    UWORD hidden;

    /* Find the number of unseen lines: */
    hidden = max(total - displayable, 0);

    /* If top is so great that the remainder of the list won't even
     * fill the displayable area, reduce top:
     */

    if (top > hidden)
       top = hidden;

    /* body is the relative size of the proportional gadget's rbody.
     * Its size in the container represents the fraction of the total
     * that is in view.  If there are no lines hidden, then body
     * should be full-size (MAXBODY).  Otherwise, body should be the
     * fraction of (the number of displayed lines - 1) over
     * (the total number of lines - 1).  The "-1" is so that when the
     * user scrolls by clicking in the container of the scroll gadget,
     * then there is a one line overlap between the two views.
     */

    (*body) = (hidden > 0) ?
	(UWORD) (((ULONG) (displayable - 1) * MAXBODY) / (total - 1)) : MAXBODY;

    /* pot is the position of the proportional gadget body, with zero
     * meaning that the scroll gadget is all the way up (or left),
     * and full (MAXPOT) meaning that the scroll gadget is all the way
     * down (or right).  If we can see all the lines, pot should be zero.
     * Otherwise, pot is the top displayed line divided by the number of
     * unseen lines.
     */

    (*pot) = (hidden > 0) ?
	(UWORD) (((ULONG) top * MAXPOT) / hidden) : 0;
}


/*------------------------------------------------------------------------*/

/*/ FindScrollerTop()
 *
 * Function to calculate the top line that is displayed in a proportional
 * gadget, given the total number of items in the list and the number
 * displayable, as well as the HorizPot or VertPot value.
 *
 */

static UWORD FindScrollerTop( UWORD total, UWORD displayable, UWORD pot )
{
    UWORD top, hidden;

    /* Find the number of unseen lines: */
    hidden = max(total - displayable, 0);

    /* pot can be thought of as the fraction of the hidden lines that
     * are before the displayed part of the list, in other words a
     * pot of zero means all hidden lines are after the displayed
     * part of the list (i.e. top = 0), and a pot of MAXPOT means all
     * the hidden lines are ahead of the displayed part
     * (i.e. top = hidden).
     */
    top = (((ULONG) hidden * pot) + (MAXPOT/2)) >> 16;

    /* Once you get back the new value of top, only redraw your list
     * if top changed from its previous value.  The proportional gadget
     * may not have moved far enough to change the value of top.
     */

    return(top);
}

/*------------------------------------------------------------------------*/

/*/ createArrowButtonA()
 *
 * Makes an arrow button (up, down, left, or right).
 *
 */

static struct ExtGadget *createArrowButtonA(struct ExtGadget *gad,
                                            struct NewGadget *ng,
                                            struct ExtGadget *scgad,
                                            LONG direction,
                                            struct TagItem *taglist)
{
struct ArrowBorder *arrowborder;

    if (gad = (struct ExtGadget *)CreateGadget(BUTTON_KIND, gad, ng,
                                                 GT_ExtraSize, sizeof(struct ArrowBorder),
                                                 GA_Immediate, TRUE,
                                                 TAG_MORE,     taglist))
    {
	/* Code is smaller if intermediate values are longs */
	struct Rect32 inner;
        WORD *points;

        gad->MoreFlags             &= ~(GMORE_GADGETHELP);
	SGAD(gad)->sg_EventHandler  = HandleScroller;
	SGAD(gad)->sg_Parent        = scgad;
	SGAD(gad)->sg_Flags        |= SG_INTUITICKS;

	/* Now let's go fill out the arrow's border structure */

	arrowborder = MEMORY_FOLLOWING(SGAD(gad));

	inner.MinX = LEFTTRIM;
	inner.MinY = TOPTRIM;
	inner.MaxX = gad->Width - 2 - LEFTTRIM;
	inner.MaxY = gad->Height - 1 - TOPTRIM;

	arrowborder->Border1.BackPen = DESIGNTEXT;
	/* JAM1 == 0, so we don't need to set it: */
    /*
     *  arrowborder->Border1.DrawMode = JAM1;
     */
	arrowborder->Border1.Count = 4;
	points = arrowborder->Border1.XY = arrowborder->Points;
	arrowborder->Border2 = arrowborder->Border1;
	arrowborder->Border2.LeftEdge = 1;
	arrowborder->Border1.NextBorder = &arrowborder->Border2;

	/* GadgetRender is an Image whose IA_Data is a border */
	SetAttrs(gad->GadgetRender, IA_Data, arrowborder,
                                    TAG_DONE );
#if 0
	/* GadgetRender is an Image whose ImageData is really a pointer
	 * to a struct Border
	 */
	arrowborder->Border2.NextBorder = (struct Border *)
	    ((struct Image *)gad->GadgetRender)->ImageData;
	((struct Image *)gad->GadgetRender)->ImageData = (APTR) arrowborder;
#endif

	switch (direction)
	{
	    /* Code is smaller if intermediate values are longs */
	    LONG sum, temp;

	    case ARROW_DOWN:
		/* Reverse MinY and MaxY, and pretend it's an ARROW_UP: */
		temp = inner.MinY;
		inner.MinY = inner.MaxY;
		inner.MaxY = temp;
		/* and fall through to the next case (no break) */
	    case ARROW_UP:
		*points++ = inner.MinX;
		*points++ = inner.MaxY;

		sum = ( inner.MinX + inner.MaxX );
		*points++ = sum / 2;
		*points++ = inner.MinY;

		*points++ = ( sum + 1 ) / 2;
		*points++ = inner.MinY;

		*points++ = inner.MaxX;
    /** NOTE WELL:  The last post-increment is deliberately missing (optimization) **/
		*points = inner.MaxY;

		break;

	    case ARROW_RIGHT:
		/* Reverse MinX and MaxX, and pretend it's an ARROW_LEFT: */
		temp = inner.MinX;
		inner.MinX = inner.MaxX;
		inner.MaxX = temp;
		/* and fall through to the next case (no break) */
	    case ARROW_LEFT:
		*points++ = inner.MaxX;
		*points++ = inner.MinY;

		sum = inner.MinY + inner.MaxY;
		*points++ = inner.MinX;
		*points++ = sum / 2;

		*points++ = inner.MinX;
		*points++ = ( sum + 1 ) / 2;

		*points++ = inner.MaxX;
    /** NOTE WELL:  The last post-increment is deliberately missing (optimization) **/
		*points = inner.MaxY;

		break;
	}
    }
    return( gad );
}
@


39.12
log
@Changes for SAS/C 6.0
@
text
@d7 1
a7 1
*   $Id: scroller.c,v 39.11 92/05/29 15:30:27 vertex Exp Locker: vertex $
a34 35
/*------------------------------------------------------------------------*/


#define GhostScroller(p,w) {}

#if 0
/* This code is used to ghost the scroll arrows whenever the prop gadget
 * is at the extremities of its domain. Turns out folks don't like this so
 * we took it out
 */
static VOID GhostScroller(struct ExtGadget *parent, struct Window *win)
{
struct TagItem tags[2];

    tags[0].ti_Tag  = GA_Disabled;
/*    tags[0].ti_Data = (SCID(parent)->scid_Visible >= SCID(parent)->scid_Total) || (SCID(parent)->scid_Flags & SC_DISABLED); */
    tags[1].ti_Tag  = TAG_DONE;

/* This code ghosts the actual slider when the whole text is visible
    TagAbleGadget(SCID(parent)->scid_Prop,win,tags);
    TagAbleGadget(parent,win,tags);
*/

    if (SCID(parent)->scid_Flags & SC_ARROWS)
    {
        tags[0].ti_Data = (SCID(parent)->scid_Top == 0) || (parent->Flags & GFLG_DISABLED);
        GT_SetGadgetAttrsA(SCID(parent)->scid_Up,win,tags);

        tags[0].ti_Data = (SCID(parent)->scid_Top + SCID(parent)->scid_Visible >= SCID(parent)->scid_Total) || (parent->Flags & GFLG_DISABLED);
        GT_SetGadgetAttrsA(SCID(parent)->scid_Down,win,tags);
    }
}
#endif


d237 5
a241 4
        if (tag->ti_Data)
            SCID(gad)->scid_Flags |= SC_DISABLED;
        else
            SCID(gad)->scid_Flags &= ~(SC_DISABLED);
a242 2

    GhostScroller(gad,win);
a392 1
            GhostScroller(scgad,imsg->IDCMPWindow);
a404 1
            GhostScroller(scgad,imsg->IDCMPWindow);
@


39.11
log
@Removed requester support
Removed ghosting of arrows on extremes
Code optimizations
@
text
@d7 1
a7 1
*   $Id: scroller.c,v 39.10 92/04/15 11:33:47 vertex Exp Locker: vertex $
d38 1
a38 1
#define GhostScroller(p,w,r) {}
d446 1
d563 2
a564 1
    if (gad = CreateGadget(BUTTON_KIND, gad, ng, GT_ExtraSize, sizeof(struct ArrowBorder),
@


39.10
log
@Fully implemented gadget help
Optimized code for space
@
text
@d7 1
a7 1
*   $Id: scroller.c,v 39.9 92/04/13 14:01:56 vertex Exp Locker: vertex $
d20 1
a20 1
struct Gadget *CreateScrollerA (struct Gadget *gad, struct NewGadget *ng,
d22 3
a24 3
BOOL HandleScroller (struct Gadget *gad, struct IntuiMessage *imsg);
void SetScrollerAttrsA (struct Gadget *gad, struct Window *win,
    struct Requester *req, struct TagItem *taglist);
d31 2
a32 2
static struct Gadget *createArrowButtonA ( struct Gadget *gad, struct NewGadget *ng,
    struct Gadget *scgad, LONG direction, struct TagItem *taglist );
d38 8
a45 2
static VOID GhostScroller(struct Gadget *parent, struct Window *win,
                          struct Requester *req)
d54 2
a55 2
    TagAbleGadget(SCID(parent)->scid_Prop,win,req,tags);
    TagAbleGadget(parent,win,req,tags);
d61 1
a61 1
        GT_SetGadgetAttrsA(SCID(parent)->scid_Up,win,req,tags);
d64 1
a64 1
        GT_SetGadgetAttrsA(SCID(parent)->scid_Down,win,req,tags);
d67 1
d75 2
a76 2
struct Gadget *CreateScrollerA( struct Gadget *gad, struct NewGadget *ng,
    struct TagItem *taglist )
d78 4
a81 4
    struct NewGadget mod_ng, arrow_ng;
    UWORD arrowsize;
    struct Gadget *scgad, *preSC;
    BOOL vertical = FALSE;
d83 1
a83 1
    extern struct TagItem to_prop_map[];
d94 1
a94 1
    if (!(scgad = gad = CreateGenericBase(gad, ng, SCROLLER_IDATA_SIZE,taglist)))
d106 1
d154 1
a154 1
    if (!(SCID(scgad)->scid_Prop = gad = CreateGenericBase(gad,&mod_ng,0,taglist)))
d157 1
a157 1
    MP(("CSC: gadget at $%lx\n", gad));
d172 1
a172 1
    if ( vertical )
d222 1
a222 1
    SetScrollerAttrsA(scgad,NULL,NULL,taglist);
d237 2
a238 2
VOID SetScrollerAttrsA(struct Gadget *gad, struct Window *win,
                       struct Requester *req, struct TagItem *taglist)
d261 1
a261 1
        NewModifyProp(SCID(gad)->scid_Prop,win,req,
d270 1
a270 1
    if (tag = TagAbleGadget(SCID(gad)->scid_Prop,win,req,taglist))
d278 1
a278 1
    GhostScroller(gad,win,req);
d294 1
a294 1
BOOL HandleScroller( struct Gadget *gad, struct IntuiMessage *imsg )
d296 1
a296 1
    struct Gadget *scgad = SGAD(gad)->sg_Parent;
a299 1
    struct Requester *req = GetReq(gad,imsg->IDCMPWindow);
d314 1
a314 1
	if (imsg->Class != GADGETUP)
d320 1
a320 1
	    if (imsg->Class == GADGETDOWN)
d323 1
a323 1
		MP(("HSC:  Got GADGETDOWN, starting TickCount\n"));
d326 1
a326 1
	    else /* (imsg->Class == INTUITICKS) */
d373 1
a373 1
	    NewModifyProp(SCID(scgad)->scid_Prop,imsg->IDCMPWindow,req,
d391 1
a391 1
    else if (imsg->Class == GADGETUP)
d393 1
a393 1
	MP(("HS:  ScrollGadget GADGETUP\n"));
d402 1
a402 1
	MP(("HS: ScrollGadget MOUSEMOVE\n"));
d428 2
a429 2
	    SetListViewTop(SCID(scgad)->scid_ListView,imsg->IDCMPWindow,req,newtop);
            GhostScroller(scgad,imsg->IDCMPWindow,req);
d434 1
a434 1
	    /* If this is a GADGETUP or GADGETDOWN and our client doesn't
d436 1
a436 1
	     * to a MOUSEMOVE, since he MUST hear of every event in which
d442 1
a442 1
            GhostScroller(scgad,imsg->IDCMPWindow,req);
d447 1
a447 1
     * the client if it was a GADGETUP or GADGETDOWN and the client
d554 7
a560 9
static struct Gadget *createArrowButtonA( struct Gadget *gad, struct NewGadget *ng,
    struct Gadget *scgad, LONG direction, struct TagItem *taglist )
{
    struct ArrowBorder *arrowborder;

    gad = CreateGadget( BUTTON_KIND, gad, ng,
	GT_ExtraSize, sizeof(struct ArrowBorder),
	GA_Immediate, TRUE,
	TAG_MORE, taglist );
d562 3
a564 1
    if (gad)
d570 4
a573 5
	SGAD(gad)->sg_EventHandler = HandleScroller;
	SGAD(gad)->sg_Parent = scgad;
	SGAD(gad)->sg_Flags |= SG_INTUITICKS;

        ((struct ExtGadget *)gad)->MoreFlags &= ~(GMORE_GADGETHELP);
d596 2
a597 3
	SetAttrs( gad->GadgetRender,
	    IA_Data, arrowborder,
	    TAG_DONE );
a660 2

/*------------------------------------------------------------------------*/
@


39.9
log
@Moved some stuff around to save bytes
Added requester support
@
text
@d7 1
a7 1
*   $Id: scroller.c,v 39.8 92/04/07 13:47:34 vertex Exp Locker: vertex $
d90 1
a90 1
    scgad->Flags = GADGIMAGE|GADGHNONE;
d154 1
a154 1
    gad->Flags        |= GADGHNONE | GADGIMAGE;
d566 2
@


39.8
log
@Now ghosts the arrows when hitting the end of a direction
Combined Set/Create() for smaller code
@
text
@d7 1
a7 1
*   $Id: scroller.c,v 39.7 92/03/26 15:15:52 peter Exp $
d38 2
a39 1
static VOID GhostScroller(struct Gadget *parent, struct Window *win)
d48 2
a49 2
    TagAbleGadget(SCID(parent)->scid_Prop,win,NULL,tags);
    TagAbleGadget(parent,win,NULL,tags);
d55 1
a55 1
        GT_SetGadgetAttrsA(SCID(parent)->scid_Up,win,NULL,tags);
d58 1
a58 1
        GT_SetGadgetAttrsA(SCID(parent)->scid_Down,win,NULL,tags);
d270 1
a270 1
    GhostScroller(gad,win);
d292 1
d366 1
a366 1
	    NewModifyProp(SCID(scgad)->scid_Prop,imsg->IDCMPWindow, NULL,
d421 2
a422 2
	    SetListViewTop(SCID(scgad)->scid_ListView,imsg->IDCMPWindow,newtop);
            GhostScroller(scgad,imsg->IDCMPWindow);
d433 1
a433 1
		imsg->Class = MOUSEMOVE;
d435 1
a435 1
            GhostScroller(scgad,imsg->IDCMPWindow);
@


39.7
log
@Uses getBevelImage() instead of MakeBevelBox().
@
text
@d7 1
a7 1
*   $Id: scroller.c,v 39.6 92/03/24 15:15:46 peter Exp Locker: peter $
d26 1
a26 1
void FindScrollerValues (UWORD total, UWORD displayable, UWORD top,
d28 1
a28 1
UWORD FindScrollerTop (UWORD total, UWORD displayable, UWORD pot);
d31 1
a31 1
struct Gadget *createArrowButtonA ( struct Gadget *gad, struct NewGadget *ng,
d34 1
d37 28
a70 1
    struct PropInfo *pi;
a72 1
    struct Image *im;
d86 1
a86 3
    scgad = gad = CreateGenericBase(gad, ng, SCROLLER_IDATA_SIZE,
	taglist);
    if (!scgad)
d88 1
d90 5
a94 10
    SGAD(scgad)->sg_SetAttrs = SetScrollerAttrsA;
    SGAD(scgad)->sg_Flags = SG_EXTRAFREE_DISPOSE;
    SGAD(scgad)->sg_GetTable = Scroller_GetTable;

    placeGadgetText( scgad, ng->ng_Flags, PLACETEXT_LEFT, NULL );

    /* Find and fill out the instance data for the scroller: */
    SCID(scgad)->scid_Top = getGTTagData(GTSC_Top, 0, taglist);
    SCID(scgad)->scid_Total = getGTTagData(GTSC_Total, 0, taglist);
    SCID(scgad)->scid_Visible = getGTTagData(GTSC_Visible, 2, taglist);
d96 1
a96 1
    SCID(scgad)->scid_Flags = PackBoolTags(NULL, taglist, to_prop_map);
d98 1
a98 2
    if ( getTagData( PGA_FREEDOM, 0, taglist ) == LORIENT_VERT )
    {
a99 1
    }
d134 2
a135 5
    if ( ! ( scgad->GadgetRender = getBevelImage( 0, 0,
	mod_ng.ng_Width, mod_ng.ng_Height, FRAME_BUTTON ) ) )
    {
	return( NULL );
    }
d141 3
a143 3
    mod_ng.ng_TopEdge += TOPTRIM;
    mod_ng.ng_Width -= LRTRIM;
    mod_ng.ng_Height -= TBTRIM;
d145 31
a175 43
    /* Change the GT_ExtraSize amount: */
    SCID(scgad)->scid_Prop = gad = CreateGenericBase(gad, &mod_ng,
	sizeof(struct PropInfo) + sizeof(struct Image),
	taglist);
    if (gad)
    {
	MP(("CSC: gadget at $%lx\n", gad));
	MP(("CSC: Filling out gadget structure\n"));

	pi = (struct PropInfo *)MEMORY_FOLLOWING(SGAD(gad));
	/* Install required blank image structure: */
	im = MEMORY_FOLLOWING(pi);
	gad->GadgetRender = (APTR) im;
	gad->Flags |= GADGHNONE | GADGIMAGE;
	gad->Activation = GADGIMMEDIATE | RELVERIFY | FOLLOWMOUSE;
	gad->GadgetType |= PROPGADGET;
	gad->SpecialInfo = (APTR) pi;

	if ( vertical )
	{
	    MP(("CSC: Initialing as vertical scroller\n"));
	    pi->Flags = AUTOKNOB | PROPBORDERLESS | FREEVERT;
	    SCID(scgad)->scid_Pot = &pi->VertPot;
	    SCID(scgad)->scid_Body = &pi->VertBody;
	}
	else
	{
	    MP(("CSC: Initialing as horizontal scroller\n"));
	    pi->Flags = AUTOKNOB | PROPBORDERLESS | FREEHORIZ;
	    SCID(scgad)->scid_Pot = &pi->HorizPot;
	    SCID(scgad)->scid_Body = &pi->HorizBody;
	}

	DP(("CSC: Finding Scroller Values given Total %ld, Vis %ld Top %ld\n",
	    (LONG)SCID(scgad)->scid_Total, (LONG)SCID(scgad)->scid_Visible, (LONG)SCID(scgad)->scid_Top));
	FindScrollerValues(SCID(scgad)->scid_Total, SCID(scgad)->scid_Visible, SCID(scgad)->scid_Top,
	    SCID(scgad)->scid_Body, SCID(scgad)->scid_Pot);
	DP(("CSC:  Body: %ld, Pot: %ld\n", (LONG)*SCID(scgad)->scid_Body, (LONG)*SCID(scgad)->scid_Pot));
	/* Initialize handlers in the SpecialGadget: */
	MP(("CSC: SpecialGadget at $%lx\n", sg));
	SGAD(gad)->sg_Parent = scgad;
	SGAD(gad)->sg_EventHandler = HandleScroller;
	SGAD(gad)->sg_Flags = SG_MOUSEMOVE;
d206 5
a210 2
	SCID(scgad)->scid_Down = gad = createArrowButtonA( gad, &arrow_ng,
	    scgad, direction, taglist );
d213 2
a214 4
    if (!gad)
    {
	return(NULL);
    }
d228 48
a290 1
    struct PropInfo *pi;
a360 1
	    pi = (struct PropInfo *)SCID(scgad)->scid_Prop->SpecialInfo;
d364 6
a369 2
	    NewModifyProp(SCID(scgad)->scid_Prop, imsg->IDCMPWindow, NULL, pi->Flags,
		pi->HorizPot, pi->VertPot, pi->HorizBody, pi->VertBody, 1);
d405 1
d410 1
d419 2
a420 4
	    InternalSetListViewAttrs(SCID(scgad)->scid_ListView, imsg->IDCMPWindow,
		NULL, TRUE,
		GTLV_Top, newtop,
		TAG_DONE);
d433 1
a449 43
void SetScrollerAttrsA( struct Gadget *gad, struct Window *win,
    struct Requester *req, struct TagItem *taglist )
{
    struct TagItem *ti;
    struct TagItem buttontags[2];
    struct PropInfo *pi;

    SCID(gad)->scid_Total = getGTTagData(GTSC_Total, SCID(gad)->scid_Total, taglist);
    SCID(gad)->scid_Visible = getGTTagData(GTSC_Visible, SCID(gad)->scid_Visible, taglist);
    SCID(gad)->scid_Top = getGTTagData(GTSC_Top, SCID(gad)->scid_Top, taglist);

    DP(("SSAA:  Total %ld, Visible %ld, Top %ld\n", (LONG)SCID(gad)->scid_Total,
	(LONG)SCID(gad)->scid_Visible, (LONG)SCID(gad)->scid_Top));
    FindScrollerValues(SCID(gad)->scid_Total, SCID(gad)->scid_Visible, SCID(gad)->scid_Top,
	SCID(gad)->scid_Body, SCID(gad)->scid_Pot);
    DP(("SSAA:  Body %ld, Pot %ld\n", (LONG)(*SCID(gad)->scid_Body),
	(LONG)(*SCID(gad)->scid_Pot)));
    pi = (struct PropInfo *)SCID(gad)->scid_Prop->SpecialInfo;
    DP(("SSAA:  Calling NMP on gad $%lx, win $%lx, Flags $%lx\n",
	SCID(gad)->scid_Prop, win, (LONG)pi->Flags));
    DP(("SSAA:  HPot %ld VPot %ld HBody %ld VBody %ld\n",
	(LONG)pi->HorizPot, (LONG)pi->VertPot,
	(LONG)pi->HorizBody, (LONG)pi->VertBody));
    NewModifyProp(SCID(gad)->scid_Prop, win, NULL, pi->Flags,
	pi->HorizPot, pi->VertPot, pi->HorizBody, pi->VertBody, 1);

    /* Test for GA_Disabled, set GADGDISABLED and refresh accordingly */
    if ( ti = TagAbleGadget(SCID(gad)->scid_Prop, win, req, taglist) )
    {
	/* If we have arrows, enable/disable those: */
	if (SCID(gad)->scid_Flags & SC_ARROWS)
	{
	    buttontags[0] = *ti;
	    buttontags[1].ti_Tag = TAG_DONE;
	    GT_SetGadgetAttrsA(SCID(gad)->scid_Up, win, req, buttontags);
	    GT_SetGadgetAttrsA(SCID(gad)->scid_Down, win, req, buttontags);
	}
    }
}


/*------------------------------------------------------------------------*/

d462 1
a462 1
void FindScrollerValues( UWORD total, UWORD displayable, UWORD top,
d513 1
a513 1
UWORD FindScrollerTop( UWORD total, UWORD displayable, UWORD pot )
d545 1
a545 1
struct Gadget *createArrowButtonA( struct Gadget *gad, struct NewGadget *ng,
d550 1
a550 1
    gad = CreateGadget( BUTTON_KIND, gad, ng, 
@


39.6
log
@Supports GetAttrs of GTSC_Top, GTSC_Total, GTSC_Visible, and GA_Disabled.
@
text
@d7 1
a7 1
*   $Id: scroller.c,v 39.5 92/03/20 12:47:06 peter Exp Locker: peter $
d61 1
a61 1
    if (!gad)
d63 4
a66 3
    gad->Flags = GADGHNONE;
    SGAD(gad)->sg_SetAttrs = SetScrollerAttrsA;
    SGAD(gad)->sg_GetTable = Scroller_GetTable;
d68 1
a68 1
    placeGadgetText( gad, ng->ng_Flags, PLACETEXT_LEFT, NULL );
a75 1
    SCID(scgad)->scid_VisualInfo = ng->ng_VisualInfo;
d115 5
a119 3
    scgad->GadgetRender = MakeBevelBox( &SCID(scgad)->scid_BevelBox,
	0, 0, mod_ng.ng_Width, mod_ng.ng_Height, BB_RAISED,
	ng->ng_VisualInfo );
@


39.5
log
@Was clobbering SG_EXTRAFREE_DISPOSE on the scroller arrows.
@
text
@d7 1
a7 1
*   $Id: scroller.c,v 39.4 92/02/20 13:56:09 peter Exp Locker: peter $
d65 1
a390 48

/*i**** gadtools.lib/SetScrollerAttrs ****************************************
*
*   NAME
*	SetScrollerAttrs -- Change attributes of a scroller gadget. (V36)
*
*   SYNOPSIS
*	SetScrollerAttrs(win, gad, top, total, visible)
*
*	void SetScrollerAttrs(struct Window *, struct Gadget *,
*	    UWORD, UWORD, UWORD);
*
*   FUNCTION
*	SetScrollerAttrs() allows a new top, total, and visible value
*	to be specified for an existing scroller.
*
*   INPUTS
*	gad - Pointer to the scroller gadget returned by CreateScroller()
*	win - Pointer to the Window containing the gadget.
*	req - Pointer to requester containing gadget (not yet)
*	taglist - Pointer to TagItem list.
*
*   TAGS
*	GTSC_Top (UWORD) - Desired new value of top, which is the position
*	    or count of  the first thing visible in the area or list.
*	GTSC_Total (UWORD) - Desired new value of total, which is the total
*	    amount or number of items in the area or list.
*	GTSC_Visible (UWORD) - Desired new value of visible, which is the
*	    amount or number of items visible in one view of the area or list.
*
*   RESULT
*	None.
*
*   EXAMPLE
*
*   NOTES
*
*   BUGS
*
*   SEE ALSO
*	CreateScroller()
*
******************************************************************************
*
* Created:  18-Sep-89, Peter Cherna
* Modified: 16-Mar-90, Peter Cherna
*
*/
@


39.4
log
@No need to OR stuff into sg_Flags.
@
text
@d7 1
a7 1
*   $Id: scroller.c,v 39.3 92/02/20 11:50:56 peter Exp Locker: peter $
d595 1
a595 1
	SGAD(gad)->sg_Flags = SG_INTUITICKS;
@


39.3
log
@Now account for SpecialGadget fields following gadget.
@
text
@d7 1
a7 1
*   $Id: scroller.c,v 39.2 92/02/03 15:49:50 peter Exp Locker: peter $
d168 1
a168 1
	SGAD(gad)->sg_Flags |= SG_MOUSEMOVE;
d595 1
a595 1
	SGAD(gad)->sg_Flags |= SG_INTUITICKS;
@


39.2
log
@Now send IDCMP_GADGETUP to scroller guy if requested.
Deleted obsolete internal autodocs.
The two arrow gadgets are now created with unified code.  The arrow
imagery is linked in with SetAttrs() instead of by poking.
@
text
@d7 1
a7 1
*   $Id: scroller.c,v 39.1 92/01/30 19:53:42 peter Exp Locker: peter $
a42 1
    struct SpecialGadget *sg;
d64 1
a64 1
    SG_FROM_GAD(gad)->sg_SetAttrs = SetScrollerAttrsA;
d135 1
a135 1
	pi = (struct PropInfo *)MEMORY_FOLLOWING(gad);
a164 1
	sg = SG_FROM_GAD(gad);
d166 3
a168 3
	sg->sg_Parent = scgad;
	sg->sg_EventHandler = HandleScroller;
	sg->sg_Flags |= SG_MOUSEMOVE;
d231 1
a231 1
    struct Gadget *scgad = SG_FROM_GAD(gad)->sg_Parent;
a579 1
    struct SpecialGadget *sg;
d593 3
a595 4
	sg = SG_FROM_GAD(gad);
	sg->sg_EventHandler = HandleScroller;
	sg->sg_Parent = scgad;
	sg->sg_Flags |= SG_INTUITICKS;
d599 1
a599 1
	arrowborder = MEMORY_FOLLOWING(gad);
@


39.1
log
@Removed RCS log.  Re-did braces, comments, and function headers.
Bumped to V39.
@
text
@d7 1
a7 1
*   $Id: scroller.c,v 38.3 92/01/30 18:09:41 peter Exp Locker: peter $
d31 2
a32 2
void InstallArrowBorder (struct Gadget *gad, struct VisualInfo *vi,
    struct ArrowBorder *arrowborder, LONG direction);
d36 1
a36 59
/*i**** gadtools.library/CreateScrollerA *************************************
*
*   NAME
*	CreateScrollerA -- Create a scroller gadget. (V36)
*
*   SYNOPSIS
*	gad = CreateScrollerA(previous, ng, taglist)
*
*	struct Gadget *CreateScrollerA(struct Gadget *, struct NewGadget *,
*	    struct TagItem *);
*
*   FUNCTION
*	CreateScrollerA() allocates and initializes a scroller gadget according
*	to the supplied NewGadget structure.  A scroller would be used when
*	there is a list of items or an area to be moved through.
*
*   INPUTS
*	previous - Pointer to the previous gadget.
*	ng - Pointer to an initialized NewGadget structure describing
*	    the desired gadget.
*	taglist - Pointer to a TagItem list.
*
*   TAGS
*	GTSC_Top (WORD) - Top visible in scroller (defaults to zero).
*	GTSC_Total (WORD) - Total in scroller area (defaults to zero).
*	GTSC_Visible (WORD) - Number visible in scroller (defaults to 2).
*	GTSC_Arrows (UWORD) - Asks for arrows to be attached to the scroller.
*	    The value supplied will be taken as the width of the arrow buttons
*	    for a horizontal scroller, or the height of those buttons for a
*	    vertical scroller (the other dimension will match the whole
*	    scroller).
*	PGA_FREEDOM - Choose LORIENT_VERT or LORIENT_HORIZ (defaults to horiz).
*	GA_IMMEDIATE (BOOL) - Hear every GADGETDOWN event (defaults to FALSE).
*	GA_RELVERIFY (BOOL) - Hear every GADGETUP event (defaults to FALSE).
*
*   RESULT
*	gad - The resulting scroller gadget, or NULL if failure or if
*	    previous was NULL.
*
*   EXAMPLE
*
*   NOTES
*	These attributes may be set by calling GT_SetGadgetAttrsA():
*	GTSC_Top (WORD) - Top visible in scroller.
*	GTSC_Total (WORD) - Total in scroller area.
*	GTSC_Visible (WORD) - Number visible in scroller.
*	
*
*   BUGS
*
*   SEE ALSO
*	CreateGadgetA(), GT_SetGadgetAttrsA()
*
******************************************************************************
*
* Created:  30-Aug-89, Peter Cherna
* Modified: 28-Feb-90, Peter Cherna
*
*/
a43 1
    struct TagItem *ti;
d47 1
a47 1
    struct ArrowBorder *arrowborder;
d77 1
a77 1
    if (ti = findTagItem(PGA_FREEDOM, taglist))
d79 1
a79 4
	if (ti->ti_Data == LORIENT_VERT)
	{
	    SCID(scgad)->scid_Flags |= GTPROP_VERTICAL;
	}
d93 1
a93 1
	if (SCID(scgad)->scid_Flags & GTPROP_VERTICAL)
d129 1
a129 2
	( sizeof(struct PropInfo) + sizeof(struct Image) +
	(arrowsize ? 2 * sizeof(struct ArrowBorder) : 0) ),
d145 1
a145 1
	if (SCID(scgad)->scid_Flags & GTPROP_VERTICAL)
d175 2
a176 1
	arrowborder = MEMORY_FOLLOWING(im);
d180 3
a182 3
	SCID(scgad)->scid_Up = gad = CreateGadgetA(BUTTON_KIND, gad, &arrow_ng,
	    taglist);
	if (gad)
d184 1
a184 7
	    InstallArrowBorder(gad, SCID(scgad)->scid_VisualInfo, arrowborder++,
		(SCID(scgad)->scid_Flags & GTPROP_VERTICAL) ? ARROW_UP : ARROW_LEFT);
	    gad->Activation |= GADGIMMEDIATE;
	    sg = SG_FROM_GAD(gad);
	    sg->sg_EventHandler = HandleScroller;
	    sg->sg_Parent = scgad;
	    sg->sg_Flags |= SG_INTUITICKS;
d186 8
a193 1
	if (SCID(scgad)->scid_Flags & GTPROP_VERTICAL)
d201 2
a202 11
	SCID(scgad)->scid_Down = gad = CreateGadgetA(BUTTON_KIND, gad, &arrow_ng, taglist);
	if (gad)
	{
	    InstallArrowBorder(gad, SCID(scgad)->scid_VisualInfo, arrowborder,
		(SCID(scgad)->scid_Flags & GTPROP_VERTICAL) ? ARROW_DOWN : ARROW_RIGHT);
	    gad->Activation |= GADGIMMEDIATE;
	    sg = SG_FROM_GAD(gad);
	    sg->sg_EventHandler = HandleScroller;
	    sg->sg_Parent = scgad;
	    sg->sg_Flags |= SG_INTUITICKS;
	}
d234 1
a234 1
    WORD newtop;
d252 1
a252 1
	if (imsg->Class == GADGETDOWN)
d254 5
a258 14
	    /* Reset tick counter: */
	    MP(("HSC:  Got GADGETDOWN, starting TickCount\n"));
	    SCID(scgad)->scid_TickCount = 0;
	}
	else if (imsg->Class == GADGETUP)
	{
	    /* We don't do anything on the upstroke: */
	    MP(("HSC:  Got GADGETUP, doing nothing\n"));
	    return(FALSE);
	}
	else /* (imsg->Class == INTUITICKS) */
	{
	    MP(("HSC:  New TickCount %ld, ", SCID(scgad)->scid_TickCount+1));
	    if (++SCID(scgad)->scid_TickCount <= ARROW_SKIPTICKS)
d260 3
a262 3
		/* Too early for the first repeat: */
		MP(("too early.\n"));
		return(FALSE);
d264 1
a264 1
	    else if (!(gad->Flags & SELECTED))
d266 14
a279 3
		/* The user rolled the mouse off the gadget */
		MP(("Mouse no longer over gadget\n"));
		return(FALSE);
a280 2
	    MP(("going to repeat.\n"));
	}
d282 10
a291 6
	/* User hit up or down gadget: */
	if (gad == SCID(scgad)->scid_Up)
	{
	    /* User hit up gadget: */
	    newtop = SCID(scgad)->scid_Top - 1;
	    if (newtop < 0)
d293 7
a299 1
		newtop = 0;
d301 13
a313 11
	}
	else /* if (gad == SCID(scgad)->scid_Down) */
	{
	    /* User hit down gadget: */
	    newtop = SCID(scgad)->scid_Top + 1;
	    hidden = max(SCID(scgad)->scid_Total - SCID(scgad)->scid_Visible, 0);
	    /* If newtop is so great that the remainder of the list won't even
	     * fill the displayable area, reduce it:
	     */
	    if (newtop > hidden)
	       newtop = hidden;
a314 13
	DP(("HSC:  Vis %ld, newtop %ld, oldtop: %ld\n",
	    (LONG) SCID(scgad)->scid_Visible, (LONG)newtop, (LONG)SCID(scgad)->scid_Top));
	/* Figure out new scroller values, and refresh: */
	FindScrollerValues(SCID(scgad)->scid_Total, SCID(scgad)->scid_Visible, newtop,
	    SCID(scgad)->scid_Body, SCID(scgad)->scid_Pot);
	DP(("HSC:  Body %ld, Pot %ld\n", (LONG)(*SCID(scgad)->scid_Body),
	    (LONG)(*SCID(scgad)->scid_Pot)));
	pi = (struct PropInfo *)SCID(scgad)->scid_Prop->SpecialInfo;
	DP(("HSC:  HPot %ld VPot %ld HBody %ld VBody %ld\n",
	    (LONG)pi->HorizPot, (LONG)pi->VertPot,
	    (LONG)pi->HorizBody, (LONG)pi->VertBody));
	NewModifyProp(SCID(scgad)->scid_Prop, imsg->IDCMPWindow, NULL, pi->Flags,
	    pi->HorizPot, pi->VertPot, pi->HorizBody, pi->VertBody, 1);
d573 1
a573 4
/*/ InstallArrowBorder()
 *
 * Installs an arrow (made of a Border) into a button gadget.
 * Assumes gadget has BorderCompI GadgetRender.
d575 1
a575 2
 * Created:  25-Jan-90, Peter Cherna
 * Modified: 22-Feb-90, Peter Cherna
d579 2
a580 2
void InstallArrowBorder( struct Gadget *gad, struct VisualInfo *vi,
    struct ArrowBorder *arrowborder, LONG direction )
d582 9
a590 85
    struct Rectangle inner;
    WORD temp, *points;

    inner.MinX = LEFTTRIM;
    inner.MinY = TOPTRIM;
    inner.MaxX = gad->Width - 2 - LEFTTRIM;
    inner.MaxY = gad->Height - 1 - TOPTRIM;

    MP(("inner: (%ld,%ld)-(%ld,%ld)\n", inner.MinX, inner.MinY,
	inner.MaxX, inner.MaxY));
    MP(("IAB:  arrowborder at $%lx\n", arrowborder));
    MP(("IAB:  arrowborder->Point[7] at $%lx\n", &arrowborder->Points[7]));
    arrowborder->Border1.BackPen = DESIGNTEXT;
    /* JAM1 == 0, so we don't need to set it: */
/*
    arrowborder->Border1.DrawMode = JAM1;
*/
    arrowborder->Border1.Count = 4;
    points = arrowborder->Border1.XY = arrowborder->Points;
    arrowborder->Border2 = arrowborder->Border1;
    arrowborder->Border2.LeftEdge = 1;
    arrowborder->Border1.NextBorder = &arrowborder->Border2;

    /* GadgetRender is an Image whose ImageData is really a pointer
     * to a struct Border
     */
    arrowborder->Border2.NextBorder = (struct Border *)
	((struct Image *)gad->GadgetRender)->ImageData;
    ((struct Image *)gad->GadgetRender)->ImageData = (APTR) arrowborder;

    MP(("IAB:  before: points at $%lx\n", points));
    switch (direction)
    {
	case ARROW_DOWN:
	    MP(("IAB:  DOWN\n"));
	    /* Reverse MinY and MaxY, and pretend it's an ARROW_UP: */
	    temp = inner.MinY;
	    inner.MinY = inner.MaxY;
	    inner.MaxY = temp;
	    /* and fall through to the next case (no break) */
	case ARROW_UP:
	    MP(("IAB:  UP\n"));
	    *points++ = inner.MinX;
	    *points++ = inner.MaxY;

	    *points++ = (inner.MinX + inner.MaxX) / 2;
	    *points++ = inner.MinY;

	    *points++ = (inner.MinX + inner.MaxX + 1) / 2;
	    *points++ = inner.MinY;

	    *points++ = inner.MaxX;
/** NOTE WELL:  The last post-increment is deliberately missing (optimization) **/
	    *points = inner.MaxY;

	    break;

	case ARROW_RIGHT:
	    MP(("IAB:  RIGHT\n"));
	    /* Reverse MinX and MaxX, and pretend it's an ARROW_LEFT: */
	    temp = inner.MinX;
	    inner.MinX = inner.MaxX;
	    inner.MaxX = temp;
	    /* and fall through to the next case (no break) */
	case ARROW_LEFT:
	    MP(("IAB:  LEFT\n"));
	    *points++ = inner.MaxX;
	    *points++ = inner.MinY;

	    *points++ = inner.MinX;
	    *points++ = (inner.MinY + inner.MaxY) / 2;

	    *points++ = inner.MinX;
	    *points++ = (inner.MinY + inner.MaxY + 1) / 2;

	    *points++ = inner.MaxX;
/** NOTE WELL:  The last post-increment is deliberately missing (optimization) **/
	    *points = inner.MaxY;

	    break;
    }
    MP(("IAB:  after: points at $%lx\n", points));
#ifdef DEBUGGING
    points = arrowborder->Border1.XY;
    for (temp = 0; temp <= 7; temp++)
d592 93
a684 1
	MP(("IAB: Points[%ld] = %ld\n", temp, *points++));
d686 1
a686 1
#endif
d688 2
@


38.3
log
@Uses new space-saving placeGadgetText() function.  As a side consequence,
the underlay gadget is no longer degenerate.  Now attach bevel box to
underlay.  Removed NEWLOOKPROPS conditionals.  Unified PackBoolTags map
with slider.
@
text
@d7 1
a7 1
*   $Id: scroller.c,v 38.2 92/01/28 08:30:04 peter Exp Locker: peter $
a8 49
*   $Log:	scroller.c,v $
 * Revision 38.2  92/01/28  08:30:04  peter
 * Eliminated unneeded "last" post-increment.
 * 
 * Revision 38.1  91/11/27  13:19:19  peter
 * AbleGadget() no longer needs its 'count' parameter.
 * Optimized extraction of instance data.
 * 
 * Revision 38.0  91/07/11  12:34:32  peter
 *  Initial V38 check-in (matches V37 release).
 * 
*   Revision 36.10  91/04/08  13:48:27  peter
*   Arrow buttons no longer turn solid black when highlighted.
*   Where appropriate uses getGTTagData(), getSTRINGTagData(),
*   findGTTagItem(), and findGATagItem() macros/stubs to save space.
*   
*   Revision 36.9  91/03/14  16:06:39  peter
*   Now uses stack-based tags instead of array-based ones when it calls
*   tag-based functions.
*   
*   Revision 36.8  90/11/07  19:42:20  peter
*   Arrows are now wise to the new button gadget imagery stuff.
*   
*   Revision 36.7  90/10/12  19:42:02  peter
*   Replaced initializer of an automatic by some assignments to save space.
*   Calls internal findTagItem() and getTagData() to save space.
*   
*   Revision 36.6  90/05/18  18:32:26  peter
*   Put space immediately before '(' in prototypes to avoid confusing ctags.
*   
*   Revision 36.5  90/05/15  14:18:45  peter
*   Put in conditional code for NEWLOOKPROPS.
*   
*   Revision 36.4  90/04/02  16:12:03  peter
*   GadgetType is now OR'd in.
*   
*   Revision 36.3  90/03/31  06:40:47  peter
*   Some taglist comments changed, minor code cleanup to match.
*   Now use CreateGadgetA() instead of specific Create[xxx]GadgetA().
*   
*   Revision 36.2  90/03/31  00:44:31  peter
*   Added some DP()s.
*   Fixed bug where prop gadget wasn't always refreshed correctly.
*   Uses builtin max().
*   
*   Revision 36.1  90/03/16  14:01:54  peter
*   RCS Clean up.
*   
*
d17 1
a17 1
/*  Function Prototypes: */
d19 1
a19 1
/*  Internal: */
d96 3
a98 4
struct Gadget *CreateScrollerA(struct Gadget *gad, struct NewGadget *ng,
    struct TagItem *taglist)

    {
d110 5
a114 4
    /*  We must create the dummy-gadget first, but we would like to
	use it as the return value, so later we move it to last
	in this piece of gadget-list.  We have to save the value of
	gad before the scroller was allocated: */
d117 1
a117 1
    /*  Create the dummy gadget with the instance data: */
d128 1
a128 1
    /*  Find and fill out the instance data for the scroller: */
d137 2
a139 2
	if (ti->ti_Data == LORIENT_VERT)
	    {
a140 1
	    }
d142 1
d154 2
d157 1
a157 3
	if (SCID(scgad)->scid_Flags & GTPROP_VERTICAL)
	    {
	    /*  Remove height of arrows from scroller height */
d159 3
a161 2
	    /*  Move the arrow to past the bottom of the whole
		scroller package, and then back up by 2*arrowsize */
d164 1
a164 1
	    }
d166 1
a166 1
	    {
a169 1
	    }
d171 1
d189 1
a189 1
    /*  Change the GT_ExtraSize amount: */
d195 1
a195 1
	{
d200 1
a200 1
	/*  Install required blank image structure: */
d209 1
a209 1
	    {
d214 1
a214 1
	    }
d216 1
a216 1
	    {
d221 1
a221 1
	    }
d228 1
a228 1
	/*  Initialize handlers in the SpecialGadget: */
d234 1
a234 1
	}
d237 1
a237 1
	{
d240 1
a240 1
	/*  Yep, we're getting arrows! */
d245 1
a245 1
	    {
d253 1
a253 1
	    }
d255 1
a255 1
	    {
d257 1
a257 1
	    }
d259 1
a259 1
	    {
d261 1
a261 1
	    }
d264 1
a264 1
	    {
a271 1
	    }
d273 1
d276 1
a276 1
	{
d278 4
a281 3
	}
    /*  Move the dummy-gadget to the end of this list, so that
	it is the one that is returned: */
d287 1
a287 1
    }
d301 2
a302 6
BOOL HandleScroller(gad, imsg)

    struct Gadget *gad;
    struct IntuiMessage *imsg;

    {
d312 4
a315 3
	{
	/*  User hit the prop gadget, so find a new value of top based on
	    the new value of Pot:  */
d318 1
a318 1
	}
d320 3
d324 1
a324 3
	if (imsg->Class == GADGETDOWN)
	    {
	    /*  Reset tick counter: */
d327 1
a327 1
	    }
d329 2
a330 2
	    {
	    /*  We don't do anything on the upstroke: */
d333 1
a333 1
	    }
d335 1
a335 1
	    {
d338 2
a339 2
		{
		/*  Too early for the first repeat: */
d342 1
a342 1
		}
d344 2
a345 2
		{
		/*  The user rolled the mouse off the gadget */
d348 1
a348 1
		}
d350 1
a350 1
	    }
d352 1
a352 1
	/*  User hit up or down gadget: */
d354 2
a355 2
	    {
	    /*  User hit up gadget: */
d358 1
a358 1
		{
a359 1
		}
d361 1
d363 2
a364 2
	    {
	    /*  User hit down gadget: */
d367 3
a369 2
	    /*  If newtop is so great that the remainder of the list won't even
		fill the displayable area, reduce it: */
d372 1
a372 1
	    }
d375 1
a375 1
	/*  Figure out new scroller values, and refresh: */
d386 1
a386 1
	}
d389 1
a389 1
	{
d392 2
a393 2
	    {
	    /*  The client wants to hear this always: */
a394 1
	    }
d396 1
d398 1
a398 1
	{
d401 2
a402 2
	    {
	    /*  The client wants to hear this always: */
a403 1
	    }
d405 1
d407 1
a407 1
	{
d409 1
a409 1
	});
d411 3
a413 2
    /*  If we cause a message, we want the code field equal to the
	new level, with the IAddress of the scroller gadget dummy */
d417 1
a417 1
    /*  Only react if the value of top actually changed: */
d421 1
a421 1
	{
d424 4
a427 3
	/*  This will end up being a proper interconnection to
	    the ListView, but for now we call SetListViewAttrs()
	    if this Scroller is part of one: */
d429 1
a429 1
	    {
d437 1
a437 1
	    }
d439 6
a444 5
	    {
	    /*  If this is a GADGETUP or GADGETDOWN and our client doesn't
		want to hear this type, we satisfy him by converting it
		to a MOUSEMOVE, since he MUST hear of every event in which
		the level changed: */
a448 1
	    }
d450 6
a455 4
    /*  The level did not change, so only let the message reach
	the client if it was a GADGETUP or GADGETDOWN and the client
	was interested in that - this condition is reflected by
	the value of hearupdown: */
d459 1
a459 1
    }
d512 3
a514 4
void SetScrollerAttrsA(struct Gadget *gad, struct Window *win,
    struct Requester *req, struct TagItem *taglist)

    {
d538 1
a538 1
    /*  Test for GA_Disabled, set GADGDISABLED and refresh accordingly */
d540 3
a543 3
	/*  If we have arrows, enable/disable those: */
	if (SCID(gad)->scid_Flags & SC_ARROWS)
	    {
a547 1
	    }
d550 1
d567 3
a569 5
void FindScrollerValues(total, displayable, top, body, pot)

    UWORD total, displayable, top;
    UWORD *body, *pot;
    {
d572 1
a572 1
    /*  Find the number of unseen lines: */
d575 3
a577 2
    /*  If top is so great that the remainder of the list won't even
	fill the displayable area, reduce top: */
d582 9
a590 8
    /*  body is the relative size of the proportional gadget's rbody.
        Its size in the container represents the fraction of the total
        that is in view.  If there are no lines hidden, then body
        should be full-size (MAXBODY).  Otherwise, body should be the
        fraction of (the number of displayed lines - 1) over
        (the total number of lines - 1).  The "-1" is so that when the
        user scrolls by clicking in the container of the scroll gadget,
        then there is a one line overlap between the two views. */
d595 7
a601 6
    /*  pot is the position of the proportional gadget body, with zero
        meaning that the scroll gadget is all the way up (or left),
        and full (MAXPOT) meaning that the scroll gadget is all the way
        down (or right).  If we can see all the lines, pot should be zero.
        Otherwise, pot is the top displayed line divided by the number of
	unseen lines. */
d605 1
a605 1
    }
d618 2
a619 7
UWORD FindScrollerTop(total, displayable, pot)

    UWORD total;
    UWORD displayable;
    UWORD pot;

    {
d622 1
a622 1
    /*  Find the number of unseen lines: */
d625 7
a631 6
    /*  pot can be thought of as the fraction of the hidden lines that
	are before the displayed part of the list, in other words a
	pot of zero means all hidden lines are after the displayed
	part of the list (i.e. top = 0), and a pot of MAXPOT means all
	the hidden lines are ahead of the displayed part
	(i.e. top = hidden). */
d634 4
a637 3
    /*  Once you get back the new value of top, only redraw your list
        if top changed from its previous value.  The proportional gadget
        may not have moved far enough to change the value of top. */
d640 1
a640 1
    }
d654 3
a656 8
void InstallArrowBorder(gad, vi, arrowborder, direction)

    struct Gadget *gad;
    struct VisualInfo *vi;
    struct ArrowBorder *arrowborder;
    LONG direction;

    {
d670 1
a670 1
    /*  JAM1 == 0, so we don't need to set it: */
d680 3
a682 2
    /*  GadgetRender is an Image whose ImageData is really a pointer
	to a struct Border */
d689 1
a689 1
	{
d692 1
a692 1
	    /*  Reverse MinY and MaxY, and pretend it's an ARROW_UP: */
d696 1
a696 1
	    /*  and fall through to the next case (no break) */
d716 1
a716 1
	    /*  Reverse MinX and MaxX, and pretend it's an ARROW_LEFT: */
d720 1
a720 1
	    /*  and fall through to the next case (no break) */
d737 1
a737 1
	}
d742 1
a742 1
	{
d744 1
a744 1
	}
d746 1
a746 1
    }
@


38.2
log
@Eliminated unneeded "last" post-increment.
@
text
@d7 1
a7 1
*   $Id: scroller.c,v 38.1 91/11/27 13:19:19 peter Exp Locker: peter $
d10 3
a70 1
void RefreshScroller (struct Window *win, struct Gadget *gad, BOOL refresh);
a151 2
    struct Rectangle rect;
    ULONG place;
d158 1
a158 6
    static struct TagItem boolmap[] =
	{
	GA_IMMEDIATE, SC_GADGETDOWN,
	GA_RELVERIFY, SC_GADGETUP,
	TAG_DONE, 0,
	};
d161 1
a161 1
	return it from CreatePalette(), so later we move it to last
d163 1
a163 1
	gad before the palette was allocated: */
d168 1
a168 4
    mod_ng.ng_Width = 0;
    mod_ng.ng_Height = 0;

    scgad = gad = CreateGenericBase(gad, &mod_ng, SCROLLER_IDATA_SIZE,
d175 1
a175 8
    rect.MinX = 0;
    rect.MaxX = ng->ng_Width - 1;
    rect.MinY = 0;
    rect.MaxY = ng->ng_Height - 1;

    if (!(place = (ng->ng_Flags & PLACETEXT_MASK)))
	place = PLACETEXT_LEFT;
    PlaceIntuiText(gad->GadgetText, &rect, place);
d182 1
a182 1
    SCID(scgad)->scid_Flags = PackBoolTags(NULL, taglist, boolmap);
d189 1
a189 1
	    SCID(scgad)->scid_Flags |= SC_VERTICAL;
d195 1
a195 2
    /*  Copy NewGadget to our own place and make changes: */
    mod_ng = *ng;
a197 11
#ifdef NEWLOOKPROPS
    mod_ng.ng_LeftEdge += 2;
    mod_ng.ng_TopEdge += 1;
    mod_ng.ng_Width -= 4;
    mod_ng.ng_Height -= 2;
#else
    mod_ng.ng_LeftEdge += LEFTTRIM;
    mod_ng.ng_TopEdge += TOPTRIM;
    mod_ng.ng_Width -= LRTRIM;
    mod_ng.ng_Height -= TBTRIM;
#endif
d199 3
d204 1
a204 1
	if (SCID(scgad)->scid_Flags & SC_VERTICAL)
d221 16
d246 1
d256 1
a256 1
	if (SCID(scgad)->scid_Flags & SC_VERTICAL)
a258 3
#ifdef NEWLOOKPROPS
	    pi->Flags = PROPNEWLOOK | AUTOKNOB | PROPBORDERLESS | FREEVERT;
#else
a259 1
#endif
a265 3
#ifdef NEWLOOKPROPS
	    pi->Flags = PROPNEWLOOK | AUTOKNOB | PROPBORDERLESS | FREEHORIZ;
#else
a266 1
#endif
a280 1
	sg->sg_Refresh = RefreshScroller;
d295 1
a295 1
		(SCID(scgad)->scid_Flags & SC_VERTICAL) ? ARROW_UP : ARROW_LEFT);
d297 4
a300 3
	    SG_FROM_GAD(gad)->sg_EventHandler = HandleScroller;
	    SG_FROM_GAD(gad)->sg_Parent = scgad;
	    SG_FROM_GAD(gad)->sg_Flags |= SG_INTUITICKS;
d302 1
a302 1
	if (SCID(scgad)->scid_Flags & SC_VERTICAL)
d314 1
a314 1
		(SCID(scgad)->scid_Flags & SC_VERTICAL) ? ARROW_DOWN : ARROW_RIGHT);
d316 4
a319 3
	    SG_FROM_GAD(gad)->sg_EventHandler = HandleScroller;
	    SG_FROM_GAD(gad)->sg_Parent = scgad;
	    SG_FROM_GAD(gad)->sg_Flags |= SG_INTUITICKS;
a338 41
/*/ RefreshScroller()
 *
 * Function to refresh Scrollers.
 *
 * Created:  30-Aug-89, Peter Cherna
 * Modified: 15-Dec-89, Peter Cherna
 *
 */

void RefreshScroller(win, gad, refresh)

    struct Window *win;
    struct Gadget *gad;
    BOOL refresh;

    {
    MP(("RSc: Gadget at $%lx\n", gad));

    /*  Draw the border around the prop gadget: */
#ifdef NEWLOOKPROPS
    DrawBevelBox(win->RPort,
	(WORD) (gad->LeftEdge - 2),
	(WORD) (gad->TopEdge - 1),
	(WORD) (gad->Width + 4),
	(WORD) (gad->Height + 2),
	GT_VisualInfo, SCID(SG_FROM_GAD(gad)->sg_Parent)->scid_VisualInfo,
	TAG_DONE);
#else
    DrawBevelBox(win->RPort,
	(WORD) (gad->LeftEdge - LEFTTRIM),
	(WORD) (gad->TopEdge - TOPTRIM),
	(WORD) (gad->Width + LRTRIM),
	(WORD) (gad->Height + TBTRIM),
	GT_VisualInfo, SCID(SG_FROM_GAD(gad)->sg_Parent)->scid_VisualInfo,
	TAG_DONE);
#endif
    }


/*------------------------------------------------------------------------*/

d439 1
a439 1
	if (SCID(scgad)->scid_Flags & SC_GADGETDOWN)
d448 1
a448 1
	if (SCID(scgad)->scid_Flags & SC_GADGETUP)
@


38.1
log
@AbleGadget() no longer needs its 'count' parameter.
Optimized extraction of instance data.
@
text
@d7 1
a7 1
*   $Id: scroller.c,v 38.0 91/07/11 12:34:32 peter Exp Locker: peter $
d10 4
d815 2
a816 1
	    *points++ = inner.MaxY;
d839 2
a840 1
	    *points++ = inner.MaxY;
@


38.0
log
@ Initial V38 check-in (matches V37 release).
@
text
@d7 1
a7 1
*   $Id: scroller.c,v 36.10 91/04/08 13:48:27 peter Exp $
d10 3
a144 1
    struct ScrollerIData *scid;
d172 1
a172 1
    scgad = gad = CreateGenericBase(gad, &mod_ng, sizeof(struct ScrollerIData),
d189 3
a191 5
    scid = SCID(gad);
    MP(("CSC: ScrollerIData at $%lx\n", scid));
    scid->sc_Top = getGTTagData(GTSC_Top, 0, taglist);
    scid->sc_Total = getGTTagData(GTSC_Total, 0, taglist);
    scid->sc_Visible = getGTTagData(GTSC_Visible, 2, taglist);
d193 2
a194 2
    scid->sc_Flags = PackBoolTags(NULL, taglist, boolmap);
    scid->sc_VisualInfo = ng->ng_VisualInfo;
d200 1
a200 1
	    scid->sc_Flags |= SC_VERTICAL;
d224 1
a224 1
	if (scid->sc_Flags & SC_VERTICAL)
d242 1
a242 1
    scid->sc_Prop = gad = CreateGenericBase(gad, &mod_ng,
d259 1
a259 1
	if (scid->sc_Flags & SC_VERTICAL)
d267 2
a268 2
	    scid->sc_Pot = &pi->VertPot;
	    scid->sc_Body = &pi->VertBody;
d278 2
a279 2
	    scid->sc_Pot = &pi->HorizPot;
	    scid->sc_Body = &pi->HorizBody;
d283 4
a286 4
	    (LONG)scid->sc_Total, (LONG)scid->sc_Visible, (LONG)scid->sc_Top));
	FindScrollerValues(scid->sc_Total, scid->sc_Visible, scid->sc_Top,
	    scid->sc_Body, scid->sc_Pot);
	DP(("CSC:  Body: %ld, Pot: %ld\n", (LONG)*scid->sc_Body, (LONG)*scid->sc_Pot));
d299 1
a299 1
	scid->sc_Flags |= SC_ARROWS;
d302 1
a302 1
	scid->sc_Up = gad = CreateGadgetA(BUTTON_KIND, gad, &arrow_ng,
d306 2
a307 2
	    InstallArrowBorder(gad, scid->sc_VisualInfo, arrowborder++,
		(scid->sc_Flags & SC_VERTICAL) ? ARROW_UP : ARROW_LEFT);
d313 1
a313 1
	if (scid->sc_Flags & SC_VERTICAL)
d321 1
a321 1
	scid->sc_Down = gad = CreateGadgetA(BUTTON_KIND, gad, &arrow_ng, taglist);
d324 2
a325 2
	    InstallArrowBorder(gad, scid->sc_VisualInfo, arrowborder,
		(scid->sc_Flags & SC_VERTICAL) ? ARROW_DOWN : ARROW_RIGHT);
d374 1
a374 1
	GT_VisualInfo, SCID(SG_FROM_GAD(gad)->sg_Parent)->sc_VisualInfo,
d382 1
a382 1
	GT_VisualInfo, SCID(SG_FROM_GAD(gad)->sg_Parent)->sc_VisualInfo,
a405 1
    struct ScrollerIData *scid = SCID(scgad);
d411 1
a411 1
    MP(("HS: Gadget at $%lx, ScrollerIData at $%lx\n", gad, scid));
d413 1
a413 1
    if (gad == scid->sc_Prop)
d417 2
a418 2
	newtop = FindScrollerTop(scid->sc_Total, scid->sc_Visible,
	    *scid->sc_Pot);
d426 1
a426 1
	    scid->sc_TickCount = 0;
d436 2
a437 2
	    MP(("HSC:  New TickCount %ld, ", scid->sc_TickCount+1));
	    if (++scid->sc_TickCount <= ARROW_SKIPTICKS)
d453 1
a453 1
	if (gad == scid->sc_Up)
d456 1
a456 1
	    newtop = scid->sc_Top - 1;
d462 1
a462 1
	else /* if (gad == scid->sc_Down) */
d465 2
a466 2
	    newtop = scid->sc_Top + 1;
	    hidden = max(scid->sc_Total - scid->sc_Visible, 0);
d473 1
a473 1
	    (LONG) scid->sc_Visible, (LONG)newtop, (LONG)scid->sc_Top));
d475 5
a479 5
	FindScrollerValues(scid->sc_Total, scid->sc_Visible, newtop,
	    scid->sc_Body, scid->sc_Pot);
	DP(("HSC:  Body %ld, Pot %ld\n", (LONG)(*scid->sc_Body),
	    (LONG)(*scid->sc_Pot)));
	pi = (struct PropInfo *)scid->sc_Prop->SpecialInfo;
d483 1
a483 1
	NewModifyProp(scid->sc_Prop, imsg->IDCMPWindow, NULL, pi->Flags,
d490 1
a490 1
	if (scid->sc_Flags & SC_GADGETDOWN)
d499 1
a499 1
	if (scid->sc_Flags & SC_GADGETUP)
d516 1
a516 1
    MP(("HS:  Old top %ld, new top %ld\n", ((LONG)scid->sc_Top),
d518 1
a518 1
    if (newtop != scid->sc_Top)
d520 2
a521 2
	scid->sc_Top = newtop;
	MP(("HS:  New Top Set %ld\n", ((LONG)scid->sc_Top)));
d525 1
a525 1
	if (scid->sc_ListView)
d528 2
a529 2
		imsg->IDCMPWindow, scid->sc_ListView, ((ULONG)newtop)));
	    InternalSetListViewAttrs(scid->sc_ListView, imsg->IDCMPWindow,
a610 1
    struct ScrollerIData *scid = SCID(gad);
d615 3
a617 3
    scid->sc_Total = getGTTagData(GTSC_Total, scid->sc_Total, taglist);
    scid->sc_Visible = getGTTagData(GTSC_Visible, scid->sc_Visible, taglist);
    scid->sc_Top = getGTTagData(GTSC_Top, scid->sc_Top, taglist);
d619 7
a625 7
    DP(("SSAA:  Total %ld, Visible %ld, Top %ld\n", (LONG)scid->sc_Total,
	(LONG)scid->sc_Visible, (LONG)scid->sc_Top));
    FindScrollerValues(scid->sc_Total, scid->sc_Visible, scid->sc_Top,
	scid->sc_Body, scid->sc_Pot);
    DP(("SSAA:  Body %ld, Pot %ld\n", (LONG)(*scid->sc_Body),
	(LONG)(*scid->sc_Pot)));
    pi = (struct PropInfo *)scid->sc_Prop->SpecialInfo;
d627 1
a627 1
	scid->sc_Prop, win, (LONG)pi->Flags));
d631 1
a631 1
    NewModifyProp(scid->sc_Prop, win, NULL, pi->Flags,
d634 2
a635 1
    if (ti = findGATagItem(GA_DISABLED, taglist))
a636 3
	/*  Do a regular enable/disable of the prop gadget: */
	AbleGadget(scid->sc_Prop, win, req, 1, (BOOL)ti->ti_Data);

d638 1
a638 1
	if (scid->sc_Flags & SC_ARROWS)
d642 2
a643 2
	    GT_SetGadgetAttrsA(scid->sc_Up, win, req, buttontags);
	    GT_SetGadgetAttrsA(scid->sc_Down, win, req, buttontags);
@
