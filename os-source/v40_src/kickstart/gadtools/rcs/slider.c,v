head     39.12;
branch   ;
access   ;
symbols  ;
locks    ; strict;
comment  @ * @;


39.12
date     92.10.16.18.23.38;  author vertex;  state Exp;
branches ;
next     39.11;

39.11
date     92.05.29.15.35.02;  author vertex;  state Exp;
branches ;
next     39.10;

39.10
date     92.04.24.10.20.44;  author vertex;  state Exp;
branches ;
next     39.9;

39.9
date     92.04.15.11.33.10;  author vertex;  state Exp;
branches ;
next     39.8;

39.8
date     92.04.13.14.02.39;  author vertex;  state Exp;
branches ;
next     39.7;

39.7
date     92.04.07.13.56.43;  author vertex;  state Exp;
branches ;
next     39.6;

39.6
date     92.03.26.15.16.35;  author peter;  state Exp;
branches ;
next     39.5;

39.5
date     92.03.24.15.15.59;  author peter;  state Exp;
branches ;
next     39.4;

39.4
date     92.02.20.13.56.27;  author peter;  state Exp;
branches ;
next     39.3;

39.3
date     92.02.20.11.51.07;  author peter;  state Exp;
branches ;
next     39.2;

39.2
date     92.02.03.15.50.02;  author peter;  state Exp;
branches ;
next     39.1;

39.1
date     92.01.30.19.54.40;  author peter;  state Exp;
branches ;
next     38.2;

38.2
date     92.01.30.18.09.53;  author peter;  state Exp;
branches ;
next     38.1;

38.1
date     91.11.27.13.18.14;  author peter;  state Exp;
branches ;
next     38.0;

38.0
date     91.07.11.12.33.04;  author peter;  state Exp;
branches ;
next     ;


desc
@@


39.12
log
@Fixed bug in the calculation of the default value for the GTSL_MaxPixelLen
tag. This caused odd clipping of the number display for sliders whenever
the title of the gadget wasn't on the same side of the slider as the
display of its current value.
                                                                          
@
text
@/*** slider.c *************************************************************
*
*   slider.c	- Slider gadget routines
*
*   Copyright 1989, 1990, Commodore-Amiga, Inc.
*
*   $Id: slider.c,v 39.11 92/05/29 15:35:02 vertex Exp Locker: vertex $
*
**************************************************************************/

/*------------------------------------------------------------------------*/

#include "gtinclude.h"

/*------------------------------------------------------------------------*/

/* !!!Note:  In general, the way the labels are positioned presumes that
 * spaces are the same width as numbers in the particular font.
 * Also, two BLTN304 warnings are generated in -rr mode (even though
 * the function that it uses __stdargs for is declared EXPLICITLY
 * that way)
 */

/*------------------------------------------------------------------------*/

/* Function Prototypes: */

/* Internal: */
struct ExtGadget *CreateSliderA (struct ExtGadget *gad, struct NewGadget *ng,
    struct TagItem *taglist);
void RefreshSlider (struct ExtGadget *gad, struct Window *win, BOOL refresh);
BOOL HandleSlider (struct ExtGadget *gad, struct IntuiMessage *imsg);
void SetSliderAttrsA (struct ExtGadget *gad, struct Window *win,
    struct TagItem *taglist);

static void FindSliderValues (UWORD numlevels, UWORD level,
    UWORD *body, UWORD *pot, BOOL invert);
static UWORD FindSliderLevel (UWORD numlevels, UWORD pot, BOOL invert);

/*------------------------------------------------------------------------*/

/* CreateSliderA() */

struct TagItem to_prop_map[] =
{
    GA_IMMEDIATE, GTPROP_GADGETDOWN,
    GA_RELVERIFY, GTPROP_GADGETUP,
    TAG_DONE, 0,
};


/*****************************************************************************/


struct ExtGadget *CreateSliderA(struct ExtGadget *gad, struct NewGadget *ng,
                             struct TagItem *taglist )
{
struct ExtGadget    *preSL, *slgad;
struct NewGadget  mod_ng;
struct TagItem   *ti;
BOOL              displaylevel;
struct Rectangle  rect, gadgetrect, result;
WORD              maxLen;
UWORD             levelPlace;
Point             textsize;
struct TagItem   *maxPixTag;
struct IntuiText *itext;
struct TextFont  *font;

    /* We must create the dummy-gadget first, but we would like to
     * use it as the return value, so later we move it to last
     * in this piece of gadget-list.  We have to save the value of
     * gad before the slider was allocated:
     */
    preSL = gad;

    if (!(slgad = CreateGenericBase(preSL, ng, SLIDER_IDATA_SIZE, taglist)))
    	return(NULL);

    slgad->Flags |= GADGIMAGE|GADGHNONE;

    SGAD(slgad)->sg_SetAttrs = SetSliderAttrsA;
    SGAD(slgad)->sg_GetTable = Slider_GetTable;
    SGAD(slgad)->sg_Refresh  = RefreshSlider;
    SGAD(slgad)->sg_Flags    = SG_EXTRAFREE_DISPOSE;

    if (!(slgad->GadgetRender = getBevelImage(0,0,slgad->Width,slgad->Height,FRAME_BUTTON)))
	return(NULL);

    mod_ng = *ng;
    mod_ng.ng_LeftEdge  += LEFTTRIM;
    mod_ng.ng_TopEdge   += TOPTRIM;
    mod_ng.ng_Width     -= LRTRIM;
    mod_ng.ng_Height    -= TBTRIM;
    mod_ng.ng_GadgetText = NULL;

    displaylevel = (findGTTagItem(GTSL_MaxLevelLen, taglist) &&
	            findGTTagItem(GTSL_LevelFormat, taglist));

    maxLen = getGTTagData(GTSL_MaxLevelLen, 2, taglist);

    if (gad = CreateGenericBase(slgad,&mod_ng, (((displaylevel) ? sizeof(struct IntuiText) +
                                ALIGNSIZE(maxLen + 1) : 0) ),
                                taglist))
    {
	DP(("CS:  gadget at $%lx\n", gad));

	SGAD(gad)->sg_Parent       = slgad;
	SGAD(gad)->sg_EventHandler = HandleSlider;
	SGAD(gad)->sg_Flags        = SG_MOUSEMOVE;

	/* Find and fill out the instance data for the slider: */
	SLID(slgad)->slid_Prop        = gad;
	SLID(slgad)->slid_Flags       = PackBoolTags(NULL, taglist, to_prop_map);
	SLID(slgad)->slid_Max         = 15;
        SLID(slgad)->slid_Extent.MinX = 1;      /* causes an invalid Extent, so first EraseOldExtent() call won't happen */
	if (ti = findTagItem(PGA_FREEDOM, taglist))
	{
	    if (ti->ti_Data == LORIENT_VERT)
	    {
		SLID(slgad)->slid_Flags |= GTPROP_VERTICAL;
	    }
	}

	/* Install required blank image structure: */
	gad->GadgetRender  = (APTR) &SLID(slgad)->slid_PropImage;
	gad->Flags         = GADGHNONE | GADGIMAGE;  /* clears away GFLG_EXTENDED flag */
	gad->Activation    = GADGIMMEDIATE | RELVERIFY | FOLLOWMOUSE;
	gad->GadgetType   |= PROPGADGET;
	gad->SpecialInfo   = (APTR) &SLID(slgad)->slid_PropInfo;

	if (displaylevel)
	{
	    SLID(slgad)->slid_IText            = MEMORY_FOLLOWING(SGAD(gad));
	    SLID(slgad)->slid_IText->FrontPen  = VI(ng->ng_VisualInfo)->vi_textPen;
	    SLID(slgad)->slid_IText->BackPen   = VI(ng->ng_VisualInfo)->vi_backgroundPen;
	    SLID(slgad)->slid_IText->DrawMode  = JAM2;
	    SLID(slgad)->slid_IText->ITextFont = ng->ng_TextAttr;
	    SLID(slgad)->slid_IText->IText     = (STRPTR)MEMORY_FOLLOWING(SLID(slgad)->slid_IText);
	}

	if (SLID(slgad)->slid_Flags & GTPROP_VERTICAL)
	{
	    SLID(slgad)->slid_PropInfo.Flags = AUTOKNOB | PROPBORDERLESS | FREEVERT;
	    SLID(slgad)->slid_Pot            = &SLID(slgad)->slid_PropInfo.VertPot;
	    SLID(slgad)->slid_Body           = &SLID(slgad)->slid_PropInfo.VertBody;
	}
	else
	{
	    SLID(slgad)->slid_PropInfo.Flags = AUTOKNOB | PROPBORDERLESS | FREEHORIZ;
	    SLID(slgad)->slid_Pot            = &SLID(slgad)->slid_PropInfo.HorizPot;
	    SLID(slgad)->slid_Body           = &SLID(slgad)->slid_PropInfo.HorizBody;
	}

	/* Move the dummy-gadget to the end of this list, so that
	 * it is the one that is returned:
	 */
	preSL->NextGadget = slgad->NextGadget;
	gad->NextGadget = slgad;
	slgad->NextGadget = NULL;
	MP(("CSL: Done.\n"));
	gad = slgad;

	SetSliderAttrsA(slgad,NULL,taglist);

        levelPlace = getGTTagData(GTSL_LevelPlace,PLACETEXT_LEFT,taglist);

        placeGadgetText(slgad,ng->ng_Flags,PLACETEXT_LEFT,&rect);

        if (itext = SLID(slgad)->slid_IText)
        {
            if (maxPixTag = findGTTagItem(GTSL_MaxPixelLen,taglist))
            {
                SLID(slgad)->slid_MaxPixelLen = maxPixTag->ti_Data;
                textsize.x = SLID(slgad)->slid_MaxPixelLen;
                textsize.y = ng->ng_TextAttr->ta_YSize;
            }
            else
            {
                if (font = OpenFont(itext->ITextFont))
                {
                    SLID(slgad)->slid_MaxPixelLen = maxLen * font->tf_XSize;
                    CloseFont(font);
                }
                else
                {
                    return(NULL);
                }
                intuiTextSize(itext,&textsize);
            }
            PlaceSizedIntuiText(itext,&rect,levelPlace,&textsize);

            gadgetrect.MinX = slgad->BoundsLeftEdge;
            gadgetrect.MinY = slgad->BoundsTopEdge;
            gadgetrect.MaxX = slgad->BoundsLeftEdge + slgad->BoundsWidth - 1;
            gadgetrect.MaxY = slgad->BoundsTopEdge + slgad->BoundsHeight - 1;

            rect.MinX = slgad->LeftEdge + itext->LeftEdge;
            rect.MinY = slgad->TopEdge + itext->TopEdge;
            rect.MaxX = rect.MinX + textsize.x;
            rect.MaxY = rect.MinY + textsize.y;

            CombineRects(&gadgetrect,&rect,&result);

            slgad->BoundsLeftEdge = result.MinX;
            slgad->BoundsTopEdge  = result.MinY;
            slgad->BoundsWidth    = result.MaxX - result.MinX + 1;
            slgad->BoundsHeight   = result.MaxY - result.MinY + 1;
        }
    }

    return(gad);
}


/*****************************************************************************/


VOID SetSliderAttrsA(struct ExtGadget *slgad, struct Window *win,
                     struct TagItem *taglist)
{
struct ExtGadget *gad;

    SLID(slgad)->slid_DispFunc      = (LONG (*)())getGTTagData(GTSL_DispFunc, (ULONG)SLID(slgad)->slid_DispFunc, taglist);
    SLID(slgad)->slid_Min           = (WORD)getGTTagData(GTSL_Min,SLID(slgad)->slid_Min,taglist);
    SLID(slgad)->slid_Max           = (WORD)getGTTagData(GTSL_Max,SLID(slgad)->slid_Max,taglist);
    SLID(slgad)->slid_Level         = (WORD)getGTTagData(GTSL_Level,SLID(slgad)->slid_Level,taglist);
    SLID(slgad)->slid_LevelFormat   = (STRPTR) getGTTagData(GTSL_LevelFormat,(ULONG)SLID(slgad)->slid_LevelFormat,taglist);
    SLID(slgad)->slid_Justification = getGTTagData(GTSL_Justification,(ULONG)SLID(slgad)->slid_Justification,taglist);

    if (SLID(slgad)->slid_Level > SLID(slgad)->slid_Max)
	SLID(slgad)->slid_Level = SLID(slgad)->slid_Max;

    else if (SLID(slgad)->slid_Level < SLID(slgad)->slid_Min)
	SLID(slgad)->slid_Level = SLID(slgad)->slid_Min;

    FindSliderValues((WORD)(SLID(slgad)->slid_Max - SLID(slgad)->slid_Min + 1),
                     (WORD)(SLID(slgad)->slid_Level - SLID(slgad)->slid_Min),
                     SLID(slgad)->slid_Body, SLID(slgad)->slid_Pot,
                     (BOOL)(SLID(slgad)->slid_Flags & GTPROP_VERTICAL));

    gad = SLID(slgad)->slid_Prop;

    if (win)
        NewModifyProp(gad, win, NULL,
                      SLID(slgad)->slid_PropInfo.Flags,
                      SLID(slgad)->slid_PropInfo.HorizPot,
                      SLID(slgad)->slid_PropInfo.VertPot,
                      SLID(slgad)->slid_PropInfo.HorizBody,
                      SLID(slgad)->slid_PropInfo.VertBody, 1);

    RefreshSlider(slgad, win, FALSE);
    TagAbleGadget(gad, win, taglist);
}


/*****************************************************************************/


/*/ RefreshSlider()
 *
 * Function to refresh the level indicator (if any) beside the slider.
 */

VOID RefreshSlider(struct ExtGadget *slgad, struct Window *win,
                   BOOL refresh )
{
LONG              num;
struct Rectangle  oldExtent;
struct RastPort  *rp;

    if (SLID(slgad)->slid_IText)
    {
	if (SLID(slgad)->slid_DispFunc)
	{
	    LONG __stdargs (*dispfunc)(struct ExtGadget *, WORD);

	    dispfunc = SLID(slgad)->slid_DispFunc;
	    num = (*dispfunc)(slgad, SLID(slgad)->slid_Level);
	    DP(("RL(sl):  level %ld, converted num %ld\n",
		(LONG)SLID(slgad)->slid_Level, num));
	}
	else
	{
	    num = (LONG) SLID(slgad)->slid_Level;
	}
	DP(("RS:  Num = %ld\n", num));
	sprintf(SLID(slgad)->slid_IText->IText, SLID(slgad)->slid_LevelFormat, num);
	DP(("RS:  Formatted label: '%s'\n", SLID(slgad)->slid_IText->IText));

	if (rp = GetRP(slgad,win))
	{
	    oldExtent = SLID(slgad)->slid_Extent;
            printITextToFit(rp,SLID(slgad)->slid_IText,
                            slgad->LeftEdge,slgad->TopEdge,
                            SLID(slgad)->slid_MaxPixelLen,
                            SLID(slgad)->slid_Justification,
                            &SLID(slgad)->slid_Extent);

            if (oldExtent.MaxX > oldExtent.MinX)
                EraseOldExtent(rp,&oldExtent,&SLID(slgad)->slid_Extent);
        }
    }
}


/*****************************************************************************/


/*/ HandleSlider()
 *
 * Function to handle IntuiMessages that relate to sliders.
 *
 * Created:  30-Aug-89, Peter Cherna
 * Modified: 08-Nov-89, Peter Cherna
 *
 */

BOOL HandleSlider(struct ExtGadget *gad, struct IntuiMessage *imsg)
{
    UWORD newlevel;
    BOOL hearupdown = FALSE;
    struct ExtGadget *slgad = SGAD(gad)->sg_Parent;

    DP(("HS: Gadget at $%lx\n", gad));

    /* IAddress for IDCMP_MOUSEMOVE's points to the window even if it
     * was a gadget being FOLLOWMOUSE'd.  We are ok to 'fix' it
     * here since it is our gadget class.
     */
    imsg->IAddress = (APTR) slgad;

    /* Find a new value of level based on the new value of Pot: */
    newlevel = FindSliderLevel((WORD)(SLID(slgad)->slid_Max - SLID(slgad)->slid_Min + 1),
	*SLID(slgad)->slid_Pot, (BOOL)(SLID(slgad)->slid_Flags & GTPROP_VERTICAL)) + SLID(slgad)->slid_Min;

    if (imsg->Class == IDCMP_GADGETDOWN)
    {
	DP(("HS: IDCMP_GADGETDOWN\n"));
	if (SLID(slgad)->slid_Flags & GTPROP_GADGETDOWN)
	{
	    /* The client wants to hear this always: */
	    hearupdown = TRUE;
	}
    }
    else if (imsg->Class == IDCMP_GADGETUP)
    {
	DP(("HS: IDCMP_GADGETUP\n"));
	if (SLID(slgad)->slid_Flags & GTPROP_GADGETUP)
	{
	    /* The client wants to hear this always: */
	    hearupdown = TRUE;
	}

	/* When we get a IDCMP_GADGETUP event, we want the knob to jump to
	 * the nearest integral level
	 */
	FindSliderValues((WORD)(SLID(slgad)->slid_Max - SLID(slgad)->slid_Min + 1),
                         (WORD)(newlevel - SLID(slgad)->slid_Min),
                         SLID(slgad)->slid_Body, SLID(slgad)->slid_Pot,
                         (BOOL)(SLID(slgad)->slid_Flags & GTPROP_VERTICAL));

	NewModifyProp(gad, imsg->IDCMPWindow, NULL,
                      SLID(slgad)->slid_PropInfo.Flags,
	              SLID(slgad)->slid_PropInfo.HorizPot,
                      SLID(slgad)->slid_PropInfo.VertPot,
                      SLID(slgad)->slid_PropInfo.HorizBody,
                      SLID(slgad)->slid_PropInfo.VertBody, 1);
    }
    D(else
    {
	DP(("HS: IDCMP_MOUSEMOVE\n"));
    });

    /* If we cause a message, we want the code field equal to the
     * new level.
     * We just stuffed a WORD into a UWORD, but it's just a carrier.
     * Later if the client copies imsg->Code into a WORD, he'll
     * get his signs back
     */
    imsg->Code = newlevel;

    /* Always react if the value of level actually changed: */
    if (newlevel != SLID(slgad)->slid_Level)
    {
	SLID(slgad)->slid_Level = newlevel;
	RefreshSlider(slgad, imsg->IDCMPWindow, FALSE);

	/* If this is a IDCMP_GADGETUP or IDCMP_GADGETDOWN and our client doesn't
	 * want to hear this type, we satisfy him by converting it
	 * to a IDCMP_MOUSEMOVE, since he MUST hear of every event in which
	 * the level changed:
	 */
	if (!hearupdown)
	    imsg->Class = IDCMP_MOUSEMOVE;
	DP(("HS: Level Changed\n"));
	D(
	    if ((imsg->Class == IDCMP_MOUSEMOVE) &&
		(hearupdown) &&
		(imsg->IAddress != (APTR)slgad))
		DP(("ERROR1: slgad $%lx, win $%lx\n",slgad, imsg->IDCMPWindow));
	);
	return(TRUE);
    }

    /* The level did not change, so only let the message reach
     * the client if it was a IDCMP_GADGETUP or IDCMP_GADGETDOWN and the client
     * was interested in that - this condition is reflected by
     * the value of hearupdown:
     */
    DP((hearupdown ? "HS: Sending message even though level unchanged\n" :
	"HS: Message dropped since level unchanged.\n"));
    D(
	if ((imsg->Class == IDCMP_MOUSEMOVE) &&
	    (hearupdown) &&
	    (imsg->IAddress != (APTR)slgad))
	    DP(("ERROR2: slgad $%lx, win $%lx\n",slgad, imsg->IDCMPWindow));
    );
    return(hearupdown);
}


/*****************************************************************************/


/*/ FindSliderValues()
 *
 * Function to calculate the Body and Pot values of a slider gadget
 * given the two values numlevels and level, representing the
 * number of levels available in the slider, and the current level.
 * For example, a Red, Green, or Blue slider would have (currently)
 * numlevels = 16, level = level of the color (0-15).
 *
 * Created:  13-Sep-89, Peter Cherna
 * Modified: 15-May-90, Peter Cherna
 *
 */

static void FindSliderValues( UWORD numlevels, UWORD level,
                              UWORD *body, UWORD *pot, BOOL invert )
{
    /* body is the relative size of the proportional gadget's body.
     * Clearly, this proportion should be 1 / numlevels.
     */

    if (numlevels > 0)
	(*body) = (MAXBODY) / numlevels;
    else
	(*body) = MAXBODY;

    /* pot is the position of the proportional gadget body, with zero
     *        meaning that the slider is all the way up (or left),
     *        and full (MAXPOT) meaning that the slider is all the way
     *        down (or right).
     *
     * For slider gadgets the derivation is a bit ugly:
     *
     * We illustrate a slider of four levels (0, 1, 2, 3) with the slider
     * at level 2.  The key observation is that pot refers the the leading
     * edge of the knob, and as such MAXPOT is not all the way to the
     * right, but is one body's width left of that.
     *
     * Level:	    0       1       2       3
     *		---------------------------------
     *		|       |       |*******|       |
     *	 	|       |       |*******|       |
     *		|       |       |*******|       |
     *		|       |       |*******|       |
     *		---------------------------------
     *		|               |       |
     *		0              pot    MAXPOT
     *
     * From which we observe that pot = MAXPOT * (level/(numlevels-1))
     *
     */

    if (numlevels > 1)
    {
	(*pot) = (((ULONG)MAXPOT) * level)/(numlevels-1);
    }
    else
    {
	(*pot) = 0;
    }

    if (invert)
    {
	(*pot) = MAXPOT - (*pot);
    }
}


/*------------------------------------------------------------------------*/

/*/ FindSliderLevel()
 *
 * Function to calculate the level of a slider gadget given the
 * total number of levels as well as the HorizPot or VertPot value.
 *
 * Created:  13-Sep-89, Peter Cherna
 * Modified: 15-May-90, Peter Cherna
 */

static UWORD FindSliderLevel( UWORD numlevels, UWORD pot, BOOL invert )
{
    UWORD level;

    /* If you thought the explanation for calculating pot from level was
     * bad, you ain't seen the reverse:
     *
     * We illustrate a 4-level slider (0, 1, 2, 3) with the knob on
     * the transition point between calling it at levels 1 and 2.
     *
     * Level:	    0       1       2       3
     *		---------------------------------
     *	 	|       |    ***|***    |       |
     *		|       |    ***|***    |       |
     *		|       |    ***|***    |       |
     *		|       |    ***|***    |       |
     *		---------------------------------
     *		|           |           |
     *		0          pot        MAXPOT
     *
     * We've already shown that the vertical lines (which represent the
     * natural position of the knob for a given level are:
     *
     * 	pot = MAXPOT * (level/(numlevels-1))
     *
     * and we see that the threshold between level and level-1
     * is half-way between pot(level) and pot(level-1),
     * from which we get
     *
     * 	level = (numlevels-1) * (pot/MAXPOT) + 1/2
     *
     */

    if (numlevels > 1)
    {
	level = (((ULONG)pot) * (numlevels-1) + MAXPOT/2) / MAXPOT;
    }
    else
    {
	level = 0;
    }

    if (invert)
    {
	/* Vertical sliders are inverted wrt. Intuition's idea of
	 * min and max:
	 */
	level = numlevels - 1 - level;
    }
    return(level);
}
@


39.11
log
@Removed requester support
Code optimizations
@
text
@d7 1
a7 1
*   $Id: slider.c,v 39.10 92/04/24 10:20:44 vertex Exp Locker: vertex $
d68 1
d180 9
a188 1
                SLID(slgad)->slid_MaxPixelLen = rect.MaxX - rect.MinX + 1;
@


39.10
log
@Fixed help bounding box positioning
@
text
@d7 1
a7 1
*   $Id: slider.c,v 39.9 92/04/15 11:33:10 vertex Exp Locker: vertex $
d29 1
a29 1
struct Gadget *CreateSliderA (struct Gadget *gad, struct NewGadget *ng,
d31 4
a34 4
void RefreshSlider (struct Gadget *gad, struct Window *win, BOOL refresh);
BOOL HandleSlider (struct Gadget *gad, struct IntuiMessage *imsg);
void SetSliderAttrsA (struct Gadget *gad, struct Window *win,
    struct Requester *req, struct TagItem *taglist);
d55 1
a55 1
struct Gadget *CreateSliderA(struct Gadget *gad, struct NewGadget *ng,
d58 1
a58 1
struct Gadget    *preSL, *slgad;
d115 1
a115 1
        SLID(slgad)->slid_Extent.MinX = 1;      /* causes an invalid Extent, so first ClearOldExtent() call won't happen */
d163 1
a163 1
	SetSliderAttrsA(slgad,NULL,NULL,taglist);
d184 4
a187 4
            gadgetrect.MinX = ((struct ExtGadget *)slgad)->BoundsLeftEdge;
            gadgetrect.MinY = ((struct ExtGadget *)slgad)->BoundsTopEdge;
            gadgetrect.MaxX = ((struct ExtGadget *)slgad)->BoundsLeftEdge + ((struct ExtGadget *)slgad)->BoundsWidth - 1;
            gadgetrect.MaxY = ((struct ExtGadget *)slgad)->BoundsTopEdge + ((struct ExtGadget *)slgad)->BoundsHeight - 1;
d196 4
a199 4
            ((struct ExtGadget *)slgad)->BoundsLeftEdge = result.MinX;
            ((struct ExtGadget *)slgad)->BoundsTopEdge  = result.MinY;
            ((struct ExtGadget *)slgad)->BoundsWidth    = result.MaxX - result.MinX + 1;
            ((struct ExtGadget *)slgad)->BoundsHeight   = result.MaxY - result.MinY + 1;
d210 2
a211 2
VOID SetSliderAttrsA(struct Gadget *slgad, struct Window *win,
                     struct Requester *req, struct TagItem *taglist)
d213 1
a213 1
struct Gadget *gad;
d236 1
a236 1
        NewModifyProp(gad, win, req,
d244 1
a244 1
    TagAbleGadget(gad, win, req, taglist);
d256 1
a256 1
VOID RefreshSlider(struct Gadget *slgad, struct Window *win,
d267 1
a267 1
	    LONG __stdargs (*dispfunc)(struct Gadget *, WORD);
d292 1
a292 1
                ClearOldExtent(rp,&oldExtent,&SLID(slgad)->slid_Extent);
d310 1
a310 1
BOOL HandleSlider(struct Gadget *gad, struct IntuiMessage *imsg)
d314 1
a314 1
    struct Gadget *slgad = SGAD(gad)->sg_Parent;
d318 1
a318 1
    /* IAddress for MOUSEMOVE's points to the window even if it
d328 1
a328 1
    if (imsg->Class == GADGETDOWN)
d330 1
a330 1
	DP(("HS: GADGETDOWN\n"));
d337 1
a337 1
    else if (imsg->Class == GADGETUP)
d339 1
a339 1
	DP(("HS: GADGETUP\n"));
d346 1
a346 1
	/* When we get a GADGETUP event, we want the knob to jump to
d354 1
a354 1
	NewModifyProp(gad, imsg->IDCMPWindow, GetReq(gad, imsg->IDCMPWindow),
d363 1
a363 1
	DP(("HS: MOUSEMOVE\n"));
d380 1
a380 1
	/* If this is a GADGETUP or GADGETDOWN and our client doesn't
d382 1
a382 1
	 * to a MOUSEMOVE, since he MUST hear of every event in which
d386 1
a386 1
	    imsg->Class = MOUSEMOVE;
d389 1
a389 1
	    if ((imsg->Class == MOUSEMOVE) &&
d398 1
a398 1
     * the client if it was a GADGETUP or GADGETDOWN and the client
d405 1
a405 1
	if ((imsg->Class == MOUSEMOVE) &&
@


39.9
log
@Fully implemented gadget help
Optimized code for space
@
text
@d7 1
a7 1
*   $Id: slider.c,v 39.8 92/04/13 14:02:39 vertex Exp Locker: vertex $
d62 1
a62 1
struct Rectangle  rect;
d67 1
a89 1

d168 2
a169 1
        if (maxPixTag = findGTTagItem(GTSL_MaxPixelLen,taglist))
d171 29
a199 9
            SLID(slgad)->slid_MaxPixelLen = maxPixTag->ti_Data;
            textsize.x = SLID(slgad)->slid_MaxPixelLen;
            textsize.y = ng->ng_TextAttr->ta_YSize;
            PlaceSizedIntuiText(SLID(slgad)->slid_IText,&rect,levelPlace,&textsize);
        }
        else
        {
            PlaceIntuiText(SLID(slgad)->slid_IText,&rect,levelPlace);
            SLID(slgad)->slid_MaxPixelLen = rect.MaxX - rect.MinX + 1;
@


39.8
log
@Moved some stuff around to save bytes
Added requester support
@
text
@d7 1
a7 1
*   $Id: slider.c,v 39.7 92/04/07 13:56:43 vertex Exp Locker: vertex $
d78 1
a78 1
    slgad->Flags = GADGIMAGE|GADGHNONE;
d126 1
a126 1
	gad->Flags        |= GADGHNONE | GADGIMAGE;
@


39.7
log
@Cleaned up stuff
CreateXX() now calls SetXX() to save bytes
Added GTSL_MaxPixelLen
GTSL_DispFunc and GTSL_Format can now be passed at SetXX() time
GTSL_Level is now checked at create-time
@
text
@d7 1
a7 1
*   $Id: slider.c,v 39.6 92/03/26 15:16:35 peter Exp Locker: vertex $
d31 1
a31 1
void RefreshSlider (struct Window *win, struct Gadget *gad, BOOL refresh);
d222 1
a222 1
    RefreshSlider(win, slgad, FALSE);
d235 1
a235 1
VOID RefreshSlider(struct Window *win, struct Gadget *slgad,
d238 3
a240 2
LONG num;
struct Rectangle oldExtent;
d261 1
a261 1
	if (win)
d264 1
a264 1
            printITextToFit(win->RPort,SLID(slgad)->slid_IText,
d271 1
a271 1
                ClearOldExtent(win->RPort,&oldExtent,&SLID(slgad)->slid_Extent);
d333 1
a333 1
	NewModifyProp(gad, imsg->IDCMPWindow, NULL,
d357 1
a357 1
	RefreshSlider(imsg->IDCMPWindow, slgad, FALSE);
@


39.6
log
@Uses getBevelImage() instead of MakeBevelBox().
@
text
@d7 1
a7 1
*   $Id: slider.c,v 39.5 92/03/24 15:15:59 peter Exp Locker: peter $
d36 1
a36 1
void FindSliderValues (UWORD numlevels, UWORD level,
d38 1
a38 1
UWORD FindSliderLevel (UWORD numlevels, UWORD pot, BOOL invert);
d51 16
a66 11
struct Gadget *CreateSliderA( struct Gadget *gad, struct NewGadget *ng,
    struct TagItem *taglist )
{
    struct Gadget *preSL, *slgad;
    struct NewGadget mod_ng;
    struct PropInfo *pi;
    struct Image *img;
    struct Rectangle rect;
    LONG num;
    struct TagItem *ti;
    BOOL displaylevel;
d75 1
a75 5
    /* Copy NewGadget to our own place and make changes: */
    mod_ng = *ng;
    slgad = gad = CreateGenericBase(gad, ng, SLIDER_IDATA_SIZE,
	taglist);
    if (!gad)
a76 1
    gad->Flags = GADGIMAGE|GADGHNONE;
d78 1
a78 11
    SGAD(gad)->sg_SetAttrs = SetSliderAttrsA;
    SGAD(gad)->sg_GetTable = Slider_GetTable;
    SGAD(gad)->sg_Refresh = RefreshSlider;
    SGAD(gad)->sg_Flags = SG_EXTRAFREE_DISPOSE;

    if ( !( gad->GadgetRender = getBevelImage( 0, 0, gad->Width, gad->Height, FRAME_BUTTON ) ) )
    {
	return( NULL );
    }

    placeGadgetText( gad, ng->ng_Flags, PLACETEXT_LEFT, &rect );
d80 14
a93 4
    mod_ng.ng_LeftEdge += LEFTTRIM;
    mod_ng.ng_TopEdge += TOPTRIM;
    mod_ng.ng_Width -= LRTRIM;
    mod_ng.ng_Height -= TBTRIM;
d97 3
a99 1
	findGTTagItem(GTSL_LevelFormat, taglist));
d101 3
a103 6
    gad = CreateGenericBase(gad, &mod_ng, (sizeof(struct PropInfo) +
	sizeof(struct Image) +
	((displaylevel) ? sizeof(struct IntuiText) +
	ALIGNSIZE(getGTTagData(GTSL_MaxLevelLen, 2, taglist) + 1) : 0) ),
	taglist);
    if (gad)
d107 4
d112 4
a115 5
	SLID(slgad)->slid_Prop = gad;
	SLID(slgad)->slid_Min = getGTTagData(GTSL_Min, 0, taglist);
	SLID(slgad)->slid_Max = getGTTagData(GTSL_Max, 15, taglist);
	SLID(slgad)->slid_Level = getGTTagData(GTSL_Level, 0, taglist);
	SLID(slgad)->slid_Flags = PackBoolTags(NULL, taglist, to_prop_map);
a122 1
	SLID(slgad)->slid_DispFunc = (LONG (*)())getGTTagData(GTSL_DispFunc, NULL, taglist);
a123 2
	pi = (struct PropInfo *)MEMORY_FOLLOWING(SGAD(gad));
	img = (struct Image *)MEMORY_FOLLOWING(pi);
d125 5
a129 5
	gad->GadgetRender = (APTR) img;
	gad->Flags |= GADGHNONE | GADGIMAGE;
	gad->Activation = GADGIMMEDIATE | RELVERIFY | FOLLOWMOUSE;
	gad->GadgetType |= PROPGADGET;
	gad->SpecialInfo = (APTR) pi;
d133 4
a136 5
	    SLID(slgad)->slid_LevelFormat = (STRPTR) getGTTagData(GTSL_LevelFormat, 0,
		taglist);
	    SLID(slgad)->slid_IText = MEMORY_FOLLOWING(img);
	    SLID(slgad)->slid_IText->FrontPen = VI(ng->ng_VisualInfo)->vi_textPen;
	    SLID(slgad)->slid_IText->DrawMode = JAM2;
d138 1
a138 21
	    SLID(slgad)->slid_IText->IText = (UBYTE *)MEMORY_FOLLOWING(SLID(slgad)->slid_IText);

	    /* Set the label to the correct level */
	    if (SLID(slgad)->slid_DispFunc)
	    {
		LONG __stdargs (*dispfunc)(struct Gadget *, WORD);

		dispfunc = SLID(slgad)->slid_DispFunc;
		num = (*dispfunc)(slgad, SLID(slgad)->slid_Level);
		DP(("CSl:  level %ld, converted num %ld\n",
		    (LONG)SLID(slgad)->slid_Level, num));
	    }
	    else
	    {
		num = (LONG) SLID(slgad)->slid_Level;
	    }

	    sprintf(SLID(slgad)->slid_IText->IText, SLID(slgad)->slid_LevelFormat, num);
	    DP(("CS:  Formatted label: '%s'\n", SLID(slgad)->slid_IText->IText));
	    PlaceIntuiText(SLID(slgad)->slid_IText, &rect,
		getGTTagData(GTSL_LevelPlace, PLACETEXT_LEFT, taglist));
d143 3
a145 3
	    pi->Flags = AUTOKNOB | PROPBORDERLESS | FREEVERT;
	    SLID(slgad)->slid_Pot = &pi->VertPot;
	    SLID(slgad)->slid_Body = &pi->VertBody;
d149 3
a151 3
	    pi->Flags = AUTOKNOB | PROPBORDERLESS | FREEHORIZ;
	    SLID(slgad)->slid_Pot = &pi->HorizPot;
	    SLID(slgad)->slid_Body = &pi->HorizBody;
a152 8
	FindSliderValues((WORD)(SLID(slgad)->slid_Max - SLID(slgad)->slid_Min + 1),
	    (WORD)(SLID(slgad)->slid_Level - SLID(slgad)->slid_Min),
	    SLID(slgad)->slid_Body, SLID(slgad)->slid_Pot, (BOOL)(SLID(slgad)->slid_Flags & GTPROP_VERTICAL));

	/* Initialize handlers in the SpecialGadget: */
	SGAD(gad)->sg_Parent = slgad;
	SGAD(gad)->sg_EventHandler = HandleSlider;
	SGAD(gad)->sg_Flags = SG_MOUSEMOVE;
d162 18
d181 1
d186 43
a228 1
/*------------------------------------------------------------------------*/
d235 2
a236 2
void RefreshSlider( struct Window *win, struct Gadget *slgad,
    BOOL refresh )
d238 2
a239 1
    LONG num;
d259 16
a274 3
	PrintIText(win->RPort, SLID(slgad)->slid_IText, slgad->LeftEdge, slgad->TopEdge);
    }
}
d276 1
a277 1
/*------------------------------------------------------------------------*/
d288 1
a288 1
BOOL HandleSlider( struct Gadget *gad, struct IntuiMessage *imsg )
a290 1
    struct PropInfo *pi;
a301 2
    pi = (struct PropInfo *)gad->SpecialInfo;
	
d328 3
a330 2
	    (WORD)(newlevel - SLID(slgad)->slid_Min),
	    SLID(slgad)->slid_Body, SLID(slgad)->slid_Pot, (BOOL)(SLID(slgad)->slid_Flags & GTPROP_VERTICAL));
d332 6
a337 2
	NewModifyProp(gad, imsg->IDCMPWindow, NULL, pi->Flags,
	    pi->HorizPot, pi->VertPot, pi->HorizBody, pi->VertBody, 1);
d392 1
a392 30
/*------------------------------------------------------------------------*/

void SetSliderAttrsA( struct Gadget *slgad, struct Window *win,
    struct Requester *req, struct TagItem *taglist )
{
    struct PropInfo *pi;
    struct Gadget *gad;

    SLID(slgad)->slid_Min = (WORD)getGTTagData(GTSL_Min, SLID(slgad)->slid_Min, taglist);
    SLID(slgad)->slid_Max = (WORD)getGTTagData(GTSL_Max, SLID(slgad)->slid_Max, taglist);
    SLID(slgad)->slid_Level = (WORD)getGTTagData(GTSL_Level, SLID(slgad)->slid_Level, taglist);

    if (SLID(slgad)->slid_Level > SLID(slgad)->slid_Max)
	SLID(slgad)->slid_Level = SLID(slgad)->slid_Max;
    else if (SLID(slgad)->slid_Level < SLID(slgad)->slid_Min)
	SLID(slgad)->slid_Level = SLID(slgad)->slid_Min;

    FindSliderValues((WORD)(SLID(slgad)->slid_Max - SLID(slgad)->slid_Min + 1),
	(WORD)(SLID(slgad)->slid_Level - SLID(slgad)->slid_Min),
	SLID(slgad)->slid_Body, SLID(slgad)->slid_Pot, (BOOL)(SLID(slgad)->slid_Flags & GTPROP_VERTICAL));

    gad = SLID(slgad)->slid_Prop;
    pi = (struct PropInfo *)gad->SpecialInfo;
    NewModifyProp(gad, win, NULL, pi->Flags,
	pi->HorizPot, pi->VertPot, pi->HorizBody, pi->VertBody, 1);
    RefreshSlider(win, slgad, FALSE);

    /* Test for GA_Disabled, set GADGDISABLED and refresh accordingly */
    TagAbleGadget(gad, win, req, taglist);
}
a394 2
/*------------------------------------------------------------------------*/

d408 2
a409 2
void FindSliderValues( UWORD numlevels, UWORD level,
    UWORD *body, UWORD *pot, BOOL invert )
d473 1
a473 1
UWORD FindSliderLevel( UWORD numlevels, UWORD pot, BOOL invert )
a523 2

/*------------------------------------------------------------------------*/
@


39.5
log
@Supports GetAttrs of GTSL_Min, GTSL_Max, GTSL_Level, and GA_Disabled.
@
text
@d7 1
a7 1
*   $Id: slider.c,v 39.4 92/02/20 13:56:27 peter Exp Locker: peter $
d76 2
a77 4
    gad->Flags = GADGHNONE;
    gad->GadgetRender = MakeBevelBox( &SLID(slgad)->slid_BevelBox,
	0, 0, gad->Width, gad->Height, BB_RAISED,
	ng->ng_VisualInfo );
d81 6
@


39.4
log
@No need to OR stuff into sg_Flags.
@
text
@d7 1
a7 1
*   $Id: slider.c,v 39.3 92/02/20 11:51:07 peter Exp Locker: peter $
d81 1
a342 41
/*i**** gadtools.lib/SetSliderAttrsA *****************************************
*
*   NAME
*	SetSliderAttrs -- Change the attributes of a Slider gadget. (V36)
*
*   SYNOPSIS
*	SetSliderAttrs(win, gad, newlevel, newmin, newmax)
*
*	void SetSliderAttrs(struct Window *, struct Gadget *,
*	    WORD, WORD, WORD);
*
*   FUNCTION
*	Allows the minimum, maximum, and current levels of a slider to
*	be changed.  The Slider will be refreshed accordingly.
*
*   INPUTS
*	win - Pointer to the Window containing the gadget.
*	gad - Pointer to the Slider gadget returned by CreateSlider().
*	newlevel - The desired new level for the slider.
*	newmin - The desired new minimum level for the slider.
*	newmax - The desired new maximum level for the slider.
*
*   RESULT
*	None.
*
*   EXAMPLE
*
*   NOTES
*
*   BUGS
*
*   SEE ALSO
*	CreateSlider()
*
******************************************************************************
*
* Created:  13-Sep-89, Peter Cherna
* Modified:  8-Jan-90, Peter Cherna
*
*/

a503 1

@


39.3
log
@Now account for SpecialGadget fields following gadget.
@
text
@d7 1
a7 1
*   $Id: slider.c,v 39.2 92/02/03 15:50:02 peter Exp Locker: peter $
d177 1
a177 1
	SGAD(gad)->sg_Flags |= SG_MOUSEMOVE;
@


39.2
log
@Deleted obsolete internal autodocs.
Introducing the dummy gadget meant that slider msgs emanated from
the wrong place, in some cases.
@
text
@d7 1
a7 1
*   $Id: slider.c,v 39.1 92/01/30 19:54:40 peter Exp Locker: peter $
a57 1
    struct SpecialGadget *sg;
d80 2
a81 3
    sg = SG_FROM_GAD(gad);
    sg->sg_SetAttrs = SetSliderAttrsA;
    sg->sg_Refresh = RefreshSlider;
d118 1
a118 1
	pi = (struct PropInfo *)MEMORY_FOLLOWING(gad);
d175 3
a177 4
	sg = SG_FROM_GAD(gad);
	sg->sg_Parent = slgad;
	sg->sg_EventHandler = HandleSlider;
	sg->sg_Flags |= SG_MOUSEMOVE;
d243 1
a243 1
    struct Gadget *slgad = SG_FROM_GAD(gad)->sg_Parent;
@


39.1
log
@Removed RCS log.  Re-did braces, comments, and function headers.
Bumped to V39.
@
text
@d7 1
a7 1
*   $Id: slider.c,v 38.2 92/01/30 18:09:53 peter Exp Locker: peter $
d42 1
a42 65
/*i**** gadtools.library/CreateSliderA ***************************************
*
*   NAME
*	CreateSliderA -- Create a slider (level) gadget. (V36)
*
*   SYNOPSIS
*	gad = CreateSliderA(previous, gad, taglist)
*
*	struct Gadget *CreateSliderA(struct Gadget *, struct NewGadget *,
*	    struct TagItem *);
*
*   FUNCTION
*	Creates a slider gadget according to the supplied NewGadget
*	structure and tags.
*
*   INPUTS
*	previous - Pointer to the previous gadget.
*	ng - Pointer to an initialized NewGadget structure that describes
*	    the desired gadget.
*	taglist - Pointer to a TagItem list.
*
*   TAGS
*	GTSL_Min (WORD) - Minimum level for slider (default 0).
*	GTSL_Max (WORD) - Maximum level for slider (default 15).
*	GTSL_Level (WORD) - Current level of slider (default 0).
*	GTSL_MaxLevelLen (WORD) - Max. length of level string when rendered.
*	GTSL_LevelFormat (STRPTR) - C-Style formatting string.  Be sure to
*	    use the 'l' (long) modifier.
*	GTSL_LevelPlace - One of PLACETEXT_LEFT, PLACETEXT_RIGHT,
*	    PLACETEXT_ABOVE, or PLACETEXT_BELOW, indicating where the level
*	    indicator is to go (default to PLACETEXT_LEFT).
*	GTSL_DispFunc ( (*LONG)() ) - Function to calculate level to be
*	    displayed.  A number-of-colors slider might want to set the slider
*	    up to think depth, and have a (1 << n) function here.  Defaults
*	    to none.  Your function must take a pointer to gadget as the
*	    first parameter, the level (WORD) as the second, and return
*	    the result as a LONG.
*
*	PGA_FREEDOM - Set to LORIENT_VERT or LORIENT_HORIZ (default).
*	GA_IMMEDIATE (BOOL) - Hear every GADGETDOWN event (default FALSE).
*	GA_RELVERIFY (BOOL) - Hear every GADGETUP even (default FALSE).
*
*   RESULT
*	gad - Pointer to the resulting slider gadget, or NULL if failure or
*	    if previous was NULL.
*
*   EXAMPLE
*
*   NOTES
*	These attributes may be changed by calling GT_SetGadgetAttrsA():
*	GTSL_Min (WORD) - Minimum level for slider.
*	GTSL_Max (WORD) - Maximum level for slider.
*	GTSL_Level (WORD) - Current level of slider.
*
*   BUGS
*
*   SEE ALSO
*	CreateGadgetA(), GT_SetGadgetAttrsA()
*
******************************************************************************
*
* Created:  13-Sep-89, Peter Cherna
* Modified: 26-Jan-90, Peter Cherna
*
*/
d250 6
a308 5
	/* IAddress for MOUSEMOVE's points to the window even if it
	 * was a gadget being FOLLOWMOUSE'd.  We are ok to 'fix' it
	 * here since it is our gadget class.
	 */
	imsg->IAddress = (APTR) slgad;
@


38.2
log
@Removed NEWLOOKPROPS conditionals.  Added an underlay gadget.  Unified
PackBoolTags map with scroller.
@
text
@d7 1
a7 1
*   $Id: slider.c,v 38.1 91/11/27 13:18:14 peter Exp Locker: peter $
a8 47
*   $Log:	slider.c,v $
 * Revision 38.1  91/11/27  13:18:14  peter
 * AbleGadget() no longer has a 'count' parameter.
 * Optimized extraction of instance data.
 * 
 * Revision 38.0  91/07/11  12:33:04  peter
 *  Initial V38 check-in (matches V37 release).
 * 
*   Revision 36.11  91/04/08  13:26:16  peter
*   Where appropriate uses getGTTagData(), getSTRINGTagData(),
*   findGTTagItem(), and findGATagItem() macros/stubs to save space.
*   
*   Revision 36.10  91/03/14  16:06:15  peter
*   Now uses stack-based tags instead of array-based ones when it calls
*   tag-based functions.
*   
*   Revision 36.9  90/10/12  19:42:15  peter
*   Replaced initializer of an automatic by some assignments to save space.
*   Calls internal findTagItem() and getTagData() to save space.
*   
*   Revision 36.8  90/05/30  13:51:59  peter
*   Doesn't include <stdio.h> anymore.
*   
*   Revision 36.7  90/05/18  18:32:54  peter
*   Put space immediately before '(' in prototypes to avoid confusing ctags.
*   
*   Revision 36.6  90/05/15  14:19:20  peter
*   Put in conditional code for NEWLOOKPROPS.
*   Vertical sliders now have their minimum at the bottom and their maximum
*   at the top.
*   
*   Revision 36.5  90/04/06  00:56:36  peter
*   Slider now jumps to the nearest integral level when you let it go.
*   
*   Revision 36.4  90/04/02  16:12:26  peter
*   GadgetType is now OR'd in.
*   
*   Revision 36.3  90/03/31  06:42:34  peter
*   Now use CreateGadgetA() instead of specific Create[xxx]GadgetA().
*   
*   Revision 36.2  90/03/31  00:45:19  peter
*   Fixed bug where prop gadget wasn't always refreshed correctly.
*   
*   Revision 36.1  90/03/16  14:03:43  peter
*   RCS Clean up.
*   
*
d18 5
a22 4
   spaces are the same width as numbers in the particular font.
   Also, two BLTN304 warnings are generated in -rr mode (even though
   the function that it uses __stdargs for is declared EXPLICITLY
   that way) */
d26 1
a26 1
/*  Function Prototypes: */
d28 1
a28 1
/*  Internal: */
d109 1
a109 1
    {
d113 1
a113 4
    };

struct Gadget *CreateSliderA(struct Gadget *gad, struct NewGadget *ng,
    struct TagItem *taglist)
d115 3
a117 1
    {
d135 1
a135 1
    /*  Copy NewGadget to our own place and make changes: */
d166 1
a166 1
	{
d169 1
a169 1
	/*  Find and fill out the instance data for the slider: */
d176 2
a178 2
	    if (ti->ti_Data == LORIENT_VERT)
		{
a179 1
		}
d181 1
d186 1
a186 1
	/*  Install required blank image structure: */
d194 1
a194 1
	    {
d203 1
a203 1
	    /*  Set the label to the correct level */
d205 1
a205 1
		{
d212 1
a212 1
		}
d214 1
a214 1
		{
d216 1
a216 1
		}
d222 1
a222 1
	    }
d225 1
a225 1
	    {
d229 1
a229 1
	    }
d231 1
a231 1
	    {
d235 1
a235 1
	    }
d240 1
a240 1
	/*  Initialize handlers in the SpecialGadget: */
d254 1
a254 1
	}
d256 1
a256 1
    }
d266 3
a268 7
void RefreshSlider(win, slgad, refresh)

    struct Window *win;
    struct Gadget *slgad;
    BOOL refresh;

    {
d272 2
a274 2
	if (SLID(slgad)->slid_DispFunc)
	    {
d281 1
a281 1
	    }
d283 1
a283 1
	    {
d285 1
a285 1
	    }
a289 1
	}
d291 1
d305 2
a306 6
BOOL HandleSlider(gad, imsg)

    struct Gadget *gad;
    struct IntuiMessage *imsg;

    {
d316 1
a316 1
    /*  Find a new value of level based on the new value of Pot: */
d321 1
a321 1
	{
d324 2
a325 2
	    {
	    /*  The client wants to hear this always: */
a326 1
	    }
d328 1
d330 1
a330 1
	{
d333 2
a334 2
	    {
	    /*  The client wants to hear this always: */
d336 1
a336 1
	    }
d338 3
a340 2
	/*  When we get a GADGETUP event, we want the knob to jump to
	    the nearest integral level */
d347 1
a347 1
	}
d349 1
a349 1
	{
d351 1
a351 1
	});
d353 6
a358 5
    /*  If we cause a message, we want the code field equal to the
	new level */
    /*  We just stuffed a WORD into a UWORD, but it's just a carrier.
	Later if the client copies imsg->Code into a WORD, he'll
	get his signs back */
d361 1
a361 1
    /*  Always react if the value of level actually changed: */
d363 1
a363 1
	{
d367 4
a370 3
	/*  IAddress for MOUSEMOVE's points to the window even if it
	    was a gadget being FOLLOWMOUSE'd.  We are ok to 'fix' it
	    here since it is our gadget class. */
d372 5
a376 4
	/*  If this is a GADGETUP or GADGETDOWN and our client doesn't
	    want to hear this type, we satisfy him by converting it
	    to a MOUSEMOVE, since he MUST hear of every event in which
	    the level changed: */
d387 1
a387 1
	}
d389 5
a393 4
    /*  The level did not change, so only let the message reach
	the client if it was a GADGETUP or GADGETDOWN and the client
	was interested in that - this condition is reflected by
	the value of hearupdown: */
d403 1
a403 1
    }
d449 3
a451 4
void SetSliderAttrsA(struct Gadget *slgad, struct Window *win,
    struct Requester *req, struct TagItem *taglist)

    {
d474 1
a474 1
    /*  Test for GA_Disabled, set GADGDISABLED and refresh accordingly */
d476 1
a476 1
    }
d494 6
a499 9
void FindSliderValues(numlevels, level, body, pot, invert)

    UWORD numlevels, level;
    UWORD *body, *pot;
    BOOL invert;

    {
    /*  body is the relative size of the proportional gadget's body.
	Clearly, this proportion should be 1 / numlevels. */
d506 25
a530 24
    /*  pot is the position of the proportional gadget body, with zero
        meaning that the slider is all the way up (or left),
        and full (MAXPOT) meaning that the slider is all the way
        down (or right).

	For slider gadgets the derivation is a bit ugly:

	We illustrate a slider of four levels (0, 1, 2, 3) with the slider
	at level 2.  The key observation is that pot refers the the leading
	edge of the knob, and as such MAXPOT is not all the way to the
	right, but is one body's width left of that.

	Level:	    0       1       2       3
		---------------------------------
		|       |       |*******|       |
		|       |       |*******|       |
		|       |       |*******|       |
		|       |       |*******|       |
		---------------------------------
		|               |       |
        	0              pot    MAXPOT

	From which we observe that pot = MAXPOT * (level/(numlevels-1))
	*/
d533 1
a533 1
	{
d535 1
a535 1
	}
d537 1
a537 1
	{
d539 1
a539 1
	}
d542 1
a542 1
	{
a543 1
	}
d545 1
d559 2
a560 7
UWORD FindSliderLevel(numlevels, pot, invert)

    UWORD numlevels;
    UWORD pot;
    BOOL invert;

    {
d563 28
a590 28
    /*  If you thought the explanation for calculating pot from level was
	bad, you ain't seen the reverse:

	We illustrate a 4-level slider (0, 1, 2, 3) with the knob on
	the transition point between calling it at levels 1 and 2.

	Level:	    0       1       2       3
		---------------------------------
		|       |    ***|***    |       |
		|       |    ***|***    |       |
		|       |    ***|***    |       |
		|       |    ***|***    |       |
		---------------------------------
		|           |           |
	        0          pot        MAXPOT


	We've already shown that the vertical lines (which represent the
	natural position of the knob for a given level are:

		pot = MAXPOT * (level/(numlevels-1))

	and we see that the threshold between level and level-1
	is half-way between pot(level) and pot(level-1),
	from which we get

		level = (numlevels-1) * (pot/MAXPOT) + 1/2
    */
d593 1
a593 1
	{
d595 1
a595 1
	}
d597 1
a597 1
	{
d599 1
a599 1
	}
d602 4
a605 3
	{
	/*  Vertical sliders are inverted wrt. Intuition's idea of
	    min and max: */
d607 1
a607 1
	}
d609 1
a609 1
    }
@


38.1
log
@AbleGadget() no longer has a 'count' parameter.
Optimized extraction of instance data.
@
text
@d7 1
a7 1
*   $Id: slider.c,v 38.0 91/07/11 12:33:04 peter Exp Locker: peter $
d10 4
a81 1
void RefreshLevel (struct Window *win, struct Gadget *gad);
d154 7
d165 1
a171 1
    ULONG place;
d175 6
a180 6
    static struct TagItem boolmap[] =
	{
	GA_IMMEDIATE, SL_GADGETDOWN,
	GA_RELVERIFY, SL_GADGETUP,
	TAG_DONE, 0,
	};
d184 14
a197 6
#ifdef NEWLOOKPROPS
    mod_ng.ng_LeftEdge += 2;
    mod_ng.ng_TopEdge += 1;
    mod_ng.ng_Width -= 4;
    mod_ng.ng_Height -= 2;
#else
d202 1
a202 1
#endif
d207 2
a208 2
    gad = CreateGenericBase(gad, &mod_ng, ( SLIDER_IDATA_SIZE +
	sizeof(struct PropInfo) + sizeof(struct Image) +
d217 5
a221 4
	SLID(gad)->slid_Min = getGTTagData(GTSL_Min, 0, taglist);
	SLID(gad)->slid_Max = getGTTagData(GTSL_Max, 15, taglist);
	SLID(gad)->slid_Level = getGTTagData(GTSL_Level, 0, taglist);
	SLID(gad)->slid_Flags = PackBoolTags(NULL, taglist, boolmap);
d226 1
a226 1
		SLID(gad)->slid_Flags |= SL_VERTICAL;
d229 1
a229 2
	SLID(gad)->slid_DispFunc = (LONG (*)())getGTTagData(GTSL_DispFunc, NULL, taglist);
	SLID(gad)->slid_VisualInfo = ng->ng_VisualInfo;
d231 1
a231 1
	pi = (struct PropInfo *)MEMORY_FOLLOWING(SLID(gad));
a239 17
	/*  This is the "extent" to the gadget visuals from the actual
	    gadget upper left: */
#ifdef NEWLOOKPROPS
	rect.MinX = - 2;
	rect.MinY = - 1;
	rect.MaxX = mod_ng.ng_Width + 1;
	rect.MaxY = mod_ng.ng_Height;
#else
	rect.MinX = - (LEFTTRIM);
	rect.MinY = - (TOPTRIM);
	rect.MaxX = mod_ng.ng_Width + (LEFTTRIM - 1);
	rect.MaxY = mod_ng.ng_Height + (TOPTRIM - 1);
#endif
	if (!(place = (mod_ng.ng_Flags & PLACETEXT_MASK)))
	    place = PLACETEXT_LEFT;
	PlaceIntuiText(gad->GadgetText, &rect, place);

d242 1
a242 1
	    SLID(gad)->slid_LevelFormat = (STRPTR) getGTTagData(GTSL_LevelFormat, 0,
d244 5
a248 5
	    SLID(gad)->slid_IText = MEMORY_FOLLOWING(img);
	    SLID(gad)->slid_IText->FrontPen = VI(ng->ng_VisualInfo)->vi_textPen;
	    SLID(gad)->slid_IText->DrawMode = JAM2;
	    SLID(gad)->slid_IText->ITextFont = ng->ng_TextAttr;
	    SLID(gad)->slid_IText->IText = (UBYTE *)MEMORY_FOLLOWING(SLID(gad)->slid_IText);
d251 1
a251 1
	    if (SLID(gad)->slid_DispFunc)
d255 2
a256 2
		dispfunc = SLID(gad)->slid_DispFunc;
		num = (*dispfunc)(gad, SLID(gad)->slid_Level);
d258 1
a258 1
		    (LONG)SLID(gad)->slid_Level, num));
d262 1
a262 1
		num = (LONG) SLID(gad)->slid_Level;
d265 4
a268 4
	    sprintf(SLID(gad)->slid_IText->IText, SLID(gad)->slid_LevelFormat, num);
	    DP(("CS:  Formatted label: '%s'\n", SLID(gad)->slid_IText->IText));
	    place = getGTTagData(GTSL_LevelPlace, PLACETEXT_LEFT, taglist);
	    PlaceIntuiText(SLID(gad)->slid_IText, &rect, place);
d270 2
a271 2

	if (SLID(gad)->slid_Flags & SL_VERTICAL)
a272 3
#ifdef NEWLOOKPROPS
	    pi->Flags = PROPNEWLOOK | AUTOKNOB | PROPBORDERLESS | FREEVERT;
#else
d274 2
a275 3
#endif
	    SLID(gad)->slid_Pot = &pi->VertPot;
	    SLID(gad)->slid_Body = &pi->VertBody;
a278 3
#ifdef NEWLOOKPROPS
	    pi->Flags = PROPNEWLOOK | AUTOKNOB | PROPBORDERLESS | FREEHORIZ;
#else
d280 2
a281 3
#endif
	    SLID(gad)->slid_Pot = &pi->HorizPot;
	    SLID(gad)->slid_Body = &pi->HorizBody;
d283 3
a285 3
	FindSliderValues((WORD)(SLID(gad)->slid_Max - SLID(gad)->slid_Min + 1),
	    (WORD)(SLID(gad)->slid_Level - SLID(gad)->slid_Min),
	    SLID(gad)->slid_Body, SLID(gad)->slid_Pot, (BOOL)(SLID(gad)->slid_Flags & SL_VERTICAL));
d289 1
a290 2
	sg->sg_Refresh = RefreshSlider;
	sg->sg_SetAttrs = SetSliderAttrsA;
d292 9
d310 1
a310 5
 * Function to refresh Sliders.
 *
 * Created:  13-Sep-89, Peter Cherna
 * Modified: 15-Dec-89, Peter Cherna
 *
d313 1
a313 1
void RefreshSlider(win, gad, refresh)
d316 1
a316 1
    struct Gadget *gad;
a319 42
    DP(("RS: Gadget at $%lx\n", gad));

    /*  Draw the border around the prop gadget: */
#ifdef NEWLOOKPROPS
    DrawBevelBox(win->RPort,
	(WORD) (gad->LeftEdge - 2),
	(WORD) (gad->TopEdge - 1),
	(WORD) (gad->Width + 4),
	(WORD) (gad->Height + 2),
	GT_VisualInfo, SLID(gad)->slid_VisualInfo,
	TAG_DONE);
#else
    DrawBevelBox(win->RPort,
	(WORD) (gad->LeftEdge - LEFTTRIM),
	(WORD) (gad->TopEdge - TOPTRIM),
	(WORD) (gad->Width + LRTRIM),
	(WORD) (gad->Height + TBTRIM),
	GT_VisualInfo, SLID(gad)->slid_VisualInfo,
	TAG_DONE);
#endif

    RefreshLevel(win, gad);
    }


/*------------------------------------------------------------------------*/

/*/ RefreshLevel()
 *
 * Function to refresh the level indicator (if any) beside the slider.
 *
 * Created:  18-Oct-89, Peter Cherna (from RefreshSlider())
 * Modified: 19-Nov-89, Peter Cherna
 *
 */

void RefreshLevel(win, gad)

    struct Window *win;
    struct Gadget *gad;

    {
d322 1
a322 1
    if (SLID(gad)->slid_IText)
d324 1
a324 1
	if (SLID(gad)->slid_DispFunc)
d328 2
a329 2
	    dispfunc = SLID(gad)->slid_DispFunc;
	    num = (*dispfunc)(gad, SLID(gad)->slid_Level);
d331 1
a331 1
		(LONG)SLID(gad)->slid_Level, num));
d335 1
a335 1
	    num = (LONG) SLID(gad)->slid_Level;
d338 3
a340 3
	sprintf(SLID(gad)->slid_IText->IText, SLID(gad)->slid_LevelFormat, num);
	DP(("RS:  Formatted label: '%s'\n", SLID(gad)->slid_IText->IText));
	PrintIText(win->RPort, SLID(gad)->slid_IText, gad->LeftEdge, gad->TopEdge);
d365 1
d372 2
a373 2
    newlevel = FindSliderLevel((WORD)(SLID(gad)->slid_Max - SLID(gad)->slid_Min + 1),
	*SLID(gad)->slid_Pot, (BOOL)(SLID(gad)->slid_Flags & SL_VERTICAL)) + SLID(gad)->slid_Min;
d378 1
a378 1
	if (SLID(gad)->slid_Flags & SL_GADGETDOWN)
d387 1
a387 1
	if (SLID(gad)->slid_Flags & SL_GADGETUP)
d395 3
a397 3
	FindSliderValues((WORD)(SLID(gad)->slid_Max - SLID(gad)->slid_Min + 1),
	    (WORD)(newlevel - SLID(gad)->slid_Min),
	    SLID(gad)->slid_Body, SLID(gad)->slid_Pot, (BOOL)(SLID(gad)->slid_Flags & SL_VERTICAL));
d415 1
a415 1
    if (newlevel != SLID(gad)->slid_Level)
d417 2
a418 2
	SLID(gad)->slid_Level = newlevel;
	RefreshLevel(imsg->IDCMPWindow, gad);
d423 1
a423 1
	imsg->IAddress = (APTR) gad;
d434 2
a435 2
		(imsg->IAddress != (APTR)gad))
		DP(("ERROR1: gad $%lx, win $%lx\n",gad, imsg->IDCMPWindow));
d449 2
a450 2
	    (imsg->IAddress != (APTR)gad))
	    DP(("ERROR2: gad $%lx, win $%lx\n",gad, imsg->IDCMPWindow));
d499 1
a499 1
void SetSliderAttrsA(struct Gadget *gad, struct Window *win,
d504 1
a504 4

    SLID(gad)->slid_Min = (WORD)(LONG)getGTTagData(GTSL_Min, SLID(gad)->slid_Min, taglist);
    SLID(gad)->slid_Max = (WORD)(LONG)getGTTagData(GTSL_Max, SLID(gad)->slid_Max, taglist);
    SLID(gad)->slid_Level = (WORD)(LONG)getGTTagData(GTSL_Level, SLID(gad)->slid_Level, taglist);
d506 3
a508 4
    if (SLID(gad)->slid_Level > SLID(gad)->slid_Max)
	SLID(gad)->slid_Level = SLID(gad)->slid_Max;
    else if (SLID(gad)->slid_Level < SLID(gad)->slid_Min)
	SLID(gad)->slid_Level = SLID(gad)->slid_Min;
d510 8
a517 3
    FindSliderValues((WORD)(SLID(gad)->slid_Max - SLID(gad)->slid_Min + 1),
	(WORD)(SLID(gad)->slid_Level - SLID(gad)->slid_Min),
	SLID(gad)->slid_Body, SLID(gad)->slid_Pot, (BOOL)(SLID(gad)->slid_Flags & SL_VERTICAL));
d519 1
d523 1
a523 1
    RefreshLevel(win, gad);
@


38.0
log
@ Initial V38 check-in (matches V37 release).
@
text
@d7 1
a7 1
*   $Id: slider.c,v 36.11 91/04/08 13:26:16 peter Exp $
d10 3
d78 1
a78 2
void RefreshLevel (struct Window *win, struct Gadget *gad,
    struct SliderIData *sl);
a157 1
    struct SliderIData *sl;
d189 1
a189 1
    gad = CreateGenericBase(gad, &mod_ng, ( sizeof(struct SliderIData) +
d199 4
a202 6
	sl = SLID(gad);
	DP(("CS: SliderIData at $%lx\n", sl));
	sl->sl_Min = getGTTagData(GTSL_Min, 0, taglist);
	sl->sl_Max = getGTTagData(GTSL_Max, 15, taglist);
	sl->sl_Level = getGTTagData(GTSL_Level, 0, taglist);
	sl->sl_Flags = PackBoolTags(NULL, taglist, boolmap);
d207 1
a207 1
		sl->sl_Flags |= SL_VERTICAL;
d210 2
a211 2
	sl->sl_DispFunc = (LONG (*)())getGTTagData(GTSL_DispFunc, NULL, taglist);
	sl->sl_VisualInfo = ng->ng_VisualInfo;
d213 1
a213 1
	pi = (struct PropInfo *)MEMORY_FOLLOWING(sl);
d241 1
a241 1
	    sl->sl_LevelFormat = (STRPTR) getGTTagData(GTSL_LevelFormat, 0,
d243 5
a247 5
	    sl->sl_IText = MEMORY_FOLLOWING(img);
	    sl->sl_IText->FrontPen = VI(ng->ng_VisualInfo)->vi_textPen;
	    sl->sl_IText->DrawMode = JAM2;
	    sl->sl_IText->ITextFont = ng->ng_TextAttr;
	    sl->sl_IText->IText = (UBYTE *)MEMORY_FOLLOWING(sl->sl_IText);
d250 1
a250 1
	    if (sl->sl_DispFunc)
d254 2
a255 2
		dispfunc = sl->sl_DispFunc;
		num = (*dispfunc)(gad, sl->sl_Level);
d257 1
a257 1
		    (LONG)sl->sl_Level, num));
d261 1
a261 1
		num = (LONG) sl->sl_Level;
d264 2
a265 2
	    sprintf(sl->sl_IText->IText, sl->sl_LevelFormat, num);
	    DP(("CS:  Formatted label: '%s'\n", sl->sl_IText->IText));
d267 1
a267 1
	    PlaceIntuiText(sl->sl_IText, &rect, place);
d270 1
a270 1
	if (sl->sl_Flags & SL_VERTICAL)
d277 2
a278 2
	    sl->sl_Pot = &pi->VertPot;
	    sl->sl_Body = &pi->VertBody;
d287 2
a288 2
	    sl->sl_Pot = &pi->HorizPot;
	    sl->sl_Body = &pi->HorizBody;
d290 3
a292 3
	FindSliderValues((WORD)(sl->sl_Max - sl->sl_Min + 1),
	    (WORD)(sl->sl_Level - sl->sl_Min),
	    sl->sl_Body, sl->sl_Pot, (BOOL)(sl->sl_Flags & SL_VERTICAL));
d323 1
a323 1
    struct SliderIData *sl = SLID(gad);
a324 2
    DP(("RS: Gadget at $%lx, SliderIData at $%lx\n", gad, sl));

d332 1
a332 1
	GT_VisualInfo, sl->sl_VisualInfo,
d340 1
a340 1
	GT_VisualInfo, sl->sl_VisualInfo,
d344 1
a344 1
    RefreshLevel(win, gad, sl);
d359 1
a359 1
void RefreshLevel(win, gad, sl)
a362 1
    struct SliderIData *sl;
d367 1
a367 1
    if (sl->sl_IText)
d369 1
a369 1
	if (sl->sl_DispFunc)
d373 2
a374 2
	    dispfunc = sl->sl_DispFunc;
	    num = (*dispfunc)(gad, sl->sl_Level);
d376 1
a376 1
		(LONG)sl->sl_Level, num));
d380 1
a380 1
	    num = (LONG) sl->sl_Level;
d383 3
a385 3
	sprintf(sl->sl_IText->IText, sl->sl_LevelFormat, num);
	DP(("RS:  Formatted label: '%s'\n", sl->sl_IText->IText));
	PrintIText(win->RPort, sl->sl_IText, gad->LeftEdge, gad->TopEdge);
a406 1
    struct SliderIData *sl = SLID(gad);
d411 1
a411 1
    DP(("HS: Gadget at $%lx, SliderIData at $%lx\n", gad, sl));
d416 2
a417 2
    newlevel = FindSliderLevel((WORD)(sl->sl_Max - sl->sl_Min + 1),
	*sl->sl_Pot, (BOOL)(sl->sl_Flags & SL_VERTICAL)) + sl->sl_Min;
d422 1
a422 1
	if (sl->sl_Flags & SL_GADGETDOWN)
d431 1
a431 1
	if (sl->sl_Flags & SL_GADGETUP)
d439 3
a441 3
	FindSliderValues((WORD)(sl->sl_Max - sl->sl_Min + 1),
	    (WORD)(newlevel - sl->sl_Min),
	    sl->sl_Body, sl->sl_Pot, (BOOL)(sl->sl_Flags & SL_VERTICAL));
d459 1
a459 1
    if (newlevel != sl->sl_Level)
d461 2
a462 2
	sl->sl_Level = newlevel;
	RefreshLevel(imsg->IDCMPWindow, gad, sl);
a546 2
    struct SliderIData *sl = SLID(gad);
    struct TagItem *ti;
d549 3
a551 3
    sl->sl_Min = (WORD)(LONG)getGTTagData(GTSL_Min, sl->sl_Min, taglist);
    sl->sl_Max = (WORD)(LONG)getGTTagData(GTSL_Max, sl->sl_Max, taglist);
    sl->sl_Level = (WORD)(LONG)getGTTagData(GTSL_Level, sl->sl_Level, taglist);
d553 4
a556 4
    if (sl->sl_Level > sl->sl_Max)
	sl->sl_Level = sl->sl_Max;
    else if (sl->sl_Level < sl->sl_Min)
	sl->sl_Level = sl->sl_Min;
d558 3
a560 3
    FindSliderValues((WORD)(sl->sl_Max - sl->sl_Min + 1),
	(WORD)(sl->sl_Level - sl->sl_Min),
	sl->sl_Body, sl->sl_Pot, (BOOL)(sl->sl_Flags & SL_VERTICAL));
d565 4
a568 6
    RefreshLevel(win, gad, sl);
    if (ti = findGATagItem(GA_DISABLED, taglist))
	{
	/*  Do a regular enable/disable: */
	AbleGadget(gad, win, req, 1, (BOOL)ti->ti_Data);
	}
@
