head     39.17;
branch   ;
access   ;
symbols  ;
locks    ; strict;
comment  @ * @;


39.17
date     93.05.06.17.03.28;  author vertex;  state Exp;
branches ;
next     39.16;

39.16
date     92.10.16.18.28.40;  author vertex;  state Exp;
branches ;
next     39.15;

39.15
date     92.08.19.18.08.29;  author vertex;  state Exp;
branches ;
next     39.14;

39.14
date     92.07.31.18.20.45;  author vertex;  state Exp;
branches ;
next     39.13;

39.13
date     92.07.16.11.00.23;  author vertex;  state Exp;
branches ;
next     39.12;

39.12
date     92.05.29.15.36.46;  author vertex;  state Exp;
branches ;
next     39.11;

39.11
date     92.04.15.11.44.18;  author vertex;  state Exp;
branches ;
next     39.10;

39.10
date     92.04.13.14.05.38;  author vertex;  state Exp;
branches ;
next     39.9;

39.9
date     92.04.07.13.58.35;  author vertex;  state Exp;
branches ;
next     39.8;

39.8
date     92.03.26.15.19.44;  author peter;  state Exp;
branches ;
next     39.7;

39.7
date     92.03.26.15.15.00;  author peter;  state Exp;
branches ;
next     39.6;

39.6
date     92.03.24.15.14.17;  author peter;  state Exp;
branches ;
next     39.5;

39.5
date     92.03.20.12.47.32;  author peter;  state Exp;
branches ;
next     39.4;

39.4
date     92.03.03.15.05.23;  author peter;  state Exp;
branches ;
next     39.3;

39.3
date     92.02.20.11.50.09;  author peter;  state Exp;
branches ;
next     39.2;

39.2
date     92.02.03.15.48.27;  author peter;  state Exp;
branches ;
next     39.1;

39.1
date     92.01.30.19.55.27;  author peter;  state Exp;
branches ;
next     38.4;

38.4
date     92.01.30.18.08.29;  author peter;  state Exp;
branches ;
next     38.3;

38.3
date     92.01.28.08.28.14;  author peter;  state Exp;
branches ;
next     38.2;

38.2
date     92.01.15.11.02.34;  author peter;  state Exp;
branches ;
next     38.1;

38.1
date     91.11.27.13.17.57;  author peter;  state Exp;
branches ;
next     38.0;

38.0
date     91.07.11.12.33.53;  author peter;  state Exp;
branches ;
next     ;


desc
@@


39.17
log
@Fixed handling of GA_Disabled
@
text
@#ifndef GADTOOLS_GTINTERNAL_H
#define GADTOOLS_GTINTERNAL_H

/* gtinternal.h
 *
 * Internal structures and #defines for Gadget Toolkit.
 *
 * Copyright 1989-1992, Commodore-Amiga, Inc.
 * All Rights Reserved.
 *
 * $Id: gtinternal.h,v 39.16 92/10/16 18:28:40 vertex Exp Locker: vertex $
 *
 */

/*------------------------------------------------------------------------*/

#ifndef INTUITION_SGHOOKS_H
#include <intuition/sghooks.h>
#endif

#ifndef LIBRARIES_GADTOOLS_H
#include <libraries/gadtools.h>
#endif

#ifndef EXEC_LIBRARIES_H
#include <exec/libraries.h>
#endif

/*------------------------------------------------------------------------*/

/* Debug macros: */

#ifdef DEBUGGING
#define DP(x)	kprintf x
#define D(x)	x
#else
#define DP(x)
#define D(x)
#endif

#ifdef MAXDEBUG
#define MP(x)	kprintf x
#define M(x)	x
#else
#define MP(x)
#define M(x)
#endif

#define POKE(value) {ULONG *x = 0;*x = value;}

VOID kprintf(STRPTR,...);


/*------------------------------------------------------------------------*/

/* Our library base */

struct GadToolsLib
{
    struct Library gtb_Library;
    UWORD gtb_Pad;
    struct Library *gtb_SysBase;
    struct Library *gtb_UtilityBase;
    struct GfxBase *gtb_GfxBase;
    struct IntuitionBase *gtb_IntuitionBase;
    struct Library *gtb_LayersBase;
/* cached match function pointers
 * ORDER MATTERS: MATCHES UTILITY LIBRARY ORDERING
 */
    void *gtb_SMult32;
    void *gtb_UMult32;
    void *gtb_SDivMod32;
    void *gtb_UDivMod32;
    Class *gtb_GTButtonIClass;
    struct Hook gtb_PaletteGHook;
};

/* For reference:
 * 	SysBase		$24(a6)
 *	UtilityBase:	$28(a6)
 *	GfxBase:	$2c(a6)
 *	UtilityBase:	$30(a6)
 */

/*------------------------------------------------------------------------*/

#define ASM    __asm
#define REG(x) register __ ## x

/*------------------------------------------------------------------------*/


/* Space-saving macros */

#define getGATagData(tag,def,list) getTagDataGA((tag)&~(GA_Dummy),def,list)

#define getGTTagData(tag,def,list) getTagDataGT((tag)&~(GT_TagBase),def,list)

#define getSTRINGTagData(tag,def,list) getTagDataSTRING((tag)&~(STRINGA_Dummy),def,list)

#define findGTTagItem(tag,list) findTagItemGT((tag)&~(GT_TagBase),list)

/*------------------------------------------------------------------------*/

/* Memory utility macros: */
#define MEMORY_FOLLOWING(ptr) ((void *)((ptr)+1))
#define MEMORY_N_FOLLOWING(ptr,n)  ((void *)( ((ULONG)ptr) + n ))

/*------------------------------------------------------------------------*/

#define GADTOOL_TYPE	0x0100	/* For Gadget->GadgetType */

/* These tags have private meanings: */
#define GT_ExtraSize	GT_Private0	/* internal use in building on generics */

#define SKETCH_KIND	10	/* OBSOLETE... */

/*------------------------------------------------------------------------*/

/* Alignment macros: */
#define GRANULARITY	4
#define ALIGNPAD(x)	((GRANULARITY-1) - ((x-1) % GRANULARITY))
#define ALIGNSIZE(x)	((x) + ALIGNPAD(x))

/*------------------------------------------------------------------------*/

#define FRAMETYPE_MASK		0x0000FFFF
#define FRAMETYPE_RECESSED	0x80000000

/*------------------------------------------------------------------------*/

/* A CycleBorder is the glyph for the cycle gadget, expressed as
 * a Border
 */

#define CB_COUNT	16	/* 16 pairs */

struct CycleBorder
{
    struct Border cb_Border;
    WORD cb_Points[CB_COUNT*2];
};

/*------------------------------------------------------------------------*/

/* Stuff for private GTButtonIClass */

/* Steal some unused imageclass tags */
#define MYIA_IText	IA_APattern

/* GTButtonIClass looks at the Border->BackPen for one of these: */
#define DESIGNSHINE	1	/* use SHINEPEN (SHADOWPEN if IDS_SELECTED) */
#define DESIGNSHADOW	2	/* use SHADOWPEN (SHINEPEN if IDS_SELECTED) */
#define DESIGNTEXT	3	/* use TEXTPEN (FILLTEXTPEN if IDS_SELECTED) */

/*------------------------------------------------------------------------*/

/* Trim (inclusive of border thickness) that should be allowed
 * around an object for the border:
 */
#define LEFTTRIM	4
#define LRTRIM		8
#define TOPTRIM		2
#define TBTRIM		4

/* Border thickness: */
#define BEVELXSIZE	2
#define BEVELYSIZE	1

/*------------------------------------------------------------------------*/

#define PLACETEXT_MASK (PLACETEXT_LEFT | PLACETEXT_RIGHT | PLACETEXT_ABOVE \
	| PLACETEXT_BELOW | PLACETEXT_IN)

/*------------------------------------------------------------------------*/

/* All gadgets allocated through CreateGadget() are actually
 * SpecialGadgets, which have a few extra fields.  These extra fields
 * are hidden from the casual user.
 */

struct SpecialGadget
{
    struct ExtGadget sg_Gadget;	/* The actual gadget */
    struct ExtGadget *sg_Parent;   /* Parent if part of composite gadget */
    BOOL (*sg_EventHandler)(struct ExtGadget *, struct IntuiMessage *);
				/* Routine to handle gadget events */
    void (*sg_Refresh)(struct ExtGadget *, struct Window *, BOOL);
				/* Routine to handle refresh */
    void (*sg_SetAttrs)(struct ExtGadget *, struct Window *,
	struct TagItem *);	/* Routine to set gadget attributes */
    struct GetTable *sg_GetTable;
    ULONG sg_Flags;		/* See below */
};

#define SG_MOUSEMOVE		1   /* This gadget cares about MOUSEMOVEs */
#define SG_CONTEXT		2   /* This is the context gadget */
#define SG_INTUITICKS	        4   /* This gadget cares about INTUITICKs */
#define SG_EXTRAFREE_DISPOSE	8   /* Call DisposeObject() on this gadget's image when freeing it */
#define SG_EXTRAFREE_CLOSEFONT  16  /* Call closeFont() on this gadget's StringInfo.Extension.Font */
#define SG_EXTRAFREE_DISPOSE_LV 32  /* Call closeFont() on a listview's font */
#define SG_MOUSEBUTTONS         64  /* This gadget cares about IDCMP_MOUSEBUTTONS */

#define SGAD(gad) ((struct SpecialGadget *)gad)

/*------------------------------------------------------------------------*/

/* Used internally as modifiable IntuiMessages */

struct QuasiMessage
{
    struct ExtIntuiMessage qm_IMessage;
    struct IntuiMessage *qm_OrigMessage;
    struct ExtGadget *qm_ContextGadget;
};

/*------------------------------------------------------------------------*/

/* Context gadget: */

struct XContext
{
    struct SpecialGadget xct_Gadget;
    /* Instance data: */
    struct ExtGadget *ctid_ActiveGadget;
    struct QuasiMessage ctid_QuasiMessage;
    BYTE ctid_QuasiUsed;
    BYTE ctid_DelayedFree;
};

#define CTID(g)	((struct XContext *)(g))

#define CONTEXT_IDATA_SIZE (sizeof(struct XContext)-sizeof(struct SpecialGadget))


/*------------------------------------------------------------------------*/

/* Instance data for checkbox gadget: */

struct XCheckbox
{
    struct SpecialGadget cbid_Gadget;
    /* Instance data: */
    WORD cbid_Checked;
};

#define CHECKBOX_IDATA_SIZE	(sizeof(struct XCheckbox)-sizeof(struct SpecialGadget))

#define CBID(g)	((struct XCheckbox *)(g))

/*------------------------------------------------------------------------*/

/* ListView gadgets: */

/* The instance data for the ListView gadget: */

struct XListView
{
    struct SpecialGadget xlv_Gadget;

    /* instance data */
    struct List      *lvid_Labels;
    WORD              lvid_Top;
    WORD              lvid_OldTop;
    WORD              lvid_Total;
    WORD	      lvid_Visible;
    UWORD	      lvid_ItemHeight;
    UWORD             lvid_Selected;
    STRPTR            lvid_SelectedName;

    struct ExtGadget *lvid_ListGad;
    struct ExtGadget *lvid_Scroller;
    struct ExtGadget *lvid_DisplayGad;

    struct Hook      *lvid_CallBack;
    struct Hook       lvid_DefaultCallBack;

    struct DrawInfo  *lvid_DrawInfo;
    struct TextFont  *lvid_Font;

    BOOL              lvid_ReadOnly;
    BOOL              lvid_AllowSelections;
    UWORD             lvid_MaxPen;
    UWORD             lvid_TickCount;
};

#define LVID(g)	((struct XListView *)(g))

#define LISTVIEW_IDATA_SIZE (sizeof(struct XListView)-sizeof(struct SpecialGadget))

/*------------------------------------------------------------------------*/

/* Mutually exclusive gadgets: */

/* The dummy gadget's instance data: */

struct XMX
{
    struct SpecialGadget xmx_Gadget;
    /* Instance data: */
    struct ExtGadget *mxid_ActiveGadget;	/* The active one */
    struct ExtGadget *mxid_FirstGadget;	/* The first one */
    WORD mxid_NumGadgets;               /* Total number of gadgets */
    WORD mxid_Active;			/* Number of the active gadget */
};

#define MXID(g)	((struct XMX *)(g))

#define MX_IDATA_SIZE	(sizeof(struct XMX)-sizeof(struct SpecialGadget))

/*------------------------------------------------------------------------*/

/* Instance data for simple number display: */
/* Shared with Text display routines, so it must match XText
 * field-for-field (with extensions allowed)
 */

struct XNumber
{
    struct SpecialGadget nmid_Gadget;	     /* Must match XText */

    /* instance data */
    struct IntuiText     nmid_IText;	     /* Must match XText */
    struct Rectangle     nmid_Extent;	     /* Must match XText */
    UWORD                nmid_Justification; /* Must match XText */
    UWORD                nmid_TextWidth;
    STRPTR               nmid_Format;
    LONG                 nmid_Number;
};

#define NMID(g)	((struct XNumber *)(g))

#define NUMBER_IDATA_SIZE	(sizeof(struct XNumber)-sizeof(struct SpecialGadget))


/* Instance data for simple text display: */

struct XText
{
    struct SpecialGadget txid_Gadget;

    /* instance data */
    struct IntuiText     txid_IText;
    struct Rectangle     txid_Extent;
    UWORD                txid_Justification;
    UWORD                txid_TextWidth;
};

#define TXID(g)	((struct XText *)(g))

#define TEXT_IDATA_SIZE	(sizeof(struct XText)-sizeof(struct SpecialGadget))

/*------------------------------------------------------------------------*/

/* Cycle gadgets: */

/* The instance data for the Cycle gadget: */

struct XCycle
{
    struct SpecialGadget cyid_Gadget;
    /* Instance data: */
    STRPTR *cyid_Labels;
    UWORD cyid_MaxLabel;
    WORD cyid_Active;
    struct IntuiText cyid_IText;
    struct CycleBorder cyid_CycleBorder;
    struct Border cyid_DarkStroke;
    struct Border cyid_LightStroke;
    WORD cyid_StrokePoints[4];
};

#define CYID(g)	((struct XCycle *)(g))

#define CYCLE_IDATA_SIZE	(sizeof(struct XCycle)-sizeof(struct SpecialGadget))

#define CYCLEGLYPHWIDTH	20

/*------------------------------------------------------------------------*/

/* Instance data for palette gadget: */

struct XPalette
{
    struct SpecialGadget xp_Gadget;
    /* Instance data follows: */
    UWORD paid_XCount;		/* Number of colors per row */
    UWORD paid_EachWidth;	/* Width of each color rectangle */
    UWORD paid_EachHeight;	/* Height of each color rectangle */
    UWORD paid_Count;		/* Number of color rectangles */
    UWORD paid_SelectedBox;	/* Active color box */
    UWORD paid_Color;            /* # of currently selected color */
    UWORD paid_ColorOffset;	/* 1st color to use in palette */
    UBYTE *paid_ColorTable;     /* Table of pens to use */
    struct DrawInfo *paid_DrawInfo; /* Cached pointer */
    UWORD paid_BoxBackup;     /* To support undoing the selection with the RMB */
    BOOL paid_Indicator;
};

#define PALETTE_IDATA_SIZE	(sizeof(struct XPalette)-sizeof(struct SpecialGadget))

#define PAID(g)	((struct XPalette *)(g))


/*------------------------------------------------------------------------*/

/* Instance data for scroller gadget: */

struct XScroller
{
    struct SpecialGadget scid_Gadget;
    /* Instance data: */
    WORD scid_Top;			/* First one you want displayed */
    WORD scid_Total;			/* total elements in list */
    WORD scid_Visible;			/* Number visible at one time */
    UWORD scid_TickCount;
    ULONG scid_Flags;			/* See below */

    struct ExtGadget *scid_ListView;	/* PRIVATE kludge pointer back
					 * to ListView if I'm in one
					 */
    struct ExtGadget *scid_Prop;		/* Pointer to prop gadget */
    struct ExtGadget *scid_Up;		/* Pointer to up arrow gadget */
    struct ExtGadget *scid_Down;		/* Pointer to down arrow gadget */
    UWORD *scid_Body, *scid_Pot;

    struct PropInfo scid_PropInfo;
    struct Image    scid_PropImage;
};

#define SCROLLER_IDATA_SIZE	(sizeof(struct XScroller)-sizeof(struct SpecialGadget))

#define SCID(g)	((struct XScroller *)(g))

/* Scroller flags include some common ones with sliders,
 * plus the scroller-specific SC_ARROWS.
 */

#define GTPROP_VERTICAL		0x00000001 /* Vert. prop */
#define GTPROP_GADGETDOWN	0x00000002 /* Guaranteed msg upon GADGETDOWN */
#define GTPROP_GADGETUP		0x00000004 /* Guaranteed msg upon GADGETUP */
#define SC_ARROWS		0x00000008 /* Has arrows */

/*------------------------------------------------------------------------*/

/* Instance data for slider gadget: */

struct XSlider
{
    struct SpecialGadget slid_Gadget;
    /* Instance data: */
    WORD slid_Min;		/* Minimum level */
    WORD slid_Max;		/* Maximum level */
    WORD slid_Level;		/* Current level */
    ULONG slid_Flags;		/* See scroller flags */
    LONG (*slid_DispFunc)();	/* Callback for number recalc. */

    UWORD *slid_Body;		/* Pointer to Vert or HorizBody */
    UWORD *slid_Pot;		/* Pointer to Vert or HorizPot */
    struct IntuiText *slid_IText;	/* IntuiText to render label/level */
    UBYTE *slid_LevelFormat;	/* Format String for level */
    struct ExtGadget *slid_Prop;

    struct PropInfo slid_PropInfo;
    struct Image    slid_PropImage;

    UWORD           slid_MaxPixelLen;   /* maximum room used up by level display */
    UBYTE           slid_Justification;

    struct Rectangle slid_Extent;   /* space occupied by slider level display */
};

#define SLIDER_IDATA_SIZE	(sizeof(struct XSlider)-sizeof(struct SpecialGadget))

#define SLID(g)	((struct XSlider *)(g))

/* Slider flags are the three GTPROP_ flags defined under scrollers. */

/*------------------------------------------------------------------------*/

/* Instance data for a string gadget: */

struct XString
{
    struct SpecialGadget stid_Gadget;
    /* Instance data: */
    struct StringInfo stid_StringInfo;
    struct StringExtend stid_Sex;
};

#define STID(g)	((struct XString *)(g))

#define STRING_IDATA_SIZE	(sizeof(struct XString)-sizeof(struct SpecialGadget))

/*------------------------------------------------------------------------*/


struct ImageLink
{
    struct ImageLink *il_Next;
    struct Image     *il_Image;
    ULONG             il_Type;  /* CHECKIMAGE or MXIMAGE */
};


/*------------------------------------------------------------------------*/

/* All the visual information we need can be found in this private
 * (hence extensible) structure:
 */

struct VisualInfo
{
    struct Screen    *vi_Screen;		/* The screen in question */
    struct TextFont  *vi_ScreenFont;	/* opened copy of screen font */
    struct DrawInfo  *vi_DrawInfo;	/* DrawInfo structure */
    struct ImageLink *vi_Images;	/* Images */
    UBYTE             vi_textPen;	/* Shorthand */
    UBYTE             vi_backgroundPen;	/* Shorthand */
};

#define VI(vi)	((struct VisualInfo *)vi)

/*------------------------------------------------------------------------*/

/* For scroller arrows: */
struct ArrowBorder
{
    struct Border Border1;
    struct Border Border2;
    WORD Points[8];
};

/* Arrow directions: */
#define ARROW_UP	0
#define ARROW_DOWN	1
#define ARROW_LEFT	2
#define ARROW_RIGHT	3

/* Number of INTUITICKS to ignore before first repeat: */
#define ARROW_SKIPTICKS	4

/*------------------------------------------------------------------------*/

#define NM_TRUETYPE(type)	((type) & ~MENU_IMAGE)

/* This structure gives us the easiest way to extract the original
 * Left value for an Custom Image menu item:
 */
struct ImageMenuItem
{
    struct MenuItem imi_MenuItem;
    void *imi_UserData;
    struct Image imi_Image;
    WORD imi_OrigLeft;
};

/*------------------------------------------------------------------------*/

/* These macros are used to generate the GT_GetGadgetAttrs tables.
 *
 * Each gadget kind has a getattr table interpreted as follows:
 *
 * Each entry is a byte-pair:
 *
 * UBYTE 1 = describes the attribute tag or is a terminator
 *	Attributes are expressed as ( attribute tag - GT_TagBase )
 *	With the special values of ~0 and ~1 as terminator.  ~1 not only
 *	terminates, but requests that GA_Disabled be recognized.
 *
 * UBYTE 2 = describes the attribute offset of the attribute, partitioned into
 *	( size:1 | offset: 7 )
 * 	Where "offset" is the offset in WORDs from the end of the Gadget
 *	structure to the attribute in the instance data.  The "size" bit
 *	is zero for a WORD-sized attribute, and one for a LONG.
 *
 * We could steal one offset bit to distinguish signed vs. non.  For now,
 * we take advantage of the fact that all attributes are either signed words
 * or long (sign extension is not an issue with longs).
 *
 * ATTR_OFFSET returns the offset of a particular attribute in the
 * instance data.  The result is the number of words past the
 * SpecialGadget structure where the attribute can be found.
 *
 * GETTABLE_ATTR generates a table entry based on a tag, a structure-cast,
 * a member name, and one of the attribute types.  If the attribute-offset
 * is out of range, illegal code will be generated, so you can notice
 * at compile time that something's wrong.
 */

#define WORD_ATTR	0x00
#define LONG_ATTR	0x80

#define MAX_OFFSET	0x7F

#define ATTR_OFFSET( cast, member ) ((&cast(0)->member - sizeof(struct SpecialGadget))/sizeof(WORD))

void CauseCompilerError(void);

/* These special attribute codes are the highest possible bytes.  An
 * attribute table always ends with one of these.
 */
#define ATTR_END	255
#define ATTR_DISABLED	254

/* This macro generates a table signifying the end of the table.
 */
#define GETTABLE_END		{ATTR_END,0}


/* This macro generates a table entry for the supplied GadTools
 * "attr"ibute.  The table entry says to look at the "member" offset
 * into the "cast" structure, for a variable of the specified "type".
 */
#define GETTABLE_ATTR( attr, cast, member, type ) \
	{ ATTR_OFFSET(cast,member) > MAX_OFFSET ? CauseCompilerError() : \
	(attr) - GT_TagBase, (type)|ATTR_OFFSET(cast,member) }

/* These macros define table entries to look for the GA_Disabled
 * attribute.  Either of these macros (as well as GETTABLE_END)
 * also define the end of the attribute table.
 *
 * If the actual gadget the caller receives can be tested for
 * the GFLG_DISABLED property, then use GETTABLE_DISABLED.
 * Certain gadget kinds have a dummy gadget, and a member gadget
 * (eg. SLID(gad)->slid_Prop for the slider) needs to be tested
 * instead.  For that type, use GETTABLE_DISABLED_MEMBER(SLID,slid_Prop).
 */

#define GETTABLE_DISABLED	{ATTR_DISABLED,0}
#define GETTABLE_DISABLED_MEMBER( cast, member ) \
	GETTABLE_ATTR( GT_TagBase+ATTR_DISABLED, cast, member, LONG_ATTR )

#define REAL_OFFSET(descriptor) (((descriptor)&MAX_OFFSET)*2+sizeof(struct SpecialGadget))

/* The following are the non-standard attributes (i.e. those not simply
 * stuck in the instance data:
 *
 * GA_Disabled - OK, since handled separately anyways
 *
 * GTIN_Number - If we embed StringInfo, then OK as inid_StringInfo.LongInt.
 *
 * GTST_String - If we embed StringInfo, then OK as stid_StringInfo.Buffer.
 *
 * GTTX_Text - OK, as txid_IText.IText
 *
 * GTMX_Active - mxid_ActiveGadget->UserData
 */

struct GetTable
{
    UBYTE gtab_tag;
    UBYTE gtab_descriptor;
};

/*------------------------------------------------------------------------*/


#define IGNORE_VISUALINFO (VOID *)~0

/*------------------------------------------------------------------------*/


#endif /* !GADTOOLS_GTINTERNAL_H */
@


39.16
log
@Added some fields to XText
@
text
@d11 1
a11 1
 * $Id: gtinternal.h,v 39.15 92/08/19 18:08:29 vertex Exp Locker: vertex $
a442 1
#define SC_DISABLED             0x00000010 /* Disabled by GA_Disabled? */
@


39.15
log
@Added support for GTTX_Clipped tag
@
text
@d11 1
a11 1
 * $Id: gtinternal.h,v 39.14 92/07/31 18:20:45 vertex Exp Locker: vertex $
d326 1
a326 1
    BOOL                 nmid_Clipped;
d346 1
a346 1
    BOOL                 txid_Clipped;
d618 1
a618 1
	(attr) - GT_TagBase, (type)|ATTR_OFFSET(cast,member)}
@


39.14
log
@Added support for linked images in the VisualInfo
@
text
@d11 1
a11 1
 * $Id: gtinternal.h,v 39.13 92/07/16 11:00:23 vertex Exp Locker: vertex $
a273 1
    ULONG             lvid_DisplayTag;
d326 1
d346 1
@


39.13
log
@*** empty log message ***
@
text
@d11 1
a11 1
 * $Id: gtinternal.h,v 39.12 92/05/29 15:36:46 vertex Exp Locker: vertex $
d497 11
d514 6
a519 7
    struct Screen   *vi_Screen;		/* The screen in question */
    struct TextFont *vi_ScreenFont;	/* opened copy of screen font */
    struct DrawInfo *vi_DrawInfo;	/* DrawInfo structure */
    struct Image    *vi_CheckImage;	/* Checkbox image */
    struct Image    *vi_MXImage;	/* MX gadget image */
    UBYTE            vi_textPen;	/* Shorthand */
    UBYTE            vi_backgroundPen;	/* Shorthand */
@


39.12
log
@*** empty log message ***
@
text
@d11 1
a11 1
 * $Id: gtinternal.h,v 39.11 92/04/15 11:44:18 vertex Exp Locker: vertex $
d196 3
a198 3
#define SG_MOUSEMOVE	1	/* This gadget cares about MOUSEMOVEs */
#define SG_CONTEXT	2	/* This is the context gadget */
#define SG_INTUITICKS	4	/* This gadget cares about INTUITICKs */
d202 1
a202 1
#define SG_MOUSEBUTTONS 64 /* This gadget cares about IDCMP_MOUSEBUTTONS */
@


39.11
log
@*** empty log message ***
@
text
@d11 1
a11 1
 * $Id: gtinternal.h,v 39.10 92/04/13 14:05:38 vertex Exp Locker: vertex $
a35 1
void kprintf(char *, ...);
d49 5
d66 1
d87 6
a115 4
#define GT_AUTOGADGET	0xFFFF	/* Reserved GadgetID for gadgets generated
				 * for you (i.e. implicitly) Not yet used!!!
				 */

d185 2
a186 2
    struct Gadget *sg_Parent;   /* Parent if part of composite gadget */
    BOOL (*sg_EventHandler)(struct Gadget *, struct IntuiMessage *);
d188 1
a188 1
    void (*sg_Refresh)(struct Gadget *, struct Window *, BOOL);
d190 1
a190 1
    void (*sg_SetAttrs)(struct Gadget *, struct Window *, struct Requester *,
d199 1
a199 1
#define SG_EXTRAFREE_DISPOSE	8	/* Call DisposeObject() on this gadget's image when freeing it */
d201 2
d214 1
a214 1
    struct Gadget *qm_ContextGadget;
d225 1
a225 1
    struct Gadget *ctid_ActiveGadget;
d262 24
a285 17
    struct List     *lvid_Labels;
    WORD             lvid_Top;
    WORD             lvid_Total;
    WORD	     lvid_Visible;
    WORD	     lvid_ItemHeight;
    UWORD            lvid_Flags;	/* See below */
    struct Node     *lvid_TopLabel;	/* Pointer to top label displayed */
    struct Gadget   *lvid_TopGadget;	/* Pointer to top Gadget */

/* lvid_Height is always derived as EachHeight*Count + TBTRIM */
    struct Gadget   *lvid_Scroller;	/* Scroller gadget */
    struct Gadget   *lvid_DisplayGad;	/* String or text gadget for display
					 * of current selection
					 */
    ULONG            lvid_DisplayTag;	/* GTST_String or GTTX_Text */
    struct IntuiText lvid_LineIText;	/* Line IntuiText */
    WORD             lvid_Selected;	/* Ordinal number of the selected one */
a287 6
/* lvid_Flags: */
#define LV_READONLY	0x0001		/* Read-only list */
#define LV_DEFERREFRESH	0x0002		/* defer refreshing since list is
					 * detached for client use
					 */

a291 13
/* Instance data for each line gadget of the listview: */

struct XLVLine
{
    struct SpecialGadget xlvl_Gadget;
    /* Instance data: */
    WORD llid_MaxX;			/* Highest pixel rendered into */
};

#define LLID(g) ((struct XLVLine *)(g))

#define LVLINE_IDATA_SIZE (sizeof(struct XLVLine)-sizeof(struct SpecialGadget))

d302 2
a303 2
    struct Gadget *mxid_ActiveGadget;	/* The active one */
    struct Gadget *mxid_FirstGadget;	/* The first one */
d394 1
a394 1
    struct VisualInfo *paid_VI; /* Cached pointer */
d396 1
d418 1
a418 1
    struct Gadget *scid_ListView;	/* PRIVATE kludge pointer back
d421 3
a423 3
    struct Gadget *scid_Prop;		/* Pointer to prop gadget */
    struct Gadget *scid_Up;		/* Pointer to up arrow gadget */
    struct Gadget *scid_Down;		/* Pointer to down arrow gadget */
d462 1
a462 1
    struct Gadget *slid_Prop;
@


39.10
log
@Life is ever changing
@
text
@d11 1
a11 1
 * $Id: gtinternal.h,v 39.9 92/04/07 13:58:35 vertex Exp Locker: vertex $
a182 2
    void (*sg_ExtraFree)(struct Gadget *);
				/* Routine to do any extra freeing stuff */
d192 2
a193 2
#define SG_EXTRAFREE_DISPOSE	8	/* Call DisposeObject() on this
				    gadget's image when freeing it */
a509 2
    UBYTE            vi_shinePen;	/* Shorthand */
    UBYTE            vi_shadowPen;	/* Shorthand */
a511 1
    UBYTE 	     vi_Flags;		/* See below */
a514 2

#define VI_SCREENHIRES	0x01
@


39.9
log
@*** empty log message ***
@
text
@d11 1
a11 1
 * $Id: gtinternal.h,v 39.8 92/03/26 15:19:44 peter Exp Locker: vertex $
d177 1
a177 1
    struct Gadget sg_Gadget;	/* The actual gadget */
d181 1
a181 1
    void (*sg_Refresh)(struct Window *, struct Gadget *, BOOL);
d205 1
a205 1
    struct IntuiMessage qm_IMessage;
d395 2
a396 1
    WORD paid_Color;		/* Active color */
d398 3
@


39.8
log
@Deleted MYIA_VisualInfo.
@
text
@d11 1
a11 1
 * $Id: gtinternal.h,v 39.7 92/03/26 15:15:00 peter Exp Locker: peter $
d253 11
a263 8
    /* Instance data: */
    struct List *lvid_Labels;
    WORD lvid_Top;
    WORD lvid_Total;
    UWORD lvid_Flags;			/* See below */
    WORD lvid_Count;			/* Resulting number of lines */
    struct Node *lvid_TopLabel;		/* Pointer to top label displayed */
    struct Gadget *lvid_TopGadget;	/* Pointer to top Gadget */
d265 2
a266 2
    struct Gadget *lvid_Scroller;	/* Scroller gadget */
    struct Gadget *lvid_DisplayGad;	/* String or text gadget for display
d269 1
a269 1
    ULONG lvid_DisplayTag;		/* GTST_String or GTTX_Text */
d271 1
a271 1
    WORD lvid_Selected;			/* Ordinal number of the selected one */
d309 1
d326 8
a333 7
    struct SpecialGadget nmid_Gadget;	/* Must match XText */
    /* Instance data: */
    
    struct IntuiText nmid_IText;	/* Must match XText */
    struct Rectangle nmid_Extent;	/* Must match XText */
    LONG nmid_Number;
    UBYTE nmid_Buffer[20];
d346 5
a350 3
    /* Instance data: */
    struct IntuiText txid_IText;
    struct Rectangle txid_Extent;
d425 3
d442 1
d463 8
d503 1
a503 2
    struct Screen *vi_Screen;		/* The screen in question */
    struct TextAttr *vi_ScreenTAttr;	/* TextAttr of screen font */
d506 7
a512 7
    struct Image *vi_CheckImage;	/* Checkbox image */
    struct Image *vi_MXImage;		/* MX gadget image */
    UBYTE vi_shinePen;			/* Shorthand */
    UBYTE vi_shadowPen;			/* Shorthand */
    UBYTE vi_textPen;			/* Shorthand */
    UBYTE vi_backgroundPen;		/* Shorthand */
    ULONG vi_Flags;			/* See below */
d517 1
a517 1
#define VI_SCREENHIRES	0x00000001
a642 2
 *
 * GTCB_Checked - gad->Flags & SELECTED
d652 7
@


39.7
log
@Added new FRAMETYPE definitions.  Deleted BevelBoxes and VisualInfo's
from instance data.  Added image pointer and semaphore to GadToolsBase.
@
text
@d11 1
a11 1
 * $Id: gtinternal.h,v 39.6 92/03/24 15:14:17 peter Exp Locker: peter $
a142 1
#define MYIA_VisualInfo	IA_APatSize
@


39.6
log
@Added sg_GetAttrs to SpecialGadget.  Re-alingend comments.
Renamed nway to cycle internally.
@
text
@d11 1
a11 1
 * $Id: gtinternal.h,v 39.5 92/03/20 12:47:32 peter Exp Locker: peter $
d120 2
a121 1
/* A BevelBox is the pretty bevelled box ever-present in the Toolkit: */
a122 16
#define BB_TRIMCOUNT	5	/* 5 pairs */
#define BB_SHADOWCOUNT	5	/* 5 pairs */

struct BevelBox
{
    struct Border bb_TrimBorder;
    struct Border bb_ShadowBorder;
    WORD bb_TrimPoints[BB_TRIMCOUNT*2];
    WORD bb_ShadowPoints[BB_SHADOWCOUNT*2];
};

/* BevelBox can be one of two kinds: */

#define BB_RAISED	(TRUE)
#define BB_RECESSED	(FALSE)

a267 1
    struct BevelBox lvid_BevelBox;
a367 1
    struct BevelBox cyid_BevelBox;
a384 1
    struct VisualInfo *paid_VisualInfo;
a418 2
    struct VisualInfo *scid_VisualInfo;
    struct BevelBox scid_BevelBox;
a452 1
    struct BevelBox slid_BevelBox;
a470 1
    struct BevelBox stid_BevelBox[2];
@


39.5
log
@Added caching pointers for utility.library math lvos.
@
text
@d4 10
a13 10
/*  gtinternal.h
*
*   Internal structures and #defines for Gadget Toolkit.
*
*   Copyright 1989, Commodore-Amiga, Inc.
*   All Rights Reserved.
*
*   $Id: gtinternal.h,v 39.4 92/03/03 15:05:23 peter Exp Locker: peter $
*
*/
d17 4
d31 1
a31 1
/*  Debug macros: */
d82 1
a82 1
/*  Space-saving macros */
d94 1
a94 1
/*  Memory utility macros: */
d100 1
a100 1
#define GADTOOL_TYPE	0x0100	/*  For Gadget->GadgetType */
d102 1
a102 1
/*  These tags have private meanings: */
d105 3
a107 2
#define GT_AUTOGADGET	0xFFFF	/*  Reserved GadgetID for gadgets generated
				    for you (i.e. implicitly) Not yet used!!!*/
d113 1
a113 1
/*  Alignment macros: */
d120 1
a120 1
/*  A BevelBox is the pretty bevelled box ever-present in the Toolkit: */
d122 2
a123 2
#define BB_TRIMCOUNT	5	/*  5 pairs */
#define BB_SHADOWCOUNT	5	/*  5 pairs */
d133 1
a133 1
/*  BevelBox can be one of two kinds: */
d140 3
a142 2
/*  A CycleBorder is the glyph for the cycle gadget, expressed as
    a Border */
d167 3
a169 2
/*  Trim (inclusive of border thickness) that should be allowed
    around an object for the border: */
d175 1
a175 1
/*  Border thickness: */
d186 4
a189 3
/*  All gadgets allocated through CreateGadget() are actually
    SpecialGadgets, which have a few extra fields.  These extra fields
    are hidden from the casual user. */
d193 2
a194 2
    struct Gadget sg_Gadget;	/*  The actual gadget */
    struct Gadget *sg_Parent;   /*  Parent if part of composite gadget */
d196 1
a196 1
				/*  Routine to handle gadget events */
d198 1
a198 1
				/*  Routine to handle refresh */
d200 1
a200 1
				/*  Routine to do any extra freeing stuff */
d202 3
a204 2
	struct TagItem *);	/*  Routine to set gadget attributes */
    ULONG sg_Flags;		/*  See below */
d207 4
a210 4
#define SG_MOUSEMOVE	1	/*  This gadget cares about MOUSEMOVEs */
#define SG_CONTEXT	2	/*  This is the context gadget */
#define SG_INTUITICKS	4	/*  This gadget cares about INTUITICKs */
#define SG_EXTRAFREE_DISPOSE	8	/*  Call DisposeObject() on this
d228 1
a228 1
/*  Context gadget: */
d247 16
a262 1
/*  ListView gadgets: */
d264 1
a264 1
/*  The instance data for the ListView gadget: */
d273 10
a282 9
    UWORD lvid_Flags;			/*  See below */
    WORD lvid_Count;			/*  Resulting number of lines */
    struct Node *lvid_TopLabel;		/*  Pointer to top label displayed */
    struct Gadget *lvid_TopGadget;	/*  Pointer to top Gadget */
/*  lvid_Height is always derived as EachHeight*Count + TBTRIM */
    struct Gadget *lvid_Scroller;	/*  Scroller gadget */
    struct Gadget *lvid_DisplayGad;	/*  String or text gadget for display
					    of current selection */
    ULONG lvid_DisplayTag;		/*  GTST_String or GTTX_Text */
d284 2
a285 3
    struct IntuiText lvid_LineIText;	/*  Line IntuiText */
    WORD lvid_Selected;			/*  Ordinal number of the selected
					    one */
d288 5
a292 4
/*  lvid_Flags: */
#define LV_READONLY	0x0001		/*  Read-only list */
#define LV_DEFERREFRESH	0x0002		/*  defer refreshing since list is
					    detached for client use */
d298 1
a298 1
/*  Instance data for each line gadget of the listview: */
d304 1
a304 1
    WORD llid_MaxX;			/*  Highest pixel rendered into */
d313 1
a313 1
/*  Mutually exclusive gadgets: */
d315 1
a315 1
/*  The dummy gadget's instance data: */
d323 1
d332 4
a335 3
/*  Instance data for simple number display: */
/*  Shared with Text display routines, so it must match XText
    field-for-field (with extensions allowed) */
d339 1
a339 1
    struct SpecialGadget nmid_Gadget;
d341 4
a344 3
    struct IntuiText nmid_IText;
    struct Rectangle nmid_Extent;

d353 1
a353 1
/*  Instance data for simple text display: */
d369 1
a369 1
/*  NWay gadgets: */
d371 1
a371 1
/*  The instance data for the NWay gadget: */
d373 20
a392 20
struct XNWay
{
    struct SpecialGadget nwid_Gadget;
    /* Instance data: */
    STRPTR *nwid_Labels;
    UWORD nwid_MaxLabel;
    UWORD nwid_Active;
    struct IntuiText nwid_IText;
    struct CycleBorder nwid_CycleBorder;
    struct Border nwid_DarkStroke;
    struct Border nwid_LightStroke;
    struct BevelBox nwid_BevelBox;
    WORD nwid_StrokePoints[4];
};

#define NWID(g)	((struct XNWay *)(g))

#define NWAY_IDATA_SIZE	(sizeof(struct XNWay)-sizeof(struct SpecialGadget))

#define NWAYGLYPHWIDTH	20
d396 1
a396 1
/*  Instance data for palette gadget: */
d407 2
a408 2
    UBYTE paid_Color;		/* Active color */
    UBYTE paid_ColorOffset;	/* 1st color to use in palette */
d418 1
a418 1
/*  Instance data for scroller gadget: */
d424 3
a426 3
    WORD scid_Top;			/*  First one you want displayed */
    WORD scid_Total;			/*  total elements in list */
    WORD scid_Visible;			/*  Number visible at one time */
d428 1
a428 1
    ULONG scid_Flags;			/*  See gadtools.h */
d430 6
a435 5
    struct Gadget *scid_ListView;		/*  PRIVATE kludge pointer back
					    to ListView if I'm in one */
    struct Gadget *scid_Prop;		/*  Pointer to prop gadget */
    struct Gadget *scid_Up;		/*  Pointer to up arrow gadget */
    struct Gadget *scid_Down;		/*  Pointer to down arrow gadget */
d449 4
a452 4
#define GTPROP_VERTICAL		0x00000001 /*  Vert. prop */
#define GTPROP_GADGETDOWN	0x00000002 /*  Guaranteed msg upon GADGETDOWN */
#define GTPROP_GADGETUP		0x00000004 /*  Guaranteed msg upon GADGETUP */
#define SC_ARROWS		0x00000008 /*  Has arrows */
d456 1
a456 1
/*  Instance data for slider gadget: */
d462 5
a466 5
    WORD slid_Min;		/*  Minimum level */
    WORD slid_Max;		/*  Maximum level */
    WORD slid_Level;		/*  Current level */
    ULONG slid_Flags;		/*  See gadtools.h */
    LONG (*slid_DispFunc)();	/*  Callback for number recalc. */
d468 4
a471 4
    UWORD *slid_Body;		/*  Pointer to Vert or HorizBody */
    UWORD *slid_Pot;		/*  Pointer to Vert or HorizPot */
    struct IntuiText *slid_IText;	/*  IntuiText to render label/level */
    UBYTE *slid_LevelFormat;	/*  Format String for level */
d480 18
a497 1
/*  Slider flags are the three GTPROP_ flags defined under scrollers. */
d501 3
a503 2
/*  All the visual information we need can be found in this private
    (hence extensible) structure: */
d507 11
a517 11
    struct Screen *vi_Screen;		/*  The screen in question */
    struct TextAttr *vi_ScreenTAttr;	/*  TextAttr of screen font */
    struct TextFont *vi_ScreenFont;	/*  opened copy of screen font */
    struct DrawInfo *vi_DrawInfo;	/*  DrawInfo structure */
    struct Image *vi_CheckImage;	/*  Checkbox image */
    struct Image *vi_MXImage;		/*  MX gadget image */
    UBYTE vi_shinePen;			/*  Shorthand */
    UBYTE vi_shadowPen;			/*  Shorthand */
    UBYTE vi_textPen;			/*  Shorthand */
    UBYTE vi_backgroundPen;		/*  Shorthand */
    ULONG vi_Flags;			/*  See below */
d526 1
a526 1
/*  For scroller arrows: */
d534 1
a534 1
/*  Arrow directions: */
d540 1
a540 1
/*  Number of INTUITICKS to ignore before first repeat: */
d547 3
a549 2
/*  This structure gives us the easiest way to extract the original
    Left value for an Custom Image menu item: */
d556 100
@


39.4
log
@Moved check and mx dims public.
@
text
@d11 1
a11 1
*   $Id: gtinternal.h,v 39.3 92/02/20 11:50:09 peter Exp Locker: peter $
d58 7
@


39.3
log
@XText and XNumber no longer store VisualInfo.  Each instance data
now encompasses a SpecialGadget instead of a Gadget.
@
text
@d11 1
a11 1
*   $Id: gtinternal.h,v 39.2 92/02/03 15:48:27 peter Exp Locker: peter $
a200 9
/*  Checkbox gadgets: */

/*  Dimensions of checkbox: */
#define CHECKBOXWIDTH	26
#define CHECKBOXHEIGHT	11


/*------------------------------------------------------------------------*/

a295 4

/*  MX Gadget width and height are dependent on the supplied imagery: */
#define MXGAD_WIDTH	17
#define MXGAD_HEIGHT	9
@


39.2
log
@Removed #define for findGATagItem(), added one for getGATagData().
Cycle instance data no longer has unused BitMap.
@
text
@d11 1
a11 1
*   $Id: gtinternal.h,v 39.1 92/01/30 19:55:27 peter Exp Locker: peter $
d62 7
d97 1
a98 1
#define SKETCH_KIND	10	/* OBSOLETE... */
d174 1
a174 3
    are hidden from the casual user by virtue of being ahead of the
    actual gadget structure, to where the result of CreateGadget()
    points.  Any of those extra fields may safely be NULL: */
d178 1
a188 1
    struct Gadget sg_Gadget;	/*  The actual gadget */
d197 1
a197 5
#define SG_EXTRASIZE (sizeof(struct SpecialGadget) - sizeof(struct Gadget))

/*  I can use this to go from a Gadget to a SpecialGadget.
    Of course, the reverse is simply (&sg->sg_Gadget) */
#define SG_FROM_GAD(gad) ((struct SpecialGadget *) ( ((ULONG)gad) - SG_EXTRASIZE ))
d216 1
a216 1
    struct ContextIData *qm_ContextIData;
d223 1
a223 1
struct ContextIData
d225 2
d233 4
a236 1
#define CTID(sg)	((struct ContextIData *)MEMORY_FOLLOWING(sg))
d246 1
a246 1
    struct Gadget xlv_Gadget;
d273 1
a273 1
#define LISTVIEW_IDATA_SIZE (sizeof(struct XListView)-sizeof(struct Gadget))
d279 1
a279 1
    struct Gadget xlvl_Gadget;
d286 1
a286 1
#define LVLINE_IDATA_SIZE (sizeof(struct XLVLine)-sizeof(struct Gadget))
d296 1
a296 1
    struct Gadget xmx_Gadget;
d304 1
a304 1
#define MX_IDATA_SIZE	(sizeof(struct XMX)-sizeof(struct Gadget))
d318 1
a318 1
    struct Gadget nmid_Gadget;
a319 1
    struct VisualInfo *nmid_VisualInfo;
d328 1
a328 1
#define NUMBER_IDATA_SIZE	(sizeof(struct XNumber)-sizeof(struct Gadget))
d335 1
a335 1
    struct Gadget txid_Gadget;
a336 1
    struct VisualInfo *txid_VisualInfo;
d343 1
a343 1
#define TEXT_IDATA_SIZE	(sizeof(struct XText)-sizeof(struct Gadget))
d353 1
a353 1
    struct Gadget nwid_Gadget;
d368 1
a368 1
#define NWAY_IDATA_SIZE	(sizeof(struct XNWay)-sizeof(struct Gadget))
d378 1
a378 1
    struct Gadget xp_Gadget;
d389 1
a389 1
#define PALETTE_IDATA_SIZE	(sizeof(struct XPalette)-sizeof(struct Gadget))
d400 1
a400 1
    struct Gadget scid_Gadget;
d418 1
a418 1
#define SCROLLER_IDATA_SIZE	(sizeof(struct XScroller)-sizeof(struct Gadget))
d437 1
a437 1
    struct Gadget slid_Gadget;
d453 1
a453 1
#define SLIDER_IDATA_SIZE	(sizeof(struct XSlider)-sizeof(struct Gadget))
@


39.1
log
@Re-did braces.  Bumped to V39.
@
text
@d11 1
a11 1
*   $Id: gtinternal.h,v 38.4 92/01/30 18:08:29 peter Exp Locker: peter $
d58 1
a58 1
    Class *gtb_BorderCompIClass;
d66 2
a73 2
#define findGATagItem(tag,list) findTagItemGA((tag)&~(GA_Dummy),list)

d134 1
a134 1
/* Stuff for private BorderCompIClass */
d136 1
a136 1
/* Steal some unused imageclass tag */
d138 1
d140 1
a140 1
/* BorderCompIClass looks at the Border->BackPen for one of these: */
a354 1
    struct BitMap nwid_GlyphBM;
a382 1
    UBYTE paid_UndoColor;	/* Color to undo to when mouse leaves bounds */
@


38.4
log
@Surgery on a number of the gadget data structures, including listview,
scroller, slider, nway.
@
text
@d11 1
a11 1
*   $Id: gtinternal.h,v 38.3 92/01/28 08:28:14 peter Exp Locker: peter $
d107 1
a107 1
    {
d112 1
a112 1
    };
d127 1
a127 1
    {
d130 1
a130 1
    };
d171 1
a171 1
    {
d183 1
a183 1
    };
d211 1
a211 1
    {
d215 1
a215 1
    };
d222 1
a222 1
    {
d227 1
a227 1
    };
d238 1
a238 1
    {
d257 1
a257 1
    };
d271 1
a271 1
    {
d275 1
a275 1
    };
d288 1
a288 1
    {
d293 1
a293 1
    };
d310 1
a310 1
    {
d318 1
a318 1
    };
d328 1
a328 1
    {
d334 1
a334 1
    };
d347 1
a347 1
    {
d360 1
a360 1
    };
d373 1
a373 1
    {
d384 1
a384 1
    };
d396 1
a396 1
    {
d413 1
a413 1
    };
d433 1
a433 1
    {
d448 1
a448 1
    };
d462 1
a462 1
    {
d474 1
a474 1
    };
d484 1
a484 1
    {
d488 1
a488 1
    };
d506 1
a506 1
    {
d511 1
a511 1
    };
@


38.3
log
@GadToolsLib structure now defined here.
@
text
@d11 1
a11 1
*   $Id: gtinternal.h,v 38.2 92/01/15 11:02:34 peter Exp Locker: peter $
d244 2
a245 1
    ULONG lvid_Flags;			/*  See below */
a247 1
    WORD lvid_Width;			/*  Of frame, less Scroller */
a248 4
    WORD lvid_InterSpace;
    WORD lvid_EachHeight;    		/*  Resulting height of each line */
    WORD lvid_Count;			/*  Resulting number of lines */
    struct TextAttr *lvid_TextAttr;	/*  Original TextAttr structure */
d253 2
a254 1
    struct VisualInfo *lvid_VisualInfo;
d260 2
a261 2
#define LV_READONLY	0x00000001	/*  Read-only list */
#define LV_DEFERREFRESH	0x00000004	/*  defer refreshing since list is
a292 1
    struct Image *mxid_Image;
a354 1
    struct VisualInfo *nwid_VisualInfo;
d412 1
d419 8
a426 6
/*  Scroller flags: */
/*  SC_GADGETDOWN / SC_GADGETUP must be the same as their SL_ counterparts */
#define SC_VERTICAL	0x00000001	/*  Vert. scroller */
#define SC_GADGETDOWN	0x00000002	/*  Guaranteed msg upon GADGETDOWN */
#define SC_GADGETUP	0x00000004	/*  Guaranteed msg upon GADGETUP */
#define SC_ARROWS	0x00000008	/*  Has arrows */
d446 2
a447 1
    struct VisualInfo *slid_VisualInfo;
d454 1
a454 6
/*  Slider flags: */
/*  SL_GADGETDOWN / SL_GADGETUP must be the same as their SC_ counterparts */
#define SL_VERTICAL	0x00000001	/*  Vert. slider */
#define SL_GADGETDOWN	0x00000002	/*  Guaranteed msg upon GADGETDOWN */
#define SL_GADGETUP	0x00000004	/*  Guaranteed msg upon GADGETUP */
#define SL_DISPLAYLEVEL	0x00000008	/*  Display level beside slider */
d467 2
@


38.2
log
@Removed definitions for sketch gadget.
@
text
@d11 1
a11 1
*   $Id: gtinternal.h,v 38.1 91/11/27 13:17:57 peter Exp Locker: peter $
a12 54
*   $Log:	gtinternal.h,v $
 * Revision 38.1  91/11/27  13:17:57  peter
 * Revised structures for Palette, ListView, MX.  SpecialGadget no longer
 * contains a node.
 * Removed definition of GTST_EditHook, since it's now in gadtools.h.
 * 
 * Revision 38.0  91/07/11  12:33:53  peter
 *  Initial V38 check-in (matches V37 release).
 * 
*   Revision 36.13  91/04/08  13:24:37  peter
*   Defined getGTTagData(), getSTRINGTagData(), findGTTagItem(), and findGATagItem()
*   as macros that remove the appropriate tag-base (or dummy) from a tag value,
*   then call a stub which reintroduces it, to save space.
*   
*   Revision 36.12  91/03/14  16:07:57  peter
*   ListViewIData now stores the tag (GTTX_Text or GTST_String).
*   
*   Revision 36.11  91/01/28  13:30:30  peter
*   Added ctid_DelayedFree field to ContextIData structure.
*   
*   Revision 36.10  90/12/18  18:13:16  peter
*   Definition of QuasiMessage now lives here.
*   ContextIData extended to include an instance of a QuasiMessage.
*   
*   Revision 36.9  90/11/19  12:55:49  peter
*   Added Border->BackPen codes for BorderCompIClass.
*   
*   Revision 36.8  90/11/07  19:42:43  peter
*   Added definition for struct CycleBorder.  Added an attribute tag for
*   BorderCompIClass.  Added more pen shorthands to the VisualInfo
*   structure.
*   
*   Revision 36.7  90/10/12  19:41:52  peter
*   MXIData structure no longer contains mxid_Labels.
*   
*   Revision 36.6  90/05/30  13:51:03  peter
*   Defined GTST_EditHook to be GT_Reserved0.
*   
*   Revision 36.5  90/05/15  14:16:29  peter
*   Added Extent rectangle to instance data for text and number display gadgets.
*   
*   Revision 36.4  90/05/03  16:30:46  peter
*   Added NM_TRUETYPE() macro for custom imagery in menus.
*   
*   Revision 36.3  90/04/02  16:07:04  peter
*   Added #define GADTOOL_TYPE.
*   
*   Revision 36.2  90/03/31  06:38:51  peter
*   Added NWAYGLYPHWIDTH define.
*   
*   Revision 36.1  90/03/16  14:06:04  peter
*   RCS Clean up.
*   
*
d21 4
d45 16
@


38.1
log
@Revised structures for Palette, ListView, MX.  SpecialGadget no longer
contains a node.
Removed definition of GTST_EditHook, since it's now in gadtools.h.
@
text
@d11 1
a11 1
*   $Id: gtinternal.h,v 38.0 91/07/11 12:33:53 peter Exp Locker: peter $
d14 5
d124 2
a462 35

/*------------------------------------------------------------------------*/

/*  Instance data for sketch gadget: */

struct XSketch
    {
    struct Gadget skid_Gadget;
    struct RastPort *skid_RastPort;
    UWORD skid_bmWidth;		/*  Width of BitMap */
    UWORD skid_bmHeight;	/*  Height of BitMap */
    UWORD skid_MagWidth;	/*  Width of each magnified pixel */
    UWORD skid_MagHeight;	/*  Height of each magnified pixel */
    UWORD skid_FirstColor;	/*  First color register to use in sketch */
    UWORD skid_Color;		/*  Current drawing color */
    UWORD skid_LastX;		/*  x-coord of last pixel drawn */
    UWORD skid_LastY;		/*  y-coord of last pixel drawn */
    UWORD skid_LastColor;	/*  color of last pixel drawn */
    ULONG skid_Flags;		/*  See below */
    UWORD skid_HotSpotX;	/*  X-coordinate of HotSpot */
    UWORD skid_HotSpotY;	/*  Y-coordinate of HotSpot */
    UWORD skid_HSColor;		/*  Color to use for HotSpot */
    UWORD skid_HSXThick;	/*  Hot spot outline x-thickness */
    UWORD skid_HSYThick;	/*  Hot spot outline y-thickness */
    };

#define SKETCH_IDATA_SIZE	(sizeof(struct XSketch)-sizeof(struct Gadget))

#define SKID(g)	((struct XSketch *)(g))

#define SK_HOTSPOT	0x00000001	/* Sketch has hot-spot */
#define SK_SETHOTSPOT	0x00000002	/* Waiting for user to click the
					   HotSpot */
#define SK_POSTSETHS	0x00000004	/* Waiting for user to release the
					   mouse after setting hotspot */
@


38.0
log
@ Initial V38 check-in (matches V37 release).
@
text
@d11 1
a11 1
*   $Id: gtinternal.h,v 36.13 91/04/08 13:24:37 peter Exp $
d14 3
a114 1
#define GTST_EditHook	GT_Reserved0	/* Private use by ASL */
a198 1
    struct MinNode sg_Node;	/*  Parent keeps a MinList of kids */
d264 1
a264 1
struct ListViewIData
d266 2
d294 1
a294 1
#define LVID(sg)	((struct ListViewIData *)MEMORY_FOLLOWING(sg))
d296 2
d300 1
a300 1
struct ListLineIData
d302 2
d307 3
a309 1
#define LLID(sg)	((struct ListLineIData *)MEMORY_FOLLOWING(sg))
d317 1
a317 1
struct MXIData
d319 4
a322 2
    struct SpecialGadget *mxid_ActiveSG;
    struct MinList mxid_List;
a323 2
    ULONG mxid_Flags;
    UWORD mxid_Active;
d326 3
a328 1
#define MXID(sg)	((struct MXIData *)MEMORY_FOLLOWING(sg))
d337 1
a337 1
/*  Shared with Text display routines, so it must match TextIData
d339 2
a340 1
struct NumberIData
d342 2
d351 19
a369 1
#define NMID(sg)	((struct NumberIData *)MEMORY_FOLLOWING(sg))
d377 1
a377 1
struct NWayIData
d379 2
d387 8
a394 1
    };
d396 1
a396 1
#define NWID(sg)	((struct NWayIData *)MEMORY_FOLLOWING(sg))
d404 1
a404 1
struct PaletteIData
d406 2
a407 10
    UBYTE paid_Color;		/*  Active color */
    UBYTE paid_ColorOffset;	/*  1st color to use in palette */
    WORD paid_IndicLeft;	/*  Dimensions of indicator area */
    WORD paid_IndicTop;
    WORD paid_IndicWidth;
    WORD paid_IndicHeight;
    WORD paid_SelectLeft;	/*  Dimensions of select area */
    WORD paid_SelectTop;
    WORD paid_SelectWidth;
    WORD paid_SelectHeight;
d409 12
a420 3
    struct Gadget *paid_FirstGadget;
    UWORD paid_Count;
    };
a421 1
#define PAID(sg)	((struct PaletteIData *)MEMORY_FOLLOWING(sg))
d427 1
a427 1
struct ScrollerIData
d429 7
a435 5
    WORD sc_Top;			/*  First one you want displayed */
    WORD sc_Total;			/*  total elements in list */
    WORD sc_Visible;			/*  Number visible at one time */
    UWORD sc_TickCount;
    ULONG sc_Flags;			/*  See gadtools.h */
d437 1
a437 1
    struct Gadget *sc_ListView;		/*  PRIVATE kludge pointer back
d439 8
a446 6
    struct Gadget *sc_Prop;		/*  Pointer to prop gadget */
    struct Gadget *sc_Up;		/*  Pointer to up arrow gadget */
    struct Gadget *sc_Down;		/*  Pointer to down arrow gadget */
    UWORD *sc_Body, *sc_Pot;
    struct VisualInfo *sc_VisualInfo;
    };
d448 1
a448 1
#define SCID(sg)	((struct ScrollerIData *)MEMORY_FOLLOWING(sg))
d461 1
a461 1
struct SketchIData
d463 1
d482 1
a482 1
#define SKID(sg)	((struct SketchIData *)MEMORY_FOLLOWING(sg))
d484 2
d496 1
a496 1
struct SliderIData
d498 16
a513 12
    WORD sl_Min;		/*  Minimum level */
    WORD sl_Max;		/*  Maximum level */
    WORD sl_Level;		/*  Current level */
    ULONG sl_Flags;		/*  See gadtools.h */
    LONG (*sl_DispFunc)();	/*  Callback for number recalc. */

    UWORD *sl_Body;		/*  Pointer to Vert or HorizBody */
    UWORD *sl_Pot;		/*  Pointer to Vert or HorizPot */
    struct IntuiText *sl_IText;	/*  IntuiText to render label/level */
    UBYTE *sl_LevelFormat;	/*  Format String for level */
    struct VisualInfo *sl_VisualInfo;
    };
d515 1
a515 1
#define SLID(sg)	((struct SliderIData *)MEMORY_FOLLOWING(sg))
a522 13

/*------------------------------------------------------------------------*/

/*  Instance data for simple text display: */

struct TextIData
    {
    struct VisualInfo *txid_VisualInfo;
    struct IntuiText txid_IText;
    struct Rectangle txid_Extent;
    };

#define TXID(sg)	((struct TextIData *)MEMORY_FOLLOWING(sg))
@
