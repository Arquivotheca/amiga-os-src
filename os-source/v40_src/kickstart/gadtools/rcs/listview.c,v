head     39.21;
branch   ;
access   ;
symbols  ;
locks    ; strict;
comment  @ * @;


39.21
date     93.05.24.11.59.08;  author vertex;  state Exp;
branches ;
next     39.20;

39.20
date     93.04.08.13.38.03;  author vertex;  state Exp;
branches ;
next     39.19;

39.19
date     92.10.16.18.30.59;  author vertex;  state Exp;
branches ;
next     39.18;

39.18
date     92.08.19.18.10.38;  author vertex;  state Exp;
branches ;
next     39.17;

39.17
date     92.07.16.11.01.47;  author vertex;  state Exp;
branches ;
next     39.16;

39.16
date     92.06.08.16.40.15;  author vertex;  state Exp;
branches ;
next     39.15;

39.15
date     92.06.03.10.15.55;  author vertex;  state Exp;
branches ;
next     39.14;

39.14
date     92.05.31.16.47.25;  author vertex;  state Exp;
branches ;
next     39.13;

39.13
date     92.05.30.12.04.16;  author vertex;  state Exp;
branches ;
next     39.12;

39.12
date     92.05.29.18.49.47;  author vertex;  state Exp;
branches ;
next     39.11;

39.11
date     92.05.29.18.07.15;  author vertex;  state Exp;
branches ;
next     39.10;

39.10
date     92.05.29.15.21.53;  author vertex;  state Exp;
branches ;
next     39.9;

39.9
date     92.04.24.10.21.14;  author vertex;  state Exp;
branches ;
next     39.8;

39.8
date     92.04.15.11.33.59;  author vertex;  state Exp;
branches ;
next     39.7;

39.7
date     92.04.13.14.07.24;  author vertex;  state Exp;
branches ;
next     39.6;

39.6
date     92.04.07.13.46.17;  author vertex;  state Exp;
branches ;
next     39.5;

39.5
date     92.03.26.15.16.21;  author peter;  state Exp;
branches ;
next     39.4;

39.4
date     92.03.24.15.14.58;  author peter;  state Exp;
branches ;
next     39.3;

39.3
date     92.02.20.11.50.18;  author peter;  state Exp;
branches ;
next     39.2;

39.2
date     92.02.03.15.48.43;  author peter;  state Exp;
branches ;
next     39.1;

39.1
date     92.01.30.19.53.07;  author peter;  state Exp;
branches ;
next     38.3;

38.3
date     92.01.30.18.08.45;  author peter;  state Exp;
branches ;
next     38.2;

38.2
date     92.01.15.11.02.48;  author peter;  state Exp;
branches ;
next     38.1;

38.1
date     91.11.27.13.17.22;  author peter;  state Exp;
branches ;
next     38.0;

38.0
date     91.07.11.12.34.18;  author peter;  state Exp;
branches ;
next     ;


desc
@@


39.21
log
@Renders unused items with BACKGROUNDPEN instead of EraseRect()
@
text
@/*** listview.c ************************************************************
*
*   listview.c	- Scrolling ListView routines
*
*   Copyright 1989, 1990, Commodore-Amiga, Inc.
*
*   $Id: listview.c,v 39.20 93/04/08 13:38:03 vertex Exp Locker: vertex $
*
**************************************************************************/

/*------------------------------------------------------------------------*/

#include "gtinclude.h"
#include <intuition/cghooks.h>


/*****************************************************************************/


BOOL HandleListView(struct ExtGadget *gad, struct IntuiMessage *imsg);
VOID SetListViewAttrsA(struct ExtGadget *gad, struct Window *win,
                       struct TagItem *taglist);


/*****************************************************************************/


#define RENDER_FULL      1
#define RENDER_UPDATE    2
#define RENDER_SELECT    3
#define RENDER_DESELECT  4


/*****************************************************************************/


static VOID ASM DefaultCallBack(REG(a1) struct LVDrawMsg *msg,
                                REG(a2) struct Node *node)
{
struct RastPort   *rp    = msg->lvdm_RastPort;
UBYTE              state = msg->lvdm_State;
struct TextExtent  extent;
ULONG              fit;
WORD               x,y;
WORD               slack;
ULONG              apen;
ULONG              bpen;
UWORD             *pens = msg->lvdm_DrawInfo->dri_Pens;
STRPTR             name;

    apen = pens[FILLTEXTPEN];
    bpen = pens[FILLPEN];
    if ((state == LVR_NORMAL) || (state == LVR_NORMALDISABLED))
    {
        apen = pens[TEXTPEN];
        bpen = pens[BACKGROUNDPEN];
    }
    SetABPenDrMd(rp,apen,bpen,JAM2);

    name = node->ln_Name;

    fit = TextFit(rp,name,strlen(name),&extent,NULL,1,
                  msg->lvdm_Bounds.MaxX-msg->lvdm_Bounds.MinX-3,
                  msg->lvdm_Bounds.MaxY-msg->lvdm_Bounds.MinY+1);

    slack = (msg->lvdm_Bounds.MaxY - msg->lvdm_Bounds.MinY) - (extent.te_Extent.MaxY - extent.te_Extent.MinY);

    x = msg->lvdm_Bounds.MinX - extent.te_Extent.MinX + 2;
    y = msg->lvdm_Bounds.MinY - extent.te_Extent.MinY + ((slack+1) / 2);

    extent.te_Extent.MinX += x;
    extent.te_Extent.MaxX += x;
    extent.te_Extent.MinY += y;
    extent.te_Extent.MaxY += y;

    Move(rp,x,y);
    Text(rp,name,fit);

    SetAPen(rp,bpen);
    FillOldExtent(rp,&msg->lvdm_Bounds,&extent.te_Extent);

    if ((state == LVR_NORMALDISABLED) || (state == LVR_SELECTEDDISABLED))
    {
        Ghost(rp,pens[BLOCKPEN],msg->lvdm_Bounds.MinX, msg->lvdm_Bounds.MinY,
                                msg->lvdm_Bounds.MaxX, msg->lvdm_Bounds.MaxY);
    }
}


/*****************************************************************************/


static VOID RenderLV(struct ExtGadget *lv, struct Window *wp, UWORD render)
{
struct Node      *node;
struct LVDrawMsg  dm;
ULONG             itemHeight = LVID(lv)->lvid_ItemHeight;
UWORD             yPos;
UWORD             i,start,end;
LONG              scrCnt,dy;
struct RastPort   clonerp;
struct RastPort  *rp;
struct ExtGadget *gad = LVID(lv)->lvid_ListGad;
struct Hook      *oldHook;
BOOL              damage;
struct Layer     *layer;
LONG              maxY;

    if (LVID(lv)->lvid_Labels == (struct List *)~0)
        return;

    if (rp = GetRP(lv,wp))
    {
        dm.lvdm_MethodID    = LV_DRAW;
        dm.lvdm_RastPort    = &clonerp;
        dm.lvdm_DrawInfo    = LVID(lv)->lvid_DrawInfo;
        dm.lvdm_Bounds.MinX = gad->LeftEdge;
        dm.lvdm_Bounds.MinY = gad->TopEdge;
        dm.lvdm_Bounds.MaxX = gad->LeftEdge + gad->Width - 1;

        cloneRastPort(&clonerp,rp);
        SetFont(&clonerp,LVID(lv)->lvid_Font);
        SetMaxPen(&clonerp,LVID(lv)->lvid_MaxPen);

        start = 0;

        if (render == RENDER_FULL)
        {
            end = LVID(lv)->lvid_Visible;
        }
        else if ((render == RENDER_SELECT) || (render == RENDER_DESELECT))
        {
            if ((LVID(lv)->lvid_Selected < LVID(lv)->lvid_Top)
            ||  (LVID(lv)->lvid_Selected >= LVID(lv)->lvid_Top + LVID(lv)->lvid_Visible))
                return;

            start = LVID(lv)->lvid_Selected - LVID(lv)->lvid_Top;
            end = start + 1;
        }
        else if (LVID(lv)->lvid_Top != LVID(lv)->lvid_OldTop)
        {
            scrCnt = LVID(lv)->lvid_Top - LVID(lv)->lvid_OldTop;

            if (abs(scrCnt)+1 < LVID(lv)->lvid_Visible)
            {
                dy = scrCnt * itemHeight;

                if (dy<0)
                {
                    end = -scrCnt;
                }
                else
                {
                    end   = LVID(lv)->lvid_Visible;
                    start = end - scrCnt;
                }

		layer = wp->WLayer;
                LockLayerInfo(layer->LayerInfo);
                oldHook = InstallLayerHook(layer,LAYERS_NOBACKFILL);

                damage = (LAYERREFRESH & layer->Flags);

	        ScrollRasterBF(&clonerp,0,dy,dm.lvdm_Bounds.MinX,
                                             dm.lvdm_Bounds.MinY,
                                             dm.lvdm_Bounds.MaxX,
                                             dm.lvdm_Bounds.MinY + UMult32(itemHeight,LVID(lv)->lvid_Visible) - 1);

                if (!damage && (LAYERREFRESH & layer->Flags))
                {
                    BeginRefresh(wp);
                    RenderLV(lv,wp,RENDER_FULL);
                    EndRefresh(wp,TRUE);
                }

                InstallLayerHook(layer,oldHook);
                UnlockLayerInfo(layer->LayerInfo);
            }
            else
            {
                end = LVID(lv)->lvid_Visible;
            }
        }
        else
        {
            return;
        }

        yPos = dm.lvdm_Bounds.MinY + start*itemHeight;

        if (LVID(lv)->lvid_Labels)
        {
            end   -= start;
            start += LVID(lv)->lvid_Top;
            i      = start;

            node = LVID(lv)->lvid_Labels->lh_Head;
            while (start-- && node->ln_Succ)
                node = node->ln_Succ;

            while (end-- && node->ln_Succ)
            {
                dm.lvdm_Bounds.MinY = yPos;
                dm.lvdm_Bounds.MaxY = yPos + itemHeight - 1;
                dm.lvdm_State       = LVR_NORMAL;

                if ((i == LVID(lv)->lvid_Selected) && (render != RENDER_DESELECT))
                    dm.lvdm_State = LVR_SELECTED;

                if (gad->Flags & GFLG_DISABLED)
                    dm.lvdm_State = dm.lvdm_State * 6 + 2;   /* don't ask... */

                CallHookPkt(LVID(lv)->lvid_CallBack,node,&dm);

                node = node->ln_Succ;

                yPos += itemHeight;
                i++;
            }
        }

        maxY = gad->TopEdge + gad->Height - 1;
        if ((render == RENDER_FULL) && (yPos <= maxY))
        {
            SetAPen(&clonerp,LVID(lv)->lvid_DrawInfo->dri_Pens[BACKGROUNDPEN]);
            RectFill(&clonerp,dm.lvdm_Bounds.MinX,yPos,dm.lvdm_Bounds.MaxX,maxY);

            if (gad->Flags & GFLG_DISABLED)
                Ghost(&clonerp,LVID(lv)->lvid_DrawInfo->dri_Pens[BLOCKPEN],
                      dm.lvdm_Bounds.MinX,
                      yPos,
                      dm.lvdm_Bounds.MaxX,
                      maxY);
        }
    }

    LVID(lv)->lvid_OldTop = LVID(lv)->lvid_Top;
}


/*****************************************************************************/


static VOID SetLVAttrs(struct ExtGadget *lv,
                       struct Window *wp,
                       struct TagItem *taglist)
{
struct TagItem   *tag;
struct Node      *node;
WORD              render = 0;
WORD              oldTop;
WORD              newTop;
WORD              oldSelected;
WORD              newSelected;
WORD              makeVis;
WORD              i;
WORD              maxTop;
struct ExtGadget *gad = LVID(lv)->lvid_ListGad;
BOOL              disabled;

    disabled = (gad->Flags & GFLG_DISABLED);
    TagAbleGadget(gad,wp,taglist);
    if (disabled != (gad->Flags & GFLG_DISABLED))
        render = RENDER_FULL;

    if (tag = findGTTagItem(GTLV_Labels,taglist))
    {
	LVID(lv)->lvid_Labels = (struct List *)tag->ti_Data;
	LVID(lv)->lvid_Total  = 0;

	if (LVID(lv)->lvid_Labels && (LVID(lv)->lvid_Labels != (struct List *)~0))
	{
            node = LVID(lv)->lvid_Labels->lh_Head;
            while (node->ln_Succ)
            {
                LVID(lv)->lvid_Total++;
                node = node->ln_Succ;
            }
	}
	render = RENDER_FULL;
    }

    /* don't do anything else if we have detached labels! */
    if (LVID(lv)->lvid_Labels == (struct List *)~0)
        return;

    oldTop = LVID(lv)->lvid_Top;
    newTop = getGTTagData(GTLV_Top,oldTop,taglist);

    if ((maxTop = LVID(lv)->lvid_Total - LVID(lv)->lvid_Visible) < 0)
        maxTop = 0;

    if (tag = findGTTagItem(GTLV_MakeVisible,taglist))
    {
        makeVis = tag->ti_Data;
        if (makeVis < 0)
            makeVis = 0;

        if (makeVis < oldTop)
            newTop = makeVis;

        if (makeVis >= oldTop + LVID(lv)->lvid_Visible)
            newTop = makeVis - LVID(lv)->lvid_Visible + 1;
    }

    if (newTop > maxTop)
        newTop = maxTop;

    oldSelected = LVID(lv)->lvid_Selected;
    if (LVID(lv)->lvid_AllowSelections)
        newSelected = getGTTagData(GTLV_Selected,oldSelected,taglist);
    else
        newSelected = ~0;

    if (newSelected >= LVID(lv)->lvid_Total)   /* fails if newSelected == ~0 */
    {
        /* NOTE! If LVID(lv)->lvid_Total is 0, newSelected will become
         * -1, or in other words ~0
         */
        newSelected = LVID(lv)->lvid_Total - 1;
    }

    if ((newSelected != oldSelected) && (!LVID(lv)->lvid_ReadOnly))
    {
        if (render == 0)
        {
            if (oldSelected != ~0)
                RenderLV(lv,wp,RENDER_DESELECT);
            render = RENDER_SELECT;
        }
        LVID(lv)->lvid_Selected = newSelected;
    }

    LVID(lv)->lvid_SelectedName = NULL;
    if (LVID(lv)->lvid_Labels)
    {
        i    = LVID(lv)->lvid_Selected;
	node = LVID(lv)->lvid_Labels->lh_Head;
	while (node->ln_Succ)
	{
	    if (i == 0)
		LVID(lv)->lvid_SelectedName = node->ln_Name;

            i--;
	    node = node->ln_Succ;
	}
    }

    if (oldTop != newTop)
    {
        LVID(lv)->lvid_Top = newTop;

        if (render == 0)
            render = RENDER_UPDATE;
        else if (render == RENDER_SELECT)
            render = RENDER_FULL;
    }

    if (render)
        RenderLV(lv,wp,render);
}


/*****************************************************************************/


VOID RefreshLV(struct ExtGadget *lv, struct Window *wp, BOOL refresh)
{
    RenderLV(lv,wp,RENDER_FULL);
}


/*****************************************************************************/


WORD MouseY(struct Window *wp)
{
    if (wp->Flags & WFLG_GIMMEZEROZERO)
        return(wp->GZZMouseY);

    return(wp->MouseY);
}


/*****************************************************************************/


static WORD GetMaxPen(struct DrawInfo *di, LONG pen, ...)
{
WORD  maxPen;
LONG *ptr;

    maxPen = 0;
    ptr    = &pen;
    while (*ptr != -1)
    {
        if (di->dri_Pens[*ptr] > maxPen)
            maxPen = di->dri_Pens[*ptr];

        ptr++;
    }

    return(maxPen);
}


/*****************************************************************************/


typedef unsigned long (*HOOKFUNC)();


struct ExtGadget *CreateListViewA(struct ExtGadget *gad, struct NewGadget *ng,
                                  struct TagItem *taglist)
{
struct NewGadget  mod_ng;
struct ExtGadget *preLV, *lv;
struct TagItem   *tag;
struct ExtGadget *displaygad = NULL;
long             frametype;
LONG             lvheight;
UWORD            scrollwidth;
UWORD            itemHeight;
UWORD            visible;
struct TagItem   tags[2];

    mod_ng               = *ng;
    mod_ng.ng_GadgetText = NULL;

    tags[0].ti_Tag  = GA_Disabled;   /* overide setting in taglist */
    tags[0].ti_Data = FALSE;
    tags[1].ti_Tag  = TAG_MORE;
    tags[1].ti_Data = (ULONG)taglist;
    if (!(lv = CreateGenericBase(gad, ng, LISTVIEW_IDATA_SIZE,tags)))
    	return(NULL);

    if (tag = findGTTagItem(GTLV_ShowSelected,taglist))
    {
        LVID(lv)->lvid_AllowSelections = TRUE;
	if (displaygad = (struct ExtGadget *)tag->ti_Data)    /* not NULL means caller has a string gadget */
	{
	    /* The visual Width had better match since we can't adjust it */
	    if (displaygad->Width + (LRTRIM + 2 * BEVELXSIZE) != ng->ng_Width)
		return(NULL);

	    displaygad->LeftEdge = ng->ng_LeftEdge + LEFTTRIM + BEVELXSIZE;
	    displaygad->TopEdge  = ng->ng_TopEdge + TOPTRIM + BEVELYSIZE;
            displaygad->MoreFlags &= ~(GMORE_GADGETHELP);   /* no help on the display gadget, the listview dummy gadget takes care of that */
	}
    }

    scrollwidth = getGTTagData(GTLV_ScrollWidth, 16, taglist);
    itemHeight  = getGTTagData(GTLV_ItemHeight,ng->ng_TextAttr->ta_YSize,taglist)
                  + getTagData(LAYOUTA_SPACING, 0, taglist);

    if ((visible = (ng->ng_Height - TBTRIM - (displaygad ? displaygad->BoundsHeight : 0)) / itemHeight) == 0)
	return(NULL);

    lvheight = visible * itemHeight + TBTRIM;

    if (displaygad)
	displaygad->TopEdge += lvheight;

    preLV = gad;

    SGAD(lv)->sg_SetAttrs = SetListViewAttrsA;
    SGAD(lv)->sg_GetTable = Listview_GetTable;
    SGAD(lv)->sg_Flags    = SG_EXTRAFREE_DISPOSE | SG_EXTRAFREE_DISPOSE_LV;
    SGAD(lv)->sg_Refresh  = RefreshLV;

    LVID(lv)->lvid_DefaultCallBack.h_SubEntry = (HOOKFUNC)DefaultCallBack;
    LVID(lv)->lvid_DefaultCallBack.h_Entry    = callCHook;
    LVID(lv)->lvid_DefaultCallBack.h_Data     = GadToolsBase;
    LVID(lv)->lvid_CallBack                   = (struct Hook *)getGTTagData(GTLV_CallBack,(ULONG)&LVID(lv)->lvid_DefaultCallBack,taglist);
    LVID(lv)->lvid_ItemHeight                 = itemHeight;
    LVID(lv)->lvid_Visible                    = visible;
    LVID(lv)->lvid_DisplayGad                 = displaygad;
    LVID(lv)->lvid_Selected                   = (UWORD)~0;
    LVID(lv)->lvid_Font                       = OpenFont(ng->ng_TextAttr);
    LVID(lv)->lvid_DrawInfo                   = VI(ng->ng_VisualInfo)->vi_DrawInfo;
    LVID(lv)->lvid_MaxPen                     = getGTTagData(GTLV_MaxPen,
                                                             GetMaxPen(LVID(lv)->lvid_DrawInfo,
                                                                       TEXTPEN,BACKGROUNDPEN,
                                                                       FILLPEN,FILLTEXTPEN,
                                                                       BLOCKPEN,
                                                                      -1),
                                                             taglist);

    frametype = FRAME_BUTTON;
    if (LVID(lv)->lvid_ReadOnly = getGTTagData(GTLV_ReadOnly, FALSE, taglist))
	frametype = FRAME_BUTTON|FRAMETYPE_RECESSED;

    if (!(lv->GadgetRender = getBevelImage(0,0,ng->ng_Width - scrollwidth,lvheight,frametype)))
	return(NULL);

    /* Well, doesn't this just suck?  The dummy gadget's height
     * should really be lvheight + displaygad->BoundsHeight,
     * but V37 forgets to add the bounds height of the display gadget.
     * Applications are depending on this, unfortunately.
     * The extra height is needed for correct label positioning,
     * so watch me add it for placeGadgetText(), then uncorrect
     * it for compatibility.
     * I'm not a happy guy, but it's a self-inflicted wound :-(
     */
    /* Set the true height of the gadget: */
    lv->Height = lvheight;
    if (displaygad)
	lv->Height += displaygad->BoundsHeight;

    lv->BoundsHeight = lv->Height;
    placeGadgetText(lv, ng->ng_Flags, PLACETEXT_ABOVE, NULL );
    lv->Height = lvheight;
    lv->Flags  |= GADGIMAGE | GADGHNONE;

    mod_ng.ng_LeftEdge = ng->ng_LeftEdge + 2;
    mod_ng.ng_TopEdge  = ng->ng_TopEdge + 2;
    mod_ng.ng_Width    = lv->Width - scrollwidth - 4;
    mod_ng.ng_Height   = lvheight - TBTRIM;
    if (!(gad = LVID(lv)->lvid_ListGad = (struct ExtGadget *)CreateGadget(GENERIC_KIND, lv, &mod_ng,
                                                             TAG_MORE, taglist)))
    {
        return(NULL);
    }

    gad->Flags                 = GADGHNONE | GADGIMAGE;  /* clears away GFLG_EXTENDED */
    gad->Activation            = GADGIMMEDIATE | RELVERIFY | FOLLOWMOUSE;
    gad->GadgetType           |= BOOLGADGET;
    SGAD(gad)->sg_Parent       = lv;
    SGAD(gad)->sg_EventHandler = HandleListView;
    SGAD(gad)->sg_Flags        = SG_MOUSEMOVE | SG_MOUSEBUTTONS | SG_INTUITICKS;

    /* get us a scroller! */
    mod_ng.ng_LeftEdge = ng->ng_LeftEdge + ng->ng_Width - scrollwidth;
    mod_ng.ng_TopEdge  = ng->ng_TopEdge;
    mod_ng.ng_Width    = scrollwidth;
    mod_ng.ng_Height   = lvheight;

    /* !!! Would need some tagitem filtering here: */
    if (!(gad = (struct ExtGadget *)CreateGadget(SCROLLER_KIND,gad,&mod_ng,
                             GTSC_Visible, visible,
                             PGA_FREEDOM,  LORIENT_VERT,
                             /* Arrows should be the same height as a single line, but no bigger
                              * than 1/4 the height of the whole scroller:
                              */
                             GTSC_Arrows,  min(itemHeight,mod_ng.ng_Height >> 2),
                             GA_Disabled,  FALSE,   /* override setting in user tag list */
                             TAG_MORE,     taglist)))
    {
	return(NULL);
    }

    LVID(lv)->lvid_Scroller  = gad;
    SCID(gad)->scid_ListView = lv;         /* Install back pointer into Scroller */
    gad->MoreFlags &= ~(GMORE_GADGETHELP); /* no help on the scroller, the dummy gadget takes care of that */

    SetListViewAttrsA(lv,NULL,taglist);

    preLV->NextGadget = lv->NextGadget;
    gad->NextGadget   = lv;
    lv->NextGadget    = NULL;

    return(lv);
}


/*****************************************************************************/


BOOL HandleListView(struct ExtGadget *gad, struct IntuiMessage *imsg)
{
struct ExtGadget *lv = SGAD(gad)->sg_Parent;
WORD              newSelected;
struct TagItem    tags[3];
BOOL              result;
ULONG             class = imsg->Class;
struct Window    *wp    = imsg->IDCMPWindow;
BOOL              allowSelections;

    if (MouseY(wp) < gad->TopEdge)
    {
        if (class == IDCMP_MOUSEMOVE)
            return(FALSE);

        if (newSelected = LVID(lv)->lvid_Top)  /* assignment! */
            newSelected--;
    }
    else if (MouseY(wp) >= gad->TopEdge + gad->Height)
    {
        if (class == IDCMP_MOUSEMOVE)
            return(FALSE);

        newSelected = LVID(lv)->lvid_Top + LVID(lv)->lvid_Visible;
    }
    else
    {
        newSelected = (MouseY(wp) - gad->TopEdge) / LVID(lv)->lvid_ItemHeight + LVID(lv)->lvid_Top;
    }

    if (newSelected >= LVID(lv)->lvid_Total)
    {
        /* NOTE! If LVID(lv)->lvid_Total is 0, newSelected will become
         * -1, or in other words ~0
         */
        newSelected = LVID(lv)->lvid_Total - 1;
    }

    if (newSelected != LVID(lv)->lvid_Selected)
    {
        tags[0].ti_Tag  = GTLV_MakeVisible;
        tags[0].ti_Data = newSelected;
        tags[1].ti_Tag  = GTLV_Selected;
        tags[1].ti_Data = newSelected;
        tags[2].ti_Tag  = TAG_DONE;

        allowSelections = LVID(lv)->lvid_AllowSelections;
        LVID(lv)->lvid_AllowSelections = TRUE;

        SetListViewAttrsA(lv,wp,tags);

        LVID(lv)->lvid_AllowSelections = allowSelections;
    }

    if ((class == IDCMP_GADGETUP) || ((class == IDCMP_MOUSEBUTTONS) && (imsg->Code == SELECTUP)))
    {
        imsg->Class    = IDCMP_GADGETUP;
        imsg->Code     = LVID(lv)->lvid_Selected;
        imsg->IAddress = (APTR)lv;

        result = (newSelected == LVID(lv)->lvid_Selected) && (newSelected != ~0);

        if (!LVID(lv)->lvid_AllowSelections)
        {
            RenderLV(lv,wp,RENDER_DESELECT);
            LVID(lv)->lvid_Selected = (UWORD)~0;
        }

        return(result);
    }

    return(FALSE);
}


/*****************************************************************************/


VOID SetListViewAttrsA(struct ExtGadget *lv, struct Window *win,
                       struct TagItem *taglist)
{
WORD         oldTop;
WORD         oldTotal;
WORD         oldSelected;
struct List *oldLabels;

    oldTop      = LVID(lv)->lvid_Top;
    oldTotal    = LVID(lv)->lvid_Total;
    oldSelected = LVID(lv)->lvid_Selected;
    oldLabels   = LVID(lv)->lvid_Labels;

    SetLVAttrs(lv,win,taglist);

    if (LVID(lv)->lvid_Labels != (struct List *)~0)
    {
        if ((oldLabels == (struct List *)~0) || (LVID(lv)->lvid_Selected != oldSelected) || findGTTagItem(GTLV_Labels,taglist))
            GT_SetGadgetAttrs(LVID(lv)->lvid_DisplayGad,win,NULL,GTST_String, LVID(lv)->lvid_SelectedName,
                                                                 TAG_MORE,    taglist);
                                                                 /* lets GA_Disabled through */

        if ((oldLabels == (struct List *)~0) || (LVID(lv)->lvid_Total != oldTotal) || (LVID(lv)->lvid_Top != oldTop))
            GT_SetGadgetAttrs(LVID(lv)->lvid_Scroller,win,NULL,GTSC_Top,   LVID(lv)->lvid_Top,
                                                               GTSC_Total, LVID(lv)->lvid_Total,
                                                               TAG_DONE);
    }
}


/*****************************************************************************/


/* for private use by SCROLLER_KIND */
VOID SetListViewTop(struct ExtGadget *lv, struct Window *win,
                    WORD top)
{
struct TagItem tags[2];

    tags[0].ti_Tag  = GTLV_Top;
    tags[0].ti_Data = top;
    tags[1].ti_Tag  = TAG_DONE;

    SetLVAttrs(lv,win,tags);
}
@


39.20
log
@Fixed bug where the prop gadget or selected item would not be updated when going from
  a ~0 list to an empty list.
@
text
@d7 1
a7 1
*   $Id: listview.c,v 39.19 92/10/16 18:30:59 vertex Exp $
a78 5
    /*!!! The above should just be "name" instead of "node->ln_Name". The
     *    SAS/C 6.00 compiler generates bad code if just "name" is used.
     *    Whenever the compiler is fixed, the code can be changed back
     */

d225 2
a226 1
            EraseRect(&clonerp,dm.lvdm_Bounds.MinX,yPos,dm.lvdm_Bounds.MaxX,maxY);
@


39.19
log
@Changes for SAS/C 6.0
@
text
@d7 1
a7 1
*   $Id: listview.c,v 39.18 92/08/19 18:10:38 vertex Exp Locker: vertex $
d654 4
a657 3
WORD oldTop;
WORD oldTotal;
WORD oldSelected;
d662 1
d668 1
a668 1
        if ((LVID(lv)->lvid_Selected != oldSelected) || findGTTagItem(GTLV_Labels,taglist))
d673 1
a673 1
        if ((LVID(lv)->lvid_Total != oldTotal) || (LVID(lv)->lvid_Top != oldTop))
@


39.18
log
@Fixed bug with not unghosting correctly when passed GA_Disabled, FALSE
@
text
@d7 1
a7 1
*   $Id: listview.c,v 39.17 92/07/16 11:01:47 vertex Exp Locker: vertex $
a14 1
#include <math.h>
d79 5
d172 1
a172 1
                                             dm.lvdm_Bounds.MinY + itemHeight*LVID(lv)->lvid_Visible - 1);
d248 1
a248 1
static VOID SetLVAttrs(struct Gadget *lv,
d250 1
a250 1
                       struct TagList *taglist)
d414 3
d475 1
a475 1
    LVID(lv)->lvid_DefaultCallBack.h_SubEntry = (APTR)DefaultCallBack;
d482 1
a482 1
    LVID(lv)->lvid_Selected                   = ~0;
d523 2
a524 2
    if (!(gad = LVID(lv)->lvid_ListGad = CreateGadget(GENERIC_KIND, lv, &mod_ng,
                                                      TAG_MORE, taglist)))
d543 1
a543 1
    if (!(gad = CreateGadget(SCROLLER_KIND,gad,&mod_ng,
d638 1
a638 1
            LVID(lv)->lvid_Selected = ~0;
d691 1
@


39.17
log
@Fixed bug with listview gadgets not working in GZZ windows
GTLV_Selected is now rejected when passed to a listview that never got
  GTLV_ShowSelected set. This fixes 2.1 Fountain's listview rendering
No longer has a delay when scrolling off the top or bottom of a listview
Fixed bug with clicking below the last item in a listview (palette prefs)
@
text
@d7 1
a7 1
*   $Id: listview.c,v 39.16 92/06/08 16:40:15 vertex Exp Locker: vertex $
d263 1
a263 1
    if (disabled != gad->Flags & GFLG_DISABLED)
a416 1
ULONG            displaytag;
a444 1
	    displaytag           = GTST_String;
a446 14
/*
	else
	{
	    mod_ng.ng_Height = itemHeight + TBTRIM;
	    if (!(displaygad = gad = CreateGadget(TEXT_KIND,gad,&mod_ng,
                                                  GTTX_Border,  TRUE,
                                                  GTTX_BackPen, VI(ng->ng_VisualInfo)->vi_backgroundPen,
                                                  TAG_DONE)))
            {
                return(NULL);
            }
            displaytag = GTTX_Text;
	}
*/
a473 1
    LVID(lv)->lvid_DisplayTag                 = displaytag;
d660 2
a661 2
            GT_SetGadgetAttrs(LVID(lv)->lvid_DisplayGad,win,NULL,LVID(lv)->lvid_DisplayTag, LVID(lv)->lvid_SelectedName,
                                                                 TAG_MORE,taglist);
@


39.16
log
@Fixed bug where the listview was modifying values in the window's rastport
@
text
@d7 1
a7 1
*   $Id: listview.c,v 39.15 92/06/03 10:15:55 vertex Exp Locker: vertex $
d310 4
a313 1
    newSelected = getGTTagData(GTLV_Selected,oldSelected,taglist);
d376 12
d591 1
a591 11

    if (class == IDCMP_GADGETDOWN)
    {
        LVID(lv)->lvid_TickCount = 0;
    }

    if (class == IDCMP_INTUITICKS)
    {
        if (++LVID(lv)->lvid_TickCount <= ARROW_SKIPTICKS)
            return(FALSE);
    }
d593 1
a593 1
    if (wp->MouseY < gad->TopEdge)
d601 1
a601 1
    else if (wp->MouseY >= gad->TopEdge + gad->Height)
d610 1
a610 1
        newSelected = (wp->MouseY - gad->TopEdge) / LVID(lv)->lvid_ItemHeight + LVID(lv)->lvid_Top;
d613 1
a613 1
    if (newSelected > LVID(lv)->lvid_Total)
d628 4
d633 2
@


39.15
log
@Corrected vertical positioning of text lines, when dealing with values of
  LAYOUTA_SPACING different than 1. THis was causing descenders to be chopped
  on when the spacing was 0, and was causing bad looking lines when spacing was
  greater than 1
@
text
@d7 1
a7 1
*   $Id: listview.c,v 39.14 92/05/31 16:47:25 vertex Exp Locker: vertex $
d102 1
a102 1
struct RastPort   originalrp;
d116 1
a116 1
        dm.lvdm_RastPort    = rp;
d122 3
a124 4
        originalrp = *rp;    /* keep the original around for later */
        cloneRastPort(rp,&originalrp);
        SetFont(rp,LVID(lv)->lvid_Font);
        SetMaxPen(rp,LVID(lv)->lvid_MaxPen);
d165 4
a168 4
	        ScrollRasterBF(rp,0,dy,dm.lvdm_Bounds.MinX,
                                       dm.lvdm_Bounds.MinY,
                                       dm.lvdm_Bounds.MaxX,
                                       dm.lvdm_Bounds.MinY + itemHeight*LVID(lv)->lvid_Visible - 1);
d226 1
a226 1
            EraseRect(rp,dm.lvdm_Bounds.MinX,yPos,dm.lvdm_Bounds.MaxX,maxY);
d229 1
a229 1
                Ghost(rp,LVID(lv)->lvid_DrawInfo->dri_Pens[BLOCKPEN],
a234 2

        *rp = originalrp;
@


39.14
log
@Fixed bug with clicking in empty listviews. They were still returning a selection
@
text
@d7 1
a7 1
*   $Id: listview.c,v 39.13 92/05/30 12:04:16 vertex Exp Locker: vertex $
d46 1
d67 2
d70 1
a70 1
    y = msg->lvdm_Bounds.MinY - extent.te_Extent.MinY + 1;
@


39.13
log
@Fixed interaction between GTLV_MakeVisible and GTLV_Top
Made updating of optional string gadget smarter, happens less often
@
text
@d7 1
a7 1
*   $Id: listview.c,v 39.12 92/05/29 18:49:47 vertex Exp Locker: vertex $
d632 1
a632 1
        result = (newSelected == LVID(lv)->lvid_Selected);
@


39.12
log
@Fixed problem with erasing the bottom of listview having less than
  the total number of visible items.
@
text
@d7 1
a7 1
*   $Id: listview.c,v 39.11 92/05/29 18:07:15 vertex Exp Locker: vertex $
d293 13
a308 12
    makeVis = getGTTagData(GTLV_MakeVisible,newTop,taglist);

    if (makeVis >= LVID(lv)->lvid_Total)
        if (makeVis = LVID(lv)->lvid_Total)    /* assignment! */
            makeVis--;

    if (makeVis < oldTop)
        newTop = makeVis;

    if (makeVis >= oldTop + LVID(lv)->lvid_Visible)
        newTop = makeVis - LVID(lv)->lvid_Visible + 1;

d655 1
d657 3
a659 2
    oldTop   = LVID(lv)->lvid_Top;
    oldTotal = LVID(lv)->lvid_Total;
d665 1
a665 1
        if (findGTTagItem(GTLV_Selected,taglist) || findGTTagItem(GTLV_Labels,taglist))
@


39.11
log
@Fixed bug with the limiting of GTLV_Top and GTLV_MakeVisible
@
text
@d7 1
a7 1
*   $Id: listview.c,v 39.10 92/05/29 15:21:53 vertex Exp Locker: vertex $
d105 1
a105 1
LONG              height;
d221 2
a222 1
        if ((render == RENDER_FULL) && (start < LVID(lv)->lvid_Visible))
d224 1
a224 1
            height = gad->TopEdge + gad->Height - 1;
a225 2
            EraseRect(rp,dm.lvdm_Bounds.MinX,yPos,dm.lvdm_Bounds.MaxX,height);

d231 1
a231 1
                      height);
@


39.10
log
@Added GTLV_CallBack. This tag allows a callback hook to be provided
to gadtools for listview handling. Currently, the hook will only
be called to render an individual item. This ads the very useful
ability to define a callback hook which is used to scroll complex
items such as graphics, etc...

Listviews now allow strumming. That is, holding down the left mouse
button and moving the mouse up or down causes the active selection
to track the mouse. Moving the mouse off the top or bottom of the
listview causes the display to scroll

Listviews that used to have a display or string gadget underneath
them now have a highlight bar to indicate the selected item. This is
in anticipation of listview multi-selection. If the listview had a
display gadget, it no longer does as the highlight bar is used. If
a listview had a string gadget, it retains it.

Listviews highlighting is done using the pen-spec method instead of
the 1.3 complementing method.

Listviews are much faster at rendering and scrolling, which makes a
noticeable difference in 8 bit planes

Added GTLV_MaxPen tag to specify the maximum pen number used by
a custom rendering callback hook. This enables more optimal scrolling
and screen updates.

{GTLV_Selected, ~0} is now supported at both create and set times

{GTLV_Labels, ~0} is now supported at create time

Listviews now support GA_Disabled. This causes the list area to be
ghosted, but the scroller and arrows remain ungnosted.
@
text
@d7 1
a7 1
*   $Id: listview.c,v 39.9 92/04/24 10:21:14 vertex Exp Locker: vertex $
d200 1
a200 1
            while (end && (node->ln_Succ))
a216 1
                end--;
d288 5
a292 3
    oldTop  = LVID(lv)->lvid_Top;
    newTop  = getGTTagData(GTLV_Top,oldTop,taglist);
    makeVis = getGTTagData(GTLV_MakeVisible,newTop,taglist);
d294 1
a294 2
    maxTop = LVID(lv)->lvid_Total - LVID(lv)->lvid_Visible;
    if ((maxTop > 0) && (newTop > maxTop))
d296 2
@


39.9
log
@Fixed help bounding box positioning
Fixed vertical dimension calculations when a string gadget is attached
@
text
@d7 1
a7 1
*   $Id: listview.c,v 39.8 92/04/15 11:33:59 vertex Exp Locker: vertex $
d14 2
d17 204
a220 1
/*------------------------------------------------------------------------*/
d222 3
a224 7
/* !!! Notes for OOP conversion.  When we go OOP, then some aspects
 * of the gadget will happen on a task other than the client's.  We
 * will then need some arbitration on things like the list to be
 * displayed.  Likely, the client would RemoveGList() the composite
 * before playing with the list.  That is likely sufficient (must
 * consider it more deeply to be sure).
 */
d226 9
a234 1
/*------------------------------------------------------------------------*/
d236 2
a237 1
/* Function Prototypes: */
d239 89
a327 52
/* Internal: */
struct Gadget *CreateListViewA (struct Gadget *gad, struct NewGadget *ng,
    struct TagItem *taglist);
void RefreshListView (struct Gadget *lv, struct Window *win, BOOL refresh);
void SetListViewAttrsA (struct Gadget *gad, struct Window *win,
    struct Requester *req, struct TagItem *taglist);

BOOL HandleListView (struct Gadget *gad, struct IntuiMessage *imsg);
void InternalSetListViewAttrsA (struct Gadget *gad, struct Window *win,
    struct Requester *req, BOOL nosetscroller, struct TagItem *taglist);


/*****************************************************************************/


STRPTR PositionTop(struct Gadget *gad, struct TagItem *taglist)
{
UWORD           makevis;
WORD            hidden;
STRPTR          selectedName;
WORD            i;
struct Node    *node;
struct TagItem *ti;

    /* Get top, reduce it if it is too high: */
    LVID(gad)->lvid_Top = getGTTagData(GTLV_Top, LVID(gad)->lvid_Top, taglist);

    makevis = getGTTagData(GTLV_MakeVisible,LVID(gad)->lvid_Top,taglist);
    if (makevis > LVID(gad)->lvid_Total)
        makevis = LVID(gad)->lvid_Total;

    if (makevis < LVID(gad)->lvid_Top)
        LVID(gad)->lvid_Top = makevis;
    else if (makevis > LVID(gad)->lvid_Top + LVID(gad)->lvid_Visible)
        LVID(gad)->lvid_Top = makevis - LVID(gad)->lvid_Top - LVID(gad)->lvid_Visible + 1;

    hidden = max(LVID(gad)->lvid_Total - LVID(gad)->lvid_Visible, 0);
    if (LVID(gad)->lvid_Top > hidden)
	LVID(gad)->lvid_Top = hidden;

    if (ti = findGTTagItem(GTLV_Selected, taglist))
	LVID(gad)->lvid_Selected = ti->ti_Data;

    DP(("ISLVA: lvid_Selected: %ld\n", LVID(gad)->lvid_Selected));

    if (LVID(gad)->lvid_Selected > LVID(gad)->lvid_Total - 1)
	LVID(gad)->lvid_Selected = LVID(gad)->lvid_Total - 1;

    DP(("ISLVA: Adjusted lvid_Selected: %ld\n", LVID(gad)->lvid_Selected));

    LVID(gad)->lvid_TopLabel = NULL;
    selectedName = NULL;
d329 2
a330 1
    if (LVID(gad)->lvid_Labels)
d332 2
a333 2
        i    = 0;
	node = LVID(gad)->lvid_Labels->lh_Head;
d336 4
a339 12
	    DP(("ISLVA: Node #%ld, '%s'\n", ((ULONG)ind), node->ln_Name));
	    if (i == LVID(gad)->lvid_Top)
	    {
		DP(("ISLVA: This is the top\n"));
		LVID(gad)->lvid_TopLabel = node;
	    }

	    if (i == LVID(gad)->lvid_Selected)
	    {
		selectedName = node->ln_Name;
	    }
	    i++;
d344 3
a346 2
    return(selectedName);
}
d348 59
d408 2
a409 26
/*****************************************************************************/


struct Gadget *CreateListViewA(struct Gadget *gad, struct NewGadget *ng,
                               struct TagItem *taglist)
{
struct NewGadget mod_ng;
LONG count;
LONG EachHeight, NumLines;
struct Gadget *preLV, *lv;
struct Node *node;
struct TagItem *ti;
struct Gadget *displaygad = NULL;
/* Assume we'll use	GTTX_Text to change the text in attached gadget */
ULONG displaytag = GTTX_Text;
long frametype;
LONG lvheight;
UWORD scrollwidth = getGTTagData(GTLV_ScrollWidth, 16, taglist);
UWORD interspace = getTagData(LAYOUTA_SPACING, 0, taglist);
STRPTR name;

    DP(("CLV:  Enter\n"));
    DP(("CLV:  ng_TextAttr: $%lx\n", ng->ng_TextAttr));
    DP(("CLV:  ng_TextAttr->ta_Name: '%20s'\n", ng->ng_TextAttr->ta_Name));
    EachHeight = ng->ng_TextAttr->ta_YSize;
    DP(("CLV:  EachHeight = %ld\n", EachHeight));
d411 6
a416 7
    /* We'll need to make other gadgets, so start with a copy
     * of supplied ng:
     */
    mod_ng = *ng;
    mod_ng.ng_GadgetText = NULL;
    mod_ng.ng_GadgetID = 0;
    DP(("CLV:  mod_ng.ng_TextAttr after copy: $%lx\n", mod_ng.ng_TextAttr));
d418 1
a418 2
    /* Check to see if caller wanted a display or string gadget attached: */
    if (ti = findGTTagItem(GTLV_ShowSelected, taglist))
d420 2
a421 1
	if (ti->ti_Data)
d423 1
a423 7
	    DP(("CLV:  Caller wants a display string gadget\n"));
	    /* a string gadget: */
	    displaygad = (struct Gadget *)ti->ti_Data;
	    DP(("CLV:  Got it at $%lx\n", displaygad));
	    /* The visual Width had better match since we can't change
	     * it after the fact (unfortunately)
	     */
a424 1
	    {
d426 1
a426 8
	    }
	    /* We'll specify a TopEdge that would coincide with the
	     * listview's TopEdge, and simply add the height of the box
	     * of line gadgets when that becomes known.  The string
	     * gadget actually starts TOPTRIM+BEVELYSIZE down from
	     * the visuals:
	     */
	    displaygad->TopEdge = ng->ng_TopEdge + TOPTRIM + BEVELYSIZE;
d428 3
a430 2
	    /* Need to use GTST_String to change the text in attached gadget */
	    displaytag = GTST_String;
d432 1
d435 16
a450 13
	    DP(("CLV:  Caller wants a display only gadget\n"));
	    /* Got to make a display-only gadget: */
	    /* TopEdge currently coincides with the listview's TopEdge,
	     * and we'll add the height of the box of line gadgets when
	     * that becomes known.
	     */
	    mod_ng.ng_Height = EachHeight + TBTRIM;
	    displaygad = gad = CreateGadget(TEXT_KIND, gad, &mod_ng,
		GTTX_Border, TRUE,
		GTTX_BackPen, VI(ng->ng_VisualInfo)->vi_backgroundPen,
		TAG_DONE);
	    DP(("CLV  Created at $%lx\n", gad));
	}
d452 2
a453 4
	if (displaygad)
            ((struct ExtGadget *)displaygad)->MoreFlags &= ~(GMORE_GADGETHELP);
    }
    EachHeight += interspace;
d455 1
a455 10
    NumLines = (ng->ng_Height - TBTRIM -
	(displaygad ? ((struct ExtGadget *)displaygad)->BoundsHeight : 0)) / EachHeight;

    DP(("CLV:  EachHeight: %ld, NumLines: %ld\n", ((LONG)EachHeight),
	((LONG)NumLines)));
    if (NumLines <= 0)
    {
	DP(("CLV: Error on account of NumLines <= 0\n"));
	return(NULL);
    }
a456 4
    lvheight = NumLines * EachHeight + TBTRIM;
    /* Now that we know NumLines, we can work out the TopEdge of
     * the displaygad, if any:
     */
a457 2
    {
	DP(("Shifting displaygad down by %ld pixels\n", lvheight ));
a458 1
    }
a459 5
    /* We need the dummy-gadget before the line gadgets are created,
     * but we would like to return it as the result from CreateListView(),
     * so later we move it to last in this piece of gadget-list.
     * We have to save the value of gad before lv was allocated:
     */
d462 4
a465 9
    DP(("CLV:  About to create dummy gadget\n"));
    lv = gad = CreateGenericBase(gad, ng, LISTVIEW_IDATA_SIZE,
	taglist);
    if (!gad)
    {
	DP(("CLV:  Error on account of failure to allocate dummy gadget\n"));
    	return(NULL);
        }
    gad->Flags |= GADGIMAGE|GADGHNONE;
d467 18
a484 8
    DP(("CLV:  Dummy gadget sg(%lx) ID %ld at $%lx\n", sizeof(*sg),
	ng->ng_GadgetID, sg));
    /* This is the gadget that causes the refresh: */
    DP(("CLV:  Installing refresh function $%lx\n", RefreshListView));
    SGAD(gad)->sg_Refresh = RefreshListView;
    SGAD(gad)->sg_SetAttrs = SetListViewAttrsA;
    SGAD(gad)->sg_GetTable = Listview_GetTable;
    SGAD(gad)->sg_Flags = SG_EXTRAFREE_DISPOSE;
a485 3
    /* Fill in the ListView Instance Data: */
    LVID(gad)->lvid_Visible = NumLines;
    LVID(gad)->lvid_Labels = (struct List *)getGTTagData(GTLV_Labels, NULL, taglist);
d487 1
a487 3
    if ( getGTTagData(GTLV_ReadOnly, FALSE, taglist) )
    {
	LVID(gad)->lvid_Flags = LV_READONLY;
a488 48
    }
    LVID(gad)->lvid_DisplayTag = displaytag;
    LVID(gad)->lvid_DisplayGad = displaygad;
    LVID(gad)->lvid_Selected = ~0;
    {
	/* Let's fill out an IntuiText we can use for rendering */
	struct IntuiText *itext = &LVID(gad)->lvid_LineIText;

	/* The pens are set from the VisualInfo.  During actual
	 * rendering, we may complement these to render a
	 * selected item.  We then uncomplement to restore.
	 */
	itext->FrontPen = VI(ng->ng_VisualInfo)->vi_textPen;
	itext->BackPen = VI(ng->ng_VisualInfo)->vi_backgroundPen;
	itext->DrawMode = JAM2;
	/* The extra space (interspace) is distributed, half
	 * above the font, half below.  We throw the extra above,
	 * since font descenders tend to make it look like there's
	 * extra room below
	 */
	itext->TopEdge = (interspace+1)>>1;
	/* LeftEdge, TopEdge = 0 */
	itext->ITextFont = ng->ng_TextAttr;
    }

    if ( !( gad->GadgetRender = getBevelImage( 0, 0,
	ng->ng_Width - scrollwidth, lvheight, frametype ) ) )
    {
	return( NULL );
    }

    DP(("CLV:  lvid_Labels: $%lx\n", LVID(gad)->lvid_Labels));
    DP(("CLV:  lvid_Flags: %ld, lvid_DisplayGad: $%lx, lvid_Selected: %ld\n",
	LVID(gad)->lvid_Flags, LVID(gad)->lvid_DisplayGad, LVID(gad)->lvid_Selected));

    if (LVID(gad)->lvid_Labels)
    {
	DP(("CLV:  Examining list at $%lx\n", LVID(gad)->lvid_Labels));
	for (node = LVID(gad)->lvid_Labels->lh_Head;
	    node->ln_Succ;
	    node = node->ln_Succ)
	{
	    DP(("CLV:  Found node # %ld: '%s'\n", LVID(gad)->lvid_Total,
		node->ln_Name));
	    LVID(gad)->lvid_Total++;
	}
    }
    DP(("CLV:  Found %ld nodes.\n", LVID(gad)->lvid_Total));
d490 2
a491 12
    name = PositionTop(gad,taglist);

    DP(("CLV:  lvid_Top: %ld\n", LVID(gad)->lvid_Top));

    if (name && displaygad)
    {
        DP(("CLV:  Setting DisplayGad initial value to '%s'\n",
            node->ln_Name));
        GT_SetGadgetAttrs(displaygad, NULL, NULL,
            LVID(gad)->lvid_DisplayTag, name,
            TAG_DONE);
    }
d503 3
a505 26
    gad->Height = lvheight;
    if ( displaygad )
    {
	gad->Height += ((struct ExtGadget *)displaygad)->BoundsHeight;
    }
    ((struct ExtGadget *)gad)->BoundsHeight = gad->Height;
    placeGadgetText( gad, ng->ng_Flags, PLACETEXT_ABOVE, NULL );
    gad->Height = lvheight;

    /* Make the gadgets in the ListView: */
    mod_ng.ng_LeftEdge = ng->ng_LeftEdge + LEFTTRIM;
    mod_ng.ng_TopEdge = ng->ng_TopEdge + TOPTRIM;
    mod_ng.ng_Width = ng->ng_Width - scrollwidth - LRTRIM;
    mod_ng.ng_Height = EachHeight;

    for (count = 0; count < NumLines; count++)
    {
	/* We need a WORD per gadget to store the max pixel position
	 * of the text rendered over the gadget, so we know how much
	 * RectFilling to color zero needs to be done.
	 */
        DP(("CLV:  mod_ng.ng_TextAttr for linegadget: $%lx\n", mod_ng.ng_TextAttr));
	if (gad = CreateGenericBase(gad, &mod_ng, LVLINE_IDATA_SIZE,
	    taglist))
	{
	    LLID(gad)->llid_MaxX = 0;
d507 21
a527 2
	    DP(("CLV:  Line gadget sg(%lx) ID %ld at $%lx\n", sizeof(*sg),
		mod_ng.ng_GadgetID, sg));
a528 39
	    /* Identify the group the gadget belongs to, and set up
	     * the handler routine.  Note that the refresh is done
	     * when the dummy-gadget is encountered:
	     */
	    SGAD(gad)->sg_Parent = lv;
	    SGAD(gad)->sg_EventHandler = HandleListView;

	    /* To make the ListView read-only, we don't give the
	     * gadgets any activation or complementing...
	     */
	    if (!(LVID(lv)->lvid_Flags & LV_READONLY))
	    {
		gad->Activation = RELVERIFY;
		gad->Flags = GADGHCOMP;    /* clears away GFLG_EXTENDED */
	    }
	    else
	    {
		gad->Flags = GADGHNONE;   /* clears away GFLG_EXTENDED */
	    }
	    gad->GadgetType |= BOOLGADGET;

	    /* If there are more gadgets than items in the list: */
	    if (count >= LVID(lv)->lvid_Total)
	    {
		gad->Flags = GADGHNONE;
	    }
	    if (count == 0)
	    {
		/* Pointer to first line gadget */
		LVID(lv)->lvid_TopGadget = gad;
	    }
	}
	mod_ng.ng_GadgetID++;
	mod_ng.ng_TopEdge += mod_ng.ng_Height;
    }

    if (!gad)
	return(NULL);

d530 4
a533 8
    mod_ng.ng_LeftEdge = ng->ng_LeftEdge + ng->ng_Width -
	scrollwidth;
    mod_ng.ng_TopEdge = ng->ng_TopEdge;
    mod_ng.ng_Width = scrollwidth;
    mod_ng.ng_Height = lvheight;
    mod_ng.ng_GadgetID = GT_AUTOGADGET;

    DP(("CLV:  mod_ng.ng_TextAttr for scroller: $%lx\n", mod_ng.ng_TextAttr));
d536 10
a545 11
    gad = CreateGadget(SCROLLER_KIND, gad, &mod_ng,
	GTSC_Top, LVID(lv)->lvid_Top,
	GTSC_Total, LVID(lv)->lvid_Total,
	GTSC_Visible, NumLines,
	PGA_FREEDOM, LORIENT_VERT,
	/* Arrows should be the same height as a single line, but no bigger
	 * than 1/4 the height of the whole scroller:
	 */
	GTSC_Arrows, min(EachHeight, mod_ng.ng_Height >> 2),
	TAG_MORE, taglist);
    if (!gad)
d547 5
a551 5
    /* Install back pointer into Scroller.  This will be a true
     * OOP interconnection when such becomes available:
     */
    LVID(lv)->lvid_Scroller = gad;
    SCID(gad)->scid_ListView = lv;
d553 1
a553 1
    ((struct ExtGadget *)gad)->MoreFlags &= ~(GMORE_GADGETHELP);
a554 3
    /* Move the dummy-gadget to the end of this list, so that
     * it is the one that is returned:
     */
d556 3
a558 2
    gad->NextGadget = lv;
    lv->NextGadget = NULL;
d566 34
a599 54
/*/ InternalSetListViewAttrsA()
 *
 * Function allowing caller to set a new top and/or list for
 * the ListView.  If the list pointer is ~0, the old one is retained.
 * If top is ~0, the old one is retained (subject to validation).
 * The last parameter determines whether a SetAttrs() should be done
 * on the Scroller.
 *
 * Created:  31-Aug-89, Peter Cherna
 * Modified: 28-Jan-90, Peter Cherna
 *
 */

void InternalSetListViewAttrsA( struct Gadget *gad, struct Window *win,
    struct Requester *req, BOOL nosetscroller, struct TagItem *taglist )
{
    struct Node *node;
    struct TagItem *ti;
    STRPTR name;
    BOOL updateselected = FALSE;
    WORD i;

    DP(("ISLVA:  win $%lx, gad $%lx\n", win, gad));

    if (ti = findGTTagItem(GTLV_Labels, taglist))
    {
	DP(("ISLVA:  Got new labels at $%lx\n", ti->ti_Data));
	LVID(gad)->lvid_Labels = (struct List *)ti->ti_Data;
	if (LVID(gad)->lvid_Labels == (struct List *)(~0))
	{
	    DP(("ISLVA:  Detaching labels\n"));
	    LVID(gad)->lvid_Labels = NULL;
	    LVID(gad)->lvid_Flags |= LV_DEFERREFRESH;
	}
	else
	{
	    LVID(gad)->lvid_Total = 0;
	    updateselected = TRUE;
	    DP(("ISLVA:  Reattaching labels\n"));
	    LVID(gad)->lvid_Flags &= ~LV_DEFERREFRESH;
	}
	if (LVID(gad)->lvid_Labels)
	{
	    DP(("ISLVA:  Examining list at $%lx\n", LVID(gad)->lvid_Labels));
	    for (node = LVID(gad)->lvid_Labels->lh_Head;
		node->ln_Succ;
		node = node->ln_Succ)
	    {
		MP(("ISLVA:  Found node # %ld: '%s'\n", LVID(gad)->lvid_Total,
		    node->ln_Name));
		LVID(gad)->lvid_Total++;
	    }
	}
	DP(("ISLVA:  Found %ld nodes.\n", LVID(gad)->lvid_Total));
d601 1
a601 1
    D(else
d603 1
a603 14
	DP(("ISLVA:  Using old labels at $%lx\n", LVID(gad)->lvid_Labels));
    });

    name = PositionTop(gad,taglist);

    DP(("ISLVA:  validated top %ld\n", ((LONG)top)));

    if (LVID(gad)->lvid_DisplayGad && (updateselected || findGTTagItem(GTLV_Selected, taglist)))
    {
	DP(("CLV:  Setting DisplayGad initial value to '%s'\n",
	    name));
	GT_SetGadgetAttrs(LVID(gad)->lvid_DisplayGad, win, req,
	    LVID(gad)->lvid_DisplayTag, name,
	    TAG_DONE);
d606 1
a606 5
    /* Number of active gadgets is the lesser of the total number
     * of items in the list, and the number of lines displayable.
     * For a read-only listview, none of the gadgets are active:
     */
    if ( !(LVID(gad)->lvid_Flags & LV_READONLY) )
d608 23
a630 3
	WORD active = LVID(gad)->lvid_Total;
	struct Gadget *runner = LVID(gad)->lvid_TopGadget;
	WORD pos;
d632 5
a636 4
	if (LVID(gad)->lvid_Flags & LV_DEFERREFRESH)
	{
	    active = 0;
	}
d638 2
a639 1
        pos = removeGList(win,runner,LVID(gad)->lvid_Visible);
d641 2
a642 19
	for (i = 0; i < LVID(gad)->lvid_Visible; i++)
	{
	    if (active)
	    {
		/* This gadget should be selectable: */
		/* Next line hand-optimized knowing GADGHCOMP = 0: */
		/* runner->Flags = (runner->Flags & ~GADGHIGHBITS) | GADGHCOMP; */
		runner->Flags &= ~GADGHIGHBITS;
		active--;
	    }
	    else
	    {
		/* This gadget should not be selectable: */
		/* Next line hand-optimized knowing GADGHCOMP = 0: */
		/* runner->Flags = (runner->Flags & ~GADGHIGHBITS) | GADGHNONE; */
		runner->Flags |= GADGHNONE;
	    }
	    runner = runner->NextGadget;
	}
a643 3
        if (win)
            AddGList(win, LVID(gad)->lvid_TopGadget, pos, LVID(gad)->lvid_Visible, req);
    }
d645 1
a645 75
    if (!nosetscroller)
    {
	/* !!! We don't want to do this if we were called by
	 * the Scroller, since its visuals are already correct.
	 * This is a model-view-controller problem, and will have
	 * to be studied under OOP
	 */
	DP(("ISLVA: Calling SetGadgetAttrsA() with scroller $%lx, top %ld, total %ld, count %ld\n",
	    LVID(gad)->lvid_Scroller, ((ULONG)LVID(gad)->lvid_Top),
	    ((ULONG)LVID(gad)->lvid_Total), ((ULONG)LVID(gad)->lvid_Visible)));
	GT_SetGadgetAttrs(LVID(gad)->lvid_Scroller, win, req,
	    GTSC_Top, LVID(gad)->lvid_Top,
	    GTSC_Total, LVID(gad)->lvid_Total,
	    TAG_DONE);
	DP(("ISLVA: Back from SSA()\n"));
    }

    if (win)
    {
        DP(("ISLVA: Calling ULV()\n"));
        RefreshListView(gad,win,FALSE);
        DP(("ISLVA: done\n"));
    }
}


/*****************************************************************************/


/*/ RefreshListView()
 *
 * Update the contents of the ListView.
 *
 * Created:  31-Aug-89, Peter Cherna
 * Modified:  4-Apr-90, Peter Cherna
 *
 *
 */

void RefreshListView( struct Gadget *gad, struct Window *win, BOOL refresh )
{
    WORD x, i;
    struct Node *node;
    struct Gadget *linegad;
    WORD minx;
    USHORT pos;
    struct RastPort cloneRP;
    struct IntuiText *lineitext;
    struct Requester *req;
    struct RastPort *rp;

    DP(("ULV:  Enter\n"));
    /* We do nothing if we're in deferred refresh mode: */
    if ((rp = GetRP(gad,win)) && (!(LVID(gad)->lvid_Flags & LV_DEFERREFRESH)))
    {
        req = GetReq(gad,win);

	/* Get a work RastPort we can muck with: */
	cloneRastPort( &cloneRP, rp);

	DP(("ULV:  Not deferring refresh\n"));
	/* If we are in refresh, we cannot remove gadgets, but we are
	 * assured of being protected against state changes.  If we're not
	 * in refresh, the reverse is true:
	 */
	if (!refresh)
	{
	    /* Remove gadgets so that we know that their state won't change
	     * during the time we blast the text over them:
	     */
	    DP(("About to RemoveGList() on gadgets (1st id $%lx)\n",
		LVID(gad)->lvid_TopGadget->GadgetID));
	    pos = removeGList(win, LVID(gad)->lvid_TopGadget, LVID(gad)->lvid_Visible);
	    DP(("Back from RemoveGList()\n"));
	}
a646 3
	i = LVID(gad)->lvid_Visible;
	node = LVID(gad)->lvid_TopLabel;
	linegad = LVID(gad)->lvid_TopGadget;
d648 5
a652 120
	DP(("ULV:  1st node $%lx, 1st linegad $%lx count %ld\n", node, linegad, LVID(gad)->lvid_Visible));
	x = gad->LeftEdge + LEFTTRIM;
	lineitext = &LVID(gad)->lvid_LineIText;
	while (i-- > 0)
	{
	    DP(("ULV:  x: %ld, y: %ld\n", ((LONG)x), ((LONG)linegad->TopEdge)));
	    /* The previous label on this line went out as far as MaxX */
	    /* We want our rendering to match the selectness of this gadget */
	    if (linegad->Flags & SELECTED)
	    {
		lineitext->FrontPen = ~lineitext->FrontPen;
		lineitext->BackPen = ~lineitext->BackPen;
	    }

	    if ((node) && (node->ln_Succ))
	    {
		/* This is a node, so print the text: */
		lineitext->IText = node->ln_Name;
		MP(("ULV:  wanting to print '%s' at (%ld,%ld), max pixels %ld\n",
		    lineitext->IText, ((LONG)x), ((LONG)linegad->TopEdge),
		    (LONG)linegad->Width));
		MP(("ULV:  Calling printITextToFit\n"));
		printITextToFit( &cloneRP, lineitext, x, linegad->TopEdge,
		    linegad->Width,GTJ_LEFT,NULL);
		MP(("ULV:  Back from printITextToFit\n"));
		/* We've rewritten upto minx: */
		minx = cloneRP.cp_x;
		node = node->ln_Succ;
	    }
	    else
	    {
		minx = x;
	    }

	    if (LLID(linegad)->llid_MaxX > minx)
	    {
		/* We have to erase the tail of the previous one: */
		setAPen( &cloneRP, lineitext->BackPen );
		MP(("ULV:  About to RectFill\n"));
		RectFill(&cloneRP, minx, linegad->TopEdge,
		    LLID(linegad)->llid_MaxX,
		    (WORD)(linegad->TopEdge + linegad->Height - 1));
		MP(("ULV:  Back from RectFill\n"));
	    }
	    LLID(linegad)->llid_MaxX = minx;

	    MP(("ULV:  About to get next gadget\n"));
	    /* Restore the pens back to non-selected */
	    if (linegad->Flags & SELECTED)
	    {
		lineitext->FrontPen = ~lineitext->FrontPen;
		lineitext->BackPen = ~lineitext->BackPen;
	    }
	    linegad = linegad->NextGadget;
	}

	if (!refresh)
	{
	    AddGList(win, LVID(gad)->lvid_TopGadget, pos, LVID(gad)->lvid_Visible, req);
	    /* No refresh is needed since these gadgets are imageless */
	}
    }
    D(else
    {
	DP(("ULV:  Refresh deferred\n"));
    }
    )
}


/*****************************************************************************/


/*/ HandleListView()
 *
 * Handles gadgets of the ListView.
 *
 * Created:  31-Aug-89, Peter Cherna
 * Modified:  4-Mar-90, Peter Cherna
 *
 */

BOOL HandleListView(struct Gadget *linegad, struct IntuiMessage *imsg)
{
struct Gadget *gad = SGAD(linegad)->sg_Parent;
WORD           index;
struct Node   *node;

    imsg->IAddress = (APTR) gad;
    index = linegad->GadgetID;
    LVID(gad)->lvid_Selected = imsg->Code = index + LVID(gad)->lvid_Top;

    if (( imsg->Code >= LVID(gad)->lvid_Total ) ||
	(LVID(gad)->lvid_Flags & LV_DEFERREFRESH ) )
    {
	/* This was one of the empty lines after the list, or the
	 * listview has had its list detached, so eat the message
	 */
	return(FALSE);
    }
    else
    {
	if (LVID(gad)->lvid_DisplayGad)
	{
	    /* !!! We are counting on TopLabel != NULL.  We should
	     * be safe from this, since we pass the test of imsg->Code
	     * >= lvid_Total.  There must be at least that many nodes.
	     */
	    node = LVID(gad)->lvid_TopLabel;
	    while ((index--) && (node->ln_Succ))
	    {
		node = node->ln_Succ;
	    }
	    GT_SetGadgetAttrs(LVID(gad)->lvid_DisplayGad, imsg->IDCMPWindow, GetReq(gad,imsg->IDCMPWindow),
		LVID(gad)->lvid_DisplayTag, node->ln_Name,
		TAG_DONE);
	}
	return(TRUE);
    }
}
d654 2
d657 1
a657 1
/*****************************************************************************/
d659 6
d666 5
a670 4
VOID SetListViewAttrsA(struct Gadget *gad, struct Window *win,
                       struct Requester *req, struct TagItem *taglist)
{
    InternalSetListViewAttrsA(gad,win,req,FALSE,taglist);
d678 2
a679 2
VOID SetListViewTop(struct Gadget *gad, struct Window *win,
                    struct Requester *req, WORD top)
d686 1
a686 1
    InternalSetListViewAttrsA(gad,win,req,TRUE,tags);
@


39.8
log
@Fully implemented gadget help
Optimized code for space
@
text
@d7 1
a7 1
*   $Id: listview.c,v 39.7 92/04/13 14:07:24 vertex Exp Locker: vertex $
d192 1
a192 1
	(displaygad ? displaygad->Height : 0)) / EachHeight;
d309 2
a310 2
     * should really be lvheight + displaygad->Height,
     * but V37 forgets to add the height of the display gadget.
d321 1
a321 1
	gad->Height += displaygad->Height;
@


39.7
log
@Moved some stuff around to save bytes
Added requester support
@
text
@d7 1
a7 1
*   $Id: listview.c,v 39.6 92/04/07 13:46:17 vertex Exp Locker: vertex $
d185 3
d227 1
a227 1
    gad->Flags = GADGIMAGE|GADGHNONE;
d323 1
d340 2
a341 3
	gad = CreateGenericBase(gad, &mod_ng, LVLINE_IDATA_SIZE,
	    taglist);
	if (gad)
d361 1
a361 1
		gad->Flags = GADGHCOMP;
d365 1
a365 1
		gad->Flags = GADGHNONE;
d387 1
a387 1
    /* Fill out a NewScroller structure: */
d416 2
d519 1
a519 2
        if (win)
            pos = RemoveGList(win,runner,LVID(gad)->lvid_Visible);
d617 1
a617 1
	    pos = RemoveGList(win, LVID(gad)->lvid_TopGadget, LVID(gad)->lvid_Visible);
d662 1
a662 1
		SetAPen( &cloneRP, lineitext->BackPen );
@


39.6
log
@Added GTLV_MakeVisible
Combined a lot of stuff in Set/Create() functions to save bytes
Now requests GTTX_BackPen for the display gadget, which gives the better
  looking gadget
@
text
@d7 1
a7 1
*   $Id: listview.c,v 39.5 92/03/26 15:16:21 peter Exp Locker: vertex $
d32 1
a32 1
void RefreshListView (struct Window *win, struct Gadget *lv, BOOL refresh);
a327 4
/*
    mod_ng.ng_TextAttr = NULL;
    mod_ng.ng_Flags = NULL;
*/
d538 1
a538 1
            AddGList(win, LVID(gad)->lvid_TopGadget, pos, LVID(gad)->lvid_Visible, NULL);
d561 1
a561 1
        RefreshListView(win, gad, FALSE);
d580 1
a580 1
void RefreshListView( struct Window *win, struct Gadget *gad, BOOL refresh )
d589 2
d594 1
a594 1
    if (!(LVID(gad)->lvid_Flags & LV_DEFERREFRESH))
d596 5
a620 2
	/* Get a work RastPort we can muck with: */
	cloneRastPort( &cloneRP, win->RPort );
d679 1
a679 1
	    AddGList(win, LVID(gad)->lvid_TopGadget, pos, LVID(gad)->lvid_Visible, NULL);
d734 1
a734 1
	    GT_SetGadgetAttrs(LVID(gad)->lvid_DisplayGad, imsg->IDCMPWindow, NULL,
d757 2
a758 1
VOID SetListViewTop(struct Gadget *gad, struct Window *win, WORD top)
d765 1
a765 1
    InternalSetListViewAttrsA(gad,win,NULL,TRUE,tags);
@


39.5
log
@Uses getBevelImage() instead of MakeBevelBox().
@
text
@d7 1
a7 1
*   $Id: listview.c,v 39.4 92/03/24 15:14:58 peter Exp Locker: peter $
d40 2
a41 1
/*------------------------------------------------------------------------*/
a42 1
/* CreateListViewA() */
d44 1
a44 2
struct Gadget *CreateListViewA( struct Gadget *gad, struct NewGadget *ng,
    struct TagItem *taglist )
d46 48
a93 12
    struct NewGadget mod_ng;
    LONG count;
    LONG EachHeight, NumLines;
    struct Gadget *preLV, *lv;
    struct Node *node;
    LONG hidden;
    struct TagItem *ti;
    struct Gadget *displaygad = NULL;
    /* Assume we'll use	GTTX_Text to change the text in attached gadget */
    ULONG displaytag = GTTX_Text;
    long frametype;
    LONG lvheight;
d95 33
a127 2
    UWORD scrollwidth = getGTTagData(GTLV_ScrollWidth, 16, taglist);
    UWORD interspace = getTagData(LAYOUTA_SPACING, 0, taglist);    
d132 1
a132 5
    /* If TextAttr is NULL, I use the screen's TextAttr (which must exist)
     * that I know of in the VisualInfo
     */
    EachHeight = ((ng->ng_TextAttr) ? ng->ng_TextAttr->ta_YSize :
	VI(ng->ng_VisualInfo)->vi_ScreenTAttr->ta_YSize);
d181 1
d236 1
a236 1
    LVID(gad)->lvid_Count = NumLines;
d246 1
a246 1
    LVID(gad)->lvid_Selected = getGTTagData(GTLV_Selected, ~0, taglist);
d292 2
a293 5
    /* Get top, reduce it if it is too high: */
    LVID(gad)->lvid_Top = getGTTagData(GTLV_Top, 0, taglist);
    hidden = max(LVID(gad)->lvid_Total - LVID(gad)->lvid_Count, 0);
    if (LVID(gad)->lvid_Top > hidden)
	LVID(gad)->lvid_Top = hidden;
d296 1
a296 8

    if (LVID(gad)->lvid_Selected > LVID(gad)->lvid_Total - 1)
    {
	LVID(gad)->lvid_Selected = LVID(gad)->lvid_Total - 1;
    }
    DP(("CLV: Adjusted lvid_Selected: %ld\n", LVID(gad)->lvid_Selected));

    if (LVID(gad)->lvid_Labels)
d298 5
a302 38
	count = 0;
	for (node = LVID(gad)->lvid_Labels->lh_Head;
	    node->ln_Succ;
	    node = node->ln_Succ)
	{
	    /* If this is the selected one and we have a display gadget,
	     * then we want to set the initial contents of the display
	     * gadget accordingly.
	     */
	    if ((count == LVID(gad)->lvid_Selected) && (displaygad))
	    {
		/* !!! BE VERY WARNED: In general it is not acceptable
		 * to call GT_SetGadgetAttrs() after a gadget is created
		 * but before it is added.  I've arranged internally that
		 * for text-display and string gadgets, it doesn't puke
		 * if you call it with window=NULL, it does the changes
		 * without adding removing or anything that depends on
		 * the gadget already being there !!!
		 */
		DP(("CLV:  Setting DisplayGad initial value to '%s'\n",
		    node->ln_Name));
		GT_SetGadgetAttrs(displaygad, NULL, NULL,
		    LVID(gad)->lvid_DisplayTag, node->ln_Name,
		    TAG_DONE);
	    }

	    /* If this is the top item in the list, we need to remember
	     * the node in question:
	     */
	    if (count == LVID(gad)->lvid_Top)
	    {
		DP(("CLV:  Found top at %ld, TopLabel node = $%lx\n",
		    LVID(gad)->lvid_Total, node));
		/* Pointer to top rendered node */
		LVID(gad)->lvid_TopLabel = node;
	    }
	    count++;
	}
d427 1
a427 10
/*------------------------------------------------------------------------*/

void SetListViewAttrsA( struct Gadget *gad, struct Window *win,
    struct Requester *req, struct TagItem *taglist )
{
    /* InternalSetListViewAttrs() is a superset of this function,
     * so call it with the extra parameter = FALSE:
     */
    InternalSetListViewAttrsA(gad, win, req, FALSE, taglist);
}
a428 1
/*------------------------------------------------------------------------*/
a446 2
    WORD hidden, ind;
    WORD top;
d448 1
d450 1
a450 1
    STRPTR name = NULL;
a453 41
#ifdef DEBUGGING
    {
	struct TagItem *ti = taglist;
	while (ti)
	{
	    DP(("ti: $%lx, ti->Tag ", ti));
	    switch (ti->ti_Tag)
	    {
		case GTLV_Top:
		    DP(("GTLV_Top"));
		    break;
		case GTLV_Labels:
		    DP(("GTLV_Labels"));
		    break;
		case GTLV_Selected:
		    DP(("GTLV_Selected"));
		    break;
		default:
		    DP(("$%lx", ti->ti_Tag));
		    break;
	    }
	    DP((", ti->data $%lx\n", ti->ti_Data));
	    switch (ti->ti_Tag)
	    {
		case TAG_DONE:
		    ti = NULL;
		    break;
		case TAG_MORE:
		    ti = (struct TagItem *)ti->ti_Data;
		    break;
		default:
		    ti++;
	    }
	}
    }
#endif
    /* Allow the caller to not set top, but remember, we still do
     * the validation
     */
    top = getGTTagData(GTLV_Top, LVID(gad)->lvid_Top, taglist);

d490 2
a491 5
    /* If top is too great for the list, reduce it */
    hidden = max(LVID(gad)->lvid_Total - LVID(gad)->lvid_Count, 0);
    DP(("ISLVA:  hidden %ld, top %ld\n", ((LONG)hidden), ((LONG)top)));
    if (top > hidden)
	top = hidden;
a492 34
    LVID(gad)->lvid_Top = top;

    if (ti = findGTTagItem(GTLV_Selected, taglist))
    {
	updateselected = TRUE;
	LVID(gad)->lvid_Selected = ti->ti_Data;
    }
    DP(("ISLVA: lvid_Selected: %ld\n", LVID(gad)->lvid_Selected));
    if (LVID(gad)->lvid_Selected > LVID(gad)->lvid_Total - 1)
    {
	LVID(gad)->lvid_Selected = LVID(gad)->lvid_Total - 1;
    }
    DP(("ISLVA: Adjusted lvid_Selected: %ld\n", LVID(gad)->lvid_Selected));

    if (!(LVID(gad)->lvid_DisplayGad))
    {
	updateselected = FALSE;
    }

    ind = 0;
    LVID(gad)->lvid_TopLabel = NULL;

    if (LVID(gad)->lvid_Labels)
    {
	for (node = LVID(gad)->lvid_Labels->lh_Head;
	    node->ln_Succ;
	    node = node->ln_Succ)
	{
	    DP(("ISLVA: Node #%ld, '%s'\n", ((ULONG)ind), node->ln_Name));
	    if (ind == top)
	    {
		DP(("ISLVA: This is the top\n"));
		LVID(gad)->lvid_TopLabel = node;
	    }
d494 1
a494 8
	    if (ind == LVID(gad)->lvid_Selected)
	    {
		name = node->ln_Name;
	    }
	    ind++;
	}
    }
    if (updateselected)
d518 2
a519 1
	pos = RemoveGList( win, runner, LVID(gad)->lvid_Count );
d521 1
a521 1
	for (ind = 0; ind < LVID(gad)->lvid_Count; ind++)
d540 3
a542 1
	AddGList(win, LVID(gad)->lvid_TopGadget, pos, LVID(gad)->lvid_Count, NULL);
d554 1
a554 1
	    ((ULONG)LVID(gad)->lvid_Total), ((ULONG)LVID(gad)->lvid_Count)));
d562 8
a569 4
    DP(("ISLVA: Calling ULV()\n"));
    RefreshListView(win, gad, FALSE);
    DP(("ISLVA: done\n"));
}
d571 1
a572 1
/*------------------------------------------------------------------------*/
d610 1
a610 1
	    pos = RemoveGList(win, LVID(gad)->lvid_TopGadget, LVID(gad)->lvid_Count);
d614 1
a614 1
	i = LVID(gad)->lvid_Count;
d620 1
a620 1
	DP(("ULV:  1st node $%lx, 1st linegad $%lx count %ld\n", node, linegad, LVID(gad)->lvid_Count));
d643 1
a643 1
		    linegad->Width );
d678 1
a678 1
	    AddGList(win, LVID(gad)->lvid_TopGadget, pos, LVID(gad)->lvid_Count, NULL);
d690 2
a691 1
/*------------------------------------------------------------------------*/
d702 1
a702 1
BOOL HandleListView( struct Gadget *linegad, struct IntuiMessage *imsg )
d704 3
a706 3
    struct Gadget *gad = SGAD(linegad)->sg_Parent;
    WORD index;
    struct Node *node;
d742 2
a743 1
/*------------------------------------------------------------------------*/
d745 19
a763 5
void InternalSetListViewAttrs( struct Gadget *gad, struct Window *win,
    struct Requester *req, BOOL nosetscroller, ULONG firsttag, ... )
{
    InternalSetListViewAttrsA(gad, win, req, nosetscroller,
	(struct TagItem *)&firsttag);
a764 2

/*------------------------------------------------------------------------*/
@


39.4
log
@Supports GetAttrs of GTLV_Top, GTLV_Labels, and GTLV_Selected.
@
text
@d7 1
a7 1
*   $Id: listview.c,v 39.3 92/02/20 11:50:18 peter Exp Locker: peter $
d57 1
a57 1
    long indentation;
d161 1
a161 1
    gad->Flags = GADGHNONE;
d170 1
d175 1
a175 1
    indentation = BB_RAISED;
d179 1
a179 1
	indentation = BB_RECESSED;
d205 5
a209 3
    gad->GadgetRender = MakeBevelBox( &LVID(gad)->lvid_BevelBox,
	0, 0, ng->ng_Width - scrollwidth, lvheight,
	indentation, ng->ng_VisualInfo );
@


39.3
log
@Now use SGAD() instead of SG_FROM_GAD().  Took some optimizations.
Listview gadget's height is now V37 compatible (though wrong).
@
text
@d7 1
a7 1
*   $Id: listview.c,v 39.2 92/02/03 15:48:43 peter Exp Locker: peter $
d169 1
a404 54

/*i**** gadtools.lib/SetListViewAttrs ***************************************
*
*   NAME
*	SetListViewAttrs -- Modify the attributes of a ListView gadget. (V36)
*
*   SYNOPSIS
*	SetListViewAttrs(win, gad, top, labels)
*
*	void SetListViewAttrs(struct Window *, struct Gadget *, WORD,
*	    struct List *);
*
*   FUNCTION
*	SetListViewAttrs() allows the displayed list or the position in
*	that list to be changed.  The ListView is then refreshed.
*
*   INPUTS
*	win - Pointer to window containing the ListView gadget.
*	gad - Pointer to the ListView gadget returned by CreateListView().
*	top - New number of top item visible (0 = the very top), or
*	    use (~0) to leave top unchanged.
*	labels - Pointer to a new Exec List, whose ln_Name fields are to
*	    be displayed, or use (~0) to leave the list unchanged.
*
*   TAGS
*	GTLV_Labels (struct List *) - List of labels whose ln_Name fields
*	    are to be displayed in the listview.  Use a value of ~0 to
*	    "detach" your List from the display.  You must detach your list
*	    before modifying the List structure, since the toolkit reserves
*	    the right to traverse it on another task's schedule.  When you
*	    are done, attach the list by using the tag pair (GTLV_Labels, list).
*	    When a list is detached, the display area will not be cleared,
*	    but it will not be refreshed either.
*
*   RESULT
*	None.
*
*   EXAMPLE
*
*   NOTES
*	The internal value of top may be reduced if too large a number
*	is supplied.
*
*   BUGS
*
*   SEE ALSO
*	CreateListView()
*
******************************************************************************
*
* Created:  31-Aug-89, Peter Cherna
* Modified: 23-Jan-90, Peter Cherna
*
*/
@


39.2
log
@Now calls cloneRastPort() instead of PrepareCloneRP().
Deleted obsolete internal autodocs.
@
text
@d7 1
a7 1
*   $Id: listview.c,v 39.1 92/01/30 19:53:07 peter Exp Locker: peter $
d48 2
a49 2
    WORD count;
    WORD EachHeight, NumLines;
a50 1
    struct SpecialGadget *sg;
d52 1
a52 1
    WORD hidden;
d58 1
d136 1
d142 2
a143 3
	DP(("Shifting displaygad down by %ld pixels\n",
	    NumLines * EachHeight + TBTRIM));
	displaygad->TopEdge += NumLines * EachHeight + TBTRIM;
a162 1
    sg = SG_FROM_GAD(gad);
d167 2
a168 2
    sg->sg_Refresh = RefreshListView;
    sg->sg_SetAttrs = SetListViewAttrsA;
d171 2
a172 2
    LVID(lv)->lvid_Count = NumLines;
    LVID(lv)->lvid_Labels = (struct List *)getGTTagData(GTLV_Labels, NULL, taglist);
d176 1
a176 1
	LVID(lv)->lvid_Flags = LV_READONLY;
d179 3
a181 3
    LVID(lv)->lvid_DisplayTag = displaytag;
    LVID(lv)->lvid_DisplayGad = displaygad;
    LVID(lv)->lvid_Selected = getGTTagData(GTLV_Selected, ~0, taglist);
d184 1
a184 1
	struct IntuiText *itext = &LVID(lv)->lvid_LineIText;
d203 2
a204 2
    lv->GadgetRender = MakeBevelBox( &LVID(lv)->lvid_BevelBox,
	0, 0, ng->ng_Width - scrollwidth, NumLines * EachHeight + TBTRIM,
d207 1
a207 1
    DP(("CLV:  lvid_Labels: $%lx\n", LVID(lv)->lvid_Labels));
d209 1
a209 1
	LVID(lv)->lvid_Flags, LVID(lv)->lvid_DisplayGad, LVID(lv)->lvid_Selected));
d211 1
a211 1
    if (LVID(lv)->lvid_Labels)
d213 2
a214 2
	DP(("CLV:  Examining list at $%lx\n", LVID(lv)->lvid_Labels));
	for (node = LVID(lv)->lvid_Labels->lh_Head;
d218 1
a218 1
	    DP(("CLV:  Found node # %ld: '%s'\n", LVID(lv)->lvid_Total,
d220 1
a220 1
	    LVID(lv)->lvid_Total++;
d223 1
a223 1
    DP(("CLV:  Found %ld nodes.\n", LVID(lv)->lvid_Total));
d226 10
a235 10
    LVID(lv)->lvid_Top = getGTTagData(GTLV_Top, 0, taglist);
    hidden = max(LVID(lv)->lvid_Total - LVID(lv)->lvid_Count, 0);
    if (LVID(lv)->lvid_Top > hidden)
	LVID(lv)->lvid_Top = hidden;
    DP(("CLV:  lvid_Top: %ld\n", LVID(lv)->lvid_Top));


    if (LVID(lv)->lvid_Selected > LVID(lv)->lvid_Total - 1)
    {
	LVID(lv)->lvid_Selected = LVID(lv)->lvid_Total - 1;
d237 1
a237 1
    DP(("CLV: Adjusted lvid_Selected: %ld\n", LVID(lv)->lvid_Selected));
d239 1
a239 1
    if (LVID(lv)->lvid_Labels)
d242 1
a242 1
	for (node = LVID(lv)->lvid_Labels->lh_Head;
d250 1
a250 1
	    if ((count == LVID(lv)->lvid_Selected) && (displaygad))
d263 1
a263 1
		    LVID(lv)->lvid_DisplayTag, node->ln_Name,
d270 1
a270 1
	    if (count == LVID(lv)->lvid_Top)
d273 1
a273 1
		    LVID(lv)->lvid_Total, node));
d275 1
a275 1
		LVID(lv)->lvid_TopLabel = node;
d280 10
d291 1
a291 1
    gad->Height = LVID(lv)->lvid_Count * EachHeight + TBTRIM;
a295 1

d297 1
a321 1
	    sg = SG_FROM_GAD(gad);
d329 2
a330 2
	    sg->sg_Parent = lv;
	    sg->sg_EventHandler = HandleListView;
d369 1
a369 1
    mod_ng.ng_Height = EachHeight * NumLines + TBTRIM;
d822 1
a822 1
    struct Gadget *gad = SG_FROM_GAD(linegad)->sg_Parent;
@


39.1
log
@Removed RCS log.  Re-did braces, comments, and function headers.
Bumped to V39.
@
text
@d7 1
a7 1
*   $Id: listview.c,v 38.3 92/01/30 18:08:45 peter Exp Locker: peter $
d42 1
a42 62
/*i**** gadtools.library/CreateListViewA *************************************
*
*   NAME
*	CreateListViewA -- Create a scrolling list gadget. (V36)
*
*   SYNOPSIS
*	gad = CreateListViewA(previous, ng, taglist)
*
*	struct Gadget *CreateListViewA(struct Gadget *, struct NewGadget *,
*	    struct TagItem *);
*
*   FUNCTION
*	CreateListViewA() creates a ListView (scrolling list) gadget based
*	on the supplied NewGadget structure and tags.
*	If the pointer to previous gadget was NULL, a NULL is immediately
*	returned.
*
*   INPUTS
*	previous - Pointer to previous gadget.
*	ng - Pointer to an initialize NewGadget structure.
*	nlv - Pointer to initialized NewListView structure.
*	taglist - Pointer to a TagItem list.
*
*   TAGS
*	GTLV_Top (UWORD) - Top item visible in the list (defaults to zero).
*	GTLV_Labels (struct List *) - List of labels whose ln_Name fields
*	    are to be displayed.
*	GTLV_ReadOnly (BOOL) - If TRUE, then listview is read-only.
*	GTLV_ScrollWidth (UWORD) - Width of scroll bar (defaults to 16).
*	LAYOUTA_SPACING - Extra space to place between lines
*	    (defaults to zero).
*	GTLV_ShowSelected (struct Gadget *) - NULL to have the currently
*	    selected item displayed beneath the listview, or pointer to
*	    an already-created toolkit STRING_KIND gadget to have an
*	    editable display of the currently selected item.
*	GTLV_Selected (UWORD) - Ordinal number of currently selected
*	    item, or ~0 to have no current selection (defaults to ~0).
*	
*   RESULT
*	gad - Pointer to resulting ListView gadget, or NULL if failure.
*
*   EXAMPLE
*
*   NOTES
*	These attributes may be changed by calling GT_SetGadgetAttrsA():
*	GTLV_Top (UWORD) - Top item visible in the list.
*	GTLV_Labels (struct List *) - New list of labels whose ln_Name fields
*	    are to be displayed, or NULL for an empty display.
*	GTLV_Selected (UWORD) - Ordinal number of currently selected
*	    item (defaults to zero if GTLV_ShowSelected is set).
*
*   BUGS
*
*   SEE ALSO
*	CreateGadgetA(), GT_SetGadgetAttrsA()
*
******************************************************************************
*
* Created:  29-Aug-89, Peter Cherna
* Modified: 28-Feb-90, Peter Cherna
*
*/
d730 1
a730 1
	PrepareCloneRP(&cloneRP, win->RPort, 0);
@


38.3
log
@Uses new space-saving placeGadgetText() function.  As a side
consequence, the underlay gadget is now under the display gadget, too.
A bunch of optimizations around what I keep in the XListView.  Fixes
the bug where line text is clipped too early.  Fixed:  clicking on a
line didn't update lvid_Selected.
@
text
@d7 1
a7 1
*   $Id: listview.c,v 38.2 92/01/15 11:02:48 peter Exp Locker: peter $
a8 60
*   $Log:	listview.c,v $
 * Revision 38.2  92/01/15  11:02:48  peter
 * Forgot to rename reference to sc_ListView as scid_ListView.
 * 
 * Revision 38.1  91/11/27  13:17:22  peter
 * Optimized extraction of instance data.
 * 
 * Revision 38.0  91/07/11  12:34:18  peter
 *  Initial V38 check-in (matches V37 release).
 * 
*   Revision 36.12  91/04/08  13:25:28  peter
*   Where appropriate uses getGTTagData(), getSTRINGTagData(),
*   findGTTagItem(), and findGATagItem() macros/stubs to save space.
*   
*   Revision 36.11  91/03/28  13:30:42  peter
*   Listview titles now positioned wrt the whole listview, not just the list-area.
*   
*   Revision 36.10  91/03/14  16:05:30  peter
*   Now uses stack-based tags instead of array-based ones when it calls
*   tag-based functions.
*   The new lvid_DisplayTag field stores the tag used to affect the
*   attached gadget's contents.
*   
*   Revision 36.9  90/11/07  19:43:44  peter
*   Now use real AddGList() instead.
*   
*   Revision 36.8  90/11/06  21:28:08  peter
*   Gadgets in read-only listviews no longer can end up flashing.
*   Detaching a list from a listview no longer scrolls the list back to the top.
*   The line gadgets in a listview with a detached list are no longer selectable.
*   
*   Revision 36.7  90/10/12  19:42:53  peter
*   Replaced initializer of an automatic by some assignments to save space.
*   Miscellaneous space juggling.
*   Calls internal findTagItem() and getTagData() to save space.
*   Calls internal addGlist() and refreshGList() to save space.
*   
*   Revision 36.6  90/05/18  18:30:56  peter
*   Put space immediately before '(' in prototypes to avoid confusing ctags.
*   
*   Revision 36.5  90/04/06  00:58:56  peter
*   No longer uses user's RastPort.
*   
*   Revision 36.4  90/04/02  16:07:52  peter
*   Warnings due to new clib/#?_protos.h eliminated.
*   Now uses builtin min.
*   No longer masks against GADTOOLMASK.
*   GadgetType is now OR'd in.
*   
*   Revision 36.3  90/03/31  06:42:17  peter
*   Now use CreateGadgetA() instead of specific Create[xxx]GadgetA().
*   
*   Revision 36.2  90/03/31  00:45:45  peter
*   Added some DP()s.
*   Uses builtin max().
*   
*   Revision 36.1  90/03/16  14:03:00  peter
*   RCS Clean up.
*   
*
d17 8
a24 7
/*  !!! Notes for OOP conversion.  When we go OOP, then some aspects
    of the gadget will happen on a task other than the client's.  We
    will then need some arbitration on things like the list to be
    displayed.  Likely, the client would RemoveGList() the composite
    before playing with the list.  That is likely sufficient (must
    consider it more deeply to be sure). */

d27 1
a27 1
/*  Function Prototypes: */
d29 1
a29 1
/*  Internal: */
d105 3
a107 4
struct Gadget *CreateListViewA(struct Gadget *gad, struct NewGadget *ng,
    struct TagItem *taglist)

    {
d127 3
a129 2
    /*  If TextAttr is NULL, I use the screen's TextAttr (which must exist)
	that I know of in the VisualInfo */
d134 3
a136 2
    /*  We'll need to make other gadgets, so start with a copy of supplied
	ng: */
d142 1
a142 1
    /*  Check to see if caller wanted a display or string gadget attached: */
d144 2
a146 2
	if (ti->ti_Data)
	    {
d148 1
a148 1
	    /*  a string gadget: */
d151 3
a153 2
	    /*  The visual Width had better match since we can't change
		it after the fact (unfortunately) */
d155 1
a155 1
		{
d157 7
a163 6
		}
	    /*  We'll specify a TopEdge that would coincide with the
		listview's TopEdge, and simply add the height of the box
		of line gadgets when that becomes known.  The string
		gadget actually starts TOPTRIM+BEVELYSIZE down from
		the visuals: */
d168 1
a168 1
	    }
d170 1
a170 1
	    {
d172 5
a176 4
	    /*  Got to make a display-only gadget: */
	    /*  TopEdge currently coincides with the listview's TopEdge,
		and we'll add the height of the box of line gadgets when
		that becomes known. */
a181 1
	    }
d183 1
d192 1
a192 1
	{
d195 1
a195 1
	}
d197 3
a199 2
    /*  Now that we know NumLines, we can work out the TopEdge of
	the displaygad, if any: */
d201 1
a201 1
	{
d205 1
a205 1
	}
d207 5
a211 4
    /*  We need the dummy-gadget before the line gadgets are created,
	but we would like to return it as the result from CreateListView(),
	so later we move it to last in this piece of gadget-list.
	We have to save the value of gad before lv was allocated: */
d218 1
a218 1
	{
d221 1
a221 1
    	}
d227 1
a227 1
    /*  This is the gadget that causes the refresh: */
d232 1
a232 1
    /*  Fill in the ListView Instance Data: */
d237 1
a237 1
	{
d240 1
a240 1
	}
d244 1
a244 1
	{
d263 1
a263 1
	}
d274 1
a274 1
	{
d279 1
a279 1
	    {
a282 1
	    }
d284 1
d287 1
a287 1
    /*  Get top, reduce it if it is too high: */
d296 1
a296 1
	{
d298 1
a298 1
	}
d302 1
a302 1
	{
d307 6
d314 8
a321 12
	    /*  If this is the selected one and we have a display gadget,
		then we want to set the initial contents of the display
		gadget accordingly. */
	    if ((count == LVID(lv)->lvid_Selected) && (displaygad))
		{
		/*  !!! BE VERY WARNED: In general it is not acceptable
		    to call GT_SetGadgetAttrs() after a gadget is created
		    but before it is added.  I've arranged internally that
		    for text-display and string gadgets, it doesn't puke
		    if you call it with window=NULL, it does the changes
		    without adding removing or anything that depends on
		    the gadget already being there !!! */
d327 1
a327 1
		}
d329 3
a331 2
	    /*  If this is the top item in the list, we need to remember
		the node in question: */
d333 1
a333 1
		{
d336 1
a336 1
		/*  Pointer to top rendered node */
d338 1
a338 1
		}
a339 1
	    }
d341 2
a342 1
    /*  Set the true height of the gadget: */
d345 1
a345 1
	{
d347 1
a347 1
	}
d351 1
a351 1
    /*  Make the gadgets in the ListView: */
d362 5
a366 4
	{
	/*  We need a WORD per gadget to store the max pixel position
	    of the text rendered over the gadget, so we know how much
	    RectFilling to color zero needs to be done.  */
d371 1
a371 1
	    {
d378 4
a381 3
	    /*  Identify the group the gadget belongs to, and set up
		the handler routine.  Note that the refresh is done
		when the dummy-gadget is encountered: */
d385 3
a387 2
	    /*  To make the ListView read-only, we don't give the
		gadgets any activation or complementing... */
d389 1
a389 1
		{
d392 1
a392 1
		}
d394 1
a394 1
		{
d396 1
a396 1
		}
d399 1
a399 1
	    /*  If there are more gadgets than items in the list: */
d401 1
a401 1
		{
d403 1
a403 1
		}
d405 2
a406 2
		{
		/*  Pointer to first line gadget */
a407 1
		}
d409 1
d412 1
a412 1
	}
d417 1
a417 1
    /*  Fill out a NewScroller structure: */
d433 3
a435 2
	/*  Arrows should be the same height as a single line, but no bigger
	    than 1/4 the height of the whole scroller: */
d440 3
a442 2
    /*  Install back pointer into Scroller.  This will be a true
	OOP interconnection when such becomes available: */
d446 3
a448 2
    /*  Move the dummy-gadget to the end of this list, so that
	it is the one that is returned: */
d453 1
a453 1
    }
d512 6
a517 6
void SetListViewAttrsA(struct Gadget *gad, struct Window *win,
    struct Requester *req, struct TagItem *taglist)

    {
    /*  InternalSetListViewAttrs() is a superset of this function,
	so call it with the extra parameter = FALSE: */
d519 1
a519 1
    }
d536 3
a538 9
void InternalSetListViewAttrsA(gad, win, req, nosetscroller, taglist)

    struct Gadget *gad;
    struct Window *win;
    struct Requester *req;
    BOOL nosetscroller;
    struct TagItem *taglist;

    {
d549 1
a549 1
	{
d552 1
a552 1
	    {
d555 1
a555 1
		{
d568 1
a568 1
		}
d571 1
a571 1
		{
a579 1
		}
d582 1
d584 3
a586 2
    /*  Allow the caller to not set top, but remember, we still do
	the validation */
d590 1
a590 1
	{
d594 1
a594 1
	    {
d598 1
a598 1
	    }
d600 1
a600 1
	    {
d605 1
a605 1
	    }
d607 1
a607 1
	    {
d612 1
a612 1
		{
a615 1
		}
d617 1
d619 1
a619 1
	}
d621 1
a621 1
	{
d623 1
a623 1
	});
d625 1
a625 1
    /*  If top is too great for the list, reduce it */
d634 1
a634 1
	{
d637 1
a637 1
	}
d640 1
a640 1
	{
d642 1
a642 1
	}
d646 1
a646 1
	{
d648 1
a648 1
	}
d654 1
a654 1
	{
d658 1
a658 1
	    {
d661 1
a661 1
		{
d664 1
a664 1
		}
d667 1
a667 1
		{
d669 1
a669 1
		}
a670 1
	    }
d672 1
d674 1
a674 1
	{
d680 1
a680 1
	}
d682 4
a685 3
    /*  Number of active gadgets is the lesser of the total number
	of items in the list, and the number of lines displayable.
	For a read-only listview, none of the gadgets are active: */
d687 1
a687 1
	{
d693 1
a693 1
	    {
d695 1
a695 1
	    }
d700 2
d703 3
a705 5
	    if (active)
		{
		/*  This gadget should be selectable: */
		/*  Next line hand-optimized knowing GADGHCOMP = 0: */
		/*  runner->Flags = (runner->Flags & ~GADGHIGHBITS) | GADGHCOMP; */
d708 1
a708 1
		}
d710 4
a713 4
		{
		/*  This gadget should not be selectable: */
		/*  Next line hand-optimized knowing GADGHCOMP = 0: */
		/*  runner->Flags = (runner->Flags & ~GADGHIGHBITS) | GADGHNONE; */
d715 1
a715 1
		}
d717 1
a717 1
	    }
d719 1
a719 1
	}
d722 1
a722 1
	{
d724 4
a727 3
	   the Scroller, since its visuals are already correct.
	   This is a model-view-controller problem, and will have
	   to be studied under OOP */
d736 1
a736 1
	}
d741 1
a741 1
    }
d756 2
a757 7
void RefreshListView(win, gad, refresh)

    struct Window *win;
    struct Gadget *gad;
    BOOL refresh;

    {
d767 1
a767 1
    /*  We do nothing if we're in deferred refresh mode: */
d769 1
a769 1
	{
d771 4
a774 3
	/*  If we are in refresh, we cannot remove gadgets, but we are
	    assured of being protected against state changes.  If we're not
	    in refresh, the reverse is true: */
d776 4
a779 3
	    {
	    /*  Remove gadgets so that we know that their state won't change
		during the time we blast the text over them: */
d784 1
a784 1
	    }
d790 1
a790 1
	/*  Get a work RastPort we can muck with: */
d796 1
a796 1
	    {
d798 2
a799 2
	    /*  The previous label on this line went out as far as MaxX */
	    /*  We want our rendering to match the selectness of this gadget */
d801 1
a801 1
		{
d804 1
a804 1
		}
d807 2
a808 2
		{
		/*  This is a node, so print the text: */
d817 1
a817 1
		/*  We've rewritten upto minx: */
d820 1
a820 1
		}
d822 1
a822 1
		{
d824 1
a824 1
		}
d827 2
a828 2
		{
		/*  We have to erase the tail of the previous one: */
d835 1
a835 1
		}
d841 1
a841 1
		{
d844 1
a844 1
		}
d846 1
a846 1
	    }
d849 1
a849 1
	    {
d851 1
a851 2
	    /*  No refresh is needed since these gadgets are imageless */
	    }
d853 1
d855 1
a855 1
	{
d857 1
a857 1
	}
d859 1
a859 1
    }
d873 2
a874 6
BOOL HandleListView(linegad, imsg)

    struct Gadget *linegad;
    struct IntuiMessage *imsg;

    {
d885 4
a888 3
	{
	/*  This was one of the empty lines after the list, or the
	    listview has had its list detached, so eat the message */
d890 1
a890 1
	}
d892 2
d895 4
a898 5
	if (LVID(gad)->lvid_DisplayGad)
	    {
	    /*  !!! We are counting on TopLabel != NULL.  We should
		be safe from this, since we pass the test of imsg->Code
		>= lvid_Total.  There must be at least that many nodes. */
d901 1
a901 1
		{
d903 1
a903 1
		}
d907 1
a907 1
	    }
a908 1
	}
d910 1
d915 3
a917 4
void InternalSetListViewAttrs(struct Gadget *gad, struct Window *win,
    struct Requester *req, BOOL nosetscroller, ULONG firsttag, ...)

    {
d920 1
a920 1
    }
@


38.2
log
@Forgot to rename reference to sc_ListView as scid_ListView.
@
text
@d7 1
a7 1
*   $Id: listview.c,v 38.1 91/11/27 13:17:22 peter Exp Locker: peter $
d10 3
a94 1
void UpdateListView (struct Window *win, struct Gadget *lv, BOOL refresh);
a173 2
    ULONG place;
    struct Rectangle rect;
d179 1
a285 3
    LVID(lv)->lvid_Width = ng->ng_Width - scrollwidth;
    LVID(lv)->lvid_InterSpace = interspace;
    LVID(lv)->lvid_EachHeight = EachHeight;
d288 6
a293 2
    LVID(lv)->lvid_Flags = getGTTagData(GTLV_ReadOnly, FALSE, taglist) ?
	LV_READONLY : 0;
a294 2
    LVID(lv)->lvid_TextAttr = ng->ng_TextAttr;
    LVID(lv)->lvid_VisualInfo = ng->ng_VisualInfo;
d297 25
d393 5
a397 1
    gad->Height = LVID(lv)->lvid_Count * LVID(lv)->lvid_EachHeight + TBTRIM;
d399 1
a399 8
    /*  Place gadgettext around original (dummy) gadget: */
    rect.MinX = 0;
    rect.MinY = 0;
    rect.MaxX = gad->Width - 1;
    rect.MaxY = gad->Height - 1 + ((displaygad) ? displaygad->Height : 0);
    if (!(place = ng->ng_Flags & PLACETEXT_MASK))
	place = PLACETEXT_ABOVE;
    PlaceIntuiText(gad->GadgetText, &rect, place);
d404 1
a404 1
    mod_ng.ng_Width = ng->ng_Width - LRTRIM - scrollwidth;
d482 1
a482 1
	GTSC_Arrows, min(LVID(lv)->lvid_EachHeight, mod_ng.ng_Height >> 2),
d590 1
a590 2
    WORD hidden, active, ind;
    struct Gadget *runner;
d736 4
a739 1
	active = LVID(gad)->lvid_Total;
d744 3
a746 1
	runner = LVID(gad)->lvid_TopGadget;
d766 1
d786 1
a786 1
    UpdateListView(win, gad, FALSE);
a794 41
 * Redraws the contents of the ListView and refreshes the borders.
 *
 * Created:  31-Aug-89, Peter Cherna
 * Modified: 15-Dec-89, Peter Cherna
 *
 */

void RefreshListView(win, gad, refresh)

    struct Window *win;
    struct Gadget *gad;
    BOOL refresh;

    {
    ULONG recessed_tag;

    DP(("RLV: win at $%lx, listview gad at $%lx\n", win, gad));
    UpdateListView(win, gad, refresh);
    DP(("RLV:  vi at $%lx\n", LVID(gad)->lvid_VisualInfo));
    MP(("RLV:  Calling DrawBevelBox\n"));

    recessed_tag = TAG_IGNORE;
    if (LVID(gad)->lvid_Flags & LV_READONLY)
	{
	recessed_tag = GTBB_Recessed;
	}

    DrawBevelBox(win->RPort,
	gad->LeftEdge, gad->TopEdge,
	LVID(gad)->lvid_Width,
	(WORD) (LVID(gad)->lvid_Count * LVID(gad)->lvid_EachHeight + TBTRIM),
	GT_VisualInfo, LVID(gad)->lvid_VisualInfo,
	recessed_tag, TRUE,
	TAG_DONE);
    }


/*------------------------------------------------------------------------*/

/*/ UpdateListView()
 *
d803 1
a803 1
void UpdateListView(win, gad, refresh)
d810 1
a810 1
    WORD x, y, i;
d816 1
a816 1
    struct IntuiText labelitext;
a835 3
	memset(&labelitext, NULL, sizeof(struct IntuiText));
	labelitext.ITextFont = LVID(gad)->lvid_TextAttr;
	labelitext.DrawMode = JAM2;
d844 1
a844 2
	y = gad->TopEdge + ((1+LVID(gad)->lvid_InterSpace)>>1) + TOPTRIM;
	DP(("ULV:  x: %ld, y: %ld\n", ((LONG)x), ((LONG)y)));
d847 1
a849 2
	    labelitext.FrontPen = (LVID(gad)->lvid_VisualInfo->vi_textPen);
	    labelitext.BackPen = (LVID(gad)->lvid_VisualInfo->vi_backgroundPen);
d852 2
a853 2
		labelitext.FrontPen = ~labelitext.FrontPen;
		labelitext.BackPen = ~labelitext.BackPen;
d859 1
a859 1
		labelitext.IText = node->ln_Name;
d861 2
a862 2
		    labelitext.IText, ((LONG)x), ((LONG)y),
		    ((LONG)(LVID(gad)->lvid_Width - (LRTRIM+LEFTTRIM)))));
d864 2
a865 2
		printITextToFit(&cloneRP, &labelitext, x, y,
		    (WORD)(LVID(gad)->lvid_Width - (LRTRIM+LEFTTRIM)));
d879 1
a879 1
		SetAPen(&cloneRP, labelitext.BackPen);
d881 1
a881 1
		RectFill(&cloneRP, minx, y,
d883 1
a883 1
		    (WORD)(y + LVID(gad)->lvid_EachHeight - LVID(gad)->lvid_InterSpace - 1));
d889 6
a895 2
	    MP(("ULV:  Incrementing y\n"));
	    y += LVID(gad)->lvid_EachHeight;
d935 1
a935 3
    imsg->Code = index + LVID(gad)->lvid_Top;


@


38.1
log
@Optimized extraction of instance data.
@
text
@d7 1
a7 1
*   $Id: listview.c,v 38.0 91/07/11 12:34:18 peter Exp Locker: peter $
d10 3
d467 1
a467 1
    SCID(gad)->sc_ListView = lv;
@


38.0
log
@ Initial V38 check-in (matches V37 release).
@
text
@d7 1
a7 1
*   $Id: listview.c,v 36.12 91/04/08 13:25:28 peter Exp $
d10 3
a163 2
    struct ListViewIData *lvid;
    struct ListLineIData *llid;
d264 1
a264 1
    lv = gad = CreateGenericBase(gad, ng, sizeof(struct ListViewIData),
a280 2
    lvid = LVID(gad);

d282 6
a287 6
    lvid->lvid_Width = ng->ng_Width - scrollwidth;
    lvid->lvid_InterSpace = interspace;
    lvid->lvid_EachHeight = EachHeight;
    lvid->lvid_Count = NumLines;
    lvid->lvid_Labels = (struct List *)getGTTagData(GTLV_Labels, NULL, taglist);
    lvid->lvid_Flags = getGTTagData(GTLV_ReadOnly, FALSE, taglist) ?
d289 6
a294 6
    lvid->lvid_DisplayTag = displaytag;
    lvid->lvid_TextAttr = ng->ng_TextAttr;
    lvid->lvid_VisualInfo = ng->ng_VisualInfo;
    lvid->lvid_DisplayGad = displaygad;
    lvid->lvid_Selected = getGTTagData(GTLV_Selected, ~0, taglist);
    DP(("CLV:  lvid_Labels: $%lx\n", lvid->lvid_Labels));
d296 1
a296 1
	lvid->lvid_Flags, lvid->lvid_DisplayGad, lvid->lvid_Selected));
d298 1
a298 1
    if (lvid->lvid_Labels)
d300 2
a301 2
	DP(("CLV:  Examining list at $%lx\n", lvid->lvid_Labels));
	for (node = lvid->lvid_Labels->lh_Head;
d305 1
a305 1
	    DP(("CLV:  Found node # %ld: '%s'\n", lvid->lvid_Total,
d307 1
a307 1
	    lvid->lvid_Total++;
d310 1
a310 1
    DP(("CLV:  Found %ld nodes.\n", lvid->lvid_Total));
d313 10
a322 10
    lvid->lvid_Top = getGTTagData(GTLV_Top, 0, taglist);
    hidden = max(lvid->lvid_Total - lvid->lvid_Count, 0);
    if (lvid->lvid_Top > hidden)
	lvid->lvid_Top = hidden;
    DP(("CLV:  lvid_Top: %ld\n", lvid->lvid_Top));


    if (lvid->lvid_Selected > lvid->lvid_Total - 1)
	{
	lvid->lvid_Selected = lvid->lvid_Total - 1;
d324 1
a324 1
    DP(("CLV: Adjusted lvid_Selected: %ld\n", lvid->lvid_Selected));
d326 1
a326 1
    if (lvid->lvid_Labels)
d329 1
a329 1
	for (node = lvid->lvid_Labels->lh_Head;
d336 1
a336 1
	    if ((count == lvid->lvid_Selected) && (displaygad))
d348 1
a348 1
		    lvid->lvid_DisplayTag, node->ln_Name,
d354 1
a354 1
	    if (count == lvid->lvid_Top)
d357 1
a357 1
		    lvid->lvid_Total, node));
d359 1
a359 1
		lvid->lvid_TopLabel = node;
d365 1
a365 1
    gad->Height = lvid->lvid_Count * lvid->lvid_EachHeight + TBTRIM;
d392 1
a392 1
	gad = CreateGenericBase(gad, &mod_ng, sizeof(struct ListLineIData),
d396 1
a396 2
	    llid = LLID(gad);
	    llid->llid_MaxX = 0;
d410 1
a410 1
	    if (!(lvid->lvid_Flags & LV_READONLY))
d422 1
a422 1
	    if (count >= lvid->lvid_Total)
d429 1
a429 1
		lvid->lvid_TopGadget = gad;
d451 2
a452 2
	GTSC_Top, lvid->lvid_Top,
	GTSC_Total, lvid->lvid_Total,
d457 1
a457 1
	GTSC_Arrows, min(lvid->lvid_EachHeight, mod_ng.ng_Height >> 2),
d463 1
a463 1
    lvid->lvid_Scroller = gad;
a563 1
    struct ListViewIData *lvid = LVID(gad);
d612 1
a612 1
    top = getGTTagData(GTLV_Top, lvid->lvid_Top, taglist);
d617 2
a618 2
	lvid->lvid_Labels = (struct List *)ti->ti_Data;
	if (lvid->lvid_Labels == (struct List *)(~0))
d621 2
a622 2
	    lvid->lvid_Labels = NULL;
	    lvid->lvid_Flags |= LV_DEFERREFRESH;
d626 1
a626 1
	    lvid->lvid_Total = 0;
d629 1
a629 1
	    lvid->lvid_Flags &= ~LV_DEFERREFRESH;
d631 1
a631 1
	if (lvid->lvid_Labels)
d633 2
a634 2
	    DP(("ISLVA:  Examining list at $%lx\n", lvid->lvid_Labels));
	    for (node = lvid->lvid_Labels->lh_Head;
d638 1
a638 1
		MP(("ISLVA:  Found node # %ld: '%s'\n", lvid->lvid_Total,
d640 1
a640 1
		lvid->lvid_Total++;
d643 1
a643 1
	DP(("ISLVA:  Found %ld nodes.\n", lvid->lvid_Total));
d647 1
a647 1
	DP(("ISLVA:  Using old labels at $%lx\n", lvid->lvid_Labels));
d651 1
a651 1
    hidden = max(lvid->lvid_Total - lvid->lvid_Count, 0);
d656 1
a656 1
    lvid->lvid_Top = top;
d661 1
a661 1
	lvid->lvid_Selected = ti->ti_Data;
d663 2
a664 2
    DP(("ISLVA: lvid_Selected: %ld\n", lvid->lvid_Selected));
    if (lvid->lvid_Selected > lvid->lvid_Total - 1)
d666 1
a666 1
	lvid->lvid_Selected = lvid->lvid_Total - 1;
d668 1
a668 1
    DP(("ISLVA: Adjusted lvid_Selected: %ld\n", lvid->lvid_Selected));
d670 1
a670 1
    if (!(lvid->lvid_DisplayGad))
d676 1
a676 1
    lvid->lvid_TopLabel = NULL;
d678 1
a678 1
    if (lvid->lvid_Labels)
d680 1
a680 1
	for (node = lvid->lvid_Labels->lh_Head;
d688 1
a688 1
		lvid->lvid_TopLabel = node;
d691 1
a691 1
	    if (ind == lvid->lvid_Selected)
d702 2
a703 2
	GT_SetGadgetAttrs(lvid->lvid_DisplayGad, win, req,
	    lvid->lvid_DisplayTag, name,
d710 1
a710 1
    if ( !(lvid->lvid_Flags & LV_READONLY) )
d712 2
a713 2
	active = lvid->lvid_Total;
	if (lvid->lvid_Flags & LV_DEFERREFRESH)
d717 2
a718 2
	runner = lvid->lvid_TopGadget;
	for (ind = 0; ind < lvid->lvid_Count; ind++)
d746 5
a750 5
	    lvid->lvid_Scroller, ((ULONG)lvid->lvid_Top),
	    ((ULONG)lvid->lvid_Total), ((ULONG)lvid->lvid_Count)));
	GT_SetGadgetAttrs(lvid->lvid_Scroller, win, req,
	    GTSC_Top, lvid->lvid_Top,
	    GTSC_Total, lvid->lvid_Total,
d772 1
a772 1
void RefreshListView(win, lv, refresh)
d775 1
a775 1
    struct Gadget *lv;
a778 1
    struct ListViewIData *lvid = LVID(lv);
d781 3
a783 3
    DP(("RLV: win at $%lx, listview gad at $%lx\n", win, lv));
    UpdateListView(win, lv, refresh);
    DP(("RLV:  vi at $%lx\n", lvid->lvid_VisualInfo));
d787 1
a787 1
    if (lvid->lvid_Flags & LV_READONLY)
d793 4
a796 4
	lv->LeftEdge, lv->TopEdge,
	lvid->lvid_Width,
	(WORD) (lvid->lvid_Count * lvid->lvid_EachHeight + TBTRIM),
	GT_VisualInfo, lvid->lvid_VisualInfo,
d814 1
a814 1
void UpdateListView(win, lv, refresh)
d817 1
a817 1
    struct Gadget *lv;
a820 2
    struct ListViewIData *lvid = LVID(lv);
    struct ListLineIData *llid;
d823 1
a823 1
    struct Gadget *gad;
d831 1
a831 1
    if (!(lvid->lvid_Flags & LV_DEFERREFRESH))
d842 2
a843 2
		lvid->lvid_TopGadget->GadgetID));
	    pos = RemoveGList(win, lvid->lvid_TopGadget, lvid->lvid_Count);
d848 1
a848 1
	labelitext.ITextFont = lvid->lvid_TextAttr;
d850 3
a852 3
	i = lvid->lvid_Count;
	node = lvid->lvid_TopLabel;
	gad = lvid->lvid_TopGadget;
d856 3
a858 3
	DP(("ULV:  1st node $%lx, 1st gad $%lx count %ld\n", node, gad, lvid->lvid_Count));
	x = lv->LeftEdge + LEFTTRIM;
	y = lv->TopEdge + ((1+lvid->lvid_InterSpace)>>1) + TOPTRIM;
a862 1
	    llid = LLID(gad);
d864 3
a866 3
	    labelitext.FrontPen = (lvid->lvid_VisualInfo->vi_textPen);
	    labelitext.BackPen = (lvid->lvid_VisualInfo->vi_backgroundPen);
	    if (gad->Flags & SELECTED)
d878 1
a878 1
		    ((LONG)(lvid->lvid_Width - (LRTRIM+LEFTTRIM)))));
d881 1
a881 1
		    (WORD)(lvid->lvid_Width - (LRTRIM+LEFTTRIM)));
d892 1
a892 1
	    if (llid->llid_MaxX > minx)
d898 2
a899 2
		    llid->llid_MaxX,
		    (WORD)(y + lvid->lvid_EachHeight - lvid->lvid_InterSpace - 1));
d902 1
a902 1
	    llid->llid_MaxX = minx;
d905 1
a905 1
	    gad = gad->NextGadget;
d907 1
a907 1
	    y += lvid->lvid_EachHeight;
d912 1
a912 1
	    AddGList(win, lvid->lvid_TopGadget, pos, lvid->lvid_Count, NULL);
d935 1
a935 1
BOOL HandleListView(gad, imsg)
d937 1
a937 1
    struct Gadget *gad;
d941 1
a941 2
    struct Gadget *lv = SG_FROM_GAD(gad)->sg_Parent;
    struct ListViewIData *lvid = LVID(lv);
d945 3
a947 3
    imsg->IAddress = (APTR) lv;
    index = gad->GadgetID;
    imsg->Code = index + lvid->lvid_Top;
d951 2
a952 2
    if (( imsg->Code >= lvid->lvid_Total ) ||
	(lvid->lvid_Flags & LV_DEFERREFRESH ) )
d960 1
a960 1
	if (lvid->lvid_DisplayGad)
d965 1
a965 1
	    node = lvid->lvid_TopLabel;
d970 2
a971 2
	    GT_SetGadgetAttrs(lvid->lvid_DisplayGad, imsg->IDCMPWindow, NULL,
		lvid->lvid_DisplayTag, node->ln_Name,
@
