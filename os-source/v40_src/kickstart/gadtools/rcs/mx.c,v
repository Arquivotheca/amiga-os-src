head     39.12;
branch   ;
access   ;
symbols  ;
locks    ; strict;
comment  @ * @;


39.12
date     92.10.16.18.29.32;  author vertex;  state Exp;
branches ;
next     39.11;

39.11
date     92.05.29.15.28.17;  author vertex;  state Exp;
branches ;
next     39.10;

39.10
date     92.04.24.17.11.16;  author vertex;  state Exp;
branches ;
next     39.9;

39.9
date     92.04.24.10.21.35;  author vertex;  state Exp;
branches ;
next     39.8;

39.8
date     92.04.15.11.35.02;  author vertex;  state Exp;
branches ;
next     39.7;

39.7
date     92.04.13.14.03.24;  author vertex;  state Exp;
branches ;
next     39.6;

39.6
date     92.04.07.13.55.36;  author vertex;  state Exp;
branches ;
next     39.5;

39.5
date     92.03.24.15.15.19;  author peter;  state Exp;
branches ;
next     39.4;

39.4
date     92.03.03.15.05.46;  author peter;  state Exp;
branches ;
next     39.3;

39.3
date     92.02.20.11.50.31;  author peter;  state Exp;
branches ;
next     39.2;

39.2
date     92.02.03.15.49.14;  author peter;  state Exp;
branches ;
next     39.1;

39.1
date     92.01.30.19.54.01;  author peter;  state Exp;
branches ;
next     38.2;

38.2
date     92.01.30.18.09.14;  author peter;  state Exp;
branches ;
next     38.1;

38.1
date     91.11.27.13.17.36;  author peter;  state Exp;
branches ;
next     38.0;

38.0
date     91.07.11.12.33.41;  author peter;  state Exp;
branches ;
next     ;


desc
@@


39.12
log
@Changes for SAS/C 6.0
@
text
@/*** mx.c *****************************************************************
*
*   mx.c	- Mutually Exclusive gadget routines
*
*   Copyright 1989, 1990, Commodore-Amiga, Inc.
*
*   $Id: mx.c,v 39.11 92/05/29 15:28:17 vertex Exp Locker: vertex $
*
**************************************************************************/

/*------------------------------------------------------------------------*/

#include "gtinclude.h"

/*------------------------------------------------------------------------*/

/* Function Prototypes: */

/* Internal: */
struct ExtGadget *CreateMXA (struct ExtGadget *gad, struct NewGadget *ng,
    struct TagItem *taglist);
void SetMXAttrsA (struct ExtGadget *gad, struct Window *win,
    struct TagItem *taglist);
BOOL HandleMX (struct ExtGadget *gad, struct IntuiMessage *imsg);

static BOOL NewActiveMX (struct ExtGadget *gad, struct Window *win);

/*------------------------------------------------------------------------*/

/* CreateMXA() */

struct ExtGadget *CreateMXA( struct ExtGadget *gad, struct NewGadget *ng,
    struct TagItem *taglist )
{
    struct NewGadget mod_ng;
    STRPTR *gadlabel;
    struct ExtGadget *preMX, *mxgad;
    UWORD interspacing;
    struct Image *mximage;
    STRPTR *labels = (STRPTR *)getGTTagData(GTMX_Labels, 0, taglist);
    struct TagItem *ti;
    struct Rectangle newrect, result, gadgetrect;

    DP(("CMX:  labels pointer at $%lx\n", labels));
    if (!labels)
    {
	DP(("CMX:  Failing on account of NULL labels\n"));
	return(NULL);
    }

    /* We've introduced an alternate tag similar to LAYOUTA_SPACING
     * that is font-sensitive.  GTMX_Spacing is added to the font-height,
     * whereas LAYOUTA_SPACING is added to the gadget image height.
     * Better it should be to the font height for people doing
     * font-sensitive layout.  The equivalent LAYOUTA_SPACING is
     * GTMX_Spacing plus font-height minus MX_HEIGHT.  This
     * spacing variable must default to one so that 8-point font
     * users get the same default as LAYOUTA_SPACING gave
     */

    interspacing = getGTTagData(GTMX_Spacing, 1, taglist) +
	ng->ng_TextAttr->ta_YSize;

    /* We give old users what they've always asked for: */
    if (ti = findTagItem(LAYOUTA_SPACING, taglist))
    {
	interspacing = ti->ti_Data + MX_HEIGHT;
    }

    /* We must create the dummy-gadget first, but we would like to
     * return it from CreateMX(), so later we move it to last
     * in this piece of gadget-list.  We have to save the value of
     * gad before mxgad was allocated:
     */
    preMX = gad;

    /* Create the dummy gadget with the instance data: */
    DP(("CMX:  about to create dummy\n"));
    if (mxgad = gad = CreateGenericBase(gad, ng, MX_IDATA_SIZE,taglist))
    {
        mxgad->Flags |= GADGHNONE;

        SGAD(mxgad)->sg_SetAttrs = SetMXAttrsA;
        SGAD(mxgad)->sg_GetTable = MX_GetTable;

        mod_ng              = *ng;
        mod_ng.ng_Flags    &= ~NG_HIGHLABEL;
        mod_ng.ng_GadgetID  = 0;

        if (!getGTTagData(GTMX_Scaled,FALSE,taglist))
        {
            mod_ng.ng_Width  = MX_WIDTH;
            mod_ng.ng_Height = MX_HEIGHT;
            /* Here we do an unusual thing.  For most gadget classes, the text
             * is contained in a box whose TopEdge corresponds to what
             * the caller calls ng.ng_TopEdge.  So for any given font size,
             * the font is a constant distance below this point.  Unfortunately,
             * for mx gadgets (and checkboxes), the ng_TopEdge represented the
             * TopEdge of the mx gadget, but the text is not a fixed
             * distance below this point, but rather vertically centered
             * with respect to the mx gadget height (a constant).  So the
             * bigger the font, the higher it would appear.
             *
             * Smart mx gadgets (GTMX_Scaled) allows radio buttons of arbitrary
             * height.  In these cases, the font is positioned correctly.
             *
             * In the meantime, we behave similar to that, except the mx gadget
             * is of fixed size, and IT is vertically-centered within such
             * a space.  Things are arranged so that for 8-point fonts, the
             * positions are exactly as before.  With the new scheme, the text
             * will appear one pixel lower than before for every two pixels
             * of font height above 8.  This makes font-sensitive layout by
             * a GadTools client possible.
             */

            /* Since we default to PLACETEXT_LEFT, we want this adjustment
             * when the place field is LEFT, RIGHT, or zero.  The most efficient
             * coding for that is to say <= PLACETEXT_RIGHT.  Works out because
             * we got lucky chosing #defines.  Not pretty, but small!
             */
            if ((ng->ng_Flags & PLACETEXT_MASK) <= PLACETEXT_RIGHT)
            {
                mod_ng.ng_TopEdge += (ng->ng_TextAttr->ta_YSize-7)/2;
            }
        }

        if (!(mximage = getSysImage(mod_ng.ng_VisualInfo,mod_ng.ng_Width, mod_ng.ng_Height, MXIMAGE)))
            return(NULL);

        DP(("CMX:  Boopsi MX Image at $%lx\n", mximage));
        DP(("CMX:  im->Width = %ld, im->Height = %ld\n",
            (LONG)mximage->Width, mximage->Height));

        gadgetrect.MinX = gadgetrect.MaxX = mxgad->LeftEdge;
        gadgetrect.MinY = gadgetrect.MaxY = mxgad->TopEdge;

        gadlabel = labels;
        while (*gadlabel)
        {
            DP(("CMX:  gadlabel $%lx, *gadlabel $%lx = '%s'\n", gadlabel,
                *gadlabel, *gadlabel));
            mod_ng.ng_GadgetText = *gadlabel++;
            /* Send taglist on down, so that GT_Underscore gets through */
            if (!(gad = (struct ExtGadget *)CreateGadgetA(GENERIC_KIND, gad, &mod_ng, taglist)))
                return(NULL);

            if (!MXID(mxgad)->mxid_FirstGadget)
                MXID(mxgad)->mxid_FirstGadget = gad;

            placeGadgetText(gad, ng->ng_Flags, PLACETEXT_LEFT, NULL );

            newrect.MinX = gad->BoundsLeftEdge;
            newrect.MinY = gad->BoundsTopEdge;
            newrect.MaxX = newrect.MinX + gad->BoundsWidth - 1;
            newrect.MaxY = newrect.MinY + gad->BoundsHeight - 1;

            CombineRects(&gadgetrect,&newrect,&result);
            gadgetrect = result;

            /* These gadgets have an image, and are highlighted by
             * an alternate image (of the same size and position):
             *
             * This also clears GFLG_EXTENDED, which disables GADGETHELP for
             * the individual gadgets
             */
            gad->Flags = GADGHIMAGE | GADGIMAGE;

            /* These gadgets are hit-select boolean gadgets,
             * with GADGIMMEDIATE
             */
            gad->Activation = GADGIMMEDIATE;
            gad->GadgetType |= BOOLGADGET;

            gad->GadgetRender = gad->SelectRender = (APTR) mximage;

            /* Identify the group the gadget belongs to, and set up
             * the handler routine:
             */
            SGAD(gad)->sg_Parent = mxgad;
            SGAD(gad)->sg_EventHandler = HandleMX;

            /* Move down for the next gadget: */
            mod_ng.ng_TopEdge += interspacing;
            mod_ng.ng_GadgetID++;

            MXID(mxgad)->mxid_NumGadgets++;
        }

        mxgad->LeftEdge = gadgetrect.MinX;
        mxgad->TopEdge  = gadgetrect.MinY;
        mxgad->Width    = gadgetrect.MaxX - gadgetrect.MinX + 1;
        mxgad->Height   = gadgetrect.MaxY - gadgetrect.MinY + 1;

        mxgad->BoundsLeftEdge = mxgad->LeftEdge;
        mxgad->BoundsTopEdge  = mxgad->TopEdge;
        mxgad->BoundsWidth    = mxgad->Width;
        mxgad->BoundsHeight   = mxgad->Height;

        if (ti = findGTTagItem(GTMX_TitlePlace,taglist))
        {
            placeGadgetText(mxgad,ti->ti_Data,PLACETEXT_ABOVE,NULL);
        }
        else
        {
            mxgad->GadgetText = NULL;
        }

        SetMXAttrsA(mxgad,NULL,taglist);

        /* Move the dummy-gadget to the end of this list, so that
         * it is the one that is returned:
         */
        preMX->NextGadget = mxgad->NextGadget;
        gad->NextGadget = mxgad;
        mxgad->NextGadget = NULL;
    }

    return(mxgad);
}


/*------------------------------------------------------------------------*/

/*/ HandleMX()
 *
 * Function to handle IDCMP events that relate to MutualExclude gadgets.
 * Call this with each IDCMP message that relates to a MX gadget.
 *
 * Created:  29-Aug-89, Peter Cherna
 * Modified: 23-Oct-89, Peter Cherna
 *
 */

BOOL HandleMX( struct ExtGadget *gad, struct IntuiMessage *imsg )
{
    DP(("HMX:  Entry\n"));
    DP(("HMX:  gad #%ld at $%lx\n", gad->GadgetID, gad));
    DP(("HMX:  gad->Flags $%lx, gad->Activation $%lx\n", gad->Flags,
	gad->Activation));
    /* Activate the gadget, and see if it was not the active one: */
    DP(("HMX:  Calling NewActiveMX\n"));
    if (NewActiveMX(gad, imsg->IDCMPWindow))
    {
	DP(("HMX:  A new one is active: # %ld\n", gad->GadgetID));
	/* The QuasiMessage has the ordinal value in the code, and
	 * the dummy-gadget (parent) as the object.
	 */
	imsg->IAddress = (APTR) SGAD(gad)->sg_Parent;
	imsg->Code     = gad->GadgetID;
	return(TRUE);
    }

    return(FALSE);
}

/*------------------------------------------------------------------------*/


void SetMXAttrsA(struct ExtGadget *gad, struct Window *win,
                 struct TagItem *taglist)
{
struct ExtGadget *activegad;
UWORD          newactive = getGTTagData(GTMX_Active, MXID(gad)->mxid_Active, taglist);
WORD           cnt;

    DP(("SetMXAttrs: win $%lx, gad $%lx, newactive %d\n",
	win, gad, newactive));

    activegad = MXID(gad)->mxid_FirstGadget;
    cnt = MXID(gad)->mxid_NumGadgets;
    while (cnt--)
    {
	TagAbleGadget(activegad,win,taglist);
	activegad = (struct ExtGadget *)activegad->NextGadget;
    }

    activegad = MXID(gad)->mxid_FirstGadget;
    while (newactive--)
    {
	activegad = (struct ExtGadget *)activegad->NextGadget;
    }
    DP(("New active mx gadget at $%lx\n", activegad));

    /* Activate the gadget: */
    DP(("Activating it\n"));
    NewActiveMX(activegad, win);
}


/*------------------------------------------------------------------------*/

/*/ NewActiveMX()
 *
 * Internal function to make the supplied Gadget the active one
 * in its group (called from HandleMX() or SetMXAttrs()).
 *
 * Returns:  TRUE if the active gadget changed, else returns FALSE.
 *
 * Created:  14-Oct-89, Peter Cherna
 * Modified: 23-Oct-89, Peter Cherna
 */

static BOOL NewActiveMX( struct ExtGadget *gad, struct Window *win)
{
struct ExtGadget *mxgad = SGAD(gad)->sg_Parent;
struct ExtGadget *pastactive;

    DP(("NAMX:  mxgad at $%lx\n", mxgad));
    /* No processing is necessary if this is already the
     * active gadget.
     */
    if (gad != MXID(mxgad)->mxid_ActiveGadget)
    {
	if (pastactive = MXID(mxgad)->mxid_ActiveGadget)
	{
            DP(("NAMX:  Deactivating previously active gadget\n"));
            /* Clear the SELECTED bit of the Flags field of the
             * previously active gadget:
             */
            SelectGadget( pastactive, win, FALSE );
        }

	/* Set the SELECTED bit of the Flags field of the newly
	 * selected gadget:
	 */
	SelectGadget( gad, win, TRUE );

	/* Note the new active gadget: */
	MXID(mxgad)->mxid_ActiveGadget = gad;
	MXID(mxgad)->mxid_Active       = gad->GadgetID;
	return(TRUE);
    }

    return(FALSE);
}
@


39.11
log
@Fixed MX_Scaled
Removed requester support
Code size optimizations
@
text
@d7 1
a7 1
*   $Id: mx.c,v 39.10 92/04/24 17:11:16 vertex Exp Locker: vertex $
d144 1
a144 1
            if (!(gad = CreateGadgetA(GENERIC_KIND, gad, &mod_ng, taglist)))
d274 1
a274 1
	activegad = activegad->NextGadget;
d280 1
a280 1
	activegad = activegad->NextGadget;
@


39.10
log
@Added support for new GTMX_TitlePlace tag
@
text
@d7 1
a7 1
*   $Id: mx.c,v 39.9 92/04/24 10:21:35 vertex Exp Locker: vertex $
d20 1
a20 1
struct Gadget *CreateMXA (struct Gadget *gad, struct NewGadget *ng,
d22 1
a22 1
void SetMXAttrsA (struct Gadget *gad, struct Window *win, struct Requester *req,
d24 1
a24 1
BOOL HandleMX (struct Gadget *gad, struct IntuiMessage *imsg);
d26 1
a26 1
static BOOL NewActiveMX (struct Gadget *gad, struct Window *win, struct Requester *req);
d32 1
a32 1
struct Gadget *CreateMXA( struct Gadget *gad, struct NewGadget *ng,
d37 1
a37 1
    struct Gadget *preMX, *mxgad;
a88 2
        mod_ng.ng_Width     = 0;
        mod_ng.ng_Height    = 0;
d152 4
a155 4
            newrect.MinX = ((struct ExtGadget *)gad)->BoundsLeftEdge;
            newrect.MinY = ((struct ExtGadget *)gad)->BoundsTopEdge;
            newrect.MaxX = newrect.MinX + ((struct ExtGadget *)gad)->BoundsWidth - 1;
            newrect.MaxY = newrect.MinY + ((struct ExtGadget *)gad)->BoundsHeight - 1;
d194 4
a197 4
        ((struct ExtGadget *)mxgad)->BoundsLeftEdge = mxgad->LeftEdge;
        ((struct ExtGadget *)mxgad)->BoundsTopEdge  = mxgad->TopEdge;
        ((struct ExtGadget *)mxgad)->BoundsWidth    = mxgad->Width;
        ((struct ExtGadget *)mxgad)->BoundsHeight   = mxgad->Height;
d208 1
a208 1
        SetMXAttrsA(mxgad,NULL,NULL,taglist);
d234 1
a234 1
BOOL HandleMX( struct Gadget *gad, struct IntuiMessage *imsg )
d242 1
a242 1
    if (NewActiveMX(gad, imsg->IDCMPWindow, GetReq(gad,imsg->IDCMPWindow)))
d259 1
a259 1
void SetMXAttrsA(struct Gadget *gad, struct Window *win, struct Requester *req,
d262 1
a262 1
struct Gadget *activegad;
d273 1
a273 1
	TagAbleGadget(activegad,win,req,taglist);
d286 1
a286 1
    NewActiveMX(activegad, win, req);
d303 1
a303 1
static BOOL NewActiveMX( struct Gadget *gad, struct Window *win, struct Requester *req)
d305 2
a306 2
struct Gadget *mxgad = SGAD(gad)->sg_Parent;
struct Gadget *pastactive;
d320 1
a320 1
            SelectGadget( pastactive, win, req, FALSE );
d326 1
a326 1
	SelectGadget( gad, win, req, TRUE );
@


39.9
log
@Now support ng_GadgetText
@
text
@d7 1
a7 1
*   $Id: mx.c,v 39.8 92/04/15 11:35:02 vertex Exp Locker: vertex $
d201 8
a208 1
        placeGadgetText(mxgad,ng->ng_Flags,PLACETEXT_ABOVE,NULL);
@


39.8
log
@Fully implemented gadget help
Optimized code for space
@
text
@d7 1
a7 1
*   $Id: mx.c,v 39.7 92/04/13 14:03:24 vertex Exp Locker: vertex $
a77 3
    mod_ng = *ng;
    mod_ng.ng_GadgetText = NULL;

d79 1
a79 1
    if (mxgad = gad = CreateGenericBase(gad, &mod_ng, MX_IDATA_SIZE,taglist))
d191 11
a201 4
        ((struct ExtGadget *)mxgad)->BoundsLeftEdge = gadgetrect.MinX;
        ((struct ExtGadget *)mxgad)->BoundsTopEdge  = gadgetrect.MinY;
        ((struct ExtGadget *)mxgad)->BoundsWidth    = gadgetrect.MaxX - gadgetrect.MinX + 1;
        ((struct ExtGadget *)mxgad)->BoundsHeight   = gadgetrect.MaxY - gadgetrect.MinY + 1;
@


39.7
log
@Moved some stuff around to save bytes
Added requester support
@
text
@d7 1
a7 1
*   $Id: mx.c,v 39.6 92/04/07 13:55:36 vertex Exp Locker: vertex $
d42 1
a78 4
    mod_ng.ng_LeftEdge = 0;
    mod_ng.ng_TopEdge = 0;
    mod_ng.ng_Width = 0;
    mod_ng.ng_Height = 0;
d84 1
a84 1
        mxgad->Flags = GADGHNONE;
d92 2
d139 3
d157 8
d167 3
d193 5
@


39.6
log
@Now supports GA_Disabled
Doing SetXX() with no GTMX_Active tag no longer resets the active
  gadget to 0
CreateXX() now calls SetXX() to save bytes
@
text
@d7 1
a7 1
*   $Id: mx.c,v 39.5 92/03/24 15:15:19 peter Exp Locker: vertex $
d26 1
a26 1
static BOOL NewActiveMX (struct Window *win, struct Gadget *gad);
d85 1
a85 3
    mxgad = gad = CreateGenericBase(gad, &mod_ng, MX_IDATA_SIZE,
	taglist);
    if (!gad)
d87 1
a87 4
	DP(("CMX:  Failing on account of failure to create dummy\n"));
    	return(NULL);
        }
    gad->Flags = GADGHNONE;
d89 32
a120 5
    SGAD(gad)->sg_SetAttrs = SetMXAttrsA;
    SGAD(gad)->sg_GetTable = MX_GetTable;
    mod_ng = *ng;
    mod_ng.ng_Flags &= ~NG_HIGHLABEL;
    mod_ng.ng_GadgetID = 0;
d122 10
a131 25
    if ( !getGTTagData( GTMX_Scaled, FALSE, taglist ) )
    {
	mod_ng.ng_Width = MX_WIDTH;
	mod_ng.ng_Height = MX_HEIGHT;
	/* Here we do an unusual thing.  For most gadget classes, the text
	 * is contained in a box whose TopEdge corresponds to what
	 * the caller calls ng.ng_TopEdge.  So for any given font size,
	 * the font is a constant distance below this point.  Unfortunately,
	 * for mx gadgets (and checkboxes), the ng_TopEdge represented the
	 * TopEdge of the mx gadget, but the text is not a fixed
	 * distance below this point, but rather vertically centered
	 * with respect to the mx gadget height (a constant).  So the
	 * bigger the font, the higher it would appear.
	 *
	 * Smart mx gadgets (GTMX_Scaled) allows radio buttons of arbitrary
	 * height.  In these cases, the font is positioned correctly.
	 *
	 * In the meantime, we behave similar to that, except the mx gadget
	 * is of fixed size, and IT is vertically-centered within such
	 * a space.  Things are arranged so that for 8-point fonts, the
	 * positions are exactly as before.  With the new scheme, the text
	 * will appear one pixel lower than before for every two pixels
	 * of font height above 8.  This makes font-sensitive layout by
	 * a GadTools client possible.
	 */
d133 2
a134 10
	/* Since we default to PLACETEXT_LEFT, we want this adjustment
	 * when the place field is LEFT, RIGHT, or zero.  The most efficient
	 * coding for that is to say <= PLACETEXT_RIGHT.  Works out because
	 * we got lucky chosing #defines.  Not pretty, but small!
	 */
	if ( (ng->ng_Flags & PLACETEXT_MASK) <= PLACETEXT_RIGHT )
	{
	    mod_ng.ng_TopEdge += (ng->ng_TextAttr->ta_YSize-7)/2;
	}
    }
d136 16
a151 5
    if ( !( mximage = getSysImage( ng->ng_VisualInfo,
	mod_ng.ng_Width, mod_ng.ng_Height, MXIMAGE ) ) )
    {
	return(NULL);
    }
d153 1
a153 3
    DP(("CMX:  Boopsi MX Image at $%lx\n", mximage));
    DP(("CMX:  im->Width = %ld, im->Height = %ld\n",
	(LONG)mximage->Width, mximage->Height));
d155 4
a158 12
    gadlabel = labels;
    while (*gadlabel)
    {
	DP(("CMX:  gadlabel $%lx, *gadlabel $%lx = '%s'\n", gadlabel,
	    *gadlabel, *gadlabel));
	mod_ng.ng_GadgetText = *gadlabel++;
	/* Send taglist on down, so that GT_Underscore gets through */
	gad = CreateGadgetA(GENERIC_KIND, gad, &mod_ng, taglist);
	if (!gad)
	{
	    return(NULL);
	}
d160 5
a164 2
	if (!MXID(mxgad)->mxid_FirstGadget)
	    MXID(mxgad)->mxid_FirstGadget = gad;
d166 1
a166 1
	placeGadgetText(gad, ng->ng_Flags, PLACETEXT_LEFT, NULL );
d168 5
a172 4
	/* These gadgets have an image, and are highlighted by
	 * an alternate image (of the same size and position):
	 */
	gad->Flags = GADGHIMAGE | GADGIMAGE;
d174 3
a176 5
	/* These gadgets are hit-select boolean gadgets,
	 * with GADGIMMEDIATE
	 */
	gad->Activation = GADGIMMEDIATE;
	gad->GadgetType |= BOOLGADGET;
d178 2
a179 1
	gad->GadgetRender = gad->SelectRender = (APTR) mximage;
d181 1
a181 5
	/* Identify the group the gadget belongs to, and set up
	 * the handler routine:
	 */
	SGAD(gad)->sg_Parent = mxgad;
	SGAD(gad)->sg_EventHandler = HandleMX;
d183 7
a189 6
	/* Move down for the next gadget: */
	mod_ng.ng_TopEdge += interspacing;
	mod_ng.ng_GadgetID++;

        MXID(mxgad)->mxid_NumGadgets++;
    }
a190 8
    SetMXAttrsA(mxgad,NULL,NULL,taglist);

    /* Move the dummy-gadget to the end of this list, so that
     * it is the one that is returned:
     */
    preMX->NextGadget = mxgad->NextGadget;
    gad->NextGadget = mxgad;
    mxgad->NextGadget = NULL;
d215 1
a215 1
    if (NewActiveMX(imsg->IDCMPWindow, gad))
d222 1
a222 1
	imsg->Code = gad->GadgetID;
d225 2
a226 2
    else
	return(FALSE);
d231 3
a233 2
void SetMXAttrsA( struct Gadget *gad, struct Window *win, struct Requester *req,
    struct TagItem *taglist )
d235 3
a237 3
    struct Gadget *activegad;
    UWORD newactive = getGTTagData(GTMX_Active, MXID(gad)->mxid_Active, taglist);
    WORD cnt;
d259 1
a259 1
    NewActiveMX(win, activegad);
d276 1
a276 1
static BOOL NewActiveMX( struct Window *win, struct Gadget *gad )
d278 2
a279 2
    struct Gadget *mxgad = SGAD(gad)->sg_Parent;
    struct Gadget *pastactive;
d293 1
a293 1
            SelectGadget( pastactive, win, NULL, FALSE );
d296 1
a296 3
	/* Always remove gadgets before changing anything about
	 * them:
	 * Set the SELECTED bit of the Flags field of the newly
d299 1
a299 1
	SelectGadget( gad, win, NULL, TRUE );
d303 1
a303 1
	MXID(mxgad)->mxid_Active = gad->GadgetID;
d306 1
a306 5
    D(else
    {
	DP(("NAMX:  This is already the active gadget\n"));
    }
    )
a308 3


/*------------------------------------------------------------------------*/
@


39.5
log
@Supports GetAttrs of GTMX_Active.  Added mxid_Active.
@
text
@d7 1
a7 1
*   $Id: mx.c,v 39.4 92/03/03 15:05:46 peter Exp Locker: peter $
d26 1
a26 1
BOOL NewActiveMX (struct Window *win, struct Gadget *gad);
a39 1
    UWORD active = getGTTagData(GTMX_Active, 0, taglist);
a146 2
    MXID(gad)->mxid_Active = active;

d160 1
a160 2
	if ( !MXID(mxgad)->mxid_FirstGadget )
	{
a161 1
	}
a182 8
	if (active-- == 0)
	{
	    /* If this is the active gadget, mark it as selected.
	     * Also, we note the gadget for later use:
	     */
	    gad->Flags |= SELECTED;
	    MXID(mxgad)->mxid_ActiveGadget = gad;
	}
d187 2
d191 2
d243 2
a244 1
    UWORD newactive = getGTTagData(GTMX_Active, 0, taglist);
d248 9
d262 1
a263 2
    DP(("New active mx gadget at $%lx\n", activegad));
    
d283 1
a283 1
BOOL NewActiveMX( struct Window *win, struct Gadget *gad )
d294 8
a301 1
	pastactive = MXID(mxgad)->mxid_ActiveGadget;
a308 6

	DP(("NAMX:  Deactivating previously active gadget\n"));
	/* Clear the SELECTED bit of the Flags field of the
	 * previously active gadget:
	 */
	SelectGadget( pastactive, win, NULL, FALSE );
@


39.4
log
@GTMX_Scaled is now accepted to scale the radio button image.
@
text
@d7 1
a7 1
*   $Id: mx.c,v 39.3 92/02/20 11:50:31 peter Exp Locker: peter $
d96 1
d148 2
a150 1

a247 40
/*i**** gadtools.lib/SetMXAttrs **********************************************
*
*   NAME
*	SetMXAttrs -- Change the attributes of an MX gadget. (V36)
*
*   SYNOPSIS
*	SetMXAttrs(win, gad, newactive)
*
*	void SetMXAttrs(struct Window *, struct Gadget *, UWORD);
*
*   FUNCTION
*	Changes the attribute (the active selection) of a mutually-exclusive
*	gadget.
*
*   INPUTS
*	win - Pointer to the window containing the gadget.
*	gad - Pointer to the mutually-exclusive gadget returned by
*	    CreateMX().
*	newactive - Ordinal number (counting from zero) of the new
*	    desired active choice.
*
*   RESULT
*	None.
*
*   EXAMPLE
*
*   NOTES
*
*   BUGS
*
*   SEE ALSO
*	CreateMX()
*
******************************************************************************
*
* Created:  14-Oct-89, Peter Cherna
* Modified: 23-Oct-89, Peter Cherna
*
*/

d311 1
@


39.3
log
@Now use SGAD() instead of SG_FROM_GAD().
@
text
@d7 1
a7 1
*   $Id: mx.c,v 39.2 92/02/03 15:49:14 peter Exp Locker: peter $
d56 1
a56 1
     * GTMX_Spacing plus font-height minus MXGAD_HEIGHT.  This
d62 1
a62 1
	ng->ng_TextAttr->ta_YSize - MXGAD_HEIGHT;
d67 1
a67 1
	interspacing = ti->ti_Data;
d96 43
a138 1
    if ( !( mximage = getSysImage( ng->ng_VisualInfo, MXIMAGE ) ) )
a146 40
    mod_ng = *ng;
    /* !!! Could really get these from mximage */
    mod_ng.ng_Width = MXGAD_WIDTH;
    mod_ng.ng_Height = MXGAD_HEIGHT;
    mod_ng.ng_Flags &= ~NG_HIGHLABEL;
    mod_ng.ng_GadgetID = 0;

    /* Here we do an evil thing.  For most gadget classes, the text
     * is contained in a box whose TopEdge corresponds to what
     * the caller calls ng.ng_TopEdge.  So for any given font size,
     * the font is a constant distance below this point.  Unfortunately,
     * for mx gadgets (and checkboxes), the ng_TopEdge represented the
     * TopEdge of the mx gadget, but the text is not a fixed
     * distance below this point, but rather vertically centered
     * with respect to the mx gadget height (a constant).  So the
     * bigger the font, the higher it would appear.
     *
     * The nice way to solve this would be allowing mx gadgets to be
     * of arbitrary (specifically ng_TextAttr->ta_YSize+const) height.
     * Then the font would be positioned correctly.
     *
     * In the meantime, we behave similar to that, except the mx gadget
     * is of fixed size, and IT is vertically-centered within such
     * a space.  Things are arranged so that for 8-point fonts, the
     * positions are exactly as before.  With the new scheme, the text
     * will appear one pixel lower than before for every two pixels
     * of font height above 8.  This makes font-sensitive layout by
     * a GadTools client possible.
     */

    /* Since we default to PLACETEXT_LEFT, we want this adjustment
     * when the place field is LEFT, RIGHT, or zero.  The most efficient
     * coding for that is to say <= PLACETEXT_RIGHT.  Works out because
     * we got lucky chosing #defines.  Not pretty, but small!
     */
    if ( (ng->ng_Flags & PLACETEXT_MASK) <= PLACETEXT_RIGHT )
    {
	mod_ng.ng_TopEdge += (ng->ng_TextAttr->ta_YSize-7)/2;
    }

a167 3
	DP(("CMX:  '%s' sg(%lx) ID %ld at $%lx\n", gad->GadgetText, sizeof(*sg),
	    mod_ng.ng_GadgetID, sg));

d196 1
a196 1
	mod_ng.ng_TopEdge += MXGAD_HEIGHT + interspacing;
a333 1
	DP(("NAMX:  Activating new gadget (# %ld)\n", MXID(mxgad)->mxid_Active));
@


39.2
log
@Deleted obsolete internal autodocs.
@
text
@d7 1
a7 1
*   $Id: mx.c,v 39.1 92/01/30 19:54:01 peter Exp Locker: peter $
a34 1
    struct SpecialGadget *sg;
d95 1
a95 1
    SG_FROM_GAD(gad)->sg_SetAttrs = SetMXAttrsA;
a165 2
	sg = SG_FROM_GAD(gad);

d185 2
a186 2
	sg->sg_Parent = mxgad;
	sg->sg_EventHandler = HandleMX;
d237 1
a237 1
	imsg->IAddress = (APTR) SG_FROM_GAD(gad)->sg_Parent;
d324 1
a324 1
    struct Gadget *mxgad = SG_FROM_GAD(gad)->sg_Parent;
@


39.1
log
@Removed RCS log.  Re-did braces, comments, and function headers.
Bumped to V39.
@
text
@d7 1
a7 1
*   $Id: mx.c,v 38.2 92/01/30 18:09:14 peter Exp Locker: peter $
d30 1
a30 57
/*i**** gadtools.library/CreateMXA *******************************************
*
*   NAME
*	CreateMXA -- Create a set of Mutually Exclusive gadgets. (V36)
*
*   SYNOPSIS
*	gad = CreateMXA(previous, ng, taglist)
*
*	struct Gadget *CreateMXA(struct Gadget *, struct NewGadget *,
*	    STRPTR *, struct TagItem *);
*
*   FUNCTION
*	Creates a set of mutually exclusive gadgets according to the
*	supplied NewGadget structure and other parameters.
*
*   INPUTS
*	previous - Pointer to the previous gadget.
*	ng - Pointer to an initialized NewGadget structure that will
*	    describe this gadget.
*	taglist - Pointer to a TagItem list.
*
*   TAGS
*	GTMX_Labels (STRPTR *) - Pointer to a NULL-terminated array of
*	    strings which are to be the labels on each individual choice.
*	    (required).
*	GTMX_Active (UWORD) - The ordinal number (counting from zero) of
*	    the initially active choice (Defaults to zero).
*	LAYOUTA_SPACING - The number of extra pixels to insert
*	    between each choice (defaults to zero).  Measured with
*	    respect to the checkbox glyph height (currently 9).
*	GTMX_Spacing (UWORD) - Use this in preference to LAYOUTA_SPACING,
*	    since this one is the extra spacing between each choice,
*	    where that amount is measured with respect to the label font.
*	    Try to keep font->ta_YSize + GTMX_Spacing >= 10 for now.
*
*   RESULT
*	gad - Pointer to the resulting mutually exclusive gadget, or NULL
*	    if failure.
*
*   EXAMPLE
*
*   NOTES
*	These attributes may be changed by calling GT_SetGadgetAttrsA():
*	GTMX_Active (UWORD) - The ordinal number (counting from zero) of
*	    the active choice.
*
*   BUGS
*
*   SEE ALSO
*	CreateGadgetA(), GT_SetGadgetAttrsA()
*
******************************************************************************
*
* Created:  29-Aug-89, Peter Cherna
* Modified:  9-May-90, Peter Cherna
*
*/
@


38.2
log
@Uses new space-saving placeGadgetText() function.
MXImage is only allocated once per VisualInfo, and shared.
@
text
@d7 1
a7 1
*   $Id: mx.c,v 38.1 91/11/27 13:17:36 peter Exp Locker: peter $
a8 67
*   $Log:	mx.c,v $
 * Revision 38.1  91/11/27  13:17:36  peter
 * Optimized extraction of instance data.  Shrunk instance data.
 * No longer keep a list of button gadgets.
 * 
 * Revision 38.0  91/07/11  12:33:41  peter
 *  Initial V38 check-in (matches V37 release).
 * 
*   Revision 36.15  91/04/08  13:26:39  peter
*   Where appropriate uses getGTTagData(), getSTRINGTagData(),
*   findGTTagItem(), and findGATagItem() macros/stubs to save space.
*   
*   Revision 36.14  91/03/28  13:31:12  peter
*   If failure occurs during allocation of the individual radio buttons,
*   the button image is now freed.
*   
*   Revision 36.13  91/03/14  16:07:12  peter
*   Now uses stack-based tags instead of array-based ones when it calls
*   tag-based functions.
*   
*   Revision 36.12  90/11/19  12:55:21  peter
*   Now passes along the tags it receives to the individual radio buttons.
*   Minor optimizations.
*   
*   Revision 36.11  90/11/07  19:43:21  peter
*   Now uses AddRefreshGList().  Use the SG_EXTRAFREE_DISPOSE flag
*   instead of ExtraFreeMX().
*   
*   Revision 36.10  90/10/12  19:41:41  peter
*   Removed unused reference to mxid->mxid_Labels.
*   Calls internal findTagItem() and getTagData() to save space.
*   Calls internal addGlist() and refreshGList() to save space.
*   
*   Revision 36.9  90/06/21  13:59:53  peter
*   Fixed error in the (unused) autodoc for CreateMX.
*   
*   Revision 36.8  90/06/11  17:34:16  peter
*   Now passes SYSIA_DrawInfo to sysiclass as per new convention.
*   
*   Revision 36.7  90/05/18  18:31:38  peter
*   Put space immediately before '(' in prototypes to avoid confusing ctags.
*   
*   Revision 36.6  90/05/15  14:18:31  peter
*   As required, now lies about screen depth for non-NewLook custom screens
*   when getting the glyph.
*   
*   Revision 36.5  90/05/03  16:31:36  peter
*   Fixed an uninitialized field in an automatic-variable.
*   
*   Revision 36.4  90/04/06  00:55:16  peter
*   Added some DP()'s.
*   Put in fix to make font-sensitive layout manageable for mx gadgets.
*   Added GTMX_Spacing tag to supplant the ill-implemented LAYOUTA_SPACING
*   tag.
*   
*   Revision 36.3  90/04/02  16:11:01  peter
*   Dropped prototype for DisposeObject().
*   No longer masks against GADTOOLMASK.
*   GadgetType is now OR'd in.
*   
*   Revision 36.2  90/03/31  06:42:04  peter
*   Now use CreateGadgetA() instead of specific Create[xxx]GadgetA().
*   
*   Revision 36.1  90/03/16  14:02:50  peter
*   RCS Clean up.
*   
*
d17 1
a17 1
/*  Function Prototypes: */
d19 1
a19 1
/*  Internal: */
d88 3
a90 4
struct Gadget *CreateMXA(struct Gadget *gad, struct NewGadget *ng,
    struct TagItem *taglist)

    {
d103 1
a103 1
	{
d106 1
a106 1
	}
d108 9
a116 8
    /*  We've introduced an alternate tag similar to LAYOUTA_SPACING
	that is font-sensitive.  GTMX_Spacing is added to the font-height,
	whereas LAYOUTA_SPACING is added to the gadget image height.
	Better it should be to the font height for people doing
	font-sensitive layout.  The equivalent LAYOUTA_SPACING is
	GTMX_Spacing plus font-height minus MXGAD_HEIGHT.  This
	spacing variable must default to one so that 8-point font
	users get the same default as LAYOUTA_SPACING gave */
d121 1
a121 1
    /*  We give old users what they've always asked for: */
d123 1
a123 1
	{
d125 1
a125 1
	}
d127 5
a131 4
    /*  We must create the dummy-gadget first, but we would like to
	return it from CreateMX(), so later we move it to last
	in this piece of gadget-list.  We have to save the value of
	gad before mxgad was allocated: */
d134 1
a134 1
    /*  Create the dummy gadget with the instance data: */
d146 1
a146 1
	{
d149 1
a149 1
    	}
a152 27
#if 00
    /*  Fill out the instance data: */
	{
	struct DrawInfo *dri = VI(ng->ng_VisualInfo)->vi_DrawInfo;
	struct Image **im = &VI(ng->ng_VisualInfo)->vi_MXImage;

	if ( !*im )
	    {
	    /* Get the mx imagery from Intuition:
	     * Note that the only place this image is disposed
	     * is in FreeVisualInfo().
	     */
	    DP(("CMX:  Calling NewObject()\n"));

	    *im = NewObject(NULL, "sysiclass",
		SYSIA_Size, 0,
		SYSIA_DrawInfo, dri,
		SYSIA_Which, MXIMAGE,
		TAG_DONE);
	    if ( !*im )
		{
		return(NULL);
		}
	    }
	    mximage = *im;
	}
#else
d154 1
a154 1
	{
d156 1
a156 2
	}
#endif
d163 1
a163 1
    /*  !!! Could really get these from mximage */
d169 22
a190 21
    /*  Here we do an evil thing.  For most gadget classes, the text
	is contained in a box whose TopEdge corresponds to what
	the caller calls ng.ng_TopEdge.  So for any given font size,
	the font is a constant distance below this point.  Unfortunately,
	for mx gadgets (and checkboxes), the ng_TopEdge represented the
	TopEdge of the mx gadget, but the text is not a fixed
	distance below this point, but rather vertically centered
	with respect to the mx gadget height (a constant).  So the
	bigger the font, the higher it would appear.

	The nice way to solve this would be allowing mx gadgets to be
	of arbitrary (specifically ng_TextAttr->ta_YSize+const) height.
	Then the font would be positioned correctly.

	In the meantime, we behave similar to that, except the mx gadget
	is of fixed size, and IT is vertically-centered within such
	a space.  Things are arranged so that for 8-point fonts, the
	positions are exactly as before.  With the new scheme, the text
	will appear one pixel lower than before for every two pixels
	of font height above 8.  This makes font-sensitive layout by
	a GadTools client possible. */
d198 1
a198 1
	{
d200 1
a200 1
	}
d205 1
a205 1
	{
d209 1
a209 1
	/*  Send taglist on down, so that GT_Underscore gets through */
d212 1
a212 1
	    {
d214 1
a214 1
	    }
d217 1
a217 1
	    {
d219 1
a219 1
	    }
d228 3
a230 2
	/*  These gadgets have an image, and are highlighted by
	    an alternate image (of the same size and position): */
d233 3
a235 2
	/*  These gadgets are hit-select boolean gadgets,
	    with GADGIMMEDIATE */
d241 3
a243 2
	/*  Identify the group the gadget belongs to, and set up
	    the handler routine: */
d247 4
a250 3
	    {
	    /*  If this is the active gadget, mark it as selected.
		Also, we note the gadget for later use: */
d253 1
a253 1
	    }
d255 1
a255 1
	/*  Move down for the next gadget: */
d258 1
a258 1
	}
d260 3
a262 2
    /*  Move the dummy-gadget to the end of this list, so that
	it is the one that is returned: */
d267 1
a267 1
    }
d282 2
a283 6
BOOL HandleMX(gad, imsg)

    struct Gadget *gad;
    struct IntuiMessage *imsg;

    {
d288 1
a288 1
    /*  Activate the gadget, and see if it was not the active one: */
d291 1
a291 1
	{
d293 3
a295 2
	/*  The QuasiMessage has the ordinal value in the code, and
	    the dummy-gadget (parent) as the object.  */
d299 1
a299 1
	}
d302 1
a302 1
    }
d346 3
a348 4
void SetMXAttrsA(struct Gadget *gad, struct Window *win, struct Requester *req,
    struct TagItem *taglist)

    {
d356 1
a356 1
	{
d358 1
a358 1
	}
d362 1
a362 1
    /*  Activate the gadget: */
d365 1
a365 1
    }
d381 2
a382 6
BOOL NewActiveMX(win, gad)

    struct Window *win;
    struct Gadget *gad;

    {
d387 3
a389 2
    /*  No processing is necessary if this is already the
	active gadget. */
d391 1
a391 1
	{
d395 5
a399 4
	/*  Always remove gadgets before changing anything about
	    them: */
	/*  Set the SELECTED bit of the Flags field of the newly
	    selected gadget: */
d403 3
a405 2
	/*  Clear the SELECTED bit of the Flags field of the
	    previously active gadget: */
d408 1
a408 1
	/*  Note the new active gadget: */
d411 1
a411 1
	}
d413 1
a413 1
	{
d415 1
a415 1
	}
d418 1
a418 1
    }
@


38.1
log
@Optimized extraction of instance data.  Shrunk instance data.
No longer keep a list of button gadgets.
@
text
@d7 1
a7 1
*   $Id: mx.c,v 38.0 91/07/11 12:33:41 peter Exp Locker: peter $
d10 4
a162 2
    struct Rectangle rect;
    ULONG place;
d164 1
d219 1
d223 1
d225 1
a225 10
	/*  Get the mx imagery from Intuition: */
	DP(("CMX:  Calling NewObject()\n"));
#ifndef SYSIA_DrawInfo
#define SYSIA_DrawInfo (IMAGE_ATTRIBUTES+24)
#endif
	if (!(MXID(mxgad)->mxid_Image = (struct Image *) NewObject(NULL, "sysiclass",
	    SYSIA_Size, 0,
	    SYSIA_DrawInfo, dri,
	    SYSIA_Which, MXIMAGE,
	    TAG_DONE)))
d227 15
a241 1
	    return(NULL);
d243 6
d250 1
d252 1
a252 1
    DP(("CMX:  Boopsi MX Image at $%lx\n", MXID(mxgad)->mxid_Image));
d254 1
a254 1
	(LONG)MXID(mxgad)->mxid_Image->Width, MXID(mxgad)->mxid_Image->Height));
d257 1
a257 1
    /*  !!! Could really get these from MXID(mxgad)->mxid_Image */
d285 6
a290 4
    if (!(place = (ng->ng_Flags & PLACETEXT_MASK)))
	place = PLACETEXT_LEFT;

    if (place & (PLACETEXT_LEFT | PLACETEXT_RIGHT))
a296 5
    rect.MinX = 0;
    rect.MinY = 0;
    rect.MaxX = MXGAD_WIDTH - 1;
    rect.MaxY = MXGAD_HEIGHT - 1;

a305 4
	    /* Peter 26-Mar-91: Nobody will be around to free the image,
	     * so it's got to go here:
	     */
	    DisposeObject(MXID(mxgad)->mxid_Image);
d314 1
a314 1
	PlaceIntuiText(gad->GadgetText, &rect, place);
d330 1
a330 1
	gad->GadgetRender = gad->SelectRender = (APTR) MXID(mxgad)->mxid_Image;
a347 3
    /*  Let the last gadget be the one that frees the boopsi image.
	We only free it once, since we only created it once */
    sg->sg_Flags = SG_EXTRAFREE_DISPOSE;
@


38.0
log
@ Initial V38 check-in (matches V37 release).
@
text
@d7 1
a7 1
*   $Id: mx.c,v 36.15 91/04/08 13:26:39 peter Exp $
d10 3
d89 1
a89 1
BOOL NewActiveMX (struct Window *win, struct SpecialGadget *sg);
d158 1
a158 2
    struct Gadget *preMX, *mx;
    struct MXIData *mxid;
d194 1
a194 1
	gad before mx was allocated: */
d206 1
a206 1
    mx = gad = CreateGenericBase(gad, &mod_ng, sizeof(struct MXIData),
d215 1
a215 6
    sg = SG_FROM_GAD(gad);
    DP(("CMX:  Dummy gadget sg(%lx) ID %ld at $%lx\n", sizeof(*sg),
	mod_ng.ng_GadgetID, sg));

    sg->sg_SetAttrs = SetMXAttrsA;
    mxid = MXID(gad);
a216 4
    DP(("CMX:  MXIData(%lx) at $%lx\n", sizeof(*mxid), mxid));
    mxid->mxid_Active = active;
    NewList((struct List *)&mxid->mxid_List);

d225 1
a225 1
	if (!(mxid->mxid_Image = (struct Image *) NewObject(NULL, "sysiclass",
d235 1
a235 1
    DP(("CMX:  Boopsi MX Image at $%lx\n", mxid->mxid_Image));
d237 1
a237 1
	(LONG)mxid->mxid_Image->Width, mxid->mxid_Image->Height));
d240 1
a240 1
    /*  !!! Could really get these from mxid->mxid_Image */
d295 1
a295 1
	    DisposeObject(mxid->mxid_Image);
d299 5
a310 2
	AddTail((struct List *)&mxid->mxid_List, (struct Node *)&sg->sg_Node);
	DP(("CMX:  Added its node at $%lx\n", &sg->sg_Node));
d320 1
a320 1
	gad->GadgetRender = gad->SelectRender = (APTR) mxid->mxid_Image;
d324 1
a324 1
	sg->sg_Parent = mx;
d331 1
a331 1
	    mxid->mxid_ActiveSG = sg;
d344 4
a347 4
    preMX->NextGadget = mx->NextGadget;
    gad->NextGadget = mx;
    mx->NextGadget = NULL;
    return(mx);
a368 2
    struct SpecialGadget *sg = SG_FROM_GAD(gad);

d370 1
a370 1
    DP(("HMX:  gad #%ld at $%lx, sg at $%lx\n", gad->GadgetID, gad, sg));
d375 1
a375 1
    if (NewActiveMX(imsg->IDCMPWindow, sg))
d380 1
a380 1
	imsg->IAddress = (APTR) sg->sg_Parent;
d434 1
a434 2
    struct MXIData *mxid = MXID(gad);
    struct MinNode *node, *next;
d439 2
a440 3
    for (node = mxid->mxid_List.mlh_Head;
	((newactive--) && (next = node->mln_Succ));
	node = next)
d442 1
a442 1
	DP(("node at $%lx\n", node));
d445 1
a445 1
    DP(("New active mx specialgadget at $%lx\n", node));
d449 1
a449 1
    NewActiveMX(win, (struct SpecialGadget *)node);
d457 1
a457 1
 * Internal function to make the supplied SpecialGadget the active one
d466 1
a466 1
BOOL NewActiveMX(win, sg)
d469 1
a469 1
    struct SpecialGadget *sg;
d472 2
a473 4
    struct MXIData *mxid = MXID(sg->sg_Parent);
    struct Gadget *activegad;
    struct Gadget *gad;
    UWORD pos;
d475 1
a475 1
    DP(("NAMX:  mxid at $%lx\n", mxid));
d478 1
a478 1
    if (sg != mxid->mxid_ActiveSG)
d480 1
a480 4
	gad = &sg->sg_Gadget;
	activegad = &mxid->mxid_ActiveSG->sg_Gadget;

	mxid->mxid_Active = gad->GadgetID;
d482 1
a482 1
	DP(("NAMX:  Activating new gadget (# %ld)\n", mxid->mxid_Active));
a484 2
	pos = RemoveGList(win, gad, 1L);

d487 1
a487 5
	gad->Flags |= SELECTED;

	/*  Put the gadget back in the same place it came from,
	    and refresh: */
	AddRefreshGList(win, gad, pos, 1L, NULL);
a489 4
	/*  Always remove gadgets before changing anything about
	    them: */
	pos = RemoveGList(win, activegad, 1L);

d492 1
a492 5
	activegad->Flags &= ~SELECTED;

	/*  Put the gadget back in the same place it came from,
	    and refresh: */
	AddRefreshGList(win, activegad, pos, 1L, NULL);
d495 1
a495 1
	mxid->mxid_ActiveSG = sg;
@
