head     39.18;
branch   ;
access   ;
symbols  ;
locks    ; strict;
comment  @ * @;


39.18
date     93.02.11.10.48.39;  author vertex;  state Exp;
branches ;
next     39.17;

39.17
date     92.12.01.08.59.20;  author vertex;  state Exp;
branches ;
next     39.16;

39.16
date     92.11.20.10.46.01;  author vertex;  state Exp;
branches ;
next     39.15;

39.15
date     92.10.16.18.30.03;  author vertex;  state Exp;
branches ;
next     39.14;

39.14
date     92.07.31.19.22.49;  author vertex;  state Exp;
branches ;
next     39.13;

39.13
date     92.07.16.11.01.12;  author vertex;  state Exp;
branches ;
next     39.12;

39.12
date     92.06.04.12.32.58;  author vertex;  state Exp;
branches ;
next     39.11;

39.11
date     92.05.29.15.50.12;  author vertex;  state Exp;
branches ;
next     39.10;

39.10
date     92.05.29.15.43.41;  author vertex;  state Exp;
branches ;
next     39.9;

39.9
date     92.04.15.11.41.32;  author vertex;  state Exp;
branches ;
next     39.8;

39.8
date     92.04.13.14.09.38;  author vertex;  state Exp;
branches ;
next     39.7;

39.7
date     92.04.07.13.59.13;  author vertex;  state Exp;
branches ;
next     39.6;

39.6
date     92.03.24.15.27.54;  author peter;  state Exp;
branches ;
next     39.5;

39.5
date     92.03.24.15.14.02;  author peter;  state Exp;
branches ;
next     39.4;

39.4
date     92.02.20.13.56.41;  author peter;  state Exp;
branches ;
next     39.3;

39.3
date     92.02.20.11.49.49;  author peter;  state Exp;
branches ;
next     39.2;

39.2
date     92.02.03.15.47.35;  author peter;  state Exp;
branches ;
next     39.1;

39.1
date     92.01.30.19.52.42;  author peter;  state Exp;
branches ;
next     38.1;

38.1
date     92.01.28.08.29.30;  author peter;  state Exp;
branches ;
next     38.0;

38.0
date     91.07.11.12.34.07;  author peter;  state Exp;
branches ;
next     ;


desc
@@


39.18
log
@Fixed autodocs
@
text
@/*** dispatch.c ***********************************************************
*
*   dispatch.c	- Gadget Toolkit dispatch routines
*
*   Copyright 1989, Commodore-Amiga, Inc.
*
*   $Id: dispatch.c,v 39.17 92/12/01 08:59:20 vertex Exp Locker: vertex $
*
**************************************************************************/

/*------------------------------------------------------------------------*/

#include "gtinclude.h"

/*------------------------------------------------------------------------*/

/* Function Prototypes: */

/* Public: */
struct IntuiMessage * __asm
LIB_GT_GetIMsg (register __a0 struct MsgPort *iport);

void __asm
LIB_GT_ReplyIMsg (register __a1 struct IntuiMessage *imsg);

void __asm
LIB_GT_RefreshWindow (register __a0 struct Window *win);

void __asm
LIB_GT_BeginRefresh (register __a0 struct Window *win);

void __asm
LIB_GT_EndRefresh (register __a0 struct Window *win,
		  register __d0 BOOL complete);

struct IntuiMessage * __asm
LIB_GT_FilterIMsg (register __a1 struct IntuiMessage *imsg);

struct IntuiMessage *__asm
LIB_GT_PostFilterIMsg (register __a1 struct IntuiMessage *imsg);

void __asm
LIB_GT_SetGadgetAttrsA (register __a0 struct ExtGadget *gad,
		       register __a1 struct Window *win,
		       register __a3 struct TagItem *taglist);

struct ExtGadget * __asm
LIB_CreateContext (register __a0 struct ExtGadget **glistptr);

/* Internal: */
static struct ExtGadget *FindContext (struct Window *win);
static void WalkRefreshGadgets (struct Window *win, BOOL refresh);

/*------------------------------------------------------------------------*/

/****** gadtools.library/GT_GetIMsg ******************************************
*
*   NAME
*	GT_GetIMsg -- get an IntuiMessage, with GadTools processing. (V36)
*
*   SYNOPSIS
*	imsg = GT_GetIMsg(intuiport)
*	D0                A0
*
*	struct IntuiMessage *GT_GetIMsg(struct MsgPort *);
*
*   FUNCTION
*	Use GT_GetIMsg() in place of the usual exec.library/GetMsg() when
*	reading IntuiMessages from your window's UserPort.  If needed,
*	the GadTools dispatcher will be invoked, and suitable processing
*	will be done for gadget actions.  This function returns a pointer
*	to a modified IntuiMessage (which is a copy of the original,
*	possibly with some supplementary information from GadTools).
*	If there are no messages (or if the only messages are meaningful
*	only to GadTools, NULL will be returned.
*
*   INPUTS
*	intuiport - the Window->UserPort of a window that is using the
*	            Gadget Toolkit.
*
*   RESULT
*	imsg - pointer to modified IntuiMessage, or NULL if there are
*	       no applicable messages.
*
*   NOTES
*	Be sure to use GT_ReplyIMsg() and not exec.library/ReplyMsg() on
*	messages obtained with GT_GetIMsg().
*	If you intend to do more with the resulting message than read
*	its fields, act on it, and reply it, you may find GT_FilterIMsg()
*	more appropriate.
*
*	Starting with V39, this function actually returns a pointer to an
*	ExtIntuiMessage structure, but the prototype was not changed for
*	source code compatibility with older software.
*
*   SEE ALSO
*	GT_ReplyIMsg(), GT_FilterIMsg()
*
******************************************************************************
*
* Created:  10-Nov-89, Peter Cherna
* Modified: 10-Nov-89, Peter Cherna
*
*/

struct IntuiMessage * ASM LIB_GT_GetIMsg(REG(a0) struct MsgPort *iport)
{
struct IntuiMessage *clientmsg;
struct IntuiMessage *imsg;

    /* Get a message until there is one that isn't eaten by the toolkit,
     * or until no more are available:
     */
    while (imsg = (struct IntuiMessage *)GetMsg(iport))
    {
	DP(("GT_GM: Win $%lx, have imsg of class $%lx, IAddress $%lx\n",imsg->IDCMPWindow, imsg->Class, imsg->IAddress));

	/* Do the dispatch */
	if (clientmsg = GT_FilterIMsg((struct IntuiMessage *)imsg))
	    return(clientmsg);

        /* Message was eaten, so ReplyMsg() it and get another one
         * if available
         */
	ReplyMsg((struct Message *)imsg);
    }

    return(NULL);
}


/*------------------------------------------------------------------------*/

/****** gadtools.library/GT_ReplyIMsg ****************************************
*
*   NAME
*	GT_ReplyIMsg -- reply a message obtained with GT_GetIMsg(). (V36)
*
*   SYNOPSIS
*	GT_ReplyIMsg(imsg)
*	             A1
*
*	VOID GT_ReplyIMsg(struct IntuiMessage *);
*
*   FUNCTION
*	Reply a modified IntuiMessage obtained with GT_GetIMsg().
*	If you use GT_GetIMsg(), use this function where you would normally
*	have used exec.library/ReplyMsg().
*	You may safely call this routine with a NULL pointer (nothing
*	will be done).
*
*   INPUTS
*	imsg - a modified IntuiMessage obtained with GT_GetIMsg(), or NULL
*	       in which case this function does nothing
*
*   NOTES
*	When using GadTools, you MUST explicitly GT_ReplyIMsg()
*	all messages you receive.  You cannot depend on CloseWindow()
*	to handle messages you have not replied.
*
*	Starting with V39, this function actually expects a pointer to an
*	ExtIntuiMessage structure, but the prototype was not changed for
*	source code compatibility with older software.
*
*   SEE ALSO
*	GT_GetIMsg()
*
******************************************************************************
*
* Created:  14-Oct-89, Peter Cherna
* Modified: 09-Nov-89, Peter Cherna
*
*/

VOID ASM LIB_GT_ReplyIMsg(REG(a1) struct IntuiMessage *imsg)
{
    if (imsg)
    {
	/* Reply the REAL IntuiMessage that was in play here: */
	ReplyMsg((struct Message *)GT_PostFilterIMsg(imsg));
    }
}


/*------------------------------------------------------------------------*/

/*/ WalkRefreshGadgets()
 *
 * Function to walk a window's gadget list and do all the special
 * refresh for the toolkit gadgets.  The boolean parameter tells
 * whether the refresh functions are expected to do Begin/EndRefresh()
 *
 * Notes:  When we go with custom gadgets, this function won't
 * be necessary, since our gadgets will have the same powers of
 * refresh as regular gadgets.
 *
 * Created:  17-Oct-89, Peter Cherna
 * Modified: 17-Nov-89, Peter Cherna
 *
 */

static VOID WalkRefreshGadgets(struct Window *win,
                               BOOL refresh)
{
struct ExtGadget *gad;

    /* Walk the list of gadgets in the supplied window: */

    gad = (struct ExtGadget *)win->FirstGadget;
    while (gad)
    {
        MP(("GT_RW:  gadget at $%lx", gad));
        /* Is this a Toolkit gadget? */
        if (gad->GadgetType & GADTOOL_TYPE)
        {
            MP((" is a toolkit gadget"));
            /* Does it have a refresh function? */
            if (SGAD(gad)->sg_Refresh)
            {
                MP((", refresh fcn at $%lx\n", SGAD(gad)->sg_Refresh));
                /* Do the refresh: */
                (*SGAD(gad)->sg_Refresh)(gad, win, refresh);
            }
        }
        MP(("\n"));
        gad = (struct ExtGadget *)gad->NextGadget;
    }
}

/*------------------------------------------------------------------------*/

/****** gadtools.library/GT_RefreshWindow ************************************
*
*   NAME
*	GT_RefreshWindow -- refresh all GadTools gadgets in a window. (V36)
*
*   SYNOPSIS
*	GT_RefreshWindow(win, req)
*	                 A0   A1
*
*	VOID GT_RefreshWindow(struct Window *, struct Requester *);
*
*   FUNCTION
*	Perform the initial refresh of all the GadTools gadgets you have
*	created.  After you have opened your window, you must call this
*	function.  Or, if you have opened your window without gadgets,
*	you add the gadgets with intuition.library/AddGList(),
*	refresh them using intuition.library/RefreshGList(), then call
*	this function.
*	You should not need this function at other times.
*
*   INPUTS
*	win - pointer to the Window containing GadTools gadgets.
*	req - reserved for future use, should always be NULL
*
*   SEE ALSO
*	GT_BeginRefresh()
*
******************************************************************************
*
* Created:  17-Oct-89, Peter Cherna
* Modified:  5-Dec-89, Peter Cherna
*
* NOTES
*	Since the requester parameter is not currently used, the actual
*	function does not define this parameter which makes the code
*	smaller.
*/

VOID ASM LIB_GT_RefreshWindow(REG(a0) struct Window *win)
{
    /* Do the refresh, but inform that we're not inside Begin/EndRefresh() */
    WalkRefreshGadgets(win, FALSE);
}


/*------------------------------------------------------------------------*/

/****** gadtools.library/GT_BeginRefresh *************************************
*
*   NAME
*	GT_BeginRefresh -- begin refreshing friendly to GadTools. (V36)
*
*   SYNOPSIS
*	GT_BeginRefresh(win)
*	                A0
*
*	VOID GT_BeginRefresh(struct Window *);
*
*   FUNCTION
*	Invokes the intuition.library/BeginRefresh() function in a manner
*	friendly to the Gadget Toolkit.  This function call permits the
*	GadTools gadgets to refresh themselves at the correct time.
*	Call GT_EndRefresh() function when done.
*
*   INPUTS
*	win - pointer to Window structure for which a IDCMP_REFRESHWINDOW
*	      IDCMP event was received.
*
*   NOTES
*	The nature of GadTools precludes the use of the IDCMP flag
*	WFLG_NOCAREREFRESH.  You must handle IDCMP_REFRESHWINDOW events
*	in at least the minimal way, namely:
*
*		case IDCMP_REFRESHWINDOW:
*		    GT_BeginRefresh(win);
*		    GT_EndRefresh(win, TRUE);
*		    break;
*
*   SEE ALSO
*	intuition.library/BeginRefresh()
*
******************************************************************************
*
* Created:  21-Nov-89, Peter Cherna
* Modified: 21-Nov-89, Peter Cherna
*
*/

VOID ASM LIB_GT_BeginRefresh(REG(a0) struct Window *win)
{
    BeginRefresh(win);
    WalkRefreshGadgets(win, TRUE);
}


/*------------------------------------------------------------------------*/

/****** gadtools.library/GT_EndRefresh ***************************************
*
*   NAME
*	GT_EndRefresh -- end refreshing friendly to GadTools. (V36)
*
*   SYNOPSIS
*	GT_EndRefresh(win, complete)
*	              A0   D0
*
*	VOID GT_EndRefresh(struct Window *, BOOL complete);
*
*   FUNCTION
*	Invokes the intuition.library/EndRefresh() function in a manner
*	friendly to the Gadget Toolkit.  This function call permits
*	GadTools gadgets to refresh themselves at the correct time.
*	Call this function to EndRefresh() when you have used
*	GT_BeginRefresh().
*
*   INPUTS
*	win - pointer to Window structure for which a IDCMP_REFRESHWINDOW
*	      IDCMP event was received.
*	complete - TRUE when done with refreshing.
*
*   SEE ALSO
*	intuition.library/EndRefresh()
*
******************************************************************************
*
* Created:  14-Dec-89, Peter Cherna
* Modified: 14-Dec-89, Peter Cherna
*
*/

VOID ASM LIB_GT_EndRefresh(REG(a0) struct Window *win, REG(d0) BOOL complete)
{
    /* Do nothing special function.  Put here by popular demand for
     * symmetry
     */
    EndRefresh(win, complete);
}

/*------------------------------------------------------------------------*/

/****** gadtools.library/GT_FilterIMsg ***************************************
*
*   NAME
*	GT_FilterIMsg -- filter an IntuiMessage through GadTools. (V36)
*
*   SYNOPSIS
*	modimsg = GT_FilterIMsg(imsg)
*	D0                      A1
*
*	struct IntuiMessage *GT_FilterIMsg(struct IntuiMessage *);
*
*   FUNCTION
*	NOTE WELL:  Extremely few programs will actually need this function.
*	You almost certainly should be using GT_GetIMsg() and GT_ReplyIMsg()
*	only, and not GT_FilterIMsg() and GT_PostFilterIMsg().
*
*	GT_FilterIMsg() takes the supplied IntuiMessage and asks the
*	Gadget Toolkit to consider and possibly act on it.  Returns
*	NULL if the message was only of significance to a GadTools gadget
*	(i.e. not to you), else returns a pointer to a modified IDCMP
*	message, which may contain additional information.
*
*	You should examine the Class, Code, and IAddress fields of
*	the returned message to learn what happened.  Do not make
*	interpretations based on the original imsg.
*
*	You should use GT_PostFilterIMsg() to revert to the original
*	IntuiMessage once you are done with the modified one.
*
*   INPUTS
*	imsg - an IntuiMessage you obtained from a Window's UserPort.
*
*   RESULT
*	modimsg - a modified IntuiMessage, possibly with extra information
*	          from GadTools, or NULL. When NULL, the message passed in to
*		  the function should be sent back to Intuition via ReplyMsg()
*
*   NOTES
*	Starting with V39, this function actually expects and returns
*	pointers to ExtIntuiMessage structures, but the prototype was not
*	changed for source code compatibility with older software.
*
*   WARNING
*	If this function returns NULL, you must call ReplyMsg() on the
*	IntuiMessage you passed in to GT_FilterIMsg(). That is, if the
*	message was processed by the toolkit you must reply this message
*	to Intuition since gadtools will not do this automatically.
*
*   SEE ALSO
*	GT_GetIMsg(), GT_PostFilterIMsg()
*
******************************************************************************
*
* Created:  10-Nov-89, Peter Cherna
* Modified: 10-Nov-89, Peter Cherna
*
* Function that interprets an IntuiMessage and dispatches it to the
* appropriate handler routine as necessary.  Returns the address of
* the modified message if the message wasn't eaten, else returns NULL.
*
* Created:  10-Nov-89, Peter Cherna (from old SpecialGetIMsg())
* Modified: 22-Mar-90, Peter Cherna
*/

struct IntuiMessage * ASM LIB_GT_FilterIMsg(REG(a1) struct IntuiMessage *imsg)
{
struct ExtGadget      *gad;
struct QuasiMessage   *quasi;
/* Pointer to context  data, which contains active gadget. */
struct ExtGadget      *ctgad;
/* Assume we're eating this message, until proven otherwise: */
BOOL                   msgforclient = FALSE;

    MP(("GT_FIM: Enter\n"));

    /* Obtain the shared QuasiIntuiMessage, or allocate a new one */

    /* Get window's context IData.  Use its embedded QuasiMessage, if available. */
    if (( ctgad = FindContext(imsg->IDCMPWindow) ) && ( !CTID(ctgad)->ctid_QuasiUsed ))
    {
	/* Mark the embedded QuasiMessage as used */
	CTID(ctgad)->ctid_QuasiUsed++;
	quasi = &CTID(ctgad)->ctid_QuasiMessage;
	quasi->qm_ContextGadget = ctgad;
	DP((" GT_FIM:  Marking the embedded quasi as used\n"));
    }
    else
    {
	/* If the context IData can't be found, or the embedded
	 * QuasiMessage is in use, allocate a new one
	 */
	quasi = AllocVec(sizeof(struct QuasiMessage), MEMF_CLEAR);
	DP((" GT_FIM:  QM unavailable!  AllocVec()'d one at $%lx\n", quasi));
	/* NOTE WELL: qm_ContextGadget is NULL.  We key off this to
	 * know to free this later
	 */
    }

    if (quasi)
    {
	/* Make QuasiMessage contain a copy of the IntuiMessage, and
	 * a pointer to the original IntuiMessage:
	 */
	quasi->qm_IMessage = *(struct ExtIntuiMessage *)imsg;
	quasi->qm_OrigMessage = imsg;

	gad = NULL;

	if ((imsg->Class == IDCMP_GADGETUP) || (imsg->Class == IDCMP_GADGETDOWN))
	{
#ifdef DEBUGGING
	    if (imsg->Class == IDCMP_GADGETUP)
		DP(("GT_FIM: Have a IDCMP_GADGETUP\n"));
	    else
		DP(("GT_FIM: Have a IDCMP_GADGETDOWN\n"));
#endif
	    /* Found a gadget event, identify the gadget: */
	    gad = (struct ExtGadget *) imsg->IAddress;
	}
	/* If we have a IDCMP_MOUSEMOVE/IDCMP_INTUITICKS, and there is an ActiveGadget: */
	else if ( ((imsg->Class == IDCMP_MOUSEMOVE)
                || (imsg->Class == IDCMP_INTUITICKS)
                || (imsg->Class == IDCMP_MOUSEBUTTONS)) &&
	    (ctgad) && (gad = CTID(ctgad)->ctid_ActiveGadget) )
	{
	    /* Since IDCMP_MOUSEMOVE's and IDCMP_INTUITICKS don't have the responsible
	     *	gadget in the IAddress field, we are sure to stuff the
	     *	address of the active gadget into our context instance
	     *	data, so that we can extract it here.
	     *	It would be NULL for a Window REPORTMOUSE-generated IDCMP_MOUSEMOVE,
	     *	or a regular IDCMP_INTUITICKS.
	     */
	    /* We have either a IDCMP_MOUSEMOVE or an IDCMP_INTUITICKS, and the gadget
	     * wants one or the other, or both.  If we have one that the
	     * gadget doesn't want, we don't want to send it a message:
	     */
	    if (((imsg->Class == IDCMP_MOUSEMOVE) &&
		(!(SGAD(gad)->sg_Flags & SG_MOUSEMOVE))) ||
		((imsg->Class == IDCMP_INTUITICKS) &&
		(!(SGAD(gad)->sg_Flags & SG_INTUITICKS))) ||
		((imsg->Class == IDCMP_MOUSEBUTTONS) &&
		(!(SGAD(gad)->sg_Flags & SG_MOUSEBUTTONS))))
	    {
		gad = NULL;
	    }
#ifdef DEBUGGING
	    if (imsg->Class == IDCMP_MOUSEMOVE)
		DP(("GT_FIM:  Have a Gadget IDCMP_MOUSEMOVE, gad $%lx\n",gad));
	    else
		DP(("GT_FIM:  Have a Gadget IDCMP_INTUITICKS, gad $%lx\n",gad));
#endif
	}
	D(if (gad)
	{
	    DP(("GT_FIM: GadgetID = $%lx, EventHandler = $%lx\n",
		gad->GadgetID, SGAD(gad)->sg_EventHandler));
	    DP(("GT_FIM: Activation = $%lx\n", gad->Activation));
	});

	/* Do we have a gadget, is it a toolkit gadget, and if so,
	 * does it have a handler?
	 */
	if ((gad) && (gad->GadgetType & GADTOOL_TYPE) &&
	    (SGAD(gad)->sg_EventHandler) )
	{
	    /* If this is a toolkit gadget that cares about IDCMP_MOUSEMOVE or
	     * IDCMP_INTUITICKS events, set or clear the context ActiveGadget
	     * upon IDCMP_GADGETDOWN or IDCMP_GADGETUP respectively:
	     */
	    if (SGAD(gad)->sg_Flags & (SG_MOUSEMOVE | SG_INTUITICKS | SG_MOUSEBUTTONS))
	    {
		if ((imsg->Class == IDCMP_GADGETUP)
                ||  ((imsg->Class == IDCMP_MOUSEBUTTONS) && (imsg->Code == SELECTUP)))
		{
		    DP(("GT_FIM:  Clearing active gadget\n"));
		    if (ctgad)
		    {
			CTID(ctgad)->ctid_ActiveGadget = NULL;
		    }
		}
		else if (imsg->Class == IDCMP_GADGETDOWN)
		{
		    DP(("GT_FIM:  Setting active gadget\n"));
		    if (ctgad)
		    {
			CTID(ctgad)->ctid_ActiveGadget = gad;
		    }
		}
	    }
	    DP(("GT_FIM: Calling handler at $%lx\n", SGAD(gad)->sg_EventHandler));
	    /* Handler returns TRUE if the message is to be passed down
	     * to the client, FALSE if it is to be eaten.  msgforclient
	     *	is this value:
	     */
	    msgforclient = (*SGAD(gad)->sg_EventHandler)(gad, (struct IntuiMessage *)quasi);
	    DP(("GT_FIM: Back from handler\n"));
	}
	else if ((imsg->Class == IDCMP_MOUSEBUTTONS) && (imsg->Code == SELECTUP))
	{
	    /* This is where boolean FOLLOWMOUSE gadgets get turned
	     * off if the user rolls off them and then releases the
	     * mouse:
	     */
	    if (ctgad)
	    {
		CTID(ctgad)->ctid_ActiveGadget = NULL;
	    }
	    msgforclient = TRUE;
	}
	else
	{
	    /* A class of message that the toolkit doesn't care about,
	     * so send it down to the client:
	     */
	    msgforclient = TRUE;
	}
    }

    if (msgforclient)
    {
	MP(("GT_FIM: Message of class $%lx, IAddress $%lx  for client\n",
	    quasi->qm_IMessage.Class, quasi->qm_IMessage.IAddress));
	return((struct IntuiMessage *)quasi);
    }
    else
    {
	/* Release the QuasiMessage */
	GT_PostFilterIMsg( (struct IntuiMessage *)quasi );

	DP(("GT_FIM: Returning Empty-handed\n"));
	return(NULL);
    }
}


/*------------------------------------------------------------------------*/

/****** gadtools.library/GT_PostFilterIMsg ***********************************
*
*   NAME
*	GT_PostFilterIMsg -- return the unfiltered message after
*	                     GT_FilterIMsg() was called, and clean up. (V36)
*
*   SYNOPSIS
*	imsg = GT_PostFilterIMsg(modimsg)
*	D0                       A1
*
*	struct IntuiMessage *GT_PostFilterIMsg(struct IntuiMessage *);
*
*   FUNCTION
*	NOTE WELL:  Extremely few programs will actually need this function.
*	You almost certainly should be using GT_GetIMsg() and GT_ReplyIMsg()
*	only, and not GT_FilterIMsg() and GT_PostFilterIMsg().
*
*	Performs any clean-up necessitated by a previous call to
*	GT_FilterIMsg().  The original IntuiMessage is now yours to handle.
*	Do not interpret the fields of the original IntuiMessage, but
*	rather use only the one you got from GT_FilterIMsg().  You
*	may only do message related things at this point, such as queueing
*	it up or replying it.  Since you got the message with
*	exec.library/GetMsg(), your responsibilities do include replying
*	it with exec.library/ReplyMsg(). This function may be safely
*	called with a NULL parameter.
*
*   INPUTS
*	modimsg - a modified IntuiMessage obtained with GT_FilterIMsg(),
*	          or NULL in which case this function does nothing and
*	          returns NULL
*
*   RESULT
*	imsg - a pointer to the original IntuiMessage, if GT_FilterIMsg()
*	       returned non-NULL.
*
*   NOTES
*	Be sure to use exec.library/ReplyMsg() on the original IntuiMessage
*	you obtained with GetMsg(), (which is the what you passed to
*	GT_FilterIMsg()), and not on the parameter of this function.
*
*	Starting with V39, this function actually expects and returns
*	pointers to ExtIntuiMessage structures, but the prototype was not
*	changed for source code compatibility with older software.
*
*   SEE ALSO
*	GT_FilterIMsg()
*
******************************************************************************
*
* Created:  09-Nov-89, Peter Cherna (from SpecialReplyMsg())
* Modified: 21-Nov-89, Peter Cherna
*
*/

struct IntuiMessage * ASM LIB_GT_PostFilterIMsg(REG(a1) struct IntuiMessage *imsg)
{
struct IntuiMessage *realimsg = NULL;
struct ExtGadget    *ctgad;

    if (imsg)
    {
	/* Extract original IntuiMessage */
	realimsg = ((struct QuasiMessage *)imsg)->qm_OrigMessage;
	/* Peter 16-May-91: The way to cancel MENUVERIFY is to
	 * change the Code field to MENUCANCEL.  Therefore,
	 * we need to copy the code field back to allow Intuition
	 * to hear it.
	 */
	realimsg->Code = imsg->Code;
	if ( ctgad = ((struct QuasiMessage *)imsg)->qm_ContextGadget )
	{
	    /* Mark the embedded QuasiMessage as not in use */
	    DP((" GT_PFIM:  Marking embedded quasi as unused\n"));
	    CTID(ctgad)->ctid_QuasiUsed = 0;
	    /* DelayedFree means that FreeGadgets() was called while
	     * a modified IntuiMessage was still unreplied.  The
	     * context gadget must be freed here and now.
	     */
	    if (CTID(ctgad)->ctid_DelayedFree)
	    {
		FreeVec(ctgad);
	    }
	}
	else
	{
	    /* This was an allocated QuasiMessage, so free it */
	    DP((" GT_PFIM:  FreeVec()ing quasi at $%lx\n", imsg));
	    FreeVec(imsg);
	}
    }

    return(realimsg);
}


/*------------------------------------------------------------------------*/

/****** gadtools.library/CreateContext ***************************************
*
*   NAME
*	CreateContext -- create a place for GadTools context data. (V36)
*
*   SYNOPSIS
*	gad = CreateContext(glistpointer);
*	D0                  A0
*
*	struct Gadget *CreateContext(struct Gadget **);
*
*   FUNCTION
*	Creates a place for GadTools to store any context data it might
*	need for your window.  In reality, an unselectable invisible
*	gadget is created, with room for the context data.
*	This function also establishes the linkage from a glist type
*	pointer to the individual gadget pointers.  Call this function
*	before any of the other gadget creation calls.
*
*   INPUTS
*	glistptr - address of a pointer to a Gadget, which was previously
*	           set to NULL.  When all the gadget creation is done, you may
*	           use that pointer as your NewWindow.FirstGadget, or
*	           in intuition.library/AddGList(),
*	           intuition.library/RefreshGList(), FreeGadgets(), etc.
*
*   RESULT
*	gad - pointer to context gadget, or NULL if failure.
*
*   EXAMPLE
*
*	struct Gadget *gad;
*	struct Gadget *glist = NULL;
*	gad = CreateContext(&glist);
*	\*  Other creation calls go here *\
*	if (gad)
*	{
*	    myNewWindow.FirstGadget = glist;
*	    if ( myWindow = OpenWindow(&myNewWindow) )
*	    {
*		GT_RefreshWindow(win,NULL);
*		\* other stuff *\
*		CloseWindow(myWindow);
*	    }
*	}
*	FreeGadgets(glist);
*
******************************************************************************
*
* Created:  08-Nov-89, Peter Cherna
* Modified: 20-Nov-89, Peter Cherna
*
*/

struct ExtGadget * ASM LIB_CreateContext(REG(a0) struct ExtGadget **glistptr)
{
struct ExtGadget *gad;
struct NewGadget  ng;

    if (glistptr)
    {
        memset(&ng, NULL, sizeof(struct NewGadget));

        /* !!! CreateGadgetA() requires a non-zero VisualInfo.  However, the
         * GENERIC_KIND gadget (when ng_GadgetText is NULL) MUST work
         * without referring to the VisualInfo if we expect to create
         * the context gadget with it.  So to fool it, we set a bogus
         * but non-zero value of VisualInfo, knowing it won't be needed
         * on the other side, but just to fool the middle-man !!!
         */
        ng.ng_VisualInfo = IGNORE_VISUALINFO;

        if (gad = CreateGenericBase((struct ExtGadget *)glistptr,&ng,CONTEXT_IDATA_SIZE,NULL))
        {
           gad->Flags = GFLG_GADGHNONE;
           SGAD(gad)->sg_Flags = SG_CONTEXT;
           return(gad);
        }
    }

    return(NULL);
}

/*------------------------------------------------------------------------*/

/****** gadtools.library/GT_SetGadgetAttrsA **********************************
*
*   NAME
*	GT_SetGadgetAttrsA -- change the attributes of a GadTools gadget. (V36)
*	GT_SetGadgetAttrs -- varargs stub for GT_SetGadgetAttrsA(). (V36)
*
*   SYNOPSIS
*	GT_SetGadgetAttrsA(gad, win, req, tagList)
*	                   A0   A1   A2   A3
*
*	VOID GT_SetGadgetAttrsA(struct Gadget *, struct Window *,
*	                        struct Requester *, struct TagItem *);
*
*	GT_SetGadgetAttrs(gad, win, req, firsttag, ...)
*
*	VOID GT_SetGadgetAttrs(struct Gadget *, struct Window *,
*	                       struct Requester *, Tag, ...);
*
*   FUNCTION
*	Change the attributes of the specified gadget, according to the
*	attributes chosen in the tag list. If an attribute is not provided
*	in the tag list, its value remains unchanged.
*
*   INPUTS
*	gad - pointer to the gadget in question. Starting with V39, this
*	      value may be NULL in which case this function does nothing
*	win - pointer to the window containing the gadget. Starting with V39,
*	      this value may be NULL in which case the internal attributes of
*	      the gadgets are altered but no rendering occurs.
*	req - reserved for future use, should always be NULL
*	tagList - pointer to an array of tags providing optional extra
*		  parameters, or NULL.
*
*   TAGS
*	BUTTON_KIND:
*	GA_Disabled (BOOL) - Set to TRUE to disable gadget, FALSE otherwise.
*	    (V36)
*
*	CHECKBOX_KIND:
*	GA_Disabled (BOOL) - Set to TRUE to disable gadget, FALSE otherwise.
*	    (V36)
*	GTCB_Checked (BOOL) - State of checkbox. (V36)
*
*	CYCLE_KIND:
*	GA_Disabled (BOOL) - Set to TRUE to disable gadget, FALSE otherwise
*	    (V37)
*	GTCY_Active (UWORD) - The ordinal number (counting from zero) of
*	    the active choice of a cycle gadget. (V36)
*	GTCY_Labels (STRPTR *) - Pointer to NULL-terminated array of strings
*	    that are the choices offered by the cycle gadget. (V37)
*
*	INTEGER_KIND:
*	GA_Disabled (BOOL) - Set to TRUE to disable gadget, FALSE otherwise
*	    (V36)
*	GTIN_Number (ULONG) - New value of the integer gadget (V36)
*
*	LISTVIEW_KIND:
*	GA_Disabled (BOOL) - Set to TRUE to disable gadget, FALSE otherwise
*	    (V39)
*	GTLV_Top (WORD) - Top item visible in the listview.  This value
*	    will be made reasonable if out-of-range. (V36)
*	GTLV_MakeVisible (WORD) - Number of an item that should be forced
*	    within the visible area of the listview by doing minimal scrolling.
*	    This tag overrides GTLV_Top. (V39)
*	GTLV_Labels (struct List *) - List of nodes whose ln_Name fields
*	    are to be displayed in the listview.  Use a value of ~0 to
*	    "detach" your List from the display.  You must detach your list
*	    before modifying the List structure, since GadTools reserves
*	    the right to traverse it on another task's schedule.  When you
*	    are done, attach the list by using the tag pair
*	    {GTLV_Labels, list}. (V36)
*	GTLV_Selected (UWORD) - Ordinal number of currently selected
*	    item. Starting with V39, you can provide ~0 to cause the currently
*	    selected item to be deselected. (V36)
*
*	MX_KIND:
*	GA_Disabled (BOOL) - Set to TRUE to disable gadget, FALSE otherwise
*	    (V39)
*	GTMX_Active (UWORD) - The ordinal number (counting from zero) of
*	    the active choice of an mx gadget. (V36)
*
*	NUMBER_KIND:
*	GTNM_Number (LONG) - A signed long integer to be displayed in
*	    the number gadget. (V36)
*	GTNM_FrontPen (UBYTE) - The pen to use when rendering the number. (V39)
*	GTNM_BackPen (UBYTE) - The pen to use when rendering the background
*	    of the number. (V39)
*	GTNM_Justification (UBYTE) - Determines how the number is rendered
*	    within the gadget box. GTJ_LEFT will make the rendering be
*	    flush with the left side of the gadget, GTJ_RIGHT will make it
*	    flush with the right side, and GTJ_CENTER will center the number
*	    within the gadget box. (V39)
*	GTNM_Format (STRPTR) - C-Style formatting string to apply on the number
*	    before display. Be sure to use the 'l' (long) modifier. This string
*	    is processed using exec.library/RawDoFmt(), so refer to that
*	    function for details. (V39)
*
*	PALETTE_KIND:
*	GA_Disabled (BOOL) - Set to TRUE to disable gadget, FALSE otherwise
*	    (V36)
*	GTPA_Color (UBYTE) - Selected color of the palette. This
*	    number is a pen number, and not the ordinal color number within
*	    the palette gadget itself. (V36)
*	GTPA_ColorOffset (UBYTE) - First color to use in palette (V39)
*	GTPA_ColorTable (UBYTE *) - Pointer to a table of pen numbers
*	    indicating  which colors should be used and edited by the palette
*	    gadget. This array must contain as many entries as there are
*	    colors displayed in the palette gadget. The array provided with
*	    this tag must remain valid for the life of the gadget or until a
*	    new table is provided. A NULL table pointer causes a 1-to-1
*	    mapping of pen numbers. (V39)
*
*	SCROLLER_KIND:
*	GA_Disabled (BOOL) - Set to TRUE to disable gadget, FALSE otherwise
*	    (V36)
*	GTSC_Top (WORD) - Top visible in scroller. (V36)
*	GTSC_Total (WORD) - Total in scroller area. (V36)
*	GTSC_Visible (WORD) - Number visible in scroller. (V36)
*
*	SLIDER_KIND:
*	GA_Disabled (BOOL) - Set to TRUE to disable gadget, FALSE otherwise
*	    (V36)
*	GTSL_Min (WORD) - Minimum level for slider. (V36)
*	GTSL_Max (WORD) - Maximum level for slider. (V36)
*	GTSL_Level (WORD) - Current level of slider. (V36)
*	GTSL_LevelFormat (STRPTR) - C-Style formatting string for slider
*	    level.  Be sure to use the 'l' (long) modifier.  This string
*	    is processed using exec.library/RawDoFmt(), so refer to that
*	    function for details. (V39)
*	GTSL_DispFunc ( LONG (*function)(struct Gadget *, WORD) ) - Function
*	    to calculate level to be displayed.  A number-of-colors slider
*	    might want to set the slider up to think depth, and have a
*	    (1 << n) function here.  Your function must
*	    take a pointer to gadget as the first parameter, the level
*	    (a WORD) as the second, and return the result as a LONG. (V39)
*	GTSL_Justification (UBYTE) - Determines how the level display is to
*	    be justified within its alotted space. Choose one of GTJ_LEFT,
*	    GTJ_RIGHT, or GTJ_CENTER. (V39)
*
*	STRING_KIND:
*	GA_Disabled (BOOL) - Set to TRUE to disable gadget, FALSE otherwise
*	    (V36)
*	GTST_String (STRPTR) - New contents of the string gadget,
*	    or NULL to reset the gadget to the empty state. (V36)
*
*	TEXT_KIND:
*	GTTX_Text - New NULL terminated string to be displayed in the text
*	    gadget. NULL means to clear the gadget. (V36)
*	GTTX_FrontPen (UBYTE) - The pen to use when rendering the text. (V39)
*	GTTX_BackPen (UBYTE) - The pen to use when rendering the background
*	    of the text. (V39)
*	GTTX_Justification (UBYTE) - Determines how the text is rendered
*	    within the gadget box. GTJ_LEFT will make the rendering be
*	    flush with the left side of the gadget, GTJ_RIGHT will make it
*	    flush with the right side, and GTJ_CENTER will center the text
*	    within the gadget box. (V39)
*
*   NOTES
*	This function may not be called inside of a GT_BeginRefresh() /
*	GT_EndRefresh() session.  (As always, restrict yourself to simple
*	rendering functions).
*
*   SEE ALSO
*	GT_GetGadgetAttrs()
*
******************************************************************************
*
* Created:   3-Dec-89, Peter Cherna
* Modified:  5-Dec-89, Peter Cherna
*
* NOTES
*	Since the requester parameter is not currently used, the actual
*	function does not define this parameter which makes the code
*	smaller.
*
*/

void __asm
LIB_GT_SetGadgetAttrsA( register __a0 struct ExtGadget *gad,
		        register __a1 struct Window *win,
		        register __a3 struct TagItem *taglist )
{
    DP(("GT_SGA:  Enter\n"));

    /* Is this a Toolkit gadget? */
    if (gad && gad->GadgetType & GADTOOL_TYPE)
    {
	DP(("GT_SGA:  Got a toolkit gadget\n"));
	/* Does it have a SetAttrs function? */
	if (SGAD(gad)->sg_SetAttrs)
	{
	    DP(("SetAttrs fcn at $%lx\n", SGAD(gad)->sg_SetAttrs));
	    /* Do it to it: */
	    (*SGAD(gad)->sg_SetAttrs)(gad, win, taglist);
	}
    }
    DP(("GT_SGA:  Exit\n"));
}


/*------------------------------------------------------------------------*/

/*/ FindContext()
 *
 * Returns pointer to the Context Instance Data, or NULL
 *
 * Created:  08-Nov-89, Peter Cherna
 * Modified:  8-Dec-89, Peter Cherna
 *
 */

static struct ExtGadget *FindContext(struct Window *win)
{
struct ExtGadget *gad;

    MP(("FC:  Enter for win $%lx\n", win));

    gad = (struct ExtGadget *)win->FirstGadget;
    while (gad)
    {
	if ((gad->GadgetType & GADTOOL_TYPE) && (SGAD(gad)->sg_Flags & SG_CONTEXT))
	    return(gad);

	gad = (struct ExtGadget *)gad->NextGadget;
    }

    return(NULL);
}


/*------------------------------------------------------------------------*/

/****** gadtools.library/GT_GetGadgetAttrsA **********************************
*
*   NAME
*	GT_GetGadgetAttrsA -- request the attributes of a GadTools gadget. (V39)
*	GT_GetGadgetAttrs -- varargs stub for GT_GetGadgetAttrsA(). (V39)
*
*   SYNOPSIS
*	numProcessed = GT_GetGadgetAttrsA(gad, win, req, taglist)
*	                                  A0   A1   A2   A3
*
*	LONG GT_GetGadgetAttrsA(struct Gadget *, struct Window *,
*	                        struct Requester *, struct TagItem *);
*
*	numProcessed = GT_GetGadgetAttrs(gad, win, req, firsttag, ...)
*
*	LONG GT_GetGadgetAttrs(struct Gadget *, struct Window *,
*                              struct Requester *, Tag, ...);
*
*   FUNCTION
*	Retrieve the attributes of the specified gadget, according to the
*	attributes chosen in the tag list.  For each entry in the tag list,
*	ti_Tag identifies the attribute, and ti_Data is a pointer to
*	the long variable where you wish the result to be stored.
*
*   INPUTS
*	gad - pointer to the gadget in question. May be NULL, in which case
*	      this function returns 0
*	win - pointer to the window containing the gadget.
*	req - reserved for future use, should always be NULL
*	taglist - pointer to TagItem list.
*
*   TAGS
*	BUTTON_KIND:
*	GA_Disabled (BOOL) - TRUE if this gadget is disabled,
*	    FALSE otherwise. (V39)
*
*	CHECKBOX_KIND:
*	GA_Disabled (BOOL) - TRUE if this gadget is disabled,
*	    FALSE otherwise. (V39)
*	GTCB_Checked (BOOL) - TRUE if this gadget is currently checked,
*	    FALSE otherwise. (V39)
*
*	CYCLE_KIND:
*	GA_Disabled (BOOL) - TRUE if this gadget is disabled,
*	    FALSE otherwise. (V39)
*	GTCY_Active (UWORD) - The ordinal number (counting from zero) of
*	    the active choice of a cycle gadget. (V39)
*	GTCY_Labels (STRPTR *) - The NULL-terminated array of strings
*	    that are the choices offered by the cycle gadget. (V39)
*
*	INTEGER_KIND:
*	GA_Disabled (BOOL) - TRUE if this gadget is disabled,
*	    FALSE otherwise. (V39)
*	GTIN_Number (ULONG) - The contents of the integer gadget. (V39)
*
*	LISTVIEW_KIND:
*	GA_Disabled (BOOL) - TRUE if this gadget is disabled,
*	    FALSE otherwise. (V39)
*	GTLV_Top (WORD) - Ordinal number of the top item visible
*	    in the listview. (V39)
*	GTLV_Labels (struct List *) - The list of nodes whose ln_Name fields
*	    are displayed in the listview. (V39)
*	GTLV_Selected (UWORD) - Ordinal number of currently selected
*	    item. Returns ~0 if no item is selected. (V39)
*
*	MX_KIND:
*	GA_Disabled (BOOL) - TRUE if this gadget is disabled,
*	    FALSE otherwise. (V39)
*	GTMX_Active (UWORD) - The ordinal number (counting from zero) of
*	    the active choice of an mx gadget. (V39)
*
*	NUMBER_KIND:
*	GTNM_Number - The signed long integer that is displayed in
*	    the read-only number. (V39)
*
*	PALETTE_KIND:
*	GA_Disabled (BOOL) - TRUE if this gadget is disabled,
*	    FALSE otherwise. (V39)
*	GTPA_Color (UBYTE) - The selected color of the palette. (V39)
*	GTPA_ColorOffset (UBYTE) - First color used in palette. (V39)
*	GTPA_ColorTable (UBYTE *) - Pointer to a table of pen numbers
*	    indicating  which colors should be used and edited by the palette
*	    gadget. May be NULL, which causes a 1-to-1 mapping of pen numbers.
*	    (V39)
*
*	SCROLLER_KIND:
*	GA_Disabled (BOOL) - TRUE if this gadget is disabled,
*	    FALSE otherwise. (V39)
*	GTSC_Top (WORD) - Top visible in scroller. (V39)
*	GTSC_Total (WORD) - Total in scroller area. (V39)
*	GTSC_Visible (WORD) - Number visible in scroller. (V39)
*
*	SLIDER_KIND:
*	GA_Disabled (BOOL) - TRUE if this gadget is disabled,
*	    FALSE otherwise. (V39)
*	GTSL_Min (WORD) - Minimum level for slider. (V39)
*	GTSL_Max (WORD) - Maximum level for slider. (V39)
*	GTSL_Level (WORD) - Current level of slider. (V39)
*
*	STRING_KIND:
*	GA_Disabled (BOOL) - TRUE if this gadget is disabled,
*	    FALSE otherwise. (V39)
*	GTST_String (STRPTR) - Returns a pointer to the string gadget's
*	    buffer. (V39)
*
*	TEXT_KIND:
*	GTTX_Text - Pointer to the string to be displayed in the
*	    read-only text-display gadget. (V39)
*
*   RESULT
*	numProcessed - the number of attributes successfully filled in.
*
*   EXAMPLE
*		long top = 0;
*		long selected = 0;
*		long result;
*		result = GT_GetGadgetAttrs( listview_gad, win, NULL,
*			GTLV_Top, &top,
*			GTLV_Selected, &selected,
*			TAG_DONE );
*		if ( result != 2 )
*		{
*			printf( "Something's wrong!" );
*		}
*
*   WARNING
*	The pointers you provide within the tag list to store the return
*	values MUST POINT TO LONGWORDS. That is, even if the type of a
*	return value is defined as (UWORD *), you must pass a pointer to
*	a longword of memory.
*
*   SEE ALSO
*	GT_SetGadgetAttrs()
*
******************************************************************************
*
* NOTES
*	Since the requester parameter is not currently used, the actual
*	function does not define this parameter which makes the code
*	smaller.
*
*/

LONG __asm
LIB_GT_GetGadgetAttrsA( register __a0 struct ExtGadget *gad,
		        register __a1 struct Window *win,
		        register __a3 struct TagItem *taglist )
{
    LONG result = 0;
    struct GetTable *table, *entry;
    struct TagItem *tstate = taglist;
    struct TagItem *ti;
    LONG attr;
    LONG done;

    DP(("GT_GGA:  Enter\n"));
    /* Is this a Toolkit gadget? */
    if (gad && gad->GadgetType & GADTOOL_TYPE)
    {
	/* Does it have a GetTable? */
	if ( table = SGAD(gad)->sg_GetTable )
	{
	    while ( ti = NextTagItem( &tstate ) )
	    {
		DP(("TagItem = {%lx,%lx}\n", ti->ti_Tag, ti->ti_Data));
		if ( ti->ti_Tag == GA_Disabled )
		{
		    DP(("  This is GA_Disabled!\n"));
		    attr = ATTR_DISABLED;
		}
		else
		{
		    attr = ti->ti_Tag - ((ULONG)GT_TagBase);
		}
		if ( attr > 0 )
		{
		    DP(("  attr = %lx, table at %lx\n", attr, table));
		    entry = table;
		    done = FALSE;
		    while ( !done )
		    {
			DP(("    entry %lx = (%lx,%lx)\n", entry, entry->gtab_tag, entry->gtab_descriptor));
			if ( attr == entry->gtab_tag )
			{
			    LONG answer, offset;

			    offset = REAL_OFFSET(entry->gtab_descriptor);
			    if ( attr == ATTR_DISABLED )
			    {
				struct ExtGadget *checkme = gad;
				DP(("    ** gadget = %lx\n", checkme ));
				if ( entry->gtab_descriptor )
				{
				    checkme = *((struct ExtGadget **) (((UBYTE *) gad) + offset));
				    DP(("    ** But checking gadget = %lx\n", checkme ));
				}
				answer = FALSE;
				if ( checkme->Flags & GFLG_DISABLED )
				{
				    answer = TRUE;
				}
			    }
			    else
			    {
				if ( entry->gtab_descriptor & LONG_ATTR )
				{
				    answer = *((LONG *) (((UBYTE *) gad) + offset));
				}
				else
				{
				    answer = *((WORD *) (((UBYTE *) gad) + offset));
				}
			    }
			    *((LONG *)ti->ti_Data) = answer;
			    result++;
			    DP(("    ** Matched: answer = %ld, result = %ld\n", answer,result));
			    done = TRUE;
			}
			/* Terminate on an ATTR_DISABLED or ATTR_END entry */
			if ( entry->gtab_tag >= ATTR_DISABLED )
			{
			    done = TRUE;
			}
			entry++;
		    }
		}
		D(else kprintf("Not GT: attr = %lx\n", attr ));
	    }
	}
    }
    DP(("GT_GGA:  Exit\n"));
    return( result );
}

/*------------------------------------------------------------------------*/

/* NOTE VERY WELL:
 *
 * The GETTABLE_ATTR() macro is designed to FAIL with a compiler error
 * should the offset in the instance data be too great to encode
 * in the table-format.  If this happens, just juggle the parameters
 * to nearer the top of the instance data.
 *
 * The current offset range is 0x7F words into the instance data,
 * so that should be good enough for a while.
 */
struct GetTable Button_GetTable[] =
{
    GETTABLE_DISABLED
};

struct GetTable Checkbox_GetTable[] =
{
    GETTABLE_ATTR(GTCB_Checked,	CBID, cbid_Checked,		WORD_ATTR),
    GETTABLE_DISABLED
};

struct GetTable Integer_GetTable[] =
{
    GETTABLE_ATTR(GTIN_Number,	STID, stid_StringInfo.LongInt,	LONG_ATTR),
    GETTABLE_DISABLED
};

struct GetTable Listview_GetTable[] =
{
    GETTABLE_ATTR(GTLV_Labels,	LVID, lvid_Labels,		LONG_ATTR),
    GETTABLE_ATTR(GTLV_Top,	LVID, lvid_Top,			WORD_ATTR),
    GETTABLE_ATTR(GTLV_Selected,LVID, lvid_Selected,		WORD_ATTR),
    GETTABLE_DISABLED_MEMBER(LVID, lvid_ListGad)
};

struct GetTable MX_GetTable[] =
{
    GETTABLE_ATTR(GTMX_Active,	MXID, mxid_Active,		WORD_ATTR),
    GETTABLE_DISABLED_MEMBER(MXID, mxid_FirstGadget)
};

struct GetTable Number_GetTable[] =
{
    GETTABLE_ATTR(GTNM_Number,	      NMID, nmid_Number,	 LONG_ATTR),
    GETTABLE_END
};

struct GetTable Cycle_GetTable[] =
{
    GETTABLE_ATTR(GTCY_Labels,	CYID, cyid_Labels,		LONG_ATTR),
    GETTABLE_ATTR(GTCY_Active,	CYID, cyid_Active,		WORD_ATTR),
    GETTABLE_DISABLED
};

struct GetTable Palette_GetTable[] =
{
    GETTABLE_ATTR(GTPA_Color,	    PAID, paid_Color,		WORD_ATTR),
    GETTABLE_ATTR(GTPA_ColorOffset, PAID, paid_ColorOffset,	WORD_ATTR),
    GETTABLE_ATTR(GTPA_ColorTable,  PAID, paid_ColorTable,	LONG_ATTR),
    GETTABLE_DISABLED
};

struct GetTable Scroller_GetTable[] =
{
    GETTABLE_ATTR(GTSC_Top,	SCID, scid_Top,			WORD_ATTR),
    GETTABLE_ATTR(GTSC_Total,	SCID, scid_Total,		WORD_ATTR),
    GETTABLE_ATTR(GTSC_Visible,	SCID, scid_Visible,		WORD_ATTR),
    GETTABLE_DISABLED_MEMBER(SCID, scid_Prop)
};

struct GetTable Slider_GetTable[] =
{
    GETTABLE_ATTR(GTSL_Min,	SLID, slid_Min,			WORD_ATTR),
    GETTABLE_ATTR(GTSL_Max,	SLID, slid_Max,			WORD_ATTR),
    GETTABLE_ATTR(GTSL_Level,	SLID, slid_Level,		WORD_ATTR),
    GETTABLE_DISABLED_MEMBER(SLID, slid_Prop)
};

struct GetTable String_GetTable[] =
{
    GETTABLE_ATTR(GTST_String,	STID, stid_StringInfo.Buffer,	LONG_ATTR),
    GETTABLE_DISABLED
};

struct GetTable Text_GetTable[] =
{
    GETTABLE_ATTR(GTTX_Text,	      TXID, txid_IText.IText,	 LONG_ATTR),
    GETTABLE_END
};

/*------------------------------------------------------------------------*/

@


39.17
log
@*** empty log message ***
@
text
@d7 1
a7 1
*   $Id: dispatch.c,v 39.16 92/11/20 10:46:01 vertex Exp Locker: vertex $
d92 1
a92 1
*	As of V39, this function actually returns a pointer to an
d161 1
a161 1
*	As of V39, this function actually expects a pointer to an
d410 3
a412 3
*	As of V39, this function actually expects and returns pointers to
*	ExtIntuiMessage structures, but the prototype was not changed for
*	source code compatibility with older software.
d650 3
a652 3
*	As of V39, this function actually expects and returns pointers to
*	ExtIntuiMessage structures, but the prototype was not changed for
*	source code compatibility with older software.
d816 5
a820 5
*	gad - pointer to the gadget in question. As of V39 this value may
*	      be NULL in which case this function does nothing
*	win - pointer to the window containing the gadget. As of V39 this value
*	      may be NULL in which case the internal attributes of the
*	      gadgets are altered but no rendering occurs.
d886 2
a887 2
*	    is processed using exec/RawDoFmt(), so refer to that function
*	    for details. (V39)
d919 2
a920 2
*	    is processed using exec/RawDoFmt(), so refer to that function
*	    for details. (V39)
@


39.16
log
@Autodoc clarification
@
text
@d7 1
a7 1
*   $Id: dispatch.c,v 39.15 92/10/16 18:30:03 vertex Exp Locker: vertex $
d856 1
a856 1
*	GTLV_Labels (struct List *) - List of labels whose ln_Name fields
d1084 1
a1084 1
*	GTLV_Labels (struct List *) - The list whose ln_Name fields
@


39.15
log
@Autodoc changes
@
text
@d7 1
a7 1
*   $Id: dispatch.c,v 39.14 92/07/31 19:22:49 vertex Exp Locker: vertex $
d1148 6
@


39.14
log
@deleteold
Cleared up autodoc for GT_FilterIMsg()
@
text
@d7 1
a7 1
*   $Id: dispatch.c,v 39.13 92/07/16 11:01:12 vertex Exp Locker: vertex $
d209 1
a209 1
    gad = win->FirstGadget;
d226 1
a226 1
        gad = gad->NextGadget;
d852 1
a852 1
*	    will be made reasonable if out-of-range (defaults to zero). (V36)
d892 3
a894 1
*	GTPA_Color (UBYTE) - Selected color of the palette. (V36)
d899 4
a902 2
*	    colors displayed in the palette gadget. (default is NULL, which
*	    causes a 1-to-1 mapping of pen numbers). (V39)
d1009 1
a1009 1
    gad = win->FirstGadget;
d1015 1
a1015 1
	gad = gad->NextGadget;
d1097 1
a1097 1
*	    the read-only number (default 0). (V39)
@


39.13
log
@*** empty log message ***
@
text
@d7 1
a7 1
*   $Id: dispatch.c,v 39.12 92/06/04 12:32:58 vertex Exp Locker: vertex $
d393 1
d397 1
d406 2
a407 1
*	          from GadTools, or NULL.
d413 6
@


39.12
log
@Removed GTPA_NumColors from the GT_SetGadgetAttrs() autodoc
@
text
@d7 1
a7 1
*   $Id: dispatch.c,v 39.11 92/05/29 15:50:12 vertex Exp Locker: vertex $
d738 1
a738 1
*		GT_RefreshWindow(win);
@


39.11
log
@Fixed autodocs concerning requester support
@
text
@d7 1
a7 1
*   $Id: dispatch.c,v 39.10 92/05/29 15:43:41 vertex Exp Locker: vertex $
a889 3
*	GTPA_NumColors (UWORD) - Number of colors to display in the palette
*	    gadget. This override GTPA_Depth and allows numbers which aren't
*	    powers of 2. (defaults to 2) (V39)
@


39.10
log
@Code optimizations
Removed requester support
Added support for sending MOUSEBUTTONS down to an event handler, in support
  of the new listview code
@
text
@d7 1
a7 1
*   $Id: dispatch.c,v 39.9 92/04/15 11:41:32 vertex Exp Locker: vertex $
d254 1
a254 2
*	req - pointer to the Requester containing the gadgets, or NULL if
*	      the gadgets are in a window. Requester support is new for V39.
d812 1
a812 2
*	req - pointer to the requester containing the gadget, or NULL if
*	      not in a requester. Requester support is new for V39.
d1042 1
a1042 2
*	req - pointer to the requester containing the gadget, or NULL if
*	      not in a requester. Requester support is new for V39.
@


39.9
log
@Fully implemented gadget help
Optimized code for space
@
text
@d7 1
a7 1
*   $Id: dispatch.c,v 39.8 92/04/13 14:09:38 vertex Exp Locker: vertex $
d27 1
a27 2
LIB_GT_RefreshWindow (register __a0 struct Window *win,
		     register __a1 struct Requester *req);
d43 1
a43 1
LIB_GT_SetGadgetAttrsA (register __a0 struct Gadget *gad,
a44 1
		       register __a2 struct Requester *req,
d47 2
a48 2
struct Gadget * __asm
LIB_CreateContext (register __a0 struct Gadget **glistptr);
d51 2
a52 2
static struct Gadget *FindContext (struct Window *win);
static void WalkRefreshGadgets (struct Window *win, struct Requester *req, BOOL refresh);
d106 1
a106 2
struct IntuiMessage * __asm
LIB_GT_GetIMsg( register __a0 struct MsgPort *iport )
d108 2
a109 2
    struct IntuiMessage *clientmsg = NULL;
    struct IntuiMessage *imsg;
d114 1
a114 1
    while ((!clientmsg) && (imsg = (struct IntuiMessage *)GetMsg(iport)))
d116 2
a117 2
	DP(("GT_GM: Win $%lx, have imsg of class $%lx, IAddress $%lx\n",
	    imsg->IDCMPWindow, imsg->Class, imsg->IAddress));
d119 7
a125 13
	clientmsg = GT_FilterIMsg((struct IntuiMessage *)imsg);
	if (!clientmsg)
	{
	    /* Message was eaten, so ReplyMsg() it and get another one
	     * if available
	     */
	    MP(("GT_GM: Replying message since not for client\n"));
	    ReplyMsg((struct Message *)imsg);
	}
	D(else
	{
	    MP(("GT_GM: Got something for the client\n"));
	});
d128 1
a128 1
    return(clientmsg);
d153 2
a154 1
*	imsg - a modified IntuiMessage obtained with GT_GetIMsg().
d175 1
a175 2
void __asm
LIB_GT_ReplyIMsg( register __a1 struct IntuiMessage *imsg )
d180 1
a180 2
	imsg = GT_PostFilterIMsg(imsg);
	ReplyMsg((struct Message *)imsg);
d187 45
d255 1
a255 1
*	      the gadgets are in a window.
d265 4
d271 1
a271 3
void __asm
LIB_GT_RefreshWindow( register __a0 struct Window *win,
		      register __a1 struct Requester *req )
d274 1
a274 1
    WalkRefreshGadgets(win, req, FALSE);
d321 1
a321 2
void __asm
LIB_GT_BeginRefresh( register __a0 struct Window *win )
d324 1
a324 1
    WalkRefreshGadgets(win, NULL, TRUE);
d363 1
a363 3
void __asm
LIB_GT_EndRefresh( register __a0 struct Window *win,
		   register __d0 BOOL complete )
d428 1
a428 2
struct IntuiMessage * __asm
LIB_GT_FilterIMsg( register __a1 struct IntuiMessage *imsg )
d430 6
a435 6
    struct Gadget *gad;
    struct QuasiMessage *quasi;
    /* Pointer to context data, which contains active gadget. */
    struct Gadget *ctgad;
    /* Assume we're eating this message, until proven otherwise: */
    BOOL msgforclient = FALSE;
d452 1
a452 1
	/* If the context IData can't be found, or the embeddedd
d481 1
a481 1
	    gad = (struct Gadget *) imsg->IAddress;
d483 4
a486 2
	/* If we have a MOUSEMOVE/INTUITICKS, and there is an ActiveGadget: */
	else if ( ((imsg->Class == MOUSEMOVE) || (imsg->Class == INTUITICKS)) &&
d489 1
a489 1
	    /* Since MOUSEMOVE's and INTUITICKS don't have the responsible
d493 2
a494 2
	     *	It would be NULL for a Window REPORTMOUSE-generated MOUSEMOVE,
	     *	or a regular INTUITICKS.
d496 1
a496 1
	    /* We have either a MOUSEMOVE or an INTUITICKS, and the gadget
d500 1
a500 1
	    if (((imsg->Class == MOUSEMOVE) &&
d502 4
a505 2
		((imsg->Class == INTUITICKS) &&
		(!(SGAD(gad)->sg_Flags & SG_INTUITICKS))))
d510 2
a511 2
	    if (imsg->Class == MOUSEMOVE)
		DP(("GT_FIM:  Have a Gadget MOUSEMOVE, gad $%lx\n",gad));
d513 1
a513 1
		DP(("GT_FIM:  Have a Gadget INTUITICKS, gad $%lx\n",gad));
d529 3
a531 3
	    /* If this is a toolkit gadget that cares about MOUSEMOVE or
	     * INTUITICKS events, set or clear the context ActiveGadget
	     * upon GADGETDOWN or GADGETUP respectively:
d533 1
a533 1
	    if (SGAD(gad)->sg_Flags & (SG_MOUSEMOVE | SG_INTUITICKS))
d535 2
a536 1
		if (imsg->Class == IDCMP_GADGETUP)
d561 1
a561 1
	else if ((imsg->Class == MOUSEBUTTONS) && (imsg->Code == SELECTUP))
d629 3
a631 1
*	modimsg - a modified IntuiMessage obtained with GT_FilterIMsg().
d656 1
a656 2
struct IntuiMessage *__asm
LIB_GT_PostFilterIMsg( register __a1 struct IntuiMessage *imsg )
d658 2
a659 2
    struct IntuiMessage *realimsg = NULL;
    struct Gadget *ctgad;
a698 69
/*/ WalkRefreshGadgets()
 *
 * Function to walk a window's gadget list and do all the special
 * refresh for the toolkit gadgets.  The boolean parameter tells
 * whether the refresh functions are expected to do Begin/EndRefresh()
 *
 * Notes:  When we go with custom gadgets, this function won't
 * be necessary, since our gadgets will have the same powers of
 * refresh as regular gadgets.
 *
 * Created:  17-Oct-89, Peter Cherna
 * Modified: 17-Nov-89, Peter Cherna
 *
 */

static void WalkRefreshGadgets( struct Window *win, struct Requester *req,
                               BOOL refresh )
{
struct Gadget *gad;
BOOL           onlyOne;

    /* Walk the list of gadgets in the supplied window: */
    /* also walk through gadgets in all requesters if (req == NULL) */

    if (!req)
    {
        req = win->FirstRequest;
        onlyOne = FALSE;
    }
    else
    {
        onlyOne = TRUE;
    }

    while (TRUE)
    {
        if (req)
            gad = req->ReqGadget;
        else
            gad = win->FirstGadget;

        while (gad)
        {
            MP(("GT_RW:  gadget at $%lx", gad));
            /* Is this a Toolkit gadget? */
            if (gad->GadgetType & GADTOOL_TYPE)
            {
                MP((" is a toolkit gadget"));
                /* Does it have a refresh function? */
                if (SGAD(gad)->sg_Refresh)
                {
                    MP((", refresh fcn at $%lx\n", SGAD(gad)->sg_Refresh));
                    /* Do the refresh: */
                    (*SGAD(gad)->sg_Refresh)(gad, win, refresh);
                }
            }
            MP(("\n"));
            gad = gad->NextGadget;
        }

        if (req && !onlyOne)
            req = req->OlderRequest;
        else
            break;
    }
}

/*------------------------------------------------------------------------*/

d753 1
a753 2
struct Gadget * __asm
LIB_CreateContext( register __a0 struct Gadget **glistptr )
d755 2
a756 12
    struct Gadget *gad;
    struct NewGadget ng;

    DP(("CC:  Enter, glistptr = $%lx\n", glistptr));

    /* Clear the structure */
    memset(&ng, NULL, sizeof(struct NewGadget));
    if (!glistptr)
    {
	DP(("CC:  Aborting on account of NULL glistptr\n"));
	return(NULL);
    }
d758 12
a769 8
    /* !!! CreateGadgetA() requires a non-zero VisualInfo.  However, the
     * GENERIC_KIND gadget (when ng_GadgetText is NULL) MUST work
     * without referring to the VisualInfo if we expect to create
     * the context gadget with it.  So to fool it, we set a bogus
     * but non-zero value of VisualInfo, knowing it won't be needed
     * on the other side, but just to fool the middle-man !!!
     */
    ng.ng_VisualInfo = IGNORE_VISUALINFO;
d771 5
a775 6
    gad = CreateGenericBase( (struct Gadget *)glistptr, &ng,
	CONTEXT_IDATA_SIZE, NULL );
    if (!gad)
    {
	DP(("CC:  Aborting on account of CG failure\n"));
    	return(NULL);
d777 3
a779 5
    DP(("GT_CC:  Context Gadget at $%lx\n", gad));
    gad->Flags = GADGHNONE;
    /* This is the Context gadget: */
    SGAD(gad)->sg_Flags = SG_CONTEXT;
    return(gad);
d808 5
a812 2
*	gad - pointer to the gadget in question.
*	win - pointer to the window containing the gadget.
d814 1
a814 1
*	      not in a requester.
d842 2
d857 2
a858 1
*	    item. (V36)
d954 5
d962 1
a962 1
LIB_GT_SetGadgetAttrsA( register __a0 struct Gadget *gad,
a963 1
		        register __a2 struct Requester *req,
d967 1
d969 1
a969 1
    if (gad->GadgetType & GADTOOL_TYPE)
d977 1
a977 1
	    (*SGAD(gad)->sg_SetAttrs)(gad, win, req, taglist);
d995 1
a995 1
static struct Gadget *FindContext( struct Window *win )
d997 1
a997 2
    struct Gadget *gad;
    struct Gadget *ctgad = NULL;
d1000 1
d1004 4
a1007 10
	if ((gad->GadgetType & GADTOOL_TYPE) &&
	(SGAD(gad)->sg_Flags & SG_CONTEXT))
	{
	    ctgad = gad;
	    gad = NULL;
	}
	else
	{
	    gad = gad->NextGadget;
	}
d1010 1
a1010 2
    MP(("FC:  Context Gad at $%lx\n", ctgad));
    return( ctgad );
d1041 2
a1042 1
*	gad - pointer to the gadget in question.
d1045 1
a1045 1
*	      not in a requester.
d1073 2
d1080 1
a1080 1
*	    item. (V39)
d1146 6
d1155 1
a1155 1
LIB_GT_GetGadgetAttrsA( register __a0 struct Gadget *gad,
a1156 1
		        register __a2 struct Requester *req,
d1168 1
a1168 1
    if (gad->GadgetType & GADTOOL_TYPE)
d1200 1
a1200 1
				struct Gadget *checkme = gad;
d1204 1
a1204 1
				    checkme = *((struct Gadget **) (((UBYTE *) gad) + offset));
d1279 1
a1279 1
    GETTABLE_END
@


39.8
log
@Changed autodocs to mention ExtIntuiMessage where appropriate
Added requester support
@
text
@d7 1
a7 1
*   $Id: dispatch.c,v 39.7 92/04/07 13:59:13 vertex Exp $
d374 1
a374 1
*	As of V39, this function actually expects and returns pointers to a
d439 1
a439 1
	if ((imsg->Class == GADGETUP) || (imsg->Class == GADGETDOWN))
d442 2
a443 2
	    if (imsg->Class == GADGETUP)
		DP(("GT_FIM: Have a GADGETUP\n"));
d445 1
a445 1
		DP(("GT_FIM: Have a GADGETDOWN\n"));
d498 1
a498 1
		if (imsg->Class == GADGETUP)
d506 1
a506 1
		else if (imsg->Class == GADGETDOWN)
d765 1
a765 1
*    {
d768 1
a768 1
*	{
d772 1
a773 1
*    }
d902 1
a902 1
*	     the number gadget. (V36)
d911 2
a912 2
*	GTNM_Format (STRPTR) - C-Style formatting string to apply on the number before
*	    display. Be sure to use the 'l' (long) modifier. This string
d1123 1
a1123 1
*	     the read-only number (default 0). (V39)
d1153 1
a1153 1
*	     buffer. (V39)
@


39.7
log
@Added GA_Disabled support for MX_KIND GetTable

..
@
text
@d7 1
a7 1
*   $Id: dispatch.c,v 39.6 92/03/24 15:27:54 peter Exp Locker: vertex $
d54 1
a54 1
static void WalkRefreshGadgets (struct Window *win, BOOL refresh);
d94 4
d122 1
a122 1
	clientmsg = GT_FilterIMsg(imsg);
d169 4
d218 3
a220 7
*	win - Pointer to the Window containing GadTools gadgets.
*	req - Pointer to requester, or NULL if not a requester (currently
*	      ignored - use NULL).
*
*   NOTES
*	req must currently be NULL.  GadTools gadgets are not supported
*	in requesters.  This field may allow such support at a future date.
d237 1
a237 1
    WalkRefreshGadgets(win, FALSE);
d288 1
a288 1
    WalkRefreshGadgets(win, TRUE);
d373 5
d434 1
a434 1
	quasi->qm_IMessage = *imsg;
d602 4
d675 2
a676 1
static void WalkRefreshGadgets( struct Window *win, BOOL refresh )
d678 2
a679 1
    struct Gadget *gad;
d682 13
a694 2
    gad = win->FirstGadget;
    while (gad)
d696 28
a723 15
	MP(("GT_RW:  gadget at $%lx", gad));
	/* Is this a Toolkit gadget? */
	if (gad->GadgetType & GADTOOL_TYPE)
	{
	    MP((" is a toolkit gadget"));
	    /* Does it have a refresh function? */
	    if (SGAD(gad)->sg_Refresh)
	    {
		MP((", refresh fcn at $%lx\n", SGAD(gad)->sg_Refresh));
		/* Do the refresh: */
		(*SGAD(gad)->sg_Refresh)(win, gad, refresh);
	    }
	}
	MP(("\n"));
	gad = gad->NextGadget;
d851 1
a851 1
*	      not in a requester.  (Not yet implemented, use NULL).
d920 9
a975 3
*	req must currently be NULL.  GadTools gadgets are not supported
*	in requesters.  This field may allow such support at a future date.
*
d1080 1
a1080 1
*	      not in a requester.  (Not yet implemented, use NULL).
d1129 5
a1174 4
*   NOTES
*	req must currently be NULL.  GadTools gadgets are not supported
*	in requesters.  This field may allow such support at a future date.
*
d1331 3
a1333 1
    GETTABLE_ATTR(GTPA_Color,	PAID, paid_Color,		WORD_ATTR),
@


39.6
log
@Added comment about table-generation macro.
@
text
@d7 1
a7 1
*   $Id: dispatch.c,v 39.5 92/03/24 15:14:02 peter Exp Locker: peter $
d53 2
a54 2
struct Gadget *FindContext (struct Window *win);
void WalkRefreshGadgets (struct Window *win, BOOL refresh);
d61 1
a61 1
*	GT_GetIMsg -- Get an IntuiMessage, with GadTools processing. (V36)
d80 2
a81 2
*	intuiport - The Window->UserPort of a window that is using the
*	    Gadget Toolkit.
d84 2
a85 2
*	imsg - Pointer to modified IntuiMessage, or NULL if there are
*	    no applicable messages.
a86 2
*   EXAMPLE
*
a93 2
*   BUGS
*
d142 1
a142 1
*	GT_ReplyIMsg -- Reply a message obtained with GT_GetIMsg(). (V36)
d158 1
a158 6
*	imsg - A modified IntuiMessage obtained with GT_GetIMsg().
*
*   RESULT
*	None.
*
*   EXAMPLE
a164 2
*   BUGS
*
d192 1
a192 1
*	GT_RefreshWindow -- Refresh all the GadTools gadgets. (V36)
d212 1
a212 1
*	    ignored - use NULL).
a213 5
*   RESULT
*	None.
*
*   EXAMPLE
*
a217 2
*   BUGS
*
d242 1
a242 1
*	GT_BeginRefresh -- Begin refreshing friendly to GadTools. (V36)
d257 2
a258 5
*	win - Pointer to Window structure for which a IDCMP_REFRESHWINDOW
*	    IDCMP event was received.
*
*   RESULT
*	None.
a259 2
*   EXAMPLE
*
a269 2
*   BUGS
*
d293 1
a293 1
*	GT_EndRefresh -- End refreshing friendly to GadTools. (V36)
d309 2
a310 2
*	win - Pointer to Window structure for which a IDCMP_REFRESHWINDOW
*	    IDCMP event was received.
a312 9
*   RESULT
*	None.
*
*   EXAMPLE
*
*   NOTES
*
*   BUGS
*
d338 1
a338 1
*	GT_FilterIMsg -- Filter an IntuiMessage through GadTools. (V36)
d363 1
a363 1
*	imsg - An IntuiMessage you obtained from a Window's UserPort.
d366 2
a367 6
*	modimsg - A modified IntuiMessage, possibly with extra information
*	    from GadTools, or NULL.
*
*   EXAMPLE
*
*   NOTES
a368 2
*   BUGS
*
d429 1
a429 1
	
d557 2
a558 2
*	GT_PostFilterIMsg -- Return the unfiltered message after
*	    GT_FilterIMsg() was called, and clean up. (V36)
d582 1
a582 1
*	modimsg - A modified IntuiMessage obtained with GT_FilterIMsg().
d585 2
a586 4
*	imsg - A pointer to the original IntuiMessage, if GT_FilterIMsg()
*	    returned non-NULL.
*
*   EXAMPLE
a592 2
*   BUGS
*
d662 1
a662 1
void WalkRefreshGadgets( struct Window *win, BOOL refresh )
d693 1
a693 1
*	CreateContext -- Create a place for GadTools context data. (V36)
d710 6
a715 6
*	glistptr - Address of a pointer to a Gadget, which was previously
*	    set to NULL.  When all the gadget creation is done, you may
*	    use that pointer as your NewWindow.FirstGadget, or
*	    in intuition.library/AddGList(), intuition.library/RefreshGList(),
*	    FreeGadgets(), etc.
*
d717 1
a717 1
*	gad - Pointer to context gadget, or NULL if failure.
a736 6
*   NOTES
*
*   BUGS
*
*   SEE ALSO
*
d767 1
a767 1
    ng.ng_VisualInfo = (void *)~0;
d788 2
a789 2
*	GT_SetGadgetAttrsA -- Change the attributes of a GadTools gadget. (V36)
*	GT_SetGadgetAttrs -- Varargs stub for GT_SetGadgetAttrsA(). (V36)
d792 1
a792 1
*	GT_SetGadgetAttrsA(gad, win, req, taglist)
d796 1
a796 1
*	    struct Requester *, struct TagItem *);
d801 1
a801 1
*	    struct Requester *, Tag, ...);
d805 2
a806 1
*	attributes chosen in the tag list.
d809 6
a814 5
*	gad - Pointer to the gadget in question.
*	win - Pointer to the window containing the gadget.
*	req - Pointer to the requester containing the gadget, or NULL if
*	    not in a requester.  (Not yet implemented, use NULL).
*	taglist - Pointer to TagItem list.
d818 2
a819 2
*	GA_Disabled (BOOL) - Set to TRUE to disable gadget, FALSE otherwise
*	    (defaults to FALSE).
d822 3
a824 3
*	GTCB_Checked (BOOL) - Initial state of checkbox, defaults to FALSE.
*	GA_Disabled (BOOL) - Set to TRUE to disable gadget, FALSE otherwise
*	    (defaults to FALSE).
d827 2
d830 3
a832 7
*	    the active choice of a cycle gadget (defaults to zero).
*	GTCY_Labels (STRPTR *) - (GadTools V37 and higher only)
*	    Pointer to NULL-terminated array of strings
*	    that are the choices offered by the cycle gadget.
*	GA_Disabled (BOOL) - (GadTools V37 and higher only)
*	    Set to TRUE to disable gadget, FALSE otherwise
*	    (defaults to FALSE).
a834 2
*	GTIN_Number (ULONG) - The initial contents of the integer gadget
*	    (default zero).
d836 2
a837 1
*	    (defaults to FALSE).
d841 4
a844 1
*	    will be made reasonable if out-of-range (defaults to zero).
d851 1
a851 1
*	    {GTLV_Labels, list}.
d853 1
a853 1
*	    item (defaults to zero if GTLV_ShowSelected is set).
d856 2
d859 1
a859 1
*	    the active choice of an mx gadget (Defaults to zero).
d862 14
a875 2
*	GTNM_Number - A signed long integer to be displayed as a read-only
*	     number (default 0).
a877 2
*	GTPA_Color (UBYTE) - Initially selected color of the palette
*	    (defaults to 1).
d879 2
a880 1
*	    (defaults to FALSE).
a882 3
*	GTSC_Top (WORD) - Top visible in scroller (defaults to zero).
*	GTSC_Total (WORD) - Total in scroller area (defaults to zero).
*	GTSC_Visible (WORD) - Number visible in scroller (defaults to 2).
d884 4
a887 1
*	    (defaults to FALSE).
a889 3
*	GTSL_Min (WORD) - Minimum level for slider (default 0).
*	GTSL_Max (WORD) - Maximum level for slider (default 15).
*	GTSL_Level (WORD) - Current level of slider (default 0).
d891 17
a907 1
*	    (defaults to FALSE).
a909 2
*	GTST_String (STRPTR) - The initial contents of the string gadget,
*	     or NULL (default) if string is to start empty.
d911 3
a913 1
*	    (defaults to FALSE).
d916 10
a925 7
*	GTTX_Text - Pointer to a NULL terminated string to be displayed,
*	    as a read-only text-display gadget, or NULL. defaults to NULL.
*
*   RESULT
*	None.
*
*   EXAMPLE
a934 2
*   BUGS
*
d936 1
d966 1
a966 1
    
d979 1
a979 1
struct Gadget *FindContext( struct Window *win )
d1010 2
a1011 2
*	GT_GetGadgetAttrsA -- Request the attributes of a GadTools gadget. (V39)
*	GT_GetGadgetAttrs -- Varargs stub for GT_GetGadgetAttrsA(). (V39)
d1014 2
a1015 2
*	result = GT_GetGadgetAttrsA(gad, win, req, taglist)
*	                            A0   A1   A2   A3
d1018 1
a1018 1
*	    struct Requester *, struct TagItem *);
d1020 1
a1020 1
*	result = GT_GetGadgetAttrs(gad, win, req, firsttag, ...)
d1023 1
a1023 1
*	    struct Requester *, Tag, ...);
d1032 5
a1036 5
*	gad - Pointer to the gadget in question.
*	win - Pointer to the window containing the gadget.
*	req - Pointer to the requester containing the gadget, or NULL if
*	    not in a requester.  (Not yet implemented, use NULL).
*	taglist - Pointer to TagItem list.
a1037 2
*   RESULT
*	
d1041 1
a1041 1
*	    FALSE otherwise.
a1043 1
*	GTCB_Checked (BOOL) - Checked state of checkbox.
d1045 3
a1047 1
*	    FALSE otherwise.
d1050 2
d1053 1
a1053 1
*	    the active choice of a cycle gadget.
d1055 1
a1055 3
*	    that are the choices offered by the cycle gadget.
*	GA_Disabled (BOOL) - TRUE if this gadget is disabled,
*	    FALSE otherwise.
a1057 1
*	GTIN_Number (ULONG) - The contents of the integer gadget.
d1059 2
a1060 1
*	    FALSE otherwise.
d1064 1
a1064 1
*	    in the listview.
d1066 1
a1066 1
*	    are displayed in the listview.
d1068 1
a1068 1
*	    item.
d1071 2
d1074 1
a1074 1
*	    the active choice of an mx gadget.
d1078 1
a1078 1
*	     the read-only number (default 0).
a1080 1
*	GTPA_Color (UBYTE) - The selected color of the palette.
d1082 2
a1083 1
*	    FALSE otherwise.
a1085 3
*	GTSC_Top (WORD) - Top visible in scroller.
*	GTSC_Total (WORD) - Total in scroller area.
*	GTSC_Visible (WORD) - Number visible in scroller.
d1087 4
a1090 1
*	    FALSE otherwise.
a1092 3
*	GTSL_Min (WORD) - Minimum level for slider.
*	GTSL_Max (WORD) - Maximum level for slider.
*	GTSL_Level (WORD) - Current level of slider.
d1094 4
a1097 1
*	    FALSE otherwise.
d1100 2
d1103 1
a1103 3
*	     buffer.
*	GA_Disabled (BOOL) - TRUE if this gadget is disabled,
*	    FALSE otherwise.
d1107 1
a1107 1
*	    read-only text-display gadget.
d1110 1
a1110 2
*	The result will be the number of attributes successfully
*	filled in.
a1128 2
*   BUGS
*
d1130 1
d1241 1
a1241 1
    GETTABLE_DISABLED,
d1247 1
a1247 1
    GETTABLE_DISABLED,
d1253 1
a1253 1
    GETTABLE_DISABLED,
d1260 2
a1261 2
    GETTABLE_ATTR(GTLV_Selected,	LVID, lvid_Selected,		WORD_ATTR),
    GETTABLE_END,
d1267 1
a1267 1
    GETTABLE_END,
d1272 2
a1273 2
    GETTABLE_ATTR(GTNM_Number,	NMID, nmid_Number,		LONG_ATTR),
    GETTABLE_END,
d1280 1
a1280 1
    GETTABLE_DISABLED,
d1286 1
a1286 1
    GETTABLE_DISABLED,
d1294 1
a1294 1
    GETTABLE_DISABLED_MEMBER(SCID, scid_Prop),
d1302 1
a1302 1
    GETTABLE_DISABLED_MEMBER(SLID, slid_Prop),
d1308 1
a1308 1
    GETTABLE_DISABLED,
d1313 2
a1314 2
    GETTABLE_ATTR(GTTX_Text,	TXID, txid_IText.IText,		LONG_ATTR),
    GETTABLE_END,
@


39.5
log
@Added GT_GetGadgetAttrs() call and get-attribute tables.
@
text
@d7 1
a7 1
*   $Id: dispatch.c,v 39.4 92/02/20 13:56:41 peter Exp Locker: peter $
d1250 10
@


39.4
log
@No need to OR stuff into sg_Flags.
@
text
@d7 1
a7 1
*   $Id: dispatch.c,v 39.3 92/02/20 11:49:49 peter Exp Locker: peter $
d1026 304
@


39.3
log
@Now use SGAD() instead of SG_FROM_GAD().
@
text
@d7 1
a7 1
*   $Id: dispatch.c,v 39.2 92/02/03 15:47:35 peter Exp Locker: peter $
d829 1
a829 1
    SGAD(gad)->sg_Flags |= SG_CONTEXT;
@


39.2
log
@Removed kludge to avoid CXERR.  Now use CreateGenericBase() here too.
@
text
@d7 1
a7 1
*   $Id: dispatch.c,v 39.1 92/01/30 19:52:42 peter Exp Locker: peter $
d53 1
a53 1
struct ContextIData *FindContext (struct Window *win);
a428 1
    struct SpecialGadget *sg;
d431 1
a431 1
    struct ContextIData *ctid;
d440 1
a440 1
    if (( ctid = FindContext(imsg->IDCMPWindow) ) && ( !ctid->ctid_QuasiUsed ))
d443 3
a445 3
	ctid->ctid_QuasiUsed++;
	quasi = &ctid->ctid_QuasiMessage;
	quasi->qm_ContextIData = ctid;
d455 1
a455 1
	/* NOTE WELL: qm_ContextIData is NULL.  We key off this to
d483 1
a483 1
	    (ctid) && (gad = ctid->ctid_ActiveGadget) )
d497 1
a497 1
		(!(SG_FROM_GAD(gad)->sg_Flags & SG_MOUSEMOVE))) ||
d499 1
a499 1
		(!(SG_FROM_GAD(gad)->sg_Flags & SG_INTUITICKS))))
d513 1
a513 1
		gad->GadgetID, SG_FROM_GAD(gad)->sg_EventHandler));
d521 1
a521 1
	    ((sg = SG_FROM_GAD(gad))->sg_EventHandler) )
d527 1
a527 1
	    if (sg->sg_Flags & (SG_MOUSEMOVE | SG_INTUITICKS))
d532 1
a532 1
		    if (ctid)
d534 1
a534 1
			ctid->ctid_ActiveGadget = NULL;
d540 1
a540 1
		    if (ctid)
d542 1
a542 1
			ctid->ctid_ActiveGadget = gad;
d546 1
a546 1
	    DP(("GT_FIM: Calling handler at $%lx\n", sg->sg_EventHandler));
d551 1
a551 1
	    msgforclient = (*sg->sg_EventHandler)(gad, (struct IntuiMessage *)quasi);
d560 1
a560 1
	    if (ctid)
d562 1
a562 1
		ctid->ctid_ActiveGadget = NULL;
d651 1
a651 1
    struct ContextIData *ctid;
d663 1
a663 1
	if ( ctid = ((struct QuasiMessage *)imsg)->qm_ContextIData )
d667 1
a667 1
	    ctid->ctid_QuasiUsed = 0;
d672 1
a672 1
	    if (ctid->ctid_DelayedFree)
d674 1
a674 1
		FreeVec(ctid->ctid_ActiveGadget);
a708 1
    struct SpecialGadget *sg;
a718 1
	    sg = SG_FROM_GAD(gad);
d720 1
a720 1
	    if (sg->sg_Refresh)
d722 1
a722 1
		MP((", refresh fcn at $%lx\n", sg->sg_Refresh));
d724 1
a724 1
		(*sg->sg_Refresh)(win, gad, refresh);
d820 1
a820 1
	sizeof(struct ContextIData), NULL );
d826 1
a826 1
    DP(("GT_CC:  Context Gadget at $%lx, ContextIData at $%lx\n", gad, CTID(gad)));
d829 1
a829 1
    SG_FROM_GAD(gad)->sg_Flags |= SG_CONTEXT;
d899 1
a899 1
*	{GTLV_Labels, list}.
a970 2
    struct SpecialGadget *sg;

a975 1
	sg = SG_FROM_GAD(gad);
d977 1
a977 1
	if (sg->sg_SetAttrs)
d979 1
a979 1
	    DP(("SetAttrs fcn at $%lx\n", sg->sg_SetAttrs));
d981 1
a981 1
	    (*sg->sg_SetAttrs)(gad, win, req, taglist);
d999 1
a999 1
struct ContextIData *FindContext( struct Window *win )
d1002 1
a1002 1
    struct Gadget *cgad = NULL;
d1009 1
a1009 1
	(SG_FROM_GAD(gad)->sg_Flags & SG_CONTEXT))
d1011 1
a1011 1
	    cgad = gad;
d1020 2
a1021 11
    if (cgad)
    {
	MP(("FC:  Context Gad at $%lx, ContextIData at $%lx\n", cgad, CTID(cgad)));
	MP(("FC:  ActiveGadget at $%lx\n", CTID(cgad)->ctid_ActiveGadget));
	return(CTID(cgad));
    }
    else
    {
	MP(("FC:  Failed to find ContextGadget\n"));
	return(NULL);
    }
@


39.1
log
@Removed RCS log.  Re-did braces, comments, and function headers.
Bumped to V39.
@
text
@d7 1
a7 1
*   $Id: dispatch.c,v 38.1 92/01/28 08:29:30 peter Exp Locker: peter $
a192 5
	/* John Toebes says stuff this label here to make that damned
	 * CXERR 28 go away.  I'll be sure to bug him real hard if
	 * it comes back :-)
	 */
LatticeCXERRFixLabel:
d822 2
a823 3
    gad = CreateGadget(GENERIC_KIND, (struct Gadget *)glistptr, &ng,
	GT_ExtraSize, sizeof(struct ContextIData),
	TAG_DONE);
@


38.1
log
@Removed __saveds.
@
text
@d7 1
a7 1
*   $Id: dispatch.c,v 38.0 91/07/11 12:34:07 peter Exp Locker: peter $
a8 74
*   $Log:	dispatch.c,v $
 * Revision 38.0  91/07/11  12:34:07  peter
 *  Initial V38 check-in (matches V37 release).
 * 
*   Revision 36.19  91/05/16  16:26:41  peter
*   The Code field from the fake IntuiMessage is now copied back into the
*   original IntuiMessage.  This allows MENUCANCEL to work again.
*   
*   Revision 36.18  91/05/07  18:03:50  peter
*   Minor autodoc update to GTLV_Top.
*   
*   Revision 36.17  91/03/14  16:07:33  peter
*   Now uses stack-based tags instead of array-based ones when it calls
*   tag-based functions.
*   Stub for GT_SetGadgetAttrs() moved into stubs.asm.
*   
*   Revision 36.16  91/01/28  13:29:54  peter
*   Improved CreateContext() and GT_RefreshWindow() autodocs.
*   Uses ctid_DelayedFree to handle callers who FreeGadgets() before
*   they GT_ReplyIMsg() the last message.
*   
*   Revision 36.15  91/01/07  21:01:41  peter
*   Clarified GT_FilterIMsg() and GT_PostFilterIMsg() autodoc.
*   
*   Revision 36.14  90/12/19  18:53:26  peter
*   Missed a test for the existence of a context IData before I used it.
*   
*   Revision 36.13  90/12/18  18:13:01  peter
*   Now takes advantage of the embedded QuasiMessage in the per-window
*   ContextIData.  This should greatly reduce the number of allocations
*   and frees that go on in the system.
*   
*   Revision 36.12  90/12/01  20:18:57  peter
*   Updated autodocs.
*   
*   Revision 36.11  90/11/19  12:56:45  peter
*   Autodocs now refer to GadTools V37 when necessary.
*   
*   Revision 36.10  90/11/07  19:43:57  peter
*   Updated autodoc.
*   
*   Revision 36.9  90/11/06  21:28:44  peter
*   Fixed an unchecked AllocMem().  Also I use AllocVec() instead.
*   Updated GT_SetGadgetAttrs() autodoc.
*   
*   Revision 36.8  90/10/12  19:40:44  peter
*   Removed unused test for REFRESHWINDOW IDCMP.
*   Autodocs now use modern Intuition names.
*   Use memset instead of initializer of an automatic to save space.
*   
*   Revision 36.7  90/06/21  13:59:12  peter
*   Improved GT_SetGadgetAttrsA() autodocs.
*   
*   Revision 36.6  90/05/18  18:30:20  peter
*   Put space immediately before '(' in prototypes to avoid confusing ctags.
*   
*   Revision 36.5  90/04/12  16:17:28  peter
*   Put register and varargs information into autodocs.
*   
*   Revision 36.4  90/04/02  16:03:31  peter
*   Warnings due to new clib/#?_protos.h eliminated.
*   Removed __stdargs from GT_SetGadgetAttrs().
*   Checks for GADTOOL_TYPE instead of GADTOOLBIT.
*   
*   Revision 36.3  90/03/31  06:43:26  peter
*   Now use CreateGadgetA() instead of specific Create[xxx]GadgetA().
*   
*   Revision 36.2  90/03/31  00:48:14  peter
*   Now checks for return of NULL from FindContext().
*   
*   Revision 36.1  90/03/16  14:01:34  peter
*   RCS Clean up.
*   
*
d17 1
a17 1
/*  Function Prototypes: */
d19 1
a19 1
/*  Public: */
d109 2
a110 3
LIB_GT_GetIMsg(register __a0 struct MsgPort *iport)

    {
d114 3
a116 2
    /*  Get a message until there is one that isn't eaten by the toolkit,
	or until no more are available: */
d118 1
a118 1
	{
d121 1
a121 1
	/*  Do the dispatch */
d124 4
a127 3
	    {
	    /*  Message was eaten, so ReplyMsg() it and get another one
		if available */
d130 1
a130 1
	    }
d132 1
a132 1
	    {
d134 2
a135 2
	    });
	}
d138 1
a138 1
    }
d187 3
a189 2
LIB_GT_ReplyIMsg(register __a1 struct IntuiMessage *imsg)

d191 1
a191 3
    if (imsg)
	{
	/*  Reply the REAL IntuiMessage that was in play here: */
d193 4
a196 3
	/*  John Toebes says stuff this label here to make that damned
	    CXERR 28 go away.  I'll be sure to bug him real hard if
	    it comes back :-) */
a198 1
	}
d200 1
d252 4
a255 5
LIB_GT_RefreshWindow(register __a0 struct Window *win,
		     register __a1 struct Requester *req)

    {
    /*  Do the refresh, but inform that we're not inside Begin/EndRefresh() */
d257 1
a257 1
    }
d311 2
a312 3
LIB_GT_BeginRefresh(register __a0 struct Window *win)

    {
d315 1
a315 1
    }
d363 6
a368 6
LIB_GT_EndRefresh(register __a0 struct Window *win,
		  register __d0 BOOL complete)

    {
    /*  Do nothing special function.  Put here by popular demand for
	symmetry */
d370 1
a370 1
    }
d431 2
a432 3
LIB_GT_FilterIMsg(register __a1 struct IntuiMessage *imsg)

    {
d436 1
a436 1
    /*  Pointer to context data, which contains active gadget. */
d438 1
a438 1
    /*  Assume we're eating this message, until proven otherwise: */
d447 1
a447 1
	{
d453 1
a453 1
	}
d455 1
a455 1
	{
d457 2
a458 1
	   QuasiMessage is in use, allocate a new one */
d464 1
a464 1
	}
d467 4
a470 3
	{
	/*  Make QuasiMessage contain a copy of the IntuiMessage, and
	    a pointer to the original IntuiMessage: */
d477 1
a477 1
	    {
d484 1
a484 1
	    /*  Found a gadget event, identify the gadget: */
d486 2
a487 2
	    }
	/*  If we have a MOUSEMOVE/INTUITICKS, and there is an ActiveGadget: */
d490 12
a501 10
	    {
	    /*  Since MOUSEMOVE's and INTUITICKS don't have the responsible
		gadget in the IAddress field, we are sure to stuff the
		address of the active gadget into our context instance
		data, so that we can extract it here.
		It would be NULL for a Window REPORTMOUSE-generated MOUSEMOVE,
		or a regular INTUITICKS. */
	    /*  We have either a MOUSEMOVE or an INTUITICKS, and the gadget
		wants one or the other, or both.  If we have one that the
		gadget doesn't want, we don't want to send it a message: */
d506 1
a506 1
		{
d508 1
a508 1
		}
d515 1
a515 1
	    }
d517 1
a517 1
	    {
d521 1
a521 1
	    });
d523 3
a525 2
	/*  Do we have a gadget, is it a toolkit gadget, and if so,
	    does it have a handler? */
d528 6
d535 1
a535 4
	    /*  If this is a toolkit gadget that cares about MOUSEMOVE or
		INTUITICKS events, set or clear the context ActiveGadget
		upon GADGETDOWN or GADGETUP respectively: */
	    if (sg->sg_Flags & (SG_MOUSEMOVE | SG_INTUITICKS))
a536 2
		if (imsg->Class == GADGETUP)
		    {
d539 1
a539 1
			{
a540 1
			}
d542 1
d544 1
a544 1
		    {
d547 1
a547 1
			{
a548 1
			}
d551 1
d553 4
a556 3
	    /*  Handler returns TRUE if the message is to be passed down
		to the client, FALSE if it is to be eaten.  msgforclient
		is this value: */
d559 1
a559 1
	    }
d561 6
a567 5
	    /*  This is where boolean FOLLOWMOUSE gadgets get turned
		off if the user rolls off them and then releases the
		mouse: */
	    if (ctid)
		{
d569 1
a569 1
		}
d571 1
a571 1
	    }
d573 4
a576 3
	    {
	    /*  A class of message that the toolkit doesn't care about,
		so send it down to the client: */
a577 1
	    }
d579 1
d582 1
a582 1
	{
d586 1
a586 1
	}
d588 1
a588 1
	{
a593 1
	}
d595 1
d654 2
a655 3
LIB_GT_PostFilterIMsg(register __a1 struct IntuiMessage *imsg)

    {
d660 1
a660 1
	{
d670 1
a670 1
	    {
d679 1
a679 1
		{
a680 1
		}
d682 1
d684 1
a684 1
	    {
a687 1
	    }
d689 1
d692 1
a692 1
    }
d712 2
a713 6
void WalkRefreshGadgets(win, refresh)

    struct Window *win;
    BOOL refresh;

    {
d717 1
a717 1
    /*  Walk the list of gadgets in the supplied window: */
d720 1
a720 1
	{
d722 1
a722 1
	/*  Is this a Toolkit gadget? */
d724 1
a724 1
	    {
d727 1
a727 1
	    /*  Does it have a refresh function? */
d729 1
a729 1
		{
d731 1
a731 1
		/*  Do the refresh: */
a732 1
		}
d734 1
a736 1
	}
d738 1
d778 1
a778 1
*	{
d781 1
a781 1
*	    {
a784 1
*	    }
d786 1
d803 2
a804 3
LIB_CreateContext(register __a0 struct Gadget **glistptr)

    {
d813 1
a813 1
	{
d816 1
a816 1
	}
d818 7
a824 6
    /*  !!! CreateGadgetA() requires a non-zero VisualInfo.  However, the
	GENERIC_KIND gadget (when ng_GadgetText is NULL) MUST work
	without referring to the VisualInfo if we expect to create
	the context gadget with it.  So to fool it, we set a bogus
	but non-zero value of VisualInfo, knowing it won't be needed
	on the other side, but just to fool the middle-man !!! */
d831 1
a831 1
	{
d834 1
a834 1
    	}
d837 1
a837 1
    /*  This is the Context gadget: */
d840 1
a840 1
    }
d908 1
a908 1
*	    {GTLV_Labels, list}.
d975 5
a979 6
LIB_GT_SetGadgetAttrsA(register __a0 struct Gadget *gad,
		       register __a1 struct Window *win,
		       register __a2 struct Requester *req,
		       register __a3 struct TagItem *taglist)

    {
d983 1
a983 1
    /*  Is this a Toolkit gadget? */
d985 1
a985 1
	{
d988 1
a988 1
	/*  Does it have a SetAttrs function? */
d990 1
a990 1
	    {
d992 1
a992 1
	    /*  Do it to it: */
a993 1
	    }
d995 1
d997 1
a997 1
    }
d1011 2
a1012 5
struct ContextIData *FindContext(win)

    struct Window *win;

    {
d1019 1
a1019 1
	{
d1022 1
a1022 1
	    {
d1025 1
a1025 1
	    }
d1027 1
a1027 1
	    {
a1028 1
	    }
d1030 1
d1033 1
a1033 1
	{
d1037 1
a1037 1
	}
d1039 1
a1039 1
	{
a1041 1
	}
d1043 1
@


38.0
log
@ Initial V38 check-in (matches V37 release).
@
text
@d7 1
a7 1
*   $Id: dispatch.c,v 36.19 91/05/16 16:26:41 peter Exp $
d10 3
d94 1
a94 1
struct IntuiMessage * __saveds __asm
d97 1
a97 1
void __saveds __asm
d100 1
a100 1
void __saveds __asm
d104 1
a104 1
void __saveds __asm
d107 1
a107 1
void __saveds __asm
d111 1
a111 1
struct IntuiMessage * __saveds __asm
d114 1
a114 1
struct IntuiMessage *__saveds __asm
d117 1
a117 1
void __saveds __asm
d123 1
a123 1
struct Gadget * __saveds __asm
d182 1
a182 1
struct IntuiMessage * __saveds __asm
d259 1
a259 1
void __saveds __asm
d324 1
a324 1
void __saveds __asm
d384 1
a384 1
void __saveds __asm
d437 1
a437 1
void __saveds __asm
d505 1
a505 1
struct IntuiMessage * __saveds __asm
d720 1
a720 1
struct IntuiMessage *__saveds __asm
d874 1
a874 1
struct Gadget * __saveds __asm
d1046 1
a1046 1
void __saveds __asm
@
