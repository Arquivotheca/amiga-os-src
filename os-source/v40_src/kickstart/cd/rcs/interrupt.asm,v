head     1.37;
branch   ;
access   ;
symbols  ;
locks    jerryh:1.37; strict;
comment  @* @;


1.37
date     93.11.18.09.07.02;  author jerryh;  state Exp;
branches ;
next     1.36;

1.36
date     93.11.03.17.22.55;  author jerryh;  state Exp;
branches ;
next     1.35;

1.35
date     93.06.01.13.55.23;  author jerryh;  state Exp;
branches ;
next     1.34;

1.34
date     93.04.30.16.53.16;  author jerryh;  state Exp;
branches ;
next     1.33;

1.33
date     93.04.27.15.58.28;  author jerryh;  state Exp;
branches ;
next     1.32;

1.32
date     93.04.12.15.50.51;  author jerryh;  state Exp;
branches ;
next     1.31;

1.31
date     93.04.08.10.19.57;  author jerryh;  state Exp;
branches ;
next     1.30;

1.30
date     93.04.02.10.30.24;  author jerryh;  state Exp;
branches ;
next     1.29;

1.29
date     93.03.29.13.35.07;  author jerryh;  state Exp;
branches ;
next     1.28;

1.28
date     93.03.26.10.27.45;  author jerryh;  state Exp;
branches ;
next     1.27;

1.27
date     93.03.24.14.16.24;  author jerryh;  state Exp;
branches ;
next     1.26;

1.26
date     93.03.22.10.12.56;  author jerryh;  state Exp;
branches ;
next     1.25;

1.25
date     93.03.16.13.22.05;  author jerryh;  state Exp;
branches ;
next     1.24;

1.24
date     93.03.08.08.55.28;  author jerryh;  state Exp;
branches ;
next     1.23;

1.23
date     93.03.06.12.34.46;  author jerryh;  state Exp;
branches ;
next     1.22;

1.22
date     93.02.23.15.53.55;  author jerryh;  state Exp;
branches ;
next     1.21;

1.21
date     93.02.16.15.59.58;  author jerryh;  state Exp;
branches ;
next     1.20;

1.20
date     93.02.15.10.18.00;  author jerryh;  state Exp;
branches ;
next     1.19;

1.19
date     93.02.11.13.51.45;  author jerryh;  state Exp;
branches ;
next     1.18;

1.18
date     93.02.08.16.39.41;  author jerryh;  state Exp;
branches ;
next     1.17;

1.17
date     93.02.04.10.25.58;  author jerryh;  state Exp;
branches ;
next     1.16;

1.16
date     93.02.03.12.10.12;  author jerryh;  state Exp;
branches ;
next     1.15;

1.15
date     93.02.03.12.03.08;  author jerryh;  state Exp;
branches ;
next     1.14;

1.14
date     93.02.02.17.08.55;  author jerryh;  state Exp;
branches ;
next     1.13;

1.13
date     93.02.02.10.53.35;  author jerryh;  state Exp;
branches ;
next     1.12;

1.12
date     93.01.22.12.01.30;  author jerryh;  state Exp;
branches ;
next     1.11;

1.11
date     93.01.15.15.41.50;  author jerryh;  state Exp;
branches ;
next     1.10;

1.10
date     93.01.07.09.40.10;  author jerryh;  state Exp;
branches ;
next     1.9;

1.9
date     92.12.12.17.46.26;  author jerryh;  state Exp;
branches ;
next     1.8;

1.8
date     92.12.11.13.36.33;  author jerryh;  state Exp;
branches ;
next     1.7;

1.7
date     92.12.09.15.22.30;  author jerryh;  state Exp;
branches ;
next     1.6;

1.6
date     92.12.07.11.59.08;  author jerryh;  state Exp;
branches ;
next     1.5;

1.5
date     92.12.05.16.54.24;  author jerryh;  state Exp;
branches ;
next     1.4;

1.4
date     92.12.04.10.19.57;  author jerryh;  state Exp;
branches ;
next     1.3;

1.3
date     92.11.23.09.23.29;  author jerryh;  state Exp;
branches ;
next     1.2;

1.2
date     92.11.02.13.33.45;  author jerryh;  state Exp;
branches ;
next     1.1;

1.1
date     92.10.21.15.04.04;  author jerryh;  state Exp;
branches ;
next     ;


desc
@interrupt server.
@


1.37
log
@Beginning of disk for CDI disks is really 00:02:00 afterall.
@
text
@

        INCLUDE "exec/types.i"
        INCLUDE "exec/nodes.i"
        INCLUDE "exec/lists.i"
        INCLUDE "exec/ports.i"
        INCLUDE "exec/libraries.i"
        INCLUDE "exec/tasks.i"
        INCLUDE "exec/devices.i"
        INCLUDE "exec/memory.i"
        INCLUDE "exec/interrupts.i"
        INCLUDE "exec/resident.i"
        INCLUDE "exec/io.i"
        INCLUDE "exec/errors.i"
        INCLUDE "exec/execbase.i"
        INCLUDE "hardware/intbits.i"
        INCLUDE "devices/trackdisk.i"
        INCLUDE "exec/ables.i"

        INCLUDE "defs.i"
        INCLUDE "cd.i"
        INCLUDE "cdprivate.i"
        INCLUDE "cdgs_hw.i"

        OPT     p=68020

************************************************************************
*                                                                      *
*    External References                                               *
*                                                                      *
************************************************************************

        XREF    EnableRX
        XREF    DisableRX

        XREF    MSFtoLSNPOS
        XREF    LSNtoMSFPOS

        XREF    MSFBINtoBCD
        XREF    MSFBCDtoBIN
        XREF    LSNtoMSF
        XREF    MSFtoLSN
        XREF    BCDtoBIN
        XREF    BINtoBCD

        XREF    Attenuate
        XREF    SetSubcodeInterrupt
        XREF    CauseInterruptList
        XREF    FlickerLight

        XREF    StopRead
        XREF    ClearPrefetch

        XREF    PutHex
        XREF    PutChar

        INT_ABLES



*
************************************************************************
*                                                                      *
*   XLIntrProc - XL node interrupt processor                           *
*                                                                      *
************************************************************************

 FUNCTION XLIntrProc
                save    a2                                              ; Call XL entry as an interrupt
                move.l  db_XferEntry(a1),a2
                move.l  CDXL_IntCode(a2),a0
                move.l  CDXL_IntData(a2),a1
                jsr     (a0)
                restore a2

                move.w  #1,d0                                           ; Clear server chain
                rts


*
************************************************************************
*                                                                      *
*   IntrProc - Main interrupt processing routine                       *
*                                                                      *
************************************************************************

 FUNCTION IntrProc
                move.l  CDINT2ENABLE+CDHARDWARE,d0                      ; Is this our interrupt?
                and.l   CDSTATUS+CDHARDWARE,d0

                bne     ServiceInt                                      ; Do something about it

                clr.l   d0                                              ; Wasn't our interrupt
                rts


ServiceInt:
                save    d2/db/hb                                        ; Initialize registers
                move.l  a1,db
                move.l  #CDHARDWARE,hb

                move.l  d0,d2                                           ; Information from drive available?
                btst    #INTB_RXDMADONE,d2
                beq     1$
                bsr     CDRXDMADone
1$
                btst    #INTB_TXDMADONE,d2                              ; Transmit of drive command complete?
                beq     2$
                bsr     CDTXDMADone
2$
                btst    #INTB_SUBCODE,d2                                ; Subcode interrupt?
                beq     3$
                bsr     CDSubCode
3$
                btst    #INTB_PBX,d2                                    ; CD-ROM interrupt?
                beq     4$
                bsr     CDROM
4$
                restore d2/db/hb                                        ; Clear server chain
                move.l  #1,d0
                rts


************************************************************************
*                                                                      *
*    CDRXDMADone                                                       *
*                                                                      *
*       Information from drive is available                            *
*                                                                      *
************************************************************************

CDRXDMADone:
                jsr     DisableRX

                move.l  db_CDCOMRXPage(db),a0                           ; Is this the first byte of a packet?
                tst.b   db_ReceivingCmd(db)
                bne     3$

                clr.w   d0                                              ; Get command byte
                move.b  db_ComRXInx(db),d0
                move.b  0(a0,d0.w),d0
                and.b   #$0f,d0

                lea     ResponseLen(pc),a1                              ; Prepare to receive rest of packet
                move.b  0(a1,d0.w),d0
                add.b   db_CDCOMRXCMP(db),d0
                subq.b  #1,d0
                move.b  d0,db_CDCOMRXCMP(db)
                move.b  #1,db_ReceivingCmd(db)

                move.b  d0,CDCOMRXCMP(hb)                               ; Clear the interrupt

                sub.b   CDCOMRXINX(hb),d0                               ; If the rest of this packet is here, parse again
                bmi     CDRXDMADone
                bne     2$
                move.l  CDSTATUS(hb),d0
                btst    #INTB_RXDMADONE,d0
                beq     CDRXDMADone
2$
                jsr     EnableRX
                rts
3$
                save    d2-d4                                           ; Get address and length of packet  
                clr.w   d2
                move.b  db_ComRXInx(db),d2
                move.b  0(a0,d2.w),d0
                and.w   #$0f,d0
                lea     ResponseLen(pc),a1
                move.b  0(a1,d0.w),d3

                clr.b   d0                                              ; Make sure checksum of packet is valid
                clr.b   d1
4$              and.w   #$FF,d2
                move.b  0(a0,d2.w),d4
                add.b   d4,d0
                add.b   #1,d2
                add.b   #1,d1
                cmp.b   d1,d3
                bne     4$
                restore d2-d4

                cmp.b   #$FF,d0                                         ; Checksum ok?
                bne     10$

                clr.w   d1                                              ; Were we instructed to ignore this packet?
                move.b  db_ComRXInx(db),d1
                move.b  0(a0,d1.w),d0     
                cmp.b   db_IgnoreResponse(db),d0
                beq     10$

                cmp.b   #CHCMD_QCODE,d0                                 ; Is this a TOC entry?
                bne     5$
                cmp.b   #1,db_ReadingTOC(db)
                beq     CDTOC
                bra     ReturnInt
5$
                and.b   #$0F,d0                                         ; Is this a response to a Q-Code command?
                cmp.b   #CHCMD_QCODE,d0
                beq     CDQCodeResponse

                addq.b  #1,d1                                           ; Is this a response to a play command?
                cmp.b   #CHCMD_SETPLAY,d0
                beq     6$
                cmp.b   #CHCMD_PLAY,d0
                bne     8$
6$
                move.w  db_Info+CDINFO_Status(db),d0                    ; Are we playing?
                btst    #CDSTSB_PLAYING,d0
                bne     7$

                move.b  0(a0,d1.w),d0                                   ; Is this a play-has-begun packet?
                bmi     CDCMDResponse
                and.b   #$78,d0
                cmp.b   #$08,d0
                bne     8$
                cmp.w   #CDCMD_PLAY,db_CMD(db)
                bne     8$

                or.w    #CDSTSF_PLAYING,db_Info+CDINFO_Status(db)       ; Play working (must set quickly incase datatype is wrong)
                jsr     SetSubcodeInterrupt
                bra     CDCMDResponse
7$
                move.w  db_Info+CDINFO_Status(db),d0                    ; Is this a play completion packet?
                btst    #CDSTSB_PLAYING,d0
                beq     8$
                move.b  0(a0,d1.w),d0
                move.b  d0,db_PlayStatus(db)
                bmi     CDPlayDone
                and.b   #$78,d0
                beq     CDPlayDone
8$
                move.b  0(a0,d1.w),d0                                   ; Is this a progress packet?  If so, ignore it.
                btst    #7,d0
                bne     9$
                and.b   #$70,d0
                bne     ReturnInt
9$
                subq.b  #1,d1                                           ; Is this a disk-change packet?
                move.b  0(a0,d1.w),d0
                and.b   #$0f,d0
                cmp.b   #CHCMD_DISKCHANGE,d0
                beq     CDDiskChange

                bra     CDCMDResponse                                   ; Response to drive command
10$
                bra     ReturnInt


ReturnInt:
                move.l  db_CDCOMRXPage(db),a0                           ; Increment pointer to beginning of next packet
                clr.w   d0
                move.b  db_ComRXInx(db),d0
                move.b  0(a0,d0.w),d0
                and.w   #$0f,d0
                lea     ResponseLen(pc),a1
                move.b  0(a1,d0.w),d1
                add.b   d1,db_ComRXInx(db)

                move.b  db_CDCOMRXCMP(db),d0                            ; Configure hardware to wait for a command byte again
                addq.b  #1,d0
                move.b  d0,db_CDCOMRXCMP(db)
                move.b  #0,db_ReceivingCmd(db)

                move.b  d0,CDCOMRXCMP(hb)                               ; Clear the interrupt

                sub.b   CDCOMRXINX(hb),d0                               ; If we have received more data, parse again
                bmi     CDRXDMADone
                bne     1$
                move.l  CDSTATUS(hb),d0
                btst    #INTB_RXDMADONE,d0
                beq     CDRXDMADone
1$
                jsr     EnableRX
                rts

ResponseLen:    dc.b    1,3,3,3,3,3,16,21,3,1,3,1,1,1,1,1



*
************************************************************************
*                                                                      *
*    CDTXDMADone - Drive command buffer is empty                       *
*                                                                      *
************************************************************************

CDTXDMADone:
                and.l   #-1-INTF_TXDMADONE,CDINT2ENABLE(hb)            ; Disable transmit DMA interrupt
                rts

*
************************************************************************
*                                                                      *
*    CDCMDResponse - Response to standard command                      *
*                                                                      *
************************************************************************

CDCMDResponse:
                move.b  db_ComRXInx(db),db_PacketAddress(db)            ; Remember address of packet

                SIGNAL  SIGF_CMDDONE                                    ; Command has completed
                bra     ReturnInt



************************************************************************
*                                                                      *
*    CDPlayDone - Play complete.                                       *
*                                                                      *
************************************************************************

CDPlayDone:
                cmp.w   #CDCMD_QCODE,db_CMD(db)                         ; If we are waiting for a Q-Code packet, wait no longer
                bne     1$
                SIGNAL  SIGF_QCODE
1$
                SIGNAL  SIGF_PLAYDONE                                   ; Signal task about play completion
                bra     ReturnInt



************************************************************************
*                                                                      *
*    CDQCodeResponse - Response to a Q-Code command.  Copy packet      *
*                                                                      *
*    in:    D1 = packet index                                          *
*                                                                      *
************************************************************************

CDQCodeResponse:
                save    d2
                lea     db_QCode(db),a0                                 ; Copy result to Q-Code packet
                move.l  db_CDCOMRXPage(db),a1                           ; Is this Q-Code packet valid?
                clr.w   d2
1$              move.b  d2,d0
                bsr     GetPackByte
                move.b  d0,(a0)+
                add.b   #1,d2
                cmp.b   #16,d2
                bne     1$
                restore d2

                bra     CDCMDResponse                                   ; Do standard response now



************************************************************************
*                                                                      *
*    CDDiskChange - Disk drawer state has changed                      *
*                                                                      *
************************************************************************

CDDiskChange
                move.l  db_CDCOMRXPage(db),a1                           ; Save the state of the drive door (zero = openned)
                clr.w   d0
                move.b  db_ComRXInx(db),d0
                add.b   #1,d0
                move.b  0(a1,d0.w),d0
                and.b   #$03,d0

                cmp.b   db_OpenState(db),d0
                beq     ReturnInt
                move.b  d0,db_OpenState(db)
                bne     3$                                              ; - Is door now openned?

                tst.w   db_Info+CDINFO_EjectReset(db)
                beq     1$
                exec    ColdReboot
1$
                tst.b   db_ReadingTOC(db)                               ; Abort disk command (if one is occurring)
                bne     2$
                move.l  db_ClassDReq(db),d0
                beq     3$
                move.l  d0,a1
                move.b  #CDERR_NoDisk,IO_ERROR(a1)
2$
                SIGNAL  SIGF_ABORTDRIVE                                 ; Abort them
3$
                SIGNAL  SIGF_DISKCHANGE                                 ; Disk drawer state has changed
                bra     ReturnInt




************************************************************************
*                                                                      *
*    CDTOC - This is a TOC entry that needs to be processed            *
*                                                                      *
*       in:  D1 = packet index                                         *
*                                                                      *
************************************************************************

CDTOC
                save    d2

                save    d1                                              ; Invert current drive light state
                jsr     FlickerLight
                restore d1

                move.w  db_Info+CDINFO_Status(db),d0                    ; Is the TOC already valid?
                btst    #CDSTSB_TOC,d0
                bne     99$

                move.l  db_CDCOMRXPage(db),a1                           ; Is this Q-Code packet valid?
                move.b  #1,d0
                bsr     GetPackByte
                tst.b   d0
                bmi     99$
                move.b  #2,d0
                bsr     GetPackByte
                tst.b   d0
                bne     99$

                move.b  #3,d0                                           ; Is this a position packet?
                bsr     GetPackByte
                and.b   #CTLADR_ADRMASK,d0
                cmp.b   #ADR_POSITION,d0
                beq     0$

                cmp.b   #ADR_HYBRID,d0                                  ; Is this a hybrid muti-session?
                bne     99$
                move.b  #5,d0
                bsr     GetPackByte
                cmp.b   #$B0,d0
                bne     99$

                move.b  #5,d0                                           ; Mark beginning of next lead-in area
                bsr     GetPackLong
                and.l   #$00FFFFFF,d0
                move.l  d0,db_TOCNext(db)
                bra     99$
0$
                move.b  #4,d0                                           ; TNO must be zero during lead-in track
                bsr     GetPackByte
                tst.b   d0
                bne     99$

                lea     db_TOC(db),a0                                   ; First track?
                move.b  #5,d0
                bsr     GetPackByte
                cmp.b   #$A0,d0
                bne     1$

                addq.b  #1,db_CDICount(db)                              ; If we have seen the first track packet an excessive
                cmp.b   #3*10,db_CDICount(db)                           ;    number of times, let's assume this is a CDI disk
                bhs     100$

                bra     5$
1$
                cmp.b   #$A1,d0                                         ; Last track?
                bne     2$
                move.b  #10,d0
                bsr     GetPackByte
                jsr     BCDtoBIN
                move.b  d0,TOCS_LastTrack(a0)
                bra     5$
2$
                cmp.b   #$A2,d0                                         ; Lead-out address?  Last track must be valid first
                bne     3$
                clr.l   d2
                move.b  TOCS_LastTrack(a0),d2
                beq     99$

                addq.w  #1,d2                                           ; Create a false entry just past table of contents
                mulu    #TOCEntry_SIZE,d2
                move.b  #0,TOCE_Track(a0,d2.w)
                move.b  #0,TOCE_CtlAdr(a0,d2.w)
                move.b  #9,d0
                bsr     GetPackLong
                and.l   #$00FFFFFF,d0
                jsr     MSFBCDtoBIN
                move.l  d0,TOCS_LeadOut(a0)
                move.l  d0,TOCE_Position(a0,d2.w)
                bra     5$
3$
                jsr     BCDtoBIN                                        ; Is the index valid?
                tst.b   d0
                beq     99$
                cmp.b   #100,d0
                bhs     99$

                clr.w   d2                                              ; Make a TOC entry
                move.b  d0,d2
                mulu    #TOCEntry_SIZE,d2
                move.b  d0,TOCE_Track(a0,d2.w)
                move.b  #3,d0
                bsr     GetPackByte
                move.b  d0,TOCE_CtlAdr(a0,d2.w)
                move.b  #9,d0
                bsr     GetPackLong
                and.l   #$00FFFFFF,d0
                jsr     MSFBCDtoBIN
                move.l  d0,TOCE_Position(a0,d2.w)
5$
                cmp.b   #1,TOCS_FirstTrack(a0)                          ; Is summary information valid?
                bne     99$
                tst.b   TOCS_LastTrack(a0)
                beq     99$
                tst.l   TOCS_LeadOut(a0)
                beq     99$

                move.b  #1,d0                                           ; Are all entries (including lead-out track) valid?
                move.w  #TOCEntry_SIZE,d2
6$              tst.b   TOCE_Track(a0,d2.w)
                beq     99$
                addq.b  #1,d0
                add.w   #TOCEntry_SIZE,d2
                cmp.b   TOCS_LastTrack(a0),d0
                bls     6$
98$
                move.b  #2,db_ReadingTOC(db)                            ; No longer reading TOC

                SIGNAL  SIGF_TOCDONE                                    ; TOC has been read successfully, stop playing
99$
                restore d2

                bra     ReturnInt
100$:
                move.b  #1,TOCSummary_SIZE+TOCE_Track(a0)                           ; Create first track of CDI disk
                move.b  #CTL_DATA|ADR_POSITION,TOCSummary_SIZE+TOCE_CtlAdr(a0)
                move.l  #$000200,TOCSummary_SIZE+TOCE_Position(a0)

                tst.b   (TOCSummary_SIZE*2)+TOCE_Track(a0)                          ; If there is no track 2, just make the
                bne     101$                                                        ;    beginning of track 2 = lead-out.
                move.b  #2,(TOCSummary_SIZE*2)+TOCE_Track(a0)
                move.b  #CTL_DATA|ADR_POSITION,(TOCSummary_SIZE*2)+TOCE_CtlAdr(a0)
                move.l  TOCS_LeadOut(a0),(TOCSummary_SIZE*2)+TOCE_Position(a0)
101$
                bra     98$



GetPackByte:
                add.b   d1,d0
                and.w   #$FF,d0
                move.b  0(a1,d0.w),d0
                rts


GetPackLong:
                save    d2/d3
                move.b  d0,d2
                bsr     GetPackByte
                move.b  d0,d3
                lsl.l   #8,d3
                add.b   #1,d2
                move.b  d2,d0
                bsr     GetPackByte
                move.b  d0,d3
                lsl.l   #8,d3
                add.b   #1,d2
                move.b  d2,d0
                bsr     GetPackByte
                move.b  d0,d3
                lsl.l   #8,d3
                add.b   #1,d2
                move.b  d2,d0
                bsr     GetPackByte
                move.b  d0,d3
                move.l  d3,d0
                restore d2/d3
                rts




************************************************************************
*                                                                      *
*    CDROM - CD-ROM data interrupt                                     *
*                                                                      *
************************************************************************

CDROM
                save    d2
                move.l  CDSTATUS(hb),d0                                 ; Has there been a DMA overrun problem?
                btst    #INTB_OVERFLOW,d0
                beq     1$
                bsr     CDOverflow
                bra     4$
1$
                move.w  CDPBX(hb),d0                                    ; Prefetch buffers full?
                clr.w   d1
                move.w  #16,d2
2$              lsr.w   #1,d0
                bcc     3$
                addq.b  #1,d1
3$              subq.w  #1,d2
                bne     2$
                cmp.b   #2,d1
                bhi     4$
                move.w  #1,d0                                           ; - Disable CD-ROM hardware and stop drive
                jsr     StopRead
4$
                SIGNAL  SIGF_PBX                                        ; Signal READ command that data is available

                move.w  #0,CDPBX(hb)                                    ; Clear the interrupt
                restore d2
                rts



************************************************************************
*                                                                      *
*    CDOverflow - CD-ROM buffer overflow interrupt                     *
*                                                                      *
************************************************************************

CDOverflow
                move.w  #1,d0                                           ; Disable CD-ROM hardware, stop drive, and invalidate
                jsr     StopRead
                jsr     ClearPrefetch
                rts



************************************************************************
*                                                                      *
*    CDSubCode - Subcode frame complete                                *
*                                                                      *
************************************************************************

CDSubCode

*************** Auto Q *************************************************

                tst.b   db_AutoQ(db)                                    ; Q-Code interrupt enabled?
                beq     1$

                SIGNAL  SIGF_QCODE                                      ; Notify Q-Code command to try again
1$
*************** Auto Frame *********************************************

                tst.b   db_AutoFrame(db)                                ; Frame interrupt enabled?
                beq     2$

                lea     db_FrameList(db),a0                             ; Cause frame interrupts
                bsr     CauseInterruptList
2$
*************** Auto Fade **********************************************

                tst.b   db_AutoFade(db)                                 ; Fade interrupt enabled?
                beq     6$

                move.w  db_Attenuation(db),d0                           ; Fade up or down
                move.w  db_TargetAttenuation(db),d1
                add.w   db_FadeStepSize(db),d0
                tst.w   db_FadeStepSize(db)
                bmi     3$

                cmp.w   d1,d0                                           ; Fade down until we reach target
                bmi     5$
                bra     4$
3$
                cmp.w   d1,d0                                           ; Fade up until we reach target
                bpl     5$
4$
                save    d1                                              ; We have reached our fade value, turn off fading
                clr.b   db_AutoFade(db)
                jsr     SetSubcodeInterrupt
                restore d0
5$
                move.w  d0,db_Attenuation(db)                           ; Set the attenuator
                bsr     Attenuate
6$
*************** Clear the interrupt ************************************

                move.b  #0,CDSUBINX(hb)                                 ; Clear the interrupt
                rts



@


1.36
log
@Added code for CDI disk detection.
@
text
@d521 1
a521 1
                move.l  #$000000,TOCSummary_SIZE+TOCE_Position(a0)
@


1.35
log
@no effective change.
@
text
@a440 1

d443 5
d510 1
a510 1

d518 12
@


1.34
log
@Removed test of cause flag.
@
text
@d1 1
@


1.33
log
@removed debugging.
@
text
@a67 5
                tst.w   db_XLCause(a1)                                  ; Is this a CDXL interrupt?
                beq     99$

                clr.w   db_XLCause(a1)                                  ; Clear the interrupt

a75 3
                rts
99$
                clr.l   d0                                              ; Wasn't our interrupt
@


1.32
log
@No effective change.
@
text
@d170 2
a171 3
                save    d2-d4  

                clr.w   d2                                              ; Get address and length of packet
a186 39

;                save    d0
;
;                move.b  0(a0,d2.w),d4
;                cmp.b   #6,d4
;                beq     41$
;
;                clr.w   d2
;                move.b  db_ComRXInx(db),d2
;                move.b  0(a0,d2.w),d0
;                and.w   #$0f,d0
;                lea     ResponseLen(pc),a1
;                move.b  0(a1,d0.w),d3
;
;                clr.b   d1
;40$             move.b  0(a0,d2.w),d4
;
;                save    d0
;                clr.l   d0
;                move.b  d4,d0
;                jsr     PutHex
;                restore d0
;
;                add.b   #1,d1
;                add.b   #1,d2
;                cmp.b   d1,d3
;                bne     40$
;41$
;                restore d0

;                save    d0
;                clr.w   d2
;                move.b  db_ComRXInx(db),d2
;                add.b   #1,d2
;                move.b  0(a0,d2.w),d0
;                and.l   #$FF,d0
;                jsr     PutHex
;                restore d0

d196 1
a196 1
                beq     11$
a252 38
    IFD DVL
                save    d0-d3/a2
                clr.w   d2
                move.b  db_ComRXInx(db),d2                              ; Get address and length of packet
                move.b  0(a0,d2.w),d0
                and.w   #$0f,d0
                lea     ResponseLen(pc),a1
                move.b  0(a1,d0.w),d3

                move.b  #'<',d0
                jsr     PutChar

                clr.b   d1
                clr.l   d0
32$
                clr.l   d0
                move.b  0(a0,d2.w),d0
                jsr     PutHex

                add.b   #1,d2
                add.b   #1,d1
                cmp.b   d1,d3
                bne     32$

                PRINT   3$,">"
                restore d0-d3/a2

                PRINT   4$,"CHECKSUM_ERROR"

                clr.l   d0
                move.b  db_ComRXInx(db),d0
                jsr     PutHex

99$             bra     99$

    ENDC

11$
@


1.31
log
@Coded for DMA overrun.  This is the way it theoretically should
work.  Needs testing.
@
text
@a677 4
        IFD DVL
                move.b  #'o',d0
                jsr     PutChar
        ENDC
@


1.30
log
@added conditional assembly for development version.
@
text
@d122 1
a122 1
                btst    #INTB_OVERFLOW,d2                               ; CD-ROM buffer full interrupt?
d124 1
a124 1
                bsr     CDOverflow
a125 4
                btst    #INTB_PBX,d2                                    ; CD-ROM interrupt?
                beq     5$
                bsr     CDROM
5$
d643 17
a659 2
                tst.w   CDPBX(hb)                                       ; Prefetch buffers full?
                bne     1$
d662 1
a662 1
1$
d666 1
d678 4
a684 2
                SIGNAL  SIGF_PBX
                move.w  #0,CDPBX(hb)
@


1.29
log
@no effective change.
@
text
@d297 1
d331 3
@


1.28
log
@Reworked interrupt to better handle OVERFLOW (CD_ROMHUNG) bit when
this hardware is working in the new gatearray when it arrives.
@
text
@d20 1
a21 1
        INCLUDE "cd.i"
@


1.27
log
@no effective change.
@
text
@d51 1
d122 1
a122 1
                btst    #INTB_PBX,d2                                    ; CD-ROM interrupt?
d124 1
a124 1
                bsr     CDROM
d126 1
a126 1
                btst    #INTB_OVERFLOW,d2                               ; CD-ROM buffer full interrupt?
d128 1
a128 1
                bsr     CDOverflow
d643 1
a643 11
                save    d1-d7/a0-a6                                     ; Enable overflow interrupt
;                or.l    #INTF_OVERFLOW,CDINT2ENABLE(hb)

                save    d2                                              ; Emulate overflow interrupt (sacrafice a prefetch)
                move.w  CDPBX(hb),d0
                clr.w   d1
                move.w  #16,d2
1$              lsr.w   #1,d0
                bcc     2$
                addq.b  #1,d1
2$              subq.w  #1,d2
d645 3
a647 4
                cmp.b   #1,d1
                bhi     3$
                jsr     CDOverflow
3$
a649 2
                restore d2
                restore d1-d7/a0-a6
d662 6
a667 2
                move.w  #1,d0                                           ; Disable CD-ROM hardware and stop drive
                jmp     StopRead
@


1.26
log
@Reworked the drive RX interrupt to make it potentially safer.
Perhaps this may fix the CHECKSUM ERROR condition.
@
text
@d643 1
a643 1
                or.l    #INTF_OVERFLOW,CDINT2ENABLE(hb)
a655 1

@


1.25
log
@no effective change.
@
text
@d143 2
a144 4
                tst.b   db_Disabled(db)                                 ; If we disabled interrupts, enable them again
                beq     1$
                jsr     EnableRX
1$
d161 1
a161 2
                jsr     DisableRX                                       ; Clear the interrupt
                move.b  d0,CDCOMRXCMP(hb)
d348 1
a348 2
                jsr     DisableRX                                       ; Clear the interrupt
                move.b  d0,CDCOMRXCMP(hb)
@


1.24
log
@Added more debug info when checksum error occurs.
@
text
@a331 2

                bra     ReturnInt
a332 1
;                PRINT   5$,"IGNORE"
@


1.23
log
@Changed packet length of cmd 0 (non-existent) to 1.
@
text
@d325 1
a325 1
                PRINT   4$,"CHECKSUM_ERROR"
d327 4
d367 1
a367 1
ResponseLen:    dc.b    1,3,3,3,3,3,16,21,3,0,3,0,0,0,0,0
@


1.22
log
@removed kprintfs.
@
text
@d187 2
a188 2
4$              move.b  0(a0,d2.w),d4

d363 1
a363 1
ResponseLen:    dc.b    3,3,3,3,3,3,16,21,3,0,3,0,0,0,0,0
@


1.21
log
@no effective change.
@
text
@d326 3
a486 3
                move.l  #':',d0
                jsr     PutChar

a596 3

                move.b  #'|',d0
                jsr     PutChar
@


1.20
log
@Fixed a TOC problem.
@
text
@d223 8
@


1.19
log
@removed a potential bug at SIGF_ABORTDRIVE
@
text
@d435 3
d439 1
a439 1
                bne     99$                                             ; - Is door now openned?
d448 1
a448 1
                beq     99$
d453 1
a453 1
99$
a521 6
;                move.b  #10,d0
;                bsr     GetPackByte
;                jsr     BCDtoBIN
;                move.b  d0,TOCS_FirstTrack(a0)
;                and.l   #$FF,d0
;                jsr     PutHex
@


1.18
log
@Fixed fading.
@
text
@a263 1

a264 1

d442 1
a442 1
                tst.b   db_ReadingTOC(db)                               ; Abort all disk commands
d447 1
d449 1
a449 2
                move.b  #CDERR_NoDisk,IO_ERROR(a1)                      ; Abort them
                SIGNAL  SIGF_ABORTDRIVE
@


1.17
log
@no effective change.
@
text
@a47 1
        XREF    BumpFade
a264 3
                lea     db_FrameList(db),a0                             ; If frame list is not empty, enable frame interrupts
                IFEMPTY a0,CDCMDResponse
                move.b  #1,db_AutoFrame(db)
d689 3
d697 2
d705 2
d708 7
a714 1
                beq     4$
d716 2
a717 4
                move.w  db_Attenuation(db),d0                           ; Adjust audio attenuation?
                cmp.w   db_TargetAttenuation(db),d0
                beq     3$
                bsr     BumpFade
d720 5
a724 1
                clr.b   db_AutoFade(db)                                 ; Turn off fading
d726 7
a732 1
4$
@


1.16
log
@internal.i is now cdprivate.i
@
text
@d34 3
@


1.15
log
@Added drive light flickering.
@
text
@d20 1
a20 1
        INCLUDE "internal.i"
@


1.14
log
@Fixed framecall interrupts.
@
text
@d249 1
a249 1
                move.w  db_Info+CDINFO_Status(db),d0                    ; Is this a play completion packet?
d471 3
a473 1
;                jsr     FlickerLight                                    ; Invert current drive light state
a508 2
                jsr     PutHex

d519 1
d522 6
a527 4
                move.b  #10,d0
                bsr     GetPackByte
                jsr     BCDtoBIN
                move.b  d0,TOCS_FirstTrack(a0)
@


1.13
log
@multi-session now attempted (does not work yet).
@
text
@d46 1
d187 22
d214 7
a220 6

                add.b   d4,d0
                add.b   #1,d2
                add.b   #1,d1
                cmp.b   d1,d3
                bne     4$
d262 6
d470 2
@


1.12
log
@Removed some comments.
@
text
@d264 1
d464 1
a464 1
                cmp.b   #ADR_HYBRID,d0                                  ; Is this a hybrid muti-session
d466 1
a466 3
                move.b  #'H',d0
                jsr     PutChar

d468 2
a469 2
                and.l   #$000000ff,d0
                jsr     PutHex
d471 4
a474 2
                bsr     GetPackByte
                and.l   #$000000ff,d0
@


1.11
log
@drive light code added.
@
text
@a100 2
;                jsr     PutHex

d467 10
d609 1
d626 2
d629 1
a630 2

                SIGNAL  SIGF_PBX                                        ; Signal READ command that data is available
a641 3
;                move.b  #'o',d0
;                jsr     PutChar

d643 1
a643 2
                jsr     StopRead
                rts
@


1.10
log
@Reset on eject should work.
@
text
@d187 1
a187 1
;
d325 1
a325 1
ResponseLen:    dc.b    3,3,3,3,3,0,16,21,3,0,3,0,0,0,0,0
d463 3
d467 3
a469 1

d614 1
d632 3
@


1.9
log
@Q-CODE interrupts now supported.
@
text
@d101 2
d187 7
d350 1
a350 1
                SIGNAL  SIGF_CMDRESPONSE                                ; Command has completed
d410 1
d412 13
d662 1
a662 1
                move.b  CDSUBINX(hb),d0                                 ; Clear the interrupt
@


1.8
log
@stripped out debug messages.
Touched up interrupt server.
@
text
@d202 1
a202 2
                and.b   #$0f,d0                                         ; Is this a TOC entry?
                cmp.b   #CHCMD_QCODE,d0
a205 2
;                cmp.b   #2,db_ReadingTOC(db)
;                beq     ReturnInt
d208 6
a213 1
                cmp.b   #CHCMD_SETPLAY,d0                               ; Is this a play-has-begun packet?
d216 4
d221 3
a223 3
6$              addq.b  #1,d1
                move.b  0(a0,d1.w),d0
                subq.b  #1,d1
d226 6
a231 1
                beq     CDCMDResponse
d233 9
a241 1
                addq.b  #1,d1
d244 1
a244 1
                bne     8$
d247 1
a247 1
8$
a253 12
                addq.b  #1,d1                                           ; Is this a play completion packet?
                move.b  0(a0,d1.w),d1
                and.b   #$08,d1
                bne     9$
                move.w  db_Info+CDINFO_Status(db),d1
                btst    #CDSTSB_PLAYING,d1
                beq     9$
                cmp.b   #CHCMD_SETPLAY,d0
                beq     CDPlayDone
                cmp.b   #CHCMD_PLAY,d0
                beq     CDPlayDone
9$
d352 1
a352 1
CDPlayDone
d364 25
a615 2
                move.b  CDSUBINX(hb),d0                                 ; Clear the interrupt

d634 1
a634 1
                rts
d639 1
@


1.7
log
@Got RX interrupt code working.
@
text
@d24 2
d141 1
a141 1
                beq     0$
d143 1
a143 1
0$
d146 1
a146 1
                bne     1$
d165 5
a169 3
;                move.l  CDSTATUS(hb),d0
;                btst    #INTB_RXDMADONE,d0
;                beq     CDRXDMADone
d172 1
a172 1
1$
d184 1
a184 1
2$              move.b  0(a0,d2.w),d4
d189 1
a189 1
                bne     2$
d194 1
a194 1
                bne     9$
d200 1
a200 1
                beq     10$
d204 1
a204 1
                bne     3$
d210 1
a210 1
3$
d212 1
a212 1
                beq     4$
d214 2
a215 2
                bne     5$
4$              addq.b  #1,d1
d221 1
a221 1
5$
d225 1
a225 1
                bne     6$
d228 1
a228 1
6$
d238 1
a238 1
                bne     7$
d241 1
a241 1
                beq     7$
d246 1
a246 1
7$
d248 1
a248 1
9$
d276 2
a277 2
10$
                PRINT   5$,"IGNORE"
d301 5
a305 3
;                move.l  CDSTATUS(hb),d0
;                btst    #INTB_RXDMADONE,d0
;                beq     CDRXDMADone
d309 1
a309 1
ResponseLen:    dc.b    3,3,3,3,3,0,16,3,3,0,0,0,0,0,0,0
a317 2
*       in:  A1 = packet address                                       *
*                                                                      *
a328 2
*       in:  A1 = packet address                                       *
*                                                                      *
a342 2
*       in:  A1 = packet address                                       *
*                                                                      *
a358 2
*       in:  A1 = packet address                                       *
*                                                                      *
d362 5
a366 1
                move.b  1(a1),d0                                        ; Save the state of the drive door (zero = openned)
@


1.6
log
@simulating overflow interrupt for now.
@
text
@d30 2
a31 2
        XREF    Enable
        XREF    Disable
d138 4
d147 1
a147 3
                move.b  db_CDCOMRXCMP(db),d0
                subq.b  #1,d0
                move.b  d0,db_ComRXInx(db)
a152 1

a154 1
                move.b  d0,CDCOMRXCMP(hb)
d158 9
a167 1

a168 9
;                move.b  #'@@',d0
;                jsr     PutChar

                move.b  db_CDCOMRXCMP(db),d0                            ; Configure hardware to wait for a command byte again
                addq.b  #1,d0
                move.b  d0,CDCOMRXCMP(hb)
                move.b  d0,db_CDCOMRXCMP(db)
                move.b  #0,db_ReceivingCmd(db)

a169 1
                clr.w   d2
d171 2
a172 1
                move.b  db_ComRXInx(db),d2                              ; Get address and length of packet
d196 1
a196 1
                beq     8$
d204 2
a205 2
;                beq     8$
                bra     8$
a206 24
;                save    d0-d3/a2
;                move.b  db_ComRXInx(db),d2                              ; Get address and length of packet
;                move.b  0(a0,d2.w),d0
;                and.w   #$0f,d0
;                lea     ResponseLen(pc),a1
;                move.b  0(a1,d0.w),d3
;
;                move.b  #'<',d0
;                jsr     PutChar
;
;                clr.b   d1
;                clr.l   d0
;22$
;                move.b  0(a0,d2.w),d0
;                jsr     PutHex
;
;                add.b   #1,d2
;                add.b   #1,d1
;                cmp.b   d1,d3
;                bne     22$
;
;                PRINT   2$,">"
;                restore d0-d3/a2

d223 1
a223 1
                bne     8$
a243 2
8$
                rts
d258 1
a258 4
                lea     0(a0,d2.w),a2
                move.l  a2,d0
                jsr     PutHex

d271 30
a302 1

d317 1
a317 2
                bclr.b  #(INTB_TXDMADONE-24),CDINT2ENABLE(hb)           ; Disable transmit DMA interrupt

a329 3
                move.b  #'R',d0
                jsr     PutChar

d333 1
a333 1
                rts
d351 1
a351 1
                rts
d369 1
a369 1
                rts
d488 3
d494 1
a494 1
                rts
a540 3
                move.b  #'P',d0
                jsr     PutChar

d553 2
a554 2
3$              restore d2

d569 2
a570 1
                jsr     StopRead                                        ; Disable CD-ROM hardware and stop drive
@


1.5
log
@stripped out massive interrupt printing.
@
text
@d541 2
d546 15
a560 1
                move.b  #0,CDPBX(hb)                                    ; Clear the interrupt
a573 2
                PRINT   1$,"PBX_OVERFLOW"

@


1.4
log
@who knows.
who knows.
@
text
@d161 3
a192 3
                move.l  #'.',d0
                jsr     PutChar

d204 3
a206 2
                cmp.b   #2,db_ReadingTOC(db)
                beq     8$
d208 24
d272 29
a300 1
                PRINT   1$,"CHECKSUM_ERROR"
d319 1
d332 2
a333 1
                PRINT   1$,"CDCMDResponse"
a491 2
                PRINT   3$,"TOC_DONE!!!!"

d541 2
a542 1
                PRINT   0$,"PBX"
@


1.3
log
@includes now relative, not absolute.
@
text
@d47 3
d90 1
a90 2
                or.l    CDINT6ENABLE+CDHARDWARE,d0
                and.l   CDSTATUS,d0
d104 1
a104 1
                btst    #INTB_DRIVECMP,d2
d106 1
a106 1
                bsr     CDDriveResponse
d108 4
d113 1
a113 1
                beq     2$
d115 1
a115 1
2$
d117 1
a117 1
                beq     3$
d119 1
a119 1
3$
d121 1
a121 1
                beq     4$
d123 1
a123 1
4$
a128 1

d131 1
a131 1
*    CDDriveResponse                                                   *
d137 3
a139 3
CDDriveResponse:
                move.l  db_CDCOMPage(db),a0                             ; Is this the first byte of a packet?
                cmp.b   #1,db_PackSize(db)
d142 4
a145 2
                clr.w   d0                                              ; Set length of the packet based on first byte
                move.b  db_ComInx(db),d0
d147 6
a152 4
                and.w   #$000f,d0
                lea     ResponseLen(pc),a0
                move.b  0(a0,d0.w),d0
                move.b  d0,db_PackSize(db)
d154 4
a157 1
                move.b  d0,CDCOMCMP(hb)
d159 1
d161 14
a174 10
                clr.w   d0                                              ; Get address of packet
                move.b  db_ComInx(db),d0
                lea     0(a0,d0.w),a1

                save    d2/d3                                           ; Set up to receive new packet
                move.b  db_PackSize(db),d3
                move.b  db_PackSize(db),d0
                add.b   d0,db_ComInx(db)
                move.b  #1,db_PackSize(db)
                move.b  #1,CDCOMCMP(hb)
d177 4
a180 3
                clr.w   d1
2$              move.b  0(a1,d1.w),d2
                cmp.b   d2,d0
d182 1
a182 1
                cmp.w   d1,d3
d184 8
a191 3
                restore d2/d3
                cmp.b   #$FF,d0
                bne     5$
d193 3
a195 1
                move.b  0(a1),d0                                        ; Were we instructed to ignore this packet?
d197 1
a197 1
                beq     5$
d199 23
a221 1
                move.b  1(a1),d0                                        ; Is this a progress packet?  If so, ignore it.
d223 4
a226 3
                bne     5$

                move.b  (a1),d0                                         ; Is this a disk-change packet?
d231 4
a234 8
                cmp.b   #CHCMD_QCODE,d0                                 ; Is this a TOC entry?
                bne     3$
                cmp.w   #CDCMD_READTOC,db_CMD(db)
                beq     CDTOC
3$
                move.b  1(a1),d0                                        ; Is this a play completion packet?
                and.b   #$08,d0
                bne     4$
d237 1
a237 1
                beq     4$
d242 3
a244 3
4$
                bra     CDCmdResponse                                   ; Response to drive command
5$
d246 7
d254 9
a262 1
ResponseLen:    dc.b    3,3,3,3,3,0,14,3,3,0,0,0,0,0,0,0
d264 3
d271 1
a271 1
*    CDCmdResponse - Response to standard command                      *
d277 4
a280 2
CDCmdResponse
                move.l  a1,db_PacketAddress(db)                         ; Remember address of packet
d328 1
a328 1
*       in:  A1 = packet address                                       *
d333 5
d342 4
a345 1
                tst.b   1(a1)                                           ; Is this Q-Code packet valid?
d347 3
a349 1
                tst.b   2(a1)
d351 3
a353 2
                
                move.b  3(a1),d0                                        ; Is this a position packet?
d358 3
a360 1
                tst.b   4(a1)                                           ; TNO must be zero during lead-in track
d363 3
a365 3
                clr.w   d0                                              ; First track?
                lea     db_TOC(db),a0
                move.b  5(a1),d0
d368 2
a369 1
                move.b  10(a1),d0
d376 2
a377 1
                move.b  10(a1),d0
d384 2
a385 1
                tst.b   TOCS_LastTrack(a0)
d387 7
a393 1
                move.l  9(a1),d0
a396 7

                move.b  TOCS_LastTrack(a0),d1                           ; Create a false entry just past table of contents
                addq.w  #1,d1
                save    d2
                move.w  d1,d2
                mulu    #TOCEntry_SIZE,d2
                move.b  d1,TOCE_Track(a0,d2.w)
a397 1
                restore d2
d406 9
a414 5
                move.w  d0,d1                                           ; Make a TOC entry
                mulu    #TOCEntry_SIZE,d1
                move.b  d0,TOCE_Track(a0,d1.w)
                move.b  3(a1),TOCE_CtlAdr(a0,d1.w)
                move.l  9(a1),d0
d417 1
a417 1
                move.l  d0,TOCE_Position(a0,d1.w)
d419 1
a419 2
                lea     db_TOC(db),a0                                   ; Is summary information valid?
                cmp.b   #1,TOCS_FirstTrack(a0)
d423 2
d426 3
a428 3
                move.w  #0,d0                                           ; Are all entries (including lead-out track) valid?
                move.w  #TOCEntry_SIZE,d1
6$              tst.b   TOCE_Track(a0,d1.w)
d430 3
a432 3
                addq.w  #1,d0
                add.w   #TOCEntry_SIZE,d1
                cmp.b   TOCS_LastTrack(a0),d1
d435 4
d441 10
d454 26
d488 1
a488 1
                move.b  #0,CDPBX                                        ; Clear the interrupt
d490 2
d504 2
@


1.2
log
@all kinds of changes.
@
text
@d2 16
a17 16
        INCLUDE "include:exec/types.i"
        INCLUDE "include:exec/nodes.i"
        INCLUDE "include:exec/lists.i"
        INCLUDE "include:exec/ports.i"
        INCLUDE "include:exec/libraries.i"
        INCLUDE "include:exec/tasks.i"
        INCLUDE "include:exec/devices.i"
        INCLUDE "include:exec/memory.i"
        INCLUDE "include:exec/interrupts.i"
        INCLUDE "include:exec/resident.i"
        INCLUDE "include:exec/io.i"
        INCLUDE "include:exec/errors.i"
        INCLUDE "include:exec/execbase.i"
        INCLUDE "include:hardware/intbits.i"
        INCLUDE "include:devices/trackdisk.i"
        INCLUDE "include:exec/ables.i"
@


1.1
log
@Initial revision
@
text
@a0 13
************************************************************************
***                                                                  ***
***                    -= CDTV DEVICE DRIVER =-                      ***
***                                                                  ***
************************************************************************
***                                                                  ***
***     CONFIDENTIAL and PROPRIETARY                                 ***
***     Copyright (c) 1990 by Commodore-Amiga, Inc.                  ***
***     Created by Carl Sassenrath, Sassenrath Research, Ukiah, CA   ***
***                                                                  ***
***     Modified 6/1/91: Jerry Horanoff                              ***
***                                                                  ***
************************************************************************
d25 3
a27 3
***
***  External References
***
d33 7
d41 3
a43 1
        XREF    StartTransfer
d45 2
d48 30
d80 3
a82 5
***
***  IntrProc
***
***     Main interrupt processing routine
***
d86 3
a88 2
                move.l  a1,db                                           ; Get hardware address
                move.l  db_HardwareBase(db),hb
d90 1
a90 2
                ; check to see if this is our interrupt
                bne     ServiceInt
d94 2
d97 3
a99 1
                save    d2-d4
d101 18
a118 1
                restore d2-d4                                           ; Clear server chain
a123 1
*
d125 26
a150 6
***
***  CDIntPlayDone
***
***     Play/Sample complete.  Execute next segment or signal complete
***
************************************************************************
d152 30
a181 2
CDIntPlayDone
                SIGNAL  SIGF_PLAYDONE                                   ; Signal task about play completion
d183 18
d203 1
a204 12
************************************************************************
***
***  CDIntDone
***
***     Command Complete or PLAY understood
***
************************************************************************

CDIntDone
                SIGNAL  SIGF_CMDDONE                                    ; Command completed (or started)

                rts
d208 22
a229 6
***
***  CDIntXLDMADone
***
***     CDXL Transfer entry complete
***
************************************************************************
d231 4
a234 3
CDIntXLDMADone
                save    a2                                              ; Check to see if we can transfer more of the dame entry
                move.l  db_XferEntry(db),a2
d236 2
a237 2
                move    #0,d1                                           ; Start next part of transfer
                bsr     StartTransfer
a238 2
                tst.l   d0                                              ; Transfer complete?
                bne     9$
d240 62
a301 4
                move.l  CDXL_DoneFunc(a2),d0                            ; Notify client that transfer is complete
                beq.s   2$
                move.l  d0,a0
                jsr     (a0)
d303 18
a320 6
                move.l  (a2),a2                                         ; Next transfer list entry
                tst.l   (a2)
                beq.s   3$
                move.l  a2,db_XferEntry(db)
                clr.l   CDXL_Actual(a2)
                bra.s   1$
d322 67
a388 6
                clr.l   db_ARG4(db)                                     ; Tell drive we don't want anymore data

                ; do DMA handshake
9$
                restore a2
                rts
d390 2
d393 2
d396 4
a399 7
************************************************************************
***
***  CDIntSubCode
***
***     Subcode Frame complete, call frame functions
***
************************************************************************
d401 5
a405 2
CDIntSubCode
                bsr     FrameFuncs                                      ; Call frame function
d409 1
a409 1
                beq     1$
a410 1
1$:
d412 3
a414 64




*
*=======================================================================
*==
*==  FrameFuncs
*==
*==     Call back frame synchornized functions.
*==
*=======================================================================

FrameFuncs:
                save    a2                                              ; Traverse frame function list (if present)
                lea     db_FrameList(db),a2
1$:             move.l  (a2),a2
                tst.l   (a2)
                beq.s   3$

                addq.l  #1,IO_ACTUAL(a2)                                ; Time to call this function?
                move.l  IO_ACTUAL(a2),d0
                cmp.l   IO_OFFSET(a2),d0
                blt.s   1$

                move.l  IO_DATA(a2),d0                                  ; Call the frame function if one is defined
                beq.s   2$
                move.l  d0,a1   
                jsr     (a1)
2$:             clr.l   IO_ACTUAL(a2)
                bra.s   1$

3$:             restore a2                                              ; All done
                rts


*=======================================================================
*==
*==  BumpFade
*==
*==     Adjust attenuator up or down to create the correct fade
*==     effect.
*==
*=======================================================================

BumpFade:
                move.w  db_Attenuation(db),d0                           ; Load up registers
                move.w  db_TargetAttenuation(db),d1

                cmp.w   d0,d1                                           ; Fade up or down?
                bhi     2$

                sub.w   db_FadeStepSize(db),d0                          ; Fade down until we reach target
                cmp.w   d1,d0
                bhi     1$
                move.w  d1,d0
1$              move.w  d0,db_Attenuation(db)
                bra     4$
2$
                add.w   db_FadeStepSize(db),d0                          ; Fade up until we reach target
                cmp.w   d1,d0
                blo     3$
                move.w  d1,d0
3$              move.w  d0,db_Attenuation(db)
a415 1
                bsr     Attenuate                                       ; Set the attenuator
d417 1
@
