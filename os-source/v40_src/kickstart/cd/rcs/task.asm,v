head     1.42;
branch   ;
access   ;
symbols  ;
locks    jerryh:1.42; strict;
comment  @* @;


1.42
date     94.02.14.09.49.34;  author jerryh;  state Exp;
branches ;
next     1.41;

1.41
date     93.10.12.16.12.44;  author jerryh;  state Exp;
branches ;
next     1.40;

1.40
date     93.09.08.11.15.12;  author jerryh;  state Exp;
branches ;
next     1.39;

1.39
date     93.09.08.10.57.16;  author jerryh;  state Exp;
branches ;
next     1.38;

1.38
date     93.09.08.10.41.13;  author jerryh;  state Exp;
branches ;
next     1.37;

1.37
date     93.08.12.13.44.02;  author jerryh;  state Exp;
branches ;
next     1.36;

1.36
date     93.05.14.09.57.45;  author jerryh;  state Exp;
branches ;
next     1.35;

1.35
date     93.04.23.14.22.41;  author jerryh;  state Exp;
branches ;
next     1.34;

1.34
date     93.04.14.16.36.55;  author jerryh;  state Exp;
branches ;
next     1.33;

1.33
date     93.04.14.16.32.52;  author jerryh;  state Exp;
branches ;
next     1.32;

1.32
date     93.04.12.15.48.56;  author jerryh;  state Exp;
branches ;
next     1.31;

1.31
date     93.04.08.11.54.10;  author jerryh;  state Exp;
branches ;
next     1.30;

1.30
date     93.04.02.09.12.07;  author jerryh;  state Exp;
branches ;
next     1.29;

1.29
date     93.03.31.16.36.51;  author jerryh;  state Exp;
branches ;
next     1.28;

1.28
date     93.03.30.14.27.15;  author jerryh;  state Exp;
branches ;
next     1.27;

1.27
date     93.03.29.13.33.25;  author jerryh;  state Exp;
branches ;
next     1.26;

1.26
date     93.03.23.09.25.27;  author jerryh;  state Exp;
branches ;
next     1.25;

1.25
date     93.03.19.16.40.24;  author jerryh;  state Exp;
branches ;
next     1.24;

1.24
date     93.03.19.13.44.47;  author jerryh;  state Exp;
branches ;
next     1.23;

1.23
date     93.03.18.14.48.49;  author jerryh;  state Exp;
branches ;
next     1.22;

1.22
date     93.03.01.14.53.55;  author jerryh;  state Exp;
branches ;
next     1.21;

1.21
date     93.02.26.14.25.43;  author jerryh;  state Exp;
branches ;
next     1.20;

1.20
date     93.02.23.15.52.35;  author jerryh;  state Exp;
branches ;
next     1.19;

1.19
date     93.02.17.15.32.08;  author jerryh;  state Exp;
branches ;
next     1.18;

1.18
date     93.02.16.15.58.45;  author jerryh;  state Exp;
branches ;
next     1.17;

1.17
date     93.02.15.10.16.27;  author jerryh;  state Exp;
branches ;
next     1.16;

1.16
date     93.02.09.15.50.37;  author jerryh;  state Exp;
branches ;
next     1.15;

1.15
date     93.02.08.16.37.49;  author jerryh;  state Exp;
branches ;
next     1.14;

1.14
date     93.02.03.12.09.12;  author jerryh;  state Exp;
branches ;
next     1.13;

1.13
date     93.02.03.12.01.06;  author jerryh;  state Exp;
branches ;
next     1.12;

1.12
date     93.02.02.17.07.04;  author jerryh;  state Exp;
branches ;
next     1.11;

1.11
date     93.01.15.15.40.27;  author jerryh;  state Exp;
branches ;
next     1.10;

1.10
date     93.01.07.09.37.38;  author jerryh;  state Exp;
branches ;
next     1.9;

1.9
date     92.12.12.17.44.37;  author jerryh;  state Exp;
branches ;
next     1.8;

1.8
date     92.12.11.13.34.41;  author jerryh;  state Exp;
branches ;
next     1.7;

1.7
date     92.12.09.15.20.35;  author jerryh;  state Exp;
branches ;
next     1.6;

1.6
date     92.12.07.11.58.11;  author jerryh;  state Exp;
branches ;
next     1.5;

1.5
date     92.12.05.16.53.13;  author jerryh;  state Exp;
branches ;
next     1.4;

1.4
date     92.12.04.10.19.15;  author jerryh;  state Exp;
branches ;
next     1.3;

1.3
date     92.11.23.09.21.31;  author jerryh;  state Exp;
branches ;
next     1.2;

1.2
date     92.11.02.13.32.04;  author jerryh;  state Exp;
branches ;
next     1.1;

1.1
date     92.10.21.15.03.09;  author jerryh;  state Exp;
branches ;
next     ;


desc
@device driver task and all device commands.
@


1.42
log
@Replaces drive light on and off commands with a jsr to LightOn/OFF.
@
text
@ 

        INCLUDE "exec/types.i"
        INCLUDE "exec/nodes.i"
        INCLUDE "exec/lists.i"
        INCLUDE "exec/ports.i"
        INCLUDE "exec/libraries.i"
        INCLUDE "exec/tasks.i"
        INCLUDE "exec/devices.i"
        INCLUDE "exec/memory.i"
        INCLUDE "exec/interrupts.i"
        INCLUDE "exec/resident.i"
        INCLUDE "exec/io.i"
        INCLUDE "exec/errors.i"
        INCLUDE "exec/execbase.i"
        INCLUDE "hardware/intbits.i"
        INCLUDE "devices/trackdisk.i"
        INCLUDE "utility/tagitem.i"
        INCLUDE "exec/ables.i"

        INCLUDE "defs.i"
        INCLUDE "cd.i"
        INCLUDE "cdprivate.i"
        INCLUDE "cdgs_hw.i"

        OPT     p=68020

************************************************************************
***
***  External References
***
************************************************************************

        XREF    MSFtoLSNPOS
        XREF    LSNtoMSFPOS
        XREF    MSFtoLSN
        XREF    LSNtoMSF
        XREF    BCDtoBIN
        XREF    MSFBINtoBCD
        XREF    MSFBCDtoBIN
        XREF    Attenuate
        XREF    Open
        XREF    Close
        XREF    Expunge
        XREF    PerformIO
        XREF    SetSubcodeInterrupt
        XREF    ClearSubcodeInterrupt
        XREF    CauseInterruptList
        XREF    CheckSeekRange
        XREF    CheckPlayRange
        XREF    LightOff

        XREF    DoCmd
        XREF    DoPacket
        XREF    SendPacket
        XREF    READTOC
        XREF    ID_PACKET
        XREF    ClearPrefetch
        XREF    ClearPrefetchIfError
        XREF    CmdOpts
        XREF    StopRead

        XREF    Enable
        XREF    Disable

        XREF    PutHex
        XREF    PutChar

        XDEF    CDTask

        XDEF    NoCommand      
        XDEF    CmdReset       
        XDEF    CmdRead        
        XDEF    CmdWrite       
        XDEF    CmdUpdate      
        XDEF    CmdClear       
        XDEF    CmdStop        
        XDEF    CmdStart       
        XDEF    CmdFlush       
        XDEF    CmdMotor       
        XDEF    CmdSeek        
        XDEF    CmdFormat      
        XDEF    CmdRemove      
        XDEF    CmdChangeNum   
        XDEF    CmdChangeState 
        XDEF    CmdProtStatus  
        XDEF    CmdGetDriveType
        XDEF    CmdGetNumTracks
        XDEF    CmdAddChangeInt
        XDEF    CmdRemChangeInt
        XDEF    CmdGetGeometry 
        XDEF    CmdEject       
        XDEF    CmdInfo        
        XDEF    CmdConfig
        XDEF    CmdTOCMSF
        XDEF    CmdTOCLSN
        XDEF    CmdReadXL      
        XDEF    CmdPlayTrack   
        XDEF    CmdPlayMSF
        XDEF    CmdPlayLSN      
        XDEF    CmdPause       
        XDEF    CmdSearch
        XDEF    CmdQCodeMSF
        XDEF    CmdQCodeLSN     
        XDEF    CmdAttenuate   
        XDEF    CmdAddFrameInt 
        XDEF    CmdRemFrameInt 

        INT_ABLES

*
************************************************************************
*                                                                      *
*   CD DEVICE DRIVER TASK                                              *
*                                                                      *
*       This is the task that runs the device driver.  Its main        *
*       body is a loop that reads requests from two message ports,     *
*       performs commands, and replies to the requests.                *
*                                                                      *
*       Two message ports are used to catagorize the requests into     *
*       two different classes:  Requests that directly access the      *
*       CD, and requests that don't or that only modify the behavior   *
*       of requests that do.  A PAUSE command for example modifies     *
*       the behavior of a PLAY command, but it doesn't effect the      *
*       request itself (aside from making the request finish later).   *
*                                                                      *
************************************************************************

CDTask:
                move.l  4(sp),db                                        ; Get device base arg and init hardware
                move.l  #CDHARDWARE,hb

                clr.l   d0                                              ; Clear all command signals
                move.l  #SIGF_CMDDONE|SIGF_PLAYDONE|SIGF_ABORTDRIVE,d1
                exec    SetSignal

                jsr     ID_PACKET                                       ; Get drive ID and set state open/closed

                jsr     READTOC                                         ; Try and detect a disk

                move.l  db_InitTask(db),a1                              ; Signal initialization task that we are running
                move.b  db_InitSignal(db),d1
                move.l  #1,d0
                lsl.l   d1,d0
                exec    Signal
TaskLoop
                clr.l   d0                                              ; Check for signals first
                move.l  d0,d1
                exec    SetSignal
                move.l  d0,d2
TestSignals

*************** Test Drive Abort Signal ********************************

                btst    #SIGB_ABORTDRIVE,d2                             ; Abort disk command?
                beq     CheckPlaySig

                clr.l   d0                                              ; Clear this signal
                move.l  #SIGF_ABORTDRIVE,d1
                exec    SetSignal

                move.w  db_Info+CDINFO_Status(db),d0                    ; If we are playing, play is now complete
                btst    #CDSTSB_PLAYING,d0
                bne     PlayComplete


*************** Play Complete ******************************************

CheckPlaySig
                btst    #SIGB_PLAYDONE,d2                               ; Play command complete?
                beq     CheckDiskChangeSig

                clr.l   d0                                              ; Clear this signal
                move.l  #SIGF_PLAYDONE,d1
                exec    SetSignal
PlayComplete
                move.w  db_Info+CDINFO_Status(db),d0                    ; If our play was aborted by a disk change, don't
                btst    #CDSTSB_PLAYING,d0                              ;   do it again.
                beq     CheckDiskChangeSig

                jsr     ClearSubcodeInterrupt                           ; Turn off all subcode interrupts

                move.w  db_TargetAttenuation(db),d0                     ; Make sure fade has completed
                cmp.w   db_Attenuation(db),d0
                beq     1$
                move.w  d0,db_Attenuation(db)
                bsr     Attenuate
1$
                jsr     LightOff                                        ; Turn off drive light

                move.l  db_ClassDReq(db),ior                            ; If the play errored out, report error
                tst.b   db_PlayStatus(db)
                bpl     2$
                tst.b   IO_ERROR(ior)
                bne     2$
                move.b  #CDERR_BadDataType,IO_ERROR(ior)
2$
                move.b  IO_ERROR(ior),d0                                ; Return status (if error, clear actual)
                cmp.b   #CDERR_ABORTED,d0
                bne     3$

                move.b  #CHCMD_PAUSE,db_Packet(db)                      ; Stop playing audio
                jsr     DoPacket
3$
                and.w   #-1-CDSTSF_PLAYING,db_Info+CDINFO_Status(db)    ; No longer playing audio

                clr.l   db_ClassDReq(db)                                ; Class D command done

                move.l  ior,a1                                          ; Request complete
                exec    ReplyMsg


*************** Disk Changed *******************************************

CheckDiskChangeSig

                btst    #SIGB_DISKCHANGE,d2                             ; Disk change signal?
                beq     ScanMsgPorts

                clr.l   d0                                              ; Clear this signal
                move.l  #SIGF_DISKCHANGE,d1
                exec    SetSignal

                tst.b   db_OpenState(db)                                ; Is the drawer now openned?
                bne     1$

                move.w  #0,db_Info+CDINFO_Status(db)                    ; Door now open.  Nothing about drive is true.

                move.l  #-2,db_SeekAdjustment(db)                       ; - Recalculate seek adjustment when disk is inserted
                clr.b   db_PhotoCD(db)                                  ; - PhotoCD disk not present
                jsr     ClearPrefetch                                   ; - Clear read prefetch buffer
                bra     2$
1$
                or.w    #CDSTSF_CLOSED,db_Info+CDINFO_Status(db)        ; Door is closed

                jsr     READTOC                                         ; Try and detect disk
2$
                addq.l  #1,db_ChgCount(db)                              ; Increment change count

                lea     db_ChgList(db),a0                               ; Cause disk change interrupts
                bsr     CauseInterruptList


*************** Scan Message Ports *************************************

ScanMsgPorts
                lea     db_ClassACmdPort(db),a0                         ; Check for a new non-disk-access type cmd
                exec    GetMsg
                tst.l   d0
                bne     ProcessACmd

                move.l  db_ClassDReq(db),d0                             ; Check status of current disk-access cmd
                bne     1$
                lea     db_ClassDCmdPort(db),a0
                exec    GetMsg
                move.l  d0,db_ClassDReq(db)
                bne     ProcessDCmd
1$
                move.l  #TASK_SIGS,d0                                   ; Wait for something to happen
                exec    Wait
                move.l  d0,d2

                bra     TestSignals


*************** Process Class A Command ********************************

ProcessACmd
                move.l  d0,ior                                          ; Perform the function (Class A)
                jsr     PerformIO

                move.l  ior,a1                                          ; Reply to command
                exec    ReplyMsg

                move.l  #CLASSA_SIGS,d1                                 ; Clear signals that should not be set
                clear   d0
                exec    SetSignal

                bra     TaskLoop


*************** Process Class D Command ********************************

ProcessDCmd
                move.l  d0,ior                                          ; Perform IO operation (Class D)
                jsr     PerformIO

                move.b  IO_ERROR(ior),d0                                ; Could we even start the command?
                beq     1$
                cmp.b   #CDERR_ABORTED,d0
                bne     2$
1$
                move.w  IO_COMMAND(ior),d0                              ; If multitasking command, don't reply yet
                lea     CmdOpts(pc),a1
                add.w   d0,d0
                move.w  0(a1,d0.w),d1
                btst    #OB_MULTITASK,d1
                bne     TaskLoop
2$
                clr.l   db_ClassDReq(db)                                ; Class D command done

                move.l  ior,a1                                          ; Normal command, reply and return
                exec    ReplyMsg

                move.l  #CLASSD_SIGS,d1                                 ; Clear signals that should not be set
                clear   d0
                exec    SetSignal

                bra     TaskLoop


*
******* cd.device/CD_READ ****************************************************
*
*   NAME
*       CD_READ -- read data from disk.
*
*   FUNCTION
*       Reads data from the CD into memory.  Data may be accessed on WORD
*       boundaries (you are not restricted to sector boundaries as with
*       normal disk devices).  Data lengths can also be described in WORD
*       amounts.
*
*   IO REQUEST INPUT
*       io_Device       preset by the call to OpenDevice()
*       io_Unit         preset by the call to OpenDevice()
*       io_Command      CD_READ
*       io_Data         pointer to the buffer where the data should be put
*       io_Length       number of bytes to read, must be a WORD multiple.
*       io_Offset       byte offset from the start of the disk describing
*                       where to read data from, must be a WORD multiple.
*
*   IO REQUEST RESULT
*       io_Error  - 0 for success, or an error code as defined in
*                   <devices/cd.h>
*       io_Actual - if io_Error is 0, number of bytes actually transferred
*
*   NOTES
*       If an error occurs when attempting a CD_READ, the software will
*       retry up to 10 times before giving up on the request.  If the
*       drive is in double-speed and an error occurs, the software will
*       retry once more in double-speed, and if this fails, will retry
*       the next 9 times in single-speed.
*
*   SEE ALSO
*       CD_READXL
*
******************************************************************************

CmdRead:
                move.w  db_Info+CDINFO_Status(db),d0                            ; There must be a ROM track
                btst    #CDSTSB_CDROM,d0
                beq     Read_NoROMErr

                clr.w   db_RetryCount(db)                                       ; Initialize retry counter

                move.l  IO_OFFSET(ior),d0                                       ; These fields must be even
                or.l    IO_LENGTH(ior),d0
                btst    #0,d0
                bne     Read_BadLength

                move.l  IO_DATA(ior),d0                                         ; Must be word aligned
                btst    #0,d0
                bne     Read_BadAddress

                save    d3
                clr.l   d3                                                      ; Current drive speed
                move.w  db_Info+CDINFO_ReadSpeed(db),d3
1$
                move.l  IO_OFFSET(ior),d1                                       ; Convert offset to block
                clr.l   d0
                move.w  db_Info+CDINFO_SectorSize(db),d0
                divul.l d0,d1

                move.l  IO_LENGTH(ior),d2                                       ; Convert length to stop offset
                sub.l   #1,d2
                divul.l d0,d2
                add.l   d1,d2

                jsr     CheckPlayRange                                          ; check range of read
                bne     readinvalidlength

                move.w  #CDCMD_READ,db_CMD(db)                                  ; Read data

                lea     db_XferNode(db),a1                                      ; Create transfer entry
                move.l  a1,db_XferEntry(db)
                move.l  IO_OFFSET(ior),db_ARG1(db)                              ; - Store start block
                move.l  IO_DATA(ior),db_ARG2(db)                                ; - Start of XL node
                move.l  IO_DATA(ior),CDXL_Buffer(a1)
                move.l  IO_LENGTH(ior),CDXL_Length(a1)
                move.l  IO_LENGTH(ior),db_ARG3(db)
                move.l  #$7FFFFFF0,db_ARG5(db)
                move.l  d3,db_ARG4(db)                                          ; - Set desired drive speed
                clr.l   CDXL_IntCode(a1)
                clr.l   IO_ACTUAL(ior)                                          ; - Current actual amount transferred
                clr.l   CDXL_Actual(a1)
                lea     db_ListEnd(db),a0
                clr.l   (a0)
                move.l  a0,MLN_SUCC(a1)
                move.b  #1,db_ECC(db)                                           ; - Enable ECC of data

                jsr     DoCmd                                                   ; Do the read

                beq     6$                                                      ; Read error?
                cmp.b   #CDERR_ABORTED,d0
                beq     6$
                cmp.b   #CDERR_NoDisk,d0
                beq     6$

                jsr     ClearPrefetchIfError                                    ; Clear read prefetch buffer if an error occurred

                add.w   #1,db_RetryCount(db)                                    ; If error, retry
                cmp.w   #2,db_RetryCount(db)
                bne     4$

                move.w  #75,d3                                                  ; Switch to normal speed.  Too many errors
4$
                cmp.w   #10,db_RetryCount(db)
                bhi     6$

                exec    Forbid                                                  ; Cancel error if not aborted
                cmp.b   #CDERR_ABORTED,IO_ERROR(ior)
                beq     5$
                clr.b   IO_ERROR(ior)
5$              exec    Permit

                bra     1$
6$
                move.l  IO_LENGTH(ior),d0                                       ; Set actual
                move.l  d0,IO_ACTUAL(ior)
                restore d3
                rts

readinvalidlength:
                restore d3
                move.b  #IOERR_BADLENGTH,IO_ERROR(ior)                          ; Length invalid
                rts


******* cd.device/CD_MOTOR ***************************************************
*
*   NAME
*       CD_MOTOR -- control the on/off state of a drive motor.
*
*   FUNCTION
*       This command gives control over the spindle motor.  The motor may be
*       turned on or off.
*
*       If the motor is just being turned on, the device will delay the
*       proper amount of time to allow the drive to come up to speed.
*       Turning the motor on or off manually is not necessary, the device does
*       this automatically if it receives a request when the motor is off.
*
*   IO REQUEST INPUT
*       io_Device       preset by the call to OpenDevice()
*       io_Unit         preset by the call to OpenDevice()
*       io_Command      CD_MOTOR
*       io_Length       the requested state of the motor, 0 to turn the motor
*                       off, and 1 to turn the motor on.
*
*   IO REQUEST RESULT
*       io_Error - 0 for success, or an error code as defined in
*                  <devices/cd.h>
*       io_Actual - if io_Error is 0 this contains the previous state of the
*                   drive motor.
*
******************************************************************************

CmdMotor:
                clr.l   IO_ACTUAL(ior)                                          ; io_Actual = motor status
                move.w  db_Info+CDINFO_Status(db),d1
                btst    #CDSTSB_SPIN,d1
                sne.b   IO_ACTUAL+3(ior)
                clr     d0

                tst.l   IO_LENGTH(ior)                                          ; Turn motor on?
                beq.s   1$

                btst    #CDSTSB_SPIN,d1                                         ; Already spinning?
                bne     3$

                move.w  #CDCMD_SPIN,db_CMD(db)                                  ; Spin it up
                bra     2$

1$:             btst    #CDSTSB_SPIN,d1                                         ; Already stopped?
                beq     3$

                move.w  #CDCMD_STOP,db_CMD(db)                                  ; Spin it down
2$:
                bsr     DoCmd                                                   ; Send command and get error
3$:
                rts

*
******* cd.device/CD_SEEK ****************************************************
*
*   NAME
*       CD_SEEK -- position laser at specified location.
*
*   FUNCTION
*       CD_SEEK moves the laser to the approximate position specified.  The
*       io_Offset field should be set to the offset to which the head is
*       to be positioned.
*
*   IO REQUEST INPUT
*       io_Device       preset by the call to OpenDevice()
*       io_Unit         preset by the call to OpenDevice()
*       io_Command      CD_SEEK
*       io_Offset       position where head is to be moved (always LSN format)
*
*   IO REQUEST RESULT
*       io_Error - 0 for success, or an error code as defined in
*                  <devices/cd.h>
*
******************************************************************************

CmdSeek:
                save    d0                                                      ; If we are prefetching, stop it
                clr.w   d0
                jsr     StopRead
                restore d0

                move.w  #CDCMD_SEEK,db_CMD(db)                                  ; Seek

                move.l  IO_OFFSET(ior),d1                                       ; Convert offset to block
                clr.l   d0
                move.w  db_Info+CDINFO_SectorSize(db),d0
                divul.l d0,d1

                jsr     CheckSeekRange                                          ; Check range of seek
                bne     seekinvalidlength

                move.l  d1,db_ARG1(db)                                          ; Seek to here

                bsr     DoCmd                                                   ; Do it
                rts

seekinvalidlength:
                move.b  #IOERR_BADLENGTH,IO_ERROR(ior)                          ; Length invalid
                rts


*
******* cd.device/CD_CHANGENUM ***********************************************
*
*   NAME
*       CD_CHANGENUM -- return the current value of the disk-change counter.
*
*   FUNCTION
*       This command returns the current value of the disk-change counter
*       The disk change counter is incremented each time a disk is inserted
*       or removed from the cd unit.
*
*   IO REQUEST INPUT
*       io_Device       preset by the call to OpenDevice()
*       io_Unit         preset by the call to OpenDevice()
*       io_Command      CD_CHANGENUM
*
*   IO REQUEST RESULT
*       io_Error - 0 for success, or an error code as defined in
*                  <devices/cd.h>
*       io_Actual - if io_Error is 0, this contains the current value of the
*                   disk-change counter.
*
******************************************************************************

CmdChangeNum:
                move.l  db_ChgCount(db),IO_ACTUAL(ior)                          ; Return change count
                rts


******* cd.device/CD_CHANGESTATE *********************************************
*
*   NAME
*       CD_CHANGESTATE -- check if a "valid" disk is currently in a drive.
*
*   FUNCTION
*       This command checks to see if there is a "valid" disk in a drive.
*
*   IO REQUEST INPUT
*       io_Device       preset by the call to OpenDevice()
*       io_Unit         preset by the call to OpenDevice()
*       io_Command      CD_CHANGESTATE
*
*   IO REQUEST RESULT
*       io_Error - 0 for success, or an error code as defined in
*                  <devices/cd.h>
*       io_Actual - 0 means there is a disk while anything else indicates
*                   there is no disk.
*
*   NOTES
*       A "valid" disk is a disk with a readable table of contents.
*
******************************************************************************

CmdChangeState:
                move.w  db_Info+CDINFO_Status(db),d0                            ; Return disk insertion state
                btst    #CDSTSB_TOC,d0
                seq     IO_ACTUAL+3(ior)
                rts


******* cd.device/CD_PROTSTATUS **********************************************
*
*   NAME
*       CD_PROTSTATUS -- return whether the current disk is write-protected.
*
*   FUNCTION
*       This command is used to determine whether the current disk is
*       write-protected.  Currently, this function always returns write-
*       protected status.  If write-once CDs are made available at some point,
*       this may change.
*
*   IO REQUEST INPUT
*       io_Device       preset by the call to OpenDevice()
*       io_Unit         preset by the call to OpenDevice()
*       io_Command      CD_PROTSTATUS
*
*   IO REQUEST RESULT
*       io_Error - 0 for success, or an error code as defined in
*                  <devices/cd.h>
*       io_Actual - 0 means the disk is NOT write-protected, while any other
*                   value indicates it is.
*
******************************************************************************

CmdProtStatus:
                move.l  #1,IO_ACTUAL(ior)                                       ; Always write protected
                rts


*****i* cd.device/CD_GETDRIVETYPE ********************************************
*
*   NAME
*       CD_GETDRIVETYPE -- return the type of disk drive for the unit that was
*                          opened.
*
*   FUNCTION
*       This command returns the type of the disk drive to the user.
*       This number will be a small integer and will come from the set of
*       DRIVEXXX constants defined in <devices/trackdisk.h>.
*
*   IO REQUEST INPUT
*       io_Device       preset by the call to OpenDevice()
*       io_Unit         preset by the call to OpenDevice()
*       io_Command      CD_GETDRIVETYPE
*
*   IO REQUEST RESULT
*       io_Error - 0 for success, or an error code as defined in
*                  <devices/cd.h>
*       io_Actual - if io_Error is 0 this contains the drive type connected to
*                   this unit.
*
*   NOTES
*       The best way to get the drive type is with the CD_GETGEOMETRY command.
*
*   SEE ALSO
*       CD_GETGEOMETRY, <devices/cd.h>, <devices/trackdisk.h>
*
******************************************************************************

CmdGetDriveType:
                move.b  #IOERR_NOCMD,IO_ERROR(ior)                              ; Not supported on the game machine
                rts


*
*****i* cd.device/CD_GETNUMTRACKS ********************************************
*
*   NAME
*       CD_GETNUMTRACKS -- return the number of tracks for the type of disk
*                          drive for the unit that was opened.
*
*   FUNCTION
*       This command returns the number of tracks that are available
*       on the disk unit (always 1).
*
*   IO REQUEST INPUT
*       io_Device       preset by the call to OpenDevice()
*       io_Unit         preset by the call to OpenDevice()
*       io_Command      CD_GETNUMTRACKS
*
*   IO REQUEST RESULT
*       io_Error - 0 for success, or an error code as defined in
*                  <devices/cd.h>
*       io_Actual - if io_Error is 0, this returns the number of tracks on
*                   the CD (the CD always has 1 big track).
*
*   SEE ALSO
*       CD_GETGEOMETRY
*
******************************************************************************

CmdGetNumTracks:
                move.l  #1,IO_ACTUAL(ior)                                       ; 1 Large track
                rts


******* cd.device/CD_ADDCHANGEINT ********************************************
*
*   NAME
*       CD_ADDCHANGEINT -- add a disk change software interrupt handler.
*
*   FUNCTION
*       This command lets you add a software interrupt handler to the
*       disk device that gets invoked whenever a disk insertion or removal
*       occurs.
*
*       You must pass in a properly initialized Exec Interrupt structure
*       and be prepared to deal with disk insertions/removals immediately.
*       The interrupt is generated by the exec Cause function, so you must
*       preserve A6.
*
*       To set up the handler, an Interrupt structure must be initialized.
*       This structure is supplied as the io_Data to the CD_ADDCHANGEINT
*       command.  The handler then gets linked into the handler chain and
*       gets invoked whenever a disk change happens.  You must eventually
*       remove the handler before you exit.
*
*       This command only returns when the handler is removed. That is,
*       the device holds onto the IO request until the CD_REMCHANGEINT command
*       is executed with that same IO request.  Hence, you must use SendIO()
*       with this command.
*
*   IO REQUEST INPUT
*       io_Device       preset by the call to OpenDevice()
*       io_Unit         preset by the call to OpenDevice()
*       io_Command      CD_ADDCHANGEINT
*       io_Length       sizeof(struct Interrupt)
*       io_Data         pointer to Interrupt structure
*
*   IO REQUEST RESULT
*       io_Error - 0 for success, or an error code as defined in
*                  <devices/cd.h>
*
*   SEE ALSO
*       CD_REMCHANGEINT, <devices/cd.h>, <exec/interrupts.h>,
*       exec.library/Cause()
*
******************************************************************************

CmdAddChangeInt:
                lea     db_ChgList(db),a0                                       ; Interrupt list
AddRequest:
                exec    Forbid                                                  ; Add request to list
                move.l  ior,a1
                exec    AddHead
                exec    Permit
                bclr.b  #IOB_QUICK,IO_FLAGS(ior)
                rts

******* cd.device/CD_REMCHANGEINT ********************************************
*
*   NAME
*       CD_REMCHANGEINT -- remove a disk change software interrupt handler.
*
*   FUNCTION
*       This command removes a disk change software interrupt added
*       by a previous use of CD_ADDCHANGEINT.
*
*   IO REQUEST INPUT
*       The same IO request used for CD_ADDCHANGEINT.
*
*       io_Device       preset by the call to OpenDevice()
*       io_Unit         preset by the call to OpenDevice()
*       io_Command      CD_REMCHANGEINT
*       io_Length       sizeof(struct Interrupt)
*       io_Data         pointer to Interrupt structure
*
*   IO REQUEST RESULT
*       io_Error - 0 for success, or an error code as defined in
*                  <devices/cd.h>
*
*   SEE ALSO
*       CD_ADDCHANGEINT, <devices/cd.h>
*
******************************************************************************

CmdRemChangeInt:
RemoveRequest:
                exec    Forbid                                                 ; Remove interrupt from list
                move.l  ior,a1
                REMOVE
                exec    Permit
                bclr.b  #IOB_QUICK,IO_FLAGS(ior)
                rts


******* cd.device/CD_GETGEOMETRY *********************************************
*
*   NAME
*       CD_GETGEOMETRY -- return the geometry of the drive.
*
*   FUNCTION
*       This command returns a full set of information about the
*       layout of the drive. The information is returned in the
*       DriveGeometry structure pointed to by io_Data.
*
*   IO REQUEST INPUT
*       io_Device       preset by the call to OpenDevice()
*       io_Unit         preset by the call to OpenDevice()
*       io_Command      CD_GETGEOMETRY
*       io_Data         pointer to a DriveGeometry structure
*       io_Length       sizeof(struct DriveGeometry)
*
*   IO REQUEST RESULT
*       io_Error  - 0 for success, or an error code as defined in
*                   <devices/cd.h>
*       io_Actual - length of data transferred.
*
*   SEE ALSO
*       CD_GETNUMTRACKS, <devices/trackdisk.h>
*
******************************************************************************

CmdGetGeometry:
                move.w  db_Info+CDINFO_Status(db),d0                            ; Make sure TOC is valid first
                btst    #CDSTSB_TOC,d0
                beq     Geom_Error

                move.l  IO_DATA(ior),a1                                         ; 2k sectors
                clr.l   d0
                move.w  db_Info+CDINFO_SectorSize(db),d0
                move.l  d0,dg_SectorSize(a1)

                move.l  db_TOC+TOCS_LeadOut(db),d0                              ; Other miscellaneous reporting
                jsr     MSFtoLSNPOS
                move.l  d0,dg_TotalSectors(a1)
                move.l  #1,dg_Cylinders(a1)
                move.l  d0,dg_CylSectors(a1)
                move.l  #1,dg_Heads(a1)
                move.l  d0,dg_TrackSectors(a1)
                move.l  #MEMF_PUBLIC,dg_BufMemType(a1)

                move.b  #DG_CDROM,dg_DeviceType(a1)                             ; Removable CD-ROM disk
                move.b  #DGF_REMOVABLE,dg_Flags(a1)
                clr.w   dg_Reserved(a1)

                move.l  #dg_SIZEOF,IO_ACTUAL(ior)                               ; DriveGeometry length
                rts
Geom_Error:
                move.b  #CDERR_NoDisk,IO_ERROR(ior)                             ; Nothing to report
                move.l  #0,IO_ACTUAL(ior)
                rts


*
******* cd.device/CD_EJECT ***************************************************
*
*   NAME
*       CD_EJECT -- Open or close the CD's drive door
*
*   IO REQUEST
*       io_Command      CD_EJECT
*       io_Data         NULL
*       io_Length       requested state of drive door (0 == close, 1 == open)
*       io_Offset       0
*
*   RESULTS
*       io_Error        0 for success, or an error code as defined in
*                       <devices/cd.h>
*       io_Actual       previous state of drive door
*
*   FUNCTION
*       This command causes the CD-ROM drive's door to open or close.
*       The desired state of the drive door is placed in io_Length.  The
*       previous state of the drive door is returned in io_Actual.
*
*   EXAMPLE
*
*   NOTES
*
*   BUGS
*
*   SEE ALSO
*
******************************************************************************

CmdEject:
                move.b  #IOERR_NOCMD,IO_ERROR(ior)                              ; Not supported on the game machine
                rts


*
**************************************** Extended CD Commands ********************************************



******* cd.device/CD_INFO ****************************************************
*
*   NAME
*       CD_INFO -- Return information/status of device
*
*   IO REQUEST
*       io_Device       preset by the call to OpenDevice()
*       io_Unit         preset by the call to OpenDevice()
*       io_Command      CD_INFO
*       io_Data         pointer to CDInfo structure
*       io_Length       sizeof(struct CDInfo)
*
*   RESULTS
*       io_Error        0 for success, or an error code as defined in
*                       <devices/cd.h>
*       io_Actual       length of data transferred
*
*   FUNCTION
*
*       This command returns current configurations and status of the device
*       driver.
*
*   EXAMPLE
*
*       struct CDInfo Info;
*
*       ior->io_Command = CD_INFO;               /* Retrieve drive info.    */
*       ior->io_Data    = (APTR)Info;            /* Here's where we want it */
*       ior->io_Length  = sizeof(struct CDInfo); /* Return whole structure  */
*       DoIO(ior);
*
*       if (!ior->io_Error) {                    /* Command succeeded       */
*
*           if (Info.Status & CDSTSF_PLAYING) printf("Audio is playing\n");
*           else                              printf("Audio not playing\n");
*           }
*
*   NOTES
*
*   BUGS
*
*   SEE ALSO
*       <devices/cd.h>
*
******************************************************************************

CmdInfo:
                lea     db_Info(db),a0                                          ; Set up copy parameters
                move.l  IO_DATA(ior),a1
                move.l  IO_LENGTH(ior),d0
                cmp.l   #CDINFO_SIZE,d0
                bhi     Info_BadLength

                move.l  d0,IO_ACTUAL(ior)                                       ; Report actual data coppied
1$
                move.b  (a0)+,(a1)+                                             ; Do the copy
                subq.l  #1,d0
                bne     1$
                rts
Info_BadLength:
                move.b  #CDERR_BADLENGTH,IO_ERROR(ior)                          ; Length too big
                rts


*
******* cd.device/CD_CONFIG **************************************************
*
*   NAME
*       CD_CONFIG -- Set drive preferences
*
*   IO REQUEST
*       io_Device       preset by the call to OpenDevice()
*       io_Unit         preset by the call to OpenDevice()
*       io_Command      CD_CONFIG
*       io_Data         pointer to first entry of TagList
*       io_Length       0
*
*   RESULTS
*       io_Error        0 for success, or an error code as defined in
*                       <devices/cd.h>
*
*   FUNCTION
*       This command sets one or more of the configuration items.
*       The configuration items are:
*
*       TAGCD_PLAYSPEED                 Default: 75
*       TAGCD_READSPEED                 Default: 75 (do not count on this)
*       TAGCD_READXLSPEED               Default: 75
*       TAGCD_SECTORSIZE                Default: 2048
*       TAGCD_XLECC                     Default: 1 (on)
*       TAGCD_EJECTRESET                Default: can be 0 (off) or 1 (on)
*
*       The speed settings are described in the number of frames (sectors)
*       per second.  All CD-ROM drives are capable of the 75 frames/second
*       rate.  Some drives are capable of 150 frames/second, and some even
*       more.  To determine the maximum frame rate of the drive, use the
*       CD_INFO command.  Valid values for caddyless Commodore CD-ROM drives
*       are 75 and 150 (normal speed and double speed).  All other values are
*       invalid.  You should always make sure the drive is capable of the
*       configuration you are requesting by either using the CD_INFO command,
*       and/or by checking for an error condition after submitting your
*       request.
*
*       There are three different types of CD-ROM sectors.  Mode 1 sectors
*       (2048 bytes), mode 2 form 1 sectors (2048 bytes), and mode 2 form 2
*       sectors (2328 bytes).  Normally, disks are encoded in Mode 1 format.
*       Mode 2 form 1 is basically the same as mode 1; however, the mode 2
*       form 2 sector format contains no CD-ROM error correction information.
*       In order to read information encoded in this sector format, the
*       drive's sector size must be configured to 2328 byte sectors.
*
*       Error correction (ECC) of the READXL command can be turned off or
*       on with this command.  Error correction can be implemented in either
*       hardware or software (depending on the CD-ROM drive).  When ECC is
*       implemented in software, CPU usage can become bursty.  Errors rarely
*       occur on CDs unless they have numerous scratches, but when they do
*       occur, they will cause a loss of CPU bandwith.  When ECC is
*       implemented in hardware, no CPU bandwidth is lost -- in this case,
*       ECC will always be on no matter how you configure the drive because 
*       it is free.  The READXL command is used primarily for displaying
*       movie-like data.  In this case, speed is essential and data integrety
*       is not; however, if the CPU is not being utilized during an XL
*       animation there is no need to disable ECC (since the bandwidth is
*       there to be used).  The only time ECC should be disabled is when you
*       are doing intense calculations in the background of a READXL command,
*       AND your program is time-critical.  Do not forget to change this back
*       when you are done!
*       
*       To make the computer reset when a CD is ejected (for an application
*       that does not exit), use the TAGCD_EJECTRESET tag.  When possible,
*       titles should be able to exit cleanly back to Workbench.  Error
*       conditions should be monitored when doing disk I/O.
*
*   EXAMPLE
*       /* Configure ReadXL for double-speed reading and turn off ECC when */
*       /* the ReadXL command is used.                                     */
*       
*       struct TagItem ConfigList[] = {
*
*           { TAGCD_READXLSPEED, 150 },
*           { TAGCD_XLECC,       0   },
*           { TAG_END,           0   }
*           };
*
*           ior->io_Command = CD_CONFIG;
*           ior->io_Data    = (APTR)&ConfigList;
*           ior->io_Length  = 0;
*           DoIO(ior);
*
*           if (ior->io_Error) printf("Could not be configured\n");
*
*   NOTES
*       Setting the configuration will not modify the behavior of a read or
*       play command already in progress.
*
*       This can be a very dangerous command.  If for instance you set
*       TAGCD_SECTORSIZE to 2328, you will no longer be able to read any
*       data encoded at 2048 byte sectors (e.g. the file system will not be
*       able to read the disk anymore).  After you read any data stored with
*       this sector format, you should immediately configure back to the
*       original default value (even if the read failed -- the disk could
*       be removed in the middle of your read).  You should NEVER use this
*       command if you are not the exclusive owner of your disk.
*
*   BUGS
*       TAG_IGNORE, TAG_MORE, and TAG_SKIP do not work.  Do not use these.
*
*       When switching speeds from single to double (or double to single),
*       If the drive is prefetching in single-speed the data you are going
*       to use in double-speed, the drive will not switch to double-speed
*       (and visa versa).  To avoid this problem, switch to the desired speed,
*       begin reading at least 4k into the data (just read two bytes), then
*       begin reading at the beginning.  This will force the prefetch buffer
*       to clear and issue a new read command with the desired speed.
*       (Fixed in 40.24).
*
*   SEE ALSO
*       CD_INFO, <utility/tagitem.h>
*
******************************************************************************

CmdConfig:
                tst.l   IO_LENGTH(ior)                                          ; Make sure Length is zero
                bne     99$

                clr.w   d0                                                      ; Make sure TagList is valid
                jsr     SetTagList
                beq     1$
                rts
1$
                move.w  #1,d0                                                   ; TagList ok, assign values
                jsr     SetTagList
                rts
99$
                move.b  #IOERR_BADLENGTH,IO_ERROR(ior)                          ; Length invalid
                rts


*===============================================================================
*=                                                                             =
*=  SetTagList - Test tag list for validity or assign tag list values          =
*=                                                                             =
*=  in: d0.w = 0: just test taglist, 1: assign taglist                         =
*=                                                                             =
*===============================================================================

SetTagList:
                save    d2-d4/a2                                                ; Save flag
                move.w  d0,d4

                move.l  IO_DATA(ior),a0                                         ; Load up registers
                lea     ConfigTable(pc),a1
                lea     db_Info(db),a2
                clr.l   d0
                clr.w   d1
1$
                move.l  0(a0,d0.l),d2                                           ; Check each item to see if it is recognized
                beq     6$

                move.l  0(a1,d1.w),d3                                           ; Start with first item in device's list
                beq     5$

                cmp.l   d2,d3                                                   ; Are the entry Tags equal?
                bne     4$

                move.l  4(a0,d0.l),d2
                cmp.l   4(a1,d1.w),d2                                           ; Is this a valid value to assign?
                beq     3$
                cmp.l   8(a1,d1.w),d2
                beq     3$
                tst.l   12(a1,d1.w)
                beq     2$
                cmp.l   12(a1,d1.w),d2
                beq     3$
2$
                move.b  #IOERR_BADADDRESS,IO_ERROR(ior)
                bra     6$
3$
                tst.w   d4                                                      ; Is this just test mode?
                beq     4$

                move.l  d1,d3                                                   ; Assign the value
                lsr.w   #3,d3
                move.w  d2,0(a2,d3.w)
4$
                add.w   #16,d1                                                  ; Next entry in device's list
                bra     1$
5$
                clr.w   d1                                                      ; Next entry in submitted list
                add.l   #8,d0
                bra     1$
6$
                restore d2-d4/a2                                                ; All done, exit
                rts


ConfigTable:
                dc.l    TAGCD_PLAYSPEED,75,150,0                                ; Valid tags and values
                dc.l    TAGCD_READSPEED,75,150,0
                dc.l    TAGCD_READXLSPEED,75,150,0
                dc.l    TAGCD_SECTORSIZE,2048,2328,2336
                dc.l    TAGCD_XLECC,0,1,0
                dc.l    TAGCD_EJECTRESET,0,1,0
                dc.l    TAG_END,0,0,0


*
******* cd.device/CD_TOCLSN **************************************************
*
*   NAME
*       CD_TOCLSN -- Return table of contents information from CD (LSN form).
*
*   IO REQUEST
*       io_Device       preset by the call to OpenDevice()
*       io_Unit         preset by the call to OpenDevice()
*       io_Command      CD_TOCLSN
*       io_Data         pointer to array where TOC is to be stored
*       io_Length       number of CDTOC entries to be fetched
*       io_Offset       entry to begin at (entry 0 is summary information)
*
*   RESULTS
*       io_Error        0 for success, or an error code as defined in
*                       <devices/cd.h>
*       io_Actual       Actual number of entries copied
*
*   FUNCTION
*       This command returns the table of contents of the disk currently in
*       the drive.  The table of contents consists of up to 100 entries.
*       Entry zero is summary information describing the number of tracks
*       and the total number of minutes on the disk.  Entries 1 through N
*       contain information about each individual track.  All position
*       information will be in LSN format.
*
*       The io_Data field points to an array of CDTOC structures to receive
*       the TOC data.
*
*       The io_Length field specifies the total number of entries to be
*       fetched.  The array pointed to by io_Data must be at least this many
*       elements in size.
*
*       The io_Offset field specifies the entry number at which to start
*       copying TOC data into *io_Data.
*
*       Entry zero (the summary entry) contains the following:
*
*       struct TOCSummary {
*
*           UBYTE        FirstTrack;    /* First track on disk (always 1)   */
*           UBYTE        LastTrack;     /* Last track on disk               */
*           union LSNMSF LeadOut;       /* Beginning of lead-out track      */
*           };
*
*       Track entries (entries 1 through number of tracks) contain:
*
*       struct TOCEntry {
*
*           UBYTE        CtlAdr;        /* Q-Code info                  */
*           UBYTE        Track;         /* Track number                 */
*           union LSNMSF Position;      /* Start position of this track */
*           };
*
*       CDTOC is described as a union between these two structures:
*
*       union CDTOC {
*
*           struct TOCSummary Summary;  /* First entry is summary info.  */
*           struct TOCEntry   Entry;    /* Entries 1-N are track entries */
*           };
*
*
*   EXAMPLE
*       
*       union CDTOC tocarray[100];
*
*       ior->io_Command = CD_TOCLSN;        /* Retrieve TOC information */
*       ior->io_Offset  = 0;                /* Start with summary info  */
*       ior->io_Length  = 100;              /* Max 99 tracks + summary  */
*       ior->io_Data    = (APTR)tocarray;   /* Here's where we want it  */
*       DoIO (ior);
*
*       if (!ior->io_Error) {               /* Command succeeded        */
*
*           firsttrack   = tocarray[0].Summary.FirstTrack;
*           lasttrack    = tocarray[0].Summary.LastTrack;
*           totalsectors = tocarray[0].Summary.LeadOut.LSN -
*                          tocarray[1].Entry.Position.LSN;
*           }
*
*   NOTES
*
*       In the above example, the amount of data on the disk is calculated as
*       being equal to the location of the lead-out track minus the start of
*       the first track (which is never zero).
*
*   BUGS
*
*   SEE ALSO
*
******************************************************************************

CmdTOCLSN:
                moveq.b #1,d0
                bra     CmdTOC

*
******* cd.device/CD_TOCMSF **************************************************
*
*   NAME
*       CD_TOCMSF -- Return table of contents information from CD (MSF form).
*
*   IO REQUEST
*       io_Device       preset by the call to OpenDevice()
*       io_Unit         preset by the call to OpenDevice()
*       io_Command      CD_TOCMSF
*       io_Data         pointer to array where TOC is to be stored
*       io_Length       number of CDTOC entries to be fetched
*       io_Offset       entry to begin at (entry 0 is summary information)
*
*   RESULTS
*       io_Error        0 for success, or an error code as defined in
*                       <devices/cd.h>
*       io_Actual       Actual number of entries copied
*
*   FUNCTION
*       This command returns the table of contents of the disk currently in
*       the drive.  The table of contents consists of up to 100 entries.
*       Entry zero is summary information describing the number of tracks
*       and the total number of minutes on the disk.  Entries 1 through N
*       contain information about each individual track.  All position
*       information will be in MSF format.
*
*       The io_Data field points to an array of CDTOC structures to receive
*       the TOC data.
*
*       The io_Length field specifies the total number of entries to be
*       fetched.  The array pointed to by io_Data must be at least this many
*       elements in size.
*
*       The io_Offset field specifies the entry number at which to start
*       copying TOC data into *io_Data.
*
*       Entry zero (the summary entry) contains the following:
*
*       struct TOCSummary {
*
*           UBYTE        FirstTrack;    /* First track on disk (always 1)   */
*           UBYTE        LastTrack;     /* Last track on disk               */
*           union LSNMSF LeadOut;       /* Beginning of lead-out track      */
*           };
*
*       Track entries (entries 1 through number of tracks) contain:
*
*       struct TOCEntry {
*
*           UBYTE        CtlAdr;        /* Q-Code info                  */
*           UBYTE        Track;         /* Track number                 */
*           union LSNMSF Position;      /* Start position of this track */
*           };
*
*       CDTOC is described as a union between these two structures:
*
*       union CDTOC {
*
*           struct TOCSummary Summary;  /* First entry is summary info.  */
*           struct TOCEntry   Entry;    /* Entries 1-N are track entries */
*           };
*
*
*   EXAMPLE
*       
*   NOTES
*
*   BUGS
*
*   SEE ALSO
*
******************************************************************************

CmdTOCMSF:
                clr.b   d0
CmdTOC:
                save    d2-d5                                                   ; Save LSN/MSF flag
                move    d0,d5

                move.w  db_Info+CDINFO_Status(db),d0                            ; There must be a ROM track
                btst    #CDSTSB_TOC,d0
                beq     tocnodisk

                lea     db_TOC(db),a0
                clr.l   IO_ACTUAL(ior)                                          ; Check bounds of parameters
                move.l  IO_DATA(ior),d0
                beq     tocinvalidaddress
                move.l  d0,a1
                move.l  IO_OFFSET(ior),d1
                cmp.l   #100,d1
                bhs     tocinvalidoffset                                        ; - A1 = Data, D1 = Start, D2 = Stop
                move.l  IO_LENGTH(ior),d2
                beq     tocinvalidlength
                bmi     tocinvalidlength
                add.l   d1,d2
                cmp.l   #100,d2
                bhi     tocinvalidlength

                mulu    #TOCEntry_SIZE,d1                                       ; Copy all requested TOC entries
                mulu    #TOCEntry_SIZE,d2
                clr.l   d3
                move.b  db_TOC+TOCS_LastTrack(db),d3
                addq.l  #1,d3
                mulu    #TOCEntry_SIZE,d3
                clr.l   d4
1$
                move.b  TOCE_CtlAdr(a0,d1.w),TOCE_CtlAdr(a1,d4.w)               ; Get CtlAdr and Track index
                move.b  TOCE_Track(a0,d1.w),TOCE_Track(a1,d4.w)

                move.l  TOCE_Position(a0,d1.w),d0                               ; Get start of track (or start of lead-out)
                tst.b   d5
                beq     2$
                bsr     MSFtoLSNPOS
2$              move.l  d0,TOCE_Position(a1,d4.w)

                add.w   #TOCEntry_SIZE,d4                                       ; Next entry (if available)
                add.w   #TOCEntry_SIZE,d1
                cmp.w   d2,d1
                bhs     3$
                cmp.w   d3,d1
                blo     1$
3$
                divu    #TOCEntry_SIZE,d4                                       ; Actual number of entries transferred
                and.l   #$0000FFFF,d4
                move.l  d4,IO_ACTUAL(ior)
tocexit:
                restore d2-d5
                rts
tocinvalidlength:
tocinvalidoffset:
                move.b  #IOERR_BADLENGTH,IO_ERROR(ior)                          ; Length invalid
                bra     tocexit
tocinvalidaddress:
                move.b  #IOERR_BADADDRESS,IO_ERROR(ior)                         ; Address invalid
                bra     tocexit
tocnodisk:
                move.b  #CDERR_NoDisk,IO_ERROR(ior)                             ; TOC not valid
                bra     tocexit


*
******* cd.device/CD_READXL **************************************************
*
*   NAME
*       CD_READXL -- Read from CD-ROM into memory via transfer list.
*
*   IO REQUEST
*       io_Device       preset by the call to OpenDevice()
*       io_Unit         preset by the call to OpenDevice()
*       io_Command      CD_READXL
*       io_Data         pointer to transfer list (i.e. struct List *).
*       io_Length       maximum transfer length (WORD multiple) or 0.
*       io_Offset       byte offset from the start of the disk describing
*                       where to read data from, must be a WORD multiple.
*
*   RESULTS
*       io_Error        0 for success, or an error code as described in
*                       <devices/cd.h>
*       io_Actual       if io_Error is 0, number of bytes actually transferred
*
*   FUNCTION
*       This command starts reading data off the disk at the specified
*       location and deposits it into memory according to the nodes in a
*       transfer list.  The pointer to the list of transfer nodes is placed
*       in io_Data.  If you have a non-circular transfer list, simply set
*       io_Length to 0 (0 is special and means ignore io_Length) -- your
*       transfer will end when your transfer list has been exhausted.  If you
*       have a circular transfer list, the list will never end.  In this case,
*       the transfer will terminate when io_Length bytes have been
*       transferred.
*
*       The fields in the CDXL node structure are:
*
*       struct  CDXL {
*
*           struct MinNode  Node;         /* double linkage                */
*           char           *Buffer;       /* data destination              */
*           LONG            Length;       /* must be even # bytes          */
*           LONG            Actual;       /* bytes transferred             */
*           APTR            IntData;      /* interrupt server data segment */
*           VOID            (*IntCode)(); /* interrupt server code entry   */
*           };
*
*       The philosophy here is that you set up the buffers you want filled,
*       create CDXL nodes describing the locations and sizes of these
*       buffers, link all the nodes together in the order that you'd like
*       (even make a circular list for animations), and execute the command.
*       The data will be streamed into the appropriate buffers until the
*       list has been exhausted, an entry with a Length of zero is
*       encountered, io_Length bytes have been transferred (if io_Length is
*       non-zero), or the command is aborted with AbortIO().
*
*       If you fill in the (*IntCode)() field with a pointer to an interrupt
*       routine, your routine will be called when the transfer for the node
*       is complete.  Your code will be called before the driver proceeds to
*       the next node.  The interrupt should follow the same rules as standard
*       interrupts (see AddIntServer of Exec autodocs).  Register A2 will
*       contain a pointer to the node just completed.  You may manipulate the
*       list from within the interrupt. Your code must be brief (this is an
*       interrupt).  When returning from this interrupt, D0 should be cleared
*       and an RTS instruction should be used to return.
*
*       Servers are called with the following register conventions:
*
*           D0 - scratch
*           D1 - scratch
*
*           A0 - scratch
*           A1 - server is_Data pointer (scratch)
*           A2 - pointer to CDXL node just completed
*
*           A5 - jump vector register (scratch)
*
*           all other registers must be preserved
*
*   EXAMPLE
*
*   NOTES
*       Try to make sure that small buffers are not overused.  Each time
*       a node is completed, an interrupt is generated.  If you find that
*       your computer is acting sluggish, or the CD_READXL command is
*       aborting, you are probably generating too many interrupts.  It is
*       not efficient to have more than a few of these interrupts generated
*       within a vertical blank.
*
*       Unlike the READ command, the READXL command will not retry a sector
*       if there is an error.  Since the READXL command's purpose is primarily
*       for animations, data streaming is considered more important than the
*       data itself.  An error will be returned in io_Error if a data error
*       did occur.  This command will never drop to a lower speed in the event
*       of an error.
*
*   BUGS
*
*   SEE ALSO
*       CMD_READ, CD_SEEK, Autodocs - AddIntServer
*
******************************************************************************

CmdReadXL:
                move.w  db_Info+CDINFO_Status(db),d0                            ; There must be a ROM track
                btst    #CDSTSB_CDROM,d0
                beq     Read_NoROMErr

                move.l  IO_OFFSET(ior),d0                                       ; These fields must be even
                btst    #0,d0
                bne     Read_BadLength
                move.l  IO_LENGTH(ior),d0
                btst    #0,d0
                bne     Read_BadLength

                move.l  IO_OFFSET(ior),d1                                       ; Convert offset to block for testing

                clr.l   d0
                move.w  db_Info+CDINFO_SectorSize(db),d0
                divul.l d0,d1

                jsr     CheckSeekRange                                          ; Check range of seek (not play)
                bne     Read_BadLength

                jsr     ClearPrefetchIfError                                    ; Clear read prefetch buffer if an error occurred

                move.l  IO_OFFSET(ior),db_ARG1(db)                              ; Store start byte

                clr.l   IO_ACTUAL(ior)                                          ; Current actual transfer length

                move.w  #CDCMD_READ,db_CMD(db)                                  ; Read data

                move.l  IO_DATA(ior),a1                                         ; Empty list?                                         
                move.l  LH_HEAD(a1),a1
                tst.l   LN_SUCC(a1)
                beq     Read_BadLength
                                                                                ; Start custom transfer list
                move.l  a1,db_XferEntry(db)
                move.l  IO_OFFSET(ior),db_ARG1(db)
                move.l  CDXL_Buffer(a1),db_ARG2(db)
                move.l  CDXL_Length(a1),db_ARG3(db)
                clr.l   d0                                                      ; - Set desired drive speed
                move.w  db_Info+CDINFO_ReadXLSpeed(db),d0
                move.l  d0,db_ARG4(db)
                move.l  #$7FFFFFF0,db_ARG5(db)
                move.l  IO_LENGTH(ior),d0
                beq     1$
                move.l  d0,db_ARG5(db)
1$              clr.l   IO_ACTUAL(ior)
                clr.l   CDXL_Actual(a1)
                move.w  db_Info+CDINFO_XLECC(db),d0                             ; Configure ECC of data
                move.b  d0,db_ECC(db)

                jsr     DoCmd                                                   ; Do the read
                rts

Read_NoROMErr:
                moveq   #CDERR_BadDataType,d0                                   ; No CD-ROM
                bra.s   Read_ReadErr
Read_BadLength:
                moveq   #CDERR_BADLENGTH,d0                                     ; Bad arguments
                bra.s   Read_ReadErr
Read_BadAddress:
                moveq   #CDERR_BADADDRESS,d0                                    ; Data not word aligned
Read_ReadErr:
                move.b  d0,IO_ERROR(ior)                                        ; Return error
                rts


*
******* cd.device/CD_PLAYTRACK ***********************************************
*
*   NAME
*       CD_PLAYTRACK -- Play one or more tracks of CD audio.
*
*   IO REQUEST
*       io_Device       preset by the call to OpenDevice()
*       io_Unit         preset by the call to OpenDevice()
*       io_Command      CD_PLAYTRACK
*       io_Data         NULL
*       io_Length       number of tracks to play
*       io_Offset       start playing at beginning of this track
*
*   RESULTS
*       io_Error        0 for success, or an error code as defined in
*                       <devices/cd.h>
*   FUNCTION
*       This command causes the drive to play the specified audio track(s).
*       The command will return when the audio has completed.
*
*       io_Offset specifies the track number (starting from 1).
*
*       io_Length specifies the number of tracks to play (0 is invalid).  
*
*   EXAMPLE
*
*       ior->io_Command = CD_PLAYTRACK;    /* Play audio tracks     */
*       ior->io_Offset  = STARTTRACK;      /* Start with this track */
*       ior->io_Length  = 3;               /* Play three tracks     */
*       DoIO(ior);
*
*   NOTES
*
*       PLAY commands are asynchronous with many other CD commands.
*       Using a separate I/O request, other commands can be sent to the device
*       that can change the behavior of the PLAY command.
*
*   BUGS
*
*   SEE ALSO
*       CD_PLAYMSF, CD_PLAYLSN, CD_PAUSE, CD_SEARCH, CD_ATTENUATE
*
******************************************************************************

CmdPlayTrack:
                save    d0                                                      ; If we are prefetching, stop it
                clr.w   d0
                jsr     StopRead
                restore d0

                save    d2                                                      ; Check validity of io_Offset
                move.l  IO_OFFSET(ior),d1
                cmp.b   db_TOC+TOCS_FirstTrack(db),d1
                blo     trackinvalidoffset
                cmp.b   db_TOC+TOCS_LastTrack(db),d1
                bhi     trackinvalidoffset

                move.l  IO_LENGTH(ior),d0                                       ; Check validity of io_Length
                bmi     trackinvalidlength
                move.l  d1,d2
                add.l   d0,d2
                sub.w   #1,d2
                cmp.b   db_TOC+TOCS_LastTrack(db),d2
                bhi     trackinvalidlength
                add.w   #1,d2

                lea     db_TOC(db),a0                                           ; Prepare to access TOC
                mulu    #TOCEntry_SIZE,d1
                mulu    #TOCEntry_SIZE,d2

                move.l  TOCE_Position(a0,d1.w),d0                               ; Start at this track
                jsr     MSFtoLSNPOS
                move.l  d0,d1

                move.l  TOCE_Position(a0,d2.w),d0                               ; Stop before this point
                jsr     MSFtoLSNPOS
                move.l  d0,d2

                move.w  #CDCMD_PLAY,db_CMD(db)                                  ; Play
                move.l  d1,db_ARG1(db)
                move.l  d2,db_ARG2(db)

                bsr     DoCmd                                                   ; Start play
trackexit:
                restore d2
                rts

trackinvalidlength:
trackinvalidoffset:
                move.b  #IOERR_BADLENGTH,IO_ERROR(ior)                          ; Length invalid
                bra     trackexit

*
******* cd.device/CD_PLAYLSN *************************************************
*
*   NAME
*        CD_PLAYLSN -- Play a selected portion of CD audio (LSN form).
*
*   IO REQUEST
*       io_Device       preset by the call to OpenDevice()
*       io_Unit         preset by the call to OpenDevice()
*       io_Command      CD_PLAYLSN
*       io_Data         NULL
*       io_Length       length of play
*       io_Offset       starting position
*
*   RESULTS
*       io_Error        0 for success, or an error code as defined in
*                       <devices/cd.h>
*
*   FUNCTION
*       This command causes the drive to start playing CD audio from the
*       specified position until the specified length has passed.
*
*       io_Offset specifies the starting position.  io_Length contains
*       the amount of time to play.  All data is specified in LSN format.
*
*       A DoIO() will not return until the requested number of sectors
*       have been played.  A SendIO() will return as soon as the PLAY
*       has been started.  At this time other commands can be sent (like
*       CD_PAUSE).  To stop a play before the specified length has been
*       reached, use AbortIO().
*
*   EXAMPLE
*       /* Play two minutes, ten seconds of audio starting at 20 minutes, */
*       /* 58 seconds, and 10 frames.                                     */
*
*       ior->io_Command = CD_PLAYLSN;   /* Play CD audio           */
*       ior->io_Offset  = 94360;        /* 20*(60*75) + 58*75 + 10 */
*       ior->io_Length  = 9750;         /* 02*(60*75) + 10*75 + 00 */
*       DoIO (ior);
*
*   NOTES
*
*   BUGS
*
*   SEE ALSO
*       CD_PLAYTRACK, CD_PAUSE, CD_SEARCH, CD_ATTENUATE
*
******************************************************************************

CmdPlayLSN:
                move.b  #1,d0
                bra     CmdPlay

*
******* cd.device/CD_PLAYMSF *************************************************
*
*   NAME
*        CD_PLAYMSF -- Play a selected portion of CD audio (MSF form).
*
*   IO REQUEST
*       io_Device       preset by the call to OpenDevice()
*       io_Unit         preset by the call to OpenDevice()
*       io_Command      CD_PLAYMSF
*       io_Data         NULL
*       io_Length       length of play
*       io_Offset       starting position
*
*   RESULTS
*       io_Error        0 for success, or an error code as defined in
*                       <devices/cd.h>
*
*   FUNCTION
*       This command causes the drive to start playing CD audio from the
*       specified position until the specified length has passed.
*
*       io_Offset specifies the starting position.  io_Length contains
*       the amount of time to play.  All data is specified in MSF format.
*
*       A DoIO() will not return until the requested number of sectors
*       have been played.  A SendIO() will return as soon as the PLAY
*       has been started.  At this time other commands can be sent (like
*       CD_PAUSE).  To stop a play before the specified length has been
*       reached, use AbortIO().
*
*   EXAMPLE
*       /* Play two minutes, ten seconds of audio starting at 20 minutes, */
*       /* 58 seconds, and 10 frames.                                     */
*
*       ior->io_Command = CD_PLAYMSF;   /* Play CD audio          */
*       ior->io_Offset  = 0x00143A0A;   /* $14=20, $3A=58, $0A=10 */
*       ior->io_Length  = 0x00020A00;   /* $02=02, $0A=10, $00=00 */
*       DoIO (ior);
*
*   NOTES
*
*   BUGS
*
*   SEE ALSO
*       CD_PLAYTRACK, CD_PAUSE, CD_SEARCH, CD_ATTENUATE
*
******************************************************************************

CmdPlayMSF:
                clr.b   d0
CmdPlay:
                save    d0                                                      ; If we are prefetching, stop it
                clr.w   d0
                jsr     StopRead
                restore d0

                save    d2/d3                                                   ; Save LSN/MSF flag
                move.b  d0,d3

                move.l  IO_OFFSET(ior),d1                                       ; Retrieve start and stop positions
                move.l  IO_LENGTH(ior),d2

                tst.b   d3                                                      ; Convert LSN to MSF?
                bne     1$
                move.l  d1,d0                                                   ; - Convert Start
                bsr     MSFtoLSNPOS
                move.l  d0,d1
                move.l  d2,d0
                bsr     MSFtoLSN
                move.l  d0,d2
1$              add.l   d1,d2

                jsr     CheckPlayRange                                          ; Check play range
                bne     playinvalidlength

                move.w  #CDCMD_PLAY,db_CMD(db)                                  ; Play
                move.l  d1,db_ARG1(db)
                move.l  d2,db_ARG2(db)

                bsr     DoCmd                                                   ; Start play
playexit:
                restore d2/d3
                rts

playinvalidlength:
                move.b  #IOERR_BADLENGTH,IO_ERROR(ior)                          ; Length invalid
                bra     playexit

*
******* cd.device/CD_PAUSE ***************************************************
*
*   NAME
*       CD_PAUSE -- Pause or unPause play command.
*
*   IO REQUEST
*       io_Device       preset by the call to OpenDevice()
*       io_Unit         preset by the call to OpenDevice()
*       io_Command      CD_PAUSE
*       io_Data         NULL
*       io_Length       pausemode : 1 = pause play; 0 = do not pause play;
*       io_Offset       0
*
*   RESULTS
*       io_Actual - if io_Error is 0, this contains the previous pause state.
*
*   FUNCTION
*       This command will place the CD in, or take the CD out of pause mode.
*       The desired pause state is placed in io_Length.  This command only
*       effects play commands.  When the audio is playing and the pausemode
*       is set, this command will immediately pause the audio output
*       suspending the play command until the play is unpaused.  When audio
*       is not playing and the pausemode is set, this command will set the
*       pause mode (having no immediate effect).  When a play command is
*       submitted, the laser will seek to the appropriate position and pause
*       at that spot.  The play command will be suspended until the play is
*       unpaused (or the play is aborted).
*
*   EXAMPLE
*
*   NOTES
*
*   BUGS
*
*   SEE ALSO
*
******************************************************************************

CmdPause:
                clr.l   IO_ACTUAL(ior)                                          ; Calculate IO_ACTUAL
                move.w  db_Info+CDINFO_Status(db),d0
                btst    #CDSTSB_PAUSED,d0
                sne.b   IO_ACTUAL+3(ior)

                tst.l   IO_LENGTH(ior)                                          ; Pause or resume?
                bne.s   1$

                tst.l   IO_ACTUAL(ior)                                          ; Already resumed?
                beq     2$

                move.w  #CDCMD_RESUME,db_CMD(db)                                ; Resume play if we were playing
                bsr     DoCmd
                rts
1$
                tst.l   IO_ACTUAL(ior)                                          ; Already paused?
                bne     2$

                move.w  #CDCMD_PAUSE,db_CMD(db)                                 ; Pause Play if we are playing
                bsr     DoCmd
2$              rts


*
******* cd.device/CD_SEARCH **************************************************
*
*   NAME
*       CD_SEARCH -- configure the mode in which PLAY commands play
*
*   IO REQUEST
*       io_Command      CD_SEARCH
*       io_Data         NULL
*       io_Length       searchmode
*       io_Offset       0
*
*   RESULTS
*       io_Actual - if io_Error is 0, this contains the previous search mode.
*
*   FUNCTION
*       This command causes a play command to play in fast-forward,
*       fast-reverse, or normal play mode.  These modes are defined as:
*
*       CDMODE_NORMAL   0   Normal play (current speed setting)
*       CDMODE_FFWD     1   Play in fast forward mode  
*       CDMODE_FREV     2   Play in fast reverse mode
*
*       The search mode can be set before the play command is sent, or during
*       a play.  If CD_SEARCH is sent before a play command is sent, the
*       mode is set and the command immediately returns.  If the mode is set
*       to REV mode, when the play command is sent the play will begin at the
*       requested end position and work backwards to the start position.
*
*       If CD_SEARCH is sent during a play, the play will automatically
*       switch to the desired mode and continue playing until the original
*       play command is completed.  If REV mode is set and the beginning of
*       the play is encountered before switching back to forward play, the
*       play command will terminate with no error.
*
*   EXAMPLE
*       /* Search in fast forward mode. */
*       ior->io_Command = CD_SEARCH;
*       ior->io_Data    = NULL;
*       ior->io_Offset  = 0;
*       ior->io_Length  = CDMODE_FFWD;
*       DoIO(ior);
*
*   NOTES
*
*   BUGS
*
*   SEE ALSO
*
******************************************************************************

CmdSearch:
                cmp.l   #3,IO_LENGTH(ior)                                       ; Is the requested mode valid?
                blo     1$
                move.b  #IOERR_BADLENGTH,IO_ERROR(ior)
                rts
1$
                move.l  #CDMODE_NORMAL,d1                                       ; Report previous search mode
                move.w  db_Info+CDINFO_Status(db),d0
                btst    #CDSTSB_SEARCH,d0
                beq     2$
                move.l  #CDMODE_FFWD,d1
                btst    #CDSTSB_DIRECTION,d0
                beq     2$
                move.l  #CDMODE_FREV,d1
2$              move.l  d1,IO_ACTUAL(ior)

                move.w  #CDCMD_SETPLAYMODE,db_CMD(db)                           ; Set PlayMode...
                move.l  IO_LENGTH(ior),db_ARG1(db)

                bsr     DoCmd                                                   ; ... please.
                rts


*
******* cd.device/CD_QCODELSN ************************************************
*
*   NAME
*       CD_QCODELSN -- Report current disk position.
*
*   IO REQUEST
*       io_Device       preset by the call to OpenDevice()
*       io_Unit         preset by the call to OpenDevice()
*       io_Command      CD_QCODELSN
*       io_Data         pointer to QCode structure
*       io_Length       0 - MUST be zero (for future compatability)
*
*   RESULTS
*       io_Error        0 for success, or an error code as defined in
*                       <devices/cd.h>
*
*   FUNCTION
*       This command reports current subcode Q channel time information.  This
*       command only returns data when CD Audio is playing (or paused).  At
*       any other time, an error is returned.  The Q-Code packet consists of:
*
*       struct QCode {
*
*           UBYTE        CtlAdr;        /* Data type / QCode type           */
*           UBYTE        Track;         /* Track number                     */
*           UBYTE        Index;         /* Track subindex number            */
*           UBYTE        Zero;          /* The "Zero" byte of Q-Code packet */
*           union LSNMSF TrackPosition; /* Position from start of track     */
*           union LSNMSF DiskPosition;  /* Position from start of disk      */
*           };
*
*   EXAMPLE
*
*       struct QCode qcode;
*
*       ior->io_Command = CD_QCODELSN;  /* Retrieve TOC information */
*       ior->io_Length  = 0;            /* MUST be zero             */
*       ior->io_Data    = (APTR)qcode;  /* Here's where we want it  */
*       DoIO (ior);
*
*       if (!ior->io_Error) {           /* Command succeeded        */
*
*           printf("Current position is: %ld\n", qcode.DiskPosition.LSN);
*           }
*
*   NOTES
*       This function may not return immediately.  It may take several frames
*       to pass by before a valid Q-Code packet can be returned.  Use SendIO()
*       and CheckIO() if response time is critical, and the information is
*       not.
*
*   BUGS
*
*   SEE ALSO
*       CD_PLAYMSF, CD_PLAYLSN, CD_PLAYTRACK, <devices/cd.h>
*
******************************************************************************

CmdQCodeLSN:
                move.b  #1,d0
                bra     CmdQCode

*
******* cd.device/CD_QCODEMSF ************************************************
*
*   NAME
*       CD_QCODEMSF -- Report current disk position.
*
*   IO REQUEST
*       io_Device       preset by the call to OpenDevice()
*       io_Unit         preset by the call to OpenDevice()
*       io_Command      CD_QCODEMSF
*       io_Data         pointer to QCode structure
*       io_Length       0 - MUST be zero (for future compatability)
*
*   RESULTS
*       io_Error        0 for success, or an error code as defined in
*                       <devices/cd.h>
*
*   FUNCTION
*       This command reports current subcode Q channel time information.  This
*       command only returns data when CD Audio is playing (or paused).  At 
*       any other time, an error is returned.  The Q-Code packet consists of:
*
*       struct QCode {
*
*           UBYTE        CtlAdr;        /* Data type / QCode type           */
*           UBYTE        Track;         /* Track number                     */
*           UBYTE        Index;         /* Track subindex number            */
*           UBYTE        Zero;          /* The "Zero" byte of Q-Code packet */
*           union LSNMSF TrackPosition; /* Position from start of track     */
*           union LSNMSF DiskPosition;  /* Position from start of disk      */
*           };
*
*   EXAMPLE
*
*       struct QCode qcode;
*
*       ior->io_Command = CD_QCODEMSF;  /* Retrieve TOC information */
*       ior->io_Length  = 0;            /* MUST be zero             */
*       ior->io_Data    = (APTR)qcode;  /* Here's where we want it  */
*       DoIO (ior);
*
*       if (!ior->io_Error) {           /* Command succeeded        */
*
*           printf("Current position is: %02d:%02d:%02d\n",
*               qcode.DiskPosition.MSF.Minute,
*               qcode.DiskPosition.MSF.Second,
*               qcode.DiskPosition.MSF.Frame);
*           }
*
*   NOTES
*       This function may not return immediately.  It may take several frames
*       to pass by before a valid Q-Code packet can be returned.  Use SendIO()
*       and CheckIO() if response time is critical, and the information is
*       not.
*
*   BUGS
*
*   SEE ALSO
*       CD_PLAYMSF, CD_PLAYLSN, CD_PLAYTRACK, <devices/cd.h>
*
******************************************************************************

CmdQCodeMSF:
                clr.b   d0
CmdQCode:
                save    d2                                                      ; Save LSN/MSF flag
                move.b  d0,d2

                move.w  #CDCMD_QCODE,db_CMD(db)                                 ; Get a valid time-encoded packet
                jsr     DoCmd
                bne     1$

                move.l  IO_DATA(ior),a1                                         ; Status byte

                move.b  db_QCode+3(db),(a1)+                                    ; Store CTLADR byte

                move.b  db_QCode+4(db),d0                                       ; Store track
                jsr     BCDtoBIN
                move.b  d0,(a1)+

                move.b  db_QCode+5(db),d0                                       ; Store subindex
                jsr     BCDtoBIN
                move.b  d0,(a1)+

                move.b  db_QCode+9(db),(a1)+                                    ; Store zero byte


                move.l  db_QCode+5(db),d0                                       ; Get relative time - convert BCD to BIN format
                and.l   #$00ffffff,d0
                jsr     MSFBCDtoBIN
                move.l  d0,(a1)+

                move.l  db_QCode+9(db),d0                                       ; Get absolute time - convert BCD to BIN format
                and.l   #$00ffffff,d0
                jsr     MSFBCDtoBIN
                move.l  d0,(a1)+

                tst.b   d2                                                      ; Convert to LSN format if requested
                beq     1$
                
                move.l  IO_DATA(ior),a1                                         ; Convert track position to LSN format
                move.l  QCODE_TrackPosition(a1),d0
                jsr     MSFtoLSNPOS
                move.l  d0,QCODE_TrackPosition(a1)

                move.l  QCODE_DiskPosition(a1),d0                               ; Convert disk position to LSN format
                jsr     MSFtoLSNPOS
                move.l  d0,QCODE_DiskPosition(a1)
1$
                restore d2
                rts


*
******* cd.device/CD_ATTENUATE ***********************************************
*
*   NAME
*       CD_ATTENUATE -- Attenuate CD audio volume (immediately or gradually)
*
*   IO REQUEST
*       io_Device       preset by the call to OpenDevice()
*       io_Unit         preset by the call to OpenDevice()
*       io_Command      CD_ATTENUATE
*       io_Data         NULL
*       io_Length       duration of volume fade in frames
*       io_Offset       target volume level (0 - 0x7FFF) (-1 = status only)
*
*   RESULTS
*       io_Error        Returns an error if drive does not support attenuation
*       io_Actual       current volume level (fade may be monitored)
*
*   FUNCTION
*       This command will ramp the CD audio volume up or down from its
*       current value to the value contained in io_Offset.  The range is 0
*       (silence) to 0x7FFF (full volume).  If -1 is specified as the target,
*       the attenuation will not be modified; the current attenuation value
*       will be returned in io_Actual.
*
*       io_Length contains the duration of the fade.  In seconds, this is
*       io_Length divided by the current frame rate (usually 75).
*
*       Note that this command returns before the fade has completed.  Thus,
*       once started, a fade cannot be aborted.  You can, however, send a
*       new CD_ATTENUATE command, which will immediately override any fade
*       currently in progress.  An io_Length of zero means attenuate
*       immediately.
*
*       If a gradual attenuation command is sent before the play command, the
*       fade will begin as soon as the play command is sent.
*
*   EXAMPLE
*
*   NOTES
*       This command has no effect on Amiga audio volume, only CD audio.
*
*       If the drive does not support volume attenuation, but does support
*       mute, a value of under $0800 should be considered mute, and equal
*       to or above should be full volume.  If chunky attenuation is
*       supported, the drive should do the best it can.  If the drive does
*       not support volume attenuation at all, an error should be returned.
*       Even if only mute is supported, if gradual attenuation is requested,
*       the device should still emulate the fade command and mute based on
*       the $0800 boundary.
*
*   BUGS
*
*   SEE ALSO
*       CD_INFO
*
******************************************************************************

CmdAttenuate:
                save    d2                                                      ; Return previous attenuation
                clr.l   IO_ACTUAL(ior)
                move.w  db_Attenuation(db),IO_ACTUAL+2(ior)

                move.l  IO_OFFSET(ior),d0                                       ; Set target attenuation
                cmp.l   #-1,d0
                beq     2$

                cmp.l   #$7FFF,d0                                               ; Cap off at $7FFF
                bls     0$
                move.l  #$7FFF,d0
0$              move.l  d0,d2

                move.l  IO_LENGTH(ior),d1
                and.l   #$7FFF,d1                                               ; Set attenuation now?
                beq.s   3$

                sub.w   db_TargetAttenuation(db),d0                             ; Calculate attenuation per step
                ext.l   d0
                divs    d1,d0

                tst.w   d0                                                      ; Minimum fade step = 1
                bne.s   1$
                move.w  #1,d0
1$              move.w  d0,db_FadeStepSize(db)

                move.w  d2,db_TargetAttenuation(db)                             ; Save our desired attenuation value

                move.b  #1,db_AutoFade(db)                                      ; Enable frame interrupts (when playing)
                jsr     SetSubcodeInterrupt
2$              restore d2
                rts
3$
                clr.w   db_FadeStepSize(db)                                     ; Cancel out any fade and set attenuation now
                move.w  d0,db_TargetAttenuation(db)
                move.w  d0,db_Attenuation(db)

                move.w  db_Info+CDINFO_Status(db),d0                            ; If we are playing audio, attenuate now
                btst    #CDSTSB_PLAYING,d0
                beq     4$
                bsr     Attenuate
4$
                restore d2
                rts


*
******* cd.device/CD_ADDFRAMEINT *********************************************
*
*   NAME
*       CD_ADDFRAMEINT -- add a CD-frame software interrupt handler.
*
*   IO REQUEST
*       io_Device       preset by the call to OpenDevice()
*       io_Unit         preset by the call to OpenDevice()
*       io_Command      CD_ADDFRAMEINT
*       io_Length       sizeof(struct Interrupt)
*       io_Data         pointer to Interrupt structure
*
*   RESULTS
*       io_Error        0 for success, or an error code as defined in
*                       <devices/cd.h>
*
*   FUNCTION
*       This command lets you add a software interrupt handler to the
*       disk device that gets invoked whenever a new frame is encountered
*       while CD audio is being played.
*
*       You must pass in a properly initialized Exec Interrupt structure
*       and be prepared to deal with frame interrupts immediately.
*       The interrupt is generated by the exec Cause function, so you must
*       preserve A6.
*
*       To set up the handler, an Interrupt structure must be initialized.
*       This structure is supplied in io_Data of the CD_ADDFRAMEINT
*       command.  The handler then gets linked into the handler chain and
*       gets invoked whenever a frame event occurs.  You must eventually
*       remove the handler before you exit.
*
*       This command only returns when the handler is removed. That is,
*       the device holds onto the IO request until the CD_REMFRAMEINT command
*       is executed with that same IO request.  Hence, you must use SendIO()
*       with this command.
*
*   NOTES
*       The interrupt handler can be added before or after a play command is
*       sent.  Interrupts will only be generated while CD audio is playing.
*       Interrupts will not be generated when audio is paused.
*
*   SEE ALSO
*       CD_REMFRAMEINT, <devices/cd.h>, <exec/interrupts.h>,
*       exec.library/Cause()
*
******************************************************************************

CmdAddFrameInt:
                lea     db_FrameList(db),a0                                     ; Add request to frame list
                jsr     AddRequest

                move.b  #1,db_AutoFrame(db)                                     ; Enable frame interrupts (when playing)
                jsr     SetSubcodeInterrupt
                rts


*
******* cd.device/CD_REMFRAMEINT *********************************************
*
*   NAME
*       CD_REMFRAMEINT -- remove a CD-frame interrupt handler.
*
*   IO REQUEST
*       The same IO request used for CD_ADDFRAMEINT.
*
*       io_Device       preset by the call to OpenDevice()
*       io_Unit         preset by the call to OpenDevice()
*       io_Command      CD_REMFRAMEINT
*       io_Length       sizeof(struct Interrupt)
*       io_Data         pointer to Interrupt structure
*
*   RESULTS
*       io_Error        0 for success, or an error code as defined in
*                       <devices/cd.h>
*
*   FUNCTION
*       This command removes a CD-frame software interrupt added
*       by a previous use of CD_ADDFRAMEINT.
*
*   BUGS
*
*   SEE ALSO
*       CD_ADDFRAMEINT, <devices/cd.h>
*
******************************************************************************

CmdRemFrameInt:
                jsr         RemoveRequest                                       ; Remove request from frame list

                lea         db_FrameList(db),a0                                 ; If list is empty, disable frame interrupts
                IFNOTEMPTY  a0,1$
                clr.b       db_AutoFrame(db)
                jsr         SetSubcodeInterrupt
1$              rts



*****i* Dummy Commands *******************************************************

CmdReset:
CmdUpdate:                                                                      ; These commands do nothing
CmdClear:
CmdStop:
CmdStart:
CmdFlush:
CmdRemove:
NoCommand:
                rts


*****i* Write Protected ******************************************************

CmdFormat:
CmdWrite:
                move.b  #CDERR_WriteProt,IO_ERROR(ior)                          ; All disks are write protected
                rts

@


1.41
log
@Added bug comment to CD_CONFIG.
@
text
@d51 1
d189 1
a189 3
                clr.w   d0                                              ; Turn off drive light
                move.w  #$0500,db_Packet(db)
                jsr     SendPacket
@


1.40
log
@ATTENUATE command now only allows values from 0 to 7FFF.
@
text
@d1056 9
@


1.39
log
@ATTENUATE command now only allows values from 0 to 7FFF.
@
text
@d2158 2
a2159 1
                clr.l   IO_ACTUAL(ior)                                          ; Return previous attenuation
a2164 1
                and.l   #$7FFF,d0
d2166 5
d2184 1
a2184 3
                move.l  IO_OFFSET(ior),d1                                       ; Save our desired attenuation value
                and.l   #$7FFF,d1
                move.w  d1,db_TargetAttenuation(db)
d2188 2
a2189 1
2$              rts
d2200 1
@


1.38
log
@Disable prefetching before a seek.
@
text
@d2164 1
d2180 1
@


1.37
log
@Added include of "utility/tagitem.i"
@
text
@d519 5
@


1.36
log
@Fixed problem with multiple abort signals from drive.
@
text
@d18 1
@


1.35
log
@Updated CD_READ CD_READXL autodocs.
@
text
@d175 4
@


1.34
log
@updated documentation to CD_CONFIG command.
@
text
@d335 5
d1465 2
a1466 1
*       did occur.
@


1.33
log
@updated documentation to CD_CONFIG command.
@
text
@d1040 1
a1040 1
*       TAG_IGNORE and TAG_MORE do not work.
@


1.32
log
@Modification made to make sure that play commands are not
aborted before they have begun.
@
text
@d961 1
a961 1
*       TAGCD_READSPEED                 Default: Max Speed
d1040 1
@


1.31
log
@Clears PhotoCD flag on disk eject.
@
text
@d144 1
a144 1
1$
d149 1
d151 1
a152 2
*************** Test Drive Abort Signal ********************************
2$
d154 1
a154 1
                beq     3$
d162 1
a162 1
                bne     4$
d166 2
a167 1
3$
d169 1
a169 1
                beq     8$
d174 1
a174 1
4$
d179 1
a179 1
                beq     5$
d182 1
a182 1
5$
d189 1
a189 1
                bpl     6$
d191 1
a191 1
                bne     6$
d193 1
a193 1
6$
d196 1
a196 1
                bne     7$
d200 1
a200 1
7$
d210 3
a212 1
8$
d214 1
a214 1
                beq     11$
d221 1
a221 1
                bne     9$
d228 2
a229 2
                bra     10$
9$
d233 1
a233 1
10$
d241 2
a242 1
11$
d246 1
a246 1
                bne     20$
d249 1
a249 1
                bne     12$
d253 2
a254 2
                bne     30$
12$
d259 1
a259 1
                bra     2$
d263 2
a264 1
20$
d275 1
a275 1
                bra     1$
d279 2
a280 1
30$
d285 4
a288 2
                bne     31$

d294 2
a295 2
                bne     1$
31$
d305 1
a305 1
                bra     1$
d396 1
a396 1
                cmp.b   #IOERR_ABORTED,d0
@


1.30
log
@version 40.11.
@
text
@d223 1
@


1.29
log
@No effective change.
@
text
@d2158 2
a2159 2

3$              clr.w   db_FadeStepSize(db)                                     ; Cancel out any fade and set attenuation now
@


1.28
log
@no effective change.
@
text
@d2132 2
a2133 2
                clr.l   IO_ACTUAL(ior)
                move.w  db_Attenuation(db),IO_ACTUAL+2(ior)                     ; Return previous attenuation
d2162 4
d2167 1
d2224 1
a2224 1
                move.b  #1,db_AutoFrame(db)                                     ; Enable frame interrupts
@


1.27
log
@no effective change.
@
text
@d1 1
a2 1

d182 2
a183 2
                clr.w   d0
                move.w  #$0500,db_Packet(db)                            ; Turn off drive light
d253 1
@


1.26
log
@Play commands now abort read prefetching.
@
text
@d21 1
a22 1
        INCLUDE "cd.i"
@


1.25
log
@just modified the autodoc of the CD_CONFIG command.
@
text
@d59 1
d1570 5
d1722 5
@


1.24
log
@Added the ability to do 2336 byte sectors along with 2328 byte sectors.
@
text
@d1018 9
@


1.23
log
@Bumped retry rate to 2.
@
text
@d1062 1
a1062 1
                beq     5$
d1065 1
a1065 1
                beq     4$
d1068 1
a1068 1
                bne     3$
d1072 1
a1072 1
                beq     2$
d1074 2
d1077 3
d1081 2
a1082 2
                bra     5$
2$
d1084 1
a1084 1
                beq     3$
d1089 1
a1089 1
3$
d1092 1
a1092 1
4$
d1096 1
a1096 1
5$
d1105 1
a1105 1
                dc.l    TAGCD_SECTORSIZE,2048,2328,0
@


1.22
log
@ReadXL modified to use a list.
@
text
@d393 1
a393 1
                cmp.w   #5,db_RetryCount(db)
@


1.21
log
@Length field now supports a length for ReadXL command.

0 = end of disk
else, maximum transfer length.
@
text
@d377 3
a379 1
                move.l  #0,MLN_SUCC(a1)
d1355 1
a1355 1
*       io_Data         pointer to the first transfer list node.
d1367 4
a1370 4
*       location and deposits it into memory according to the nodes in the
*       transfer list.  The address of the first node in the transfer list
*       is placed in io_Data.  If you have a non-circular transfer list, simply
*       set io_Length to 0 (0 is special and means ignore io_Length) -- your
d1373 2
a1374 1
*       the transfer will terminate when io_Length bytes have been transferred.
d1394 2
a1395 1
*       encountered, or the command is aborted with AbortIO().
d1472 5
a1476 1
                move.l  IO_DATA(ior),a1                                         ; Start custom transfer list
@


1.20
log
@modified READ autodoc.
@
text
@d372 1
d1354 3
a1356 2
*       io_Length       0
*       io_Offset       starting location to begin read (WORD multiple).
d1367 5
a1371 2
*       is placed in io_Data.  io_Length is not used because the length of the
*       transfer is dictated by the length assigned within the nodes. 
d1447 2
a1448 1
                tst.l   IO_LENGTH(ior)
d1476 5
a1480 1
                clr.l   IO_ACTUAL(ior)
@


1.19
log
@revised autodoc.
@
text
@d307 1
a307 1
*       amounts.  Sectors and lengths are always in LSN format.
@


1.18
log
@Fixed problem with TOC and autodocs.
@
text
@d351 3
a353 2
                moveq.l #BLOCK_SHIFT,d0
                lsr.l   d0,d1
d357 1
a357 2
                moveq.l #BLOCK_SHIFT,d0
                lsr.l   d0,d2
d498 3
a500 2
                moveq.l #BLOCK_SHIFT,d0
                lsr.l   d0,d1
d832 2
d874 2
d939 2
d1118 2
d1216 2
d1446 4
a1449 2
                moveq.l #BLOCK_SHIFT,d0
                lsr.l   d0,d1
d1506 2
a1507 2
*       Music.
*
d1532 1
a1532 1
*       CD_PLAYMSF, CD_PLAYLSN, CD_PAUSE, CD_SEARCH
d1594 2
d1624 1
a1624 1
*       CD_PLAYTRACK, CD_PAUSE, CD_SEARCH
d1647 2
d1677 1
a1677 1
*       CD_PLAYTRACK, CD_PAUSE, CD_SEARCH
a1730 1
*
d1867 2
d1872 2
a1873 2
*       command only returns data when CD Audio is playing.  At any other
*       time, an error is returned.  The Q-Code packet consists of:
d1930 2
d1935 2
a1936 2
*       command only returns data when CD Audio is playing.  At any other
*       time, an error is returned.  The Q-Code packet consists of:
a2043 1
*
d2136 2
a2137 2
*       io_Error - 0 for success, or an error code as defined in
*                  <devices/cd.h>
d2150 1
a2150 1
*       This structure is supplied as the io_Data to the CD_ADDFRAMEINT
d2162 2
a2163 1
*       sent.
d2196 2
a2197 2
*       io_Error - 0 for success, or an error code as defined in
*                  <devices/cd.h>
@


1.17
log
@Range checking on reads now working.
@
text
@a429 2
*       The spindle motor may automatically spins down if there is an absence
*       of activity.
d1012 1
a1012 1
*       CD_INFO, <utility/taglist.h>
d1170 4
a1173 4
*           firsttrack   = tocarray[0].TOCSummary.FirstTrack;
*           lasttrack    = tocarray[0].TOCSummary.LastTrack;
*           totalsectors = tocarray[0].TOCSummary.LeadOut.LSN -
*                          tocarray[1].TOCEntry.Position.LSN;
d1313 3
a1315 3
                divu    #TOCEntry_SIZE,d3                                       ; Actual number of entries transferred
                and.l   #$0000FFFF,d3
                move.l  d3,IO_ACTUAL(ior)
@


1.16
log
@Read commands clear prefetch if there is an error in next sector.
@
text
@d346 3
a348 3
                save    d2
                clr.l   d2                                                      ; Current drive speed
                move.w  db_Info+CDINFO_ReadSpeed(db),d2
d350 9
a358 3
                move.l  IO_OFFSET(ior),d0                                       ; Convert offset to block
                moveq.l #BLOCK_SHIFT,d1
                lsr.l   d1,d0
d372 1
a372 1
                move.l  d2,db_ARG4(db)                                          ; - Set desired drive speed
d393 1
a393 1
                move.w  #75,d2                                                  ; Switch to normal speed.  Too many errors
d408 1
a408 1
                restore d2
d412 1
a412 1
                restore d2
d1436 3
a1438 3
                move.l  IO_OFFSET(ior),d0                                       ; Convert offset to block for testing
                moveq.l #BLOCK_SHIFT,d1
                lsr.l   d1,d0
d1683 1
a1683 2
1$
                add.l   d1,d2
@


1.15
log
@Fixed a bunch of commands (after writing all test programs).
@
text
@d57 1
d381 2
d1434 4
a1437 1
                ; check SEEEEEKKKK (not play range) range
@


1.14
log
@internal.i is now cdprivate.i
@
text
@d46 1
d172 1
a172 4
                clr.b   db_AutoQ(db)                                    ; Turn off frame interrupts
                clr.b   db_AutoFrame(db)
                clr.b   db_AutoFade(db)
                jsr     SetSubcodeInterrupt
d490 3
a492 3
                move.l  IO_OFFSET(ior),d0                                       ; Convert offset to block
                moveq.l #BLOCK_SHIFT,d1
                lsr.l   d1,d0
d497 1
a497 1
                move.l  d0,db_ARG1(db)                                          ; Seek to here
d654 1
a654 1
*       CD_GETDRIVETYPE, CD_GETGEOMETRY
d776 1
a776 1
*       CD_GETDRIVETYPE, CD_GETNUMTRACKS, <devices/trackdisk.h>
d785 2
a786 1
                clr.l   d0                                                      ; 2k sectors
d788 1
a788 1
                move.l  d0,dg_SectorSize(ior)
d792 16
a807 19
                move.l  d0,d1
                move.l  db_TOC+TOCE_Position(db),d0
                jsr     MSFtoLSNPOS
                sub.l   d0,d1
                move.l  d1,dg_TotalSectors(ior)
                move.l  #1,dg_Cylinders(ior)
                move.l  d1,dg_CylSectors(ior)
                move.l  #1,dg_Heads(ior)
                move.l  d1,dg_TrackSectors(ior)
                move.l  #MEMF_PUBLIC,dg_BufMemType(ior)

                move.b  #DG_CDROM,dg_DeviceType(ior)                            ; Removable CD-ROM disk
                move.b  #DGF_REMOVABLE,dg_Flags(ior)
                clr.w   dg_Reserved(ior)

                move.l  dg_SIZEOF,IO_ACTUAL(ior)                                ; DriveGeometry length
                rts
Geom_Error
                move.l  #0,IO_ACTUAL(ior)                                       ; Nothing to report
a1541 6
                move.w  db_TargetAttenuation(db),d0                             ; Make sure attenuation is correct
                cmp.w   db_Attenuation(db),d0
                beq     1$
                move.w  d0,db_Attenuation(db)
1$              bsr     Attenuate                

a1676 6
                move.w  db_TargetAttenuation(db),d0                             ; Make sure attenuation is correct
                cmp.w   db_Attenuation(db),d0
                beq     2$
                move.w  d0,db_Attenuation(db)
2$              bsr     Attenuate                

d2060 1
a2060 1
                clr.w   IO_ACTUAL(ior)
a2062 3
                move.l  IO_LENGTH(ior),d1                                       ; Current status only?
                bmi     2$

d2064 2
a2065 1
                move.w  d0,db_TargetAttenuation
d2067 1
d2069 1
a2069 1
                beq.s   1$
d2074 8
a2081 1
                move.w  d0,db_FadeStepSize(db)
d2083 3
a2085 4
                bne.s   2$                                                      ; Minimum fade step = 1
                move.w  #1,db_FadeStepSize(db)                          
2$:
                rts
d2087 1
a2087 1
1$:             clr.w   db_FadeStepSize(db)                                     ; Cancel out any fade and set attenuation now
a2145 5
                exec    Forbid                                                  ; Are we playing audio?
                move.w  db_Info+CDINFO_Status(db),d0
                btst    #CDSTSB_PLAYING,d0
                beq     1$

a2147 2
1$
                exec    Permit                                                  ; All done
@


1.13
log
@TOC commands now return errors if not TOC is present.
@
text
@d21 1
a21 1
        INCLUDE "internal.i"
@


1.12
log
@Fixed framecall interrupts.
changed some disables to forbids.
@
text
@d1267 4
d1322 3
@


1.11
log
@no effective change.
@
text
@d62 1
d182 1
d391 1
a391 1
                jsr     Disable                                                 ; Cancel error if not aborted
d395 1
a395 1
5$              jsr     Enable
d676 3
a678 2
*       and be prepared to deal with disk insertions/removals
*       immediately.
d711 1
a711 1
                jsr     Disable                                                 ; Add request to list
d714 1
a714 1
                jsr     Enable
d747 1
a747 1
                jsr     Disable                                                 ; Remove interrupt from list
d750 1
a750 1
                jsr     Enable
a1690 6
                bne     playexit

                lea     db_FrameList(db),a0                                     ; If list is not empty, enable frame interrupts
                IFEMPTY a0,playexit
                move.b  #1,db_AutoFrame(db)
                jsr     SetSubcodeInterrupt
d2122 2
d2150 1
a2150 1
                jsr     Disable                                                 ; Are we playing audio?
d2158 1
a2158 1
                jsr     Enable                                                  ; All done
@


1.10
log
@Reworked main task for abort IO stuff.  Q-Code commands should work now.
Play commands should work now too.
@
text
@d52 1
d181 3
@


1.9
log
@All kinds of changes to miscellaneous commands.
@
text
@d51 1
d126 4
d140 5
a144 4
                lea     db_ClassACmdPort(db),a0                         ; Check for a new non-disk-access type cmd
                exec    GetMsg
                tst.l   d0
                bne     9$
d146 1
a146 6
                move.l  db_ClassDReq(db),d0                             ; Check status of current disk-access cmd
                bne     2$
                lea     db_ClassDCmdPort(db),a0
                exec    GetMsg
                move.l  d0,db_ClassDReq(db)
                bne     10$
d148 6
a153 3
                move.l  #TASK_SIGS,d0                                   ; Wait for something to happen
                exec    Wait
                move.l  d0,d2
d155 3
a157 2
                btst    #SIGB_PLAYDONE,d2                               ; Play command complete?
                beq     6$
d161 3
d165 4
a173 2
                and.w   #-1-CDSTSF_PLAYING,db_Info+CDINFO_Status(db)    ; No longer playing audio

d176 1
a176 1
                beq     3$
d179 1
a179 1
3$
d182 1
a182 1
                bpl     4$
d184 1
a184 1
                bne     4$
d186 1
a186 1
4$
d189 1
a189 1
                bne     5$
d191 5
a195 3
                move.w  #CDCMD_STOPPLAY,db_CMD(db)                      ; Stop audio from playing
                jsr     DoCmd
5$
d203 1
a203 1
6$
d205 5
a209 1
                beq     1$
d212 3
a214 1
                bne     7$
a215 1
                move.w  #0,db_Info+CDINFO_Status(db)                    ; Door now open.  Nothing about drive status is true.
d218 2
a219 2
                bra     8$
7$
d223 1
a223 1
8$
d228 20
a247 1
                bra     1$
d251 1
a251 1
9$
d266 1
a266 1
10$
d271 1
a271 1
                bne     11$
d279 1
a279 1
11$
d369 1
a369 1
                
d371 4
a374 2
                cmp.b   #CDERR_ABORTED,d0
                beq     5$
d382 1
a382 1
                cmp.w   #20,db_RetryCount(db)
d410 1
a410 1
*       This command gives control over the spindle motor. The motor may be
d510 3
a512 3
*       This command returns the current value of the disk-change counter (as
*       used by the enhanced commands).  The disk change counter is
*       incremented each time a disk is inserted or removed from the cd unit.
a528 3

                move.l  db_ChgCount(db),d0
                jsr     PutHex
d548 1
a548 1
*       io_Actual - 0 menas there is a disk while anything else indicates
d671 1
a671 2
*       immediately.  From within the interrupt handler, you may only call the
*       status commands that can use IOF_QUICK.
d914 1
a914 1
*       CD_CONFIG -- Set speed preferences and/or sector size
d934 1
a934 1
*       TAGCD_EJECTRESET                Default: 0 (off)
d963 8
a970 8
*       it is free.  The READXL command is used primarily for display movie-
*       like data.  In this case, speed is essential and data integrety is
*       not; however, if the CPU is not being utilized during an XL animation,
*       there is no need to disable ECC (since the bandwidth is there to be
*       used).  The only time ECC should be disabled is when you are doing
*       intense calculations in the background of a READXL command, AND your
*       program is time-critical.  Do not forget to change this back when
*       you are done!
d1204 1
a1204 1
*       contain information about each individual track. All position
d1336 1
a1336 1
*       transfer list. The address of the first node in the transfer list
d1536 2
a1537 2
                bsr     Attenuate                
1$
d1575 1
a1575 1
*       A DoIO() will not return until the requested number have sectors
d1626 1
a1626 1
*       A DoIO() will not return until the requested number have sectors
d1677 2
a1678 2
                bsr     Attenuate                
2$
a1751 1

d1753 1
a1753 1
1$:
d1759 1
a1759 2
2$
                rts
d1788 1
a1788 1
*       to REV mode, when the play command is sent, the play will begin at the
d1801 1
d1862 1
a1863 1
*           union LSNMSF TrackPosition; /* Position from start of track     */
d1923 1
a1924 1
*           union LSNMSF TrackPosition; /* Position from start of track     */
d1982 1
a1982 1
                move.l  (a1)+,d0                                                ; Get absolute time - convert BCD to BIN format
d1985 1
d1987 1
a1987 1
                move.l  (a1)+,d0                                                ; Get relative time - convert BCD to BIN format
d1990 1
d1995 2
a1996 2
                move.l  IO_DATA(ior),a1                                         ; Convert disk position to LSN format
                move.l  QCODE_DiskPosition(a1),d0
d1998 1
a1998 1
                move.l  d0,QCODE_DiskPosition(a1)
d2000 1
a2000 1
                move.l  QCODE_TrackPosition(a1),d0                              ; Convert track position to LSN format
d2002 1
a2002 1
                move.l  d0,QCODE_TrackPosition(a1)
d2031 2
a2032 2
*       the attenuation will not be modified; the attenuation value will be
*       returned in io_Actual.
a2120 2
*       From within the interrupt handler, you may only call commands that
*       can use IOF_QUICK.
@


1.8
log
@Read command changes.
Task now signals when it is completely running.
@
text
@d38 2
d138 1
a138 1
                bne     8$
d145 1
a145 1
                bne     9$
d152 1
a152 1
                beq     5$
d162 1
a162 3
                move.w  db_Info+CDINFO_Status(db),d0                    ; No longer playing audio
                bclr    #CDSTSB_PLAYING,d0
                move.w  d0,db_Info+CDINFO_Status(db)
d170 8
a177 2
                move.l  db_ClassDReq(db),ior                            ; Return status (if error, clear actual)
                move.b  IO_ERROR(ior),d0
d179 1
a179 1
                bne     4$
d183 1
a183 1
4$
d191 1
a191 1
5$
a194 2
                PRINT   5$,"DISK_CHANGE"

d196 1
a196 3
                bne     6$

                PRINT   6$,"OPEN"
d201 2
a202 4
                bra     7$
6$
                PRINT   7$,"CLOSED"

d206 1
a206 1
7$
d215 1
a215 3
8$
;                PRINT   2$,"*CLASS_A*"

d230 1
a230 3
9$
;                PRINT   3$,"*CLASS_D*"

d235 1
a235 1
                bne     10$
d243 1
a243 1
10$
d330 1
d379 2
a380 2
*       The spindle motor may automatically spins down if there is an absense
*       of inactivity.
a397 2
                PRINT   1$,"MOTOR"

a417 2
                PRINT   3$,"DoingCMD"

d455 1
a455 6
                move.l  d0,d1                                                   ; Add on position of sector 0
                move.l  db_TOC+TOCEntry_SIZE+TOCE_Position(db),d0
                jsr     MSFtoLSNPOS
                add.l   d0,d1

                move.l  d1,db_ARG1(db)
a524 5
                beq     1$
                PRINT   1$,"DISK"
                rts
1$
                PRINT   2$,"NODISK"
a745 2
                ; perform a read of sector 0 (?)

a869 6

                PRINT   1$,"---STATUS---"
                clr.l   d0
                move.w  db_Info+CDINFO_Status(db),d0
                jsr     PutHex

d947 1
a947 1
*       struct TagItem ConfigList[] {
d976 26
a1001 2
                save    d2/d3/a2                                                ; Load up registers
                move.l  IO_DATA(ior),a0
d1021 2
a1022 2
                move.b  #CDERR_NotSpecified,IO_ERROR(ior)
                bra     3$
d1024 3
d1038 1
a1038 4
                restore d2/d3/a2                                                ; All done, exit
                rts
99$
                move.b  #IOERR_BADLENGTH,IO_ERROR(ior)                          ; Length invalid
d1043 1
a1043 1
                dc.l    TAGCD_PLAYSPEED,75,150,0
a1225 4
                move.w  db_Info+CDINFO_Status(db),d0                            ; Make sure TOC is valid first
                btst    #CDSTSB_TOC,d0
                beq     tocerror

a1270 3
tocerror:
                move.b  #CDERR_NoDisk,IO_ERROR(ior)                             ; TOC invalid, no disk present
                bra     tocexit
d1405 2
d1470 2
a1471 6
                save    d2                                                      ; Make sure TOC is valid first
                move.w  db_Info+CDINFO_Status(db),d0
                btst    #CDSTSB_TOC,d0
                beq     trackinvalidtoc

                move.l  IO_OFFSET(ior),d1                                       ; Check validity of io_Offset
a1511 3
trackinvalidtoc:
                move.b  #CDERR_NoDisk,IO_ERROR(ior)                             ; TOC invalid, no disk
                bra     trackexit
a1621 4
                move.w  db_Info+CDINFO_Status(db),d0                            ; Make sure TOC is valid first
                btst    #CDSTSB_TOC,d0
                beq     playinvalidtoc

a1627 1
                jsr     PutHex
a1629 1
                jsr     PutHex
a1630 1
                jsr     PutHex                                                  ; - Convert Length
a1632 1
                jsr     PutHex
a1634 2
                move.l  d2,d0
                jsr     PutHex
a1662 3
playinvalidtoc:
                move.b  #CDERR_NoDisk,IO_ERROR(ior)                             ; TOC invalid, no disk
                bra     playexit
d1930 1
a1930 1
                move.b  #CDCMD_QCODE,db_CMD(db)                                 ; Get a valid time-encoded packet
d1948 4
a1951 10
                clr.b   (a1)+                                                   ; Get absolute time - convert BCD to BIN format
                move.b  db_QCode+6(db),d0
                bsr     BCDtoBIN
                move.b  d0,(a1)+
                move.b  db_QCode+7(db),d0
                bsr     BCDtoBIN
                move.b  d0,(a1)+
                move.b  db_QCode+8(db),d0
                bsr     BCDtoBIN
                move.b  d0,(a1)+
d1953 3
a1955 10
                clr.b   (a1)+                                                   ; Get relative time - convert BCD to BIN format
                move.b  db_QCode+10(db),d0
                bsr     BCDtoBIN
                move.b  d0,(a1)+
                move.b  db_QCode+11(db),d0
                bsr     BCDtoBIN
                move.b  d0,(a1)+
                move.b  db_QCode+12(db),d0
                bsr     BCDtoBIN
                move.b  d0,(a1)+
@


1.7
log
@Added some print statements.
Activated drive speed flag.
@
text
@d25 2
d50 2
d112 1
a112 1
*       CD, and requests that don't or that only modifies the behavior *
d123 2
d127 7
a133 3
                PRINT   1$,"TaskRunning"

1$              lea     db_ClassACmdPort(db),a0                         ; Check for a new non-disk-access type cmd
d136 1
a136 1
                bne     7$
d143 1
a143 1
                bne     8$
d189 1
a189 4
                addq.l  #1,db_ChgCount(db)                              ; Increment change count

                lea     db_ChgList(db),a0                               ; Cause disk change interrupts
                bsr     CauseInterruptList
d194 2
d198 2
a199 1
                bra     1$
d201 7
a207 3
                move.w  db_Info+CDINFO_Status(db),d0                    ; Door is closed
                bset    #CDSTSB_CLOSED,d0
                move.w  d0,db_Info+CDINFO_Status(db)
d209 2
a210 2
                move.b  #CDCMD_SPIN,db_CMD(db)                          ; Try and detect disk
                jsr     DoCmd
d215 2
a216 8
7$
                save    d0
                move.w  IO_COMMAND(ior),d0                              ; If multitasking command, don't reply yet
                PRINT   8$,"***CMD***"
                jsr     PutHex
                restore d0

                PRINT   2$,"*CLASS_A*"
d232 2
a233 8
8$
                save    d0
                move.w  IO_COMMAND(ior),d0                              ; If multitasking command, don't reply yet
                PRINT   9$,"***CMD***"
                jsr     PutHex
                restore d0

                PRINT   4$,"*CLASS_D*"
d239 1
a239 1
                bne     9$
d241 4
d247 1
a247 1
9$
d295 2
a296 2
;                btst    #CDSTSB_CDROM,d0
;                beq     Read_NoROMErr
d308 4
d317 2
a318 2
;                jsr     CheckPlayRange                                          ; check range of read
;                bne     readinvalidlength
d329 1
a329 3
                clr.l   d0                                                      ; - Set desired drive speed
                move.w  db_Info+CDINFO_ReadSpeed(db),d0
                move.l  d0,db_ARG4(db)
d345 1
a345 1
                bclr.b  #0,d2                                                   ; Switch to normal speed.  Too many errors
d359 2
a360 1
                move.l  d0,IO_ACTUAL(ior)                 
d364 1
d503 3
d537 5
d884 1
a884 1
                move.l  d0,IO_ACTUAL(ior)
d887 7
a893 1
                dbne    d0,1$
@


1.6
log
@no effective change.
@
text
@d202 6
d225 6
a238 9
                move.w  IO_COMMAND(ior),d0                              ; If multitasking command, don't reply yet
                PRINT   5$,"***CMD***"
                jsr     PutHex
                lea     CmdOpts(pc),a1
                add.w   d0,d0
                move.w  0(a1,d0.w),d1
                move.w  d1,d0
                jsr     PutHex

d319 3
d1384 3
@


1.5
log
@mods to cmdRead were made.
@
text
@d235 1
@


1.4
log
@who knows.
who knows.
@
text
@d285 2
a286 2
                btst    #CDSTSB_CDROM,d0
                beq     Read_NoROMErr
d303 2
a304 2
                jsr     CheckPlayRange                                          ; check range of read
                bne     readinvalidlength
d310 1
a310 5
                move.l  IO_OFFSET(ior),d1                                       ; - Store start block
                move.l  db_TOC+TOCEntry_SIZE+TOCE_Position(db),d0               ; - Add on position of sector 0
                jsr     MSFtoLSNPOS
                add.l   d0,d1
                move.l  d1,db_ARG1(db)
@


1.3
log
@Added TagList.
@
text
@d31 2
d40 1
d47 2
d53 2
d81 2
a82 1
        XDEF    CmdTOC         
d85 2
a86 1
        XDEF    CmdPlay        
d89 2
a90 1
        XDEF    CmdQCode       
d119 4
d202 2
d205 1
a205 1
                jsr     PERFORMIO(db)
d219 2
d222 1
a222 1
                jsr     PERFORMIO(db)
d228 3
a230 1
                move.l  db_CmdOpts(db),a1
d233 2
a265 1
*       io_Flags        0
d310 6
a315 1
                move.l  IO_OFFSET(ior),db_ARG1(db)                              ; Store start block
a316 1
                move.l  IO_DATA(ior),db_ARG2(db)
d320 1
a320 1
                clr.l   IO_ACTUAL(ior)                                          ; Current actual amount transferred
a375 1
*       io_Flags        0 or IOF_QUICK
d388 2
d397 1
a397 1
                bne.s   1$
d410 2
a430 1
*       io_Flags        0 or IOF_QUICK
d449 4
a452 1
                move.l  d0,db_ARG1(db)
d454 2
a478 1
*       io_Flags        0 or IOF_QUICK
a504 1
*       io_Flags        0 or IOF_QUICK
a538 1
*       io_Flags        0 or IOF_QUICK
a567 1
*       io_Flags        0 or IOF_QUICK
a602 1
*       io_Flags        0 or IOF_QUICK
a649 1
*       io_Flags        0
a687 1
*       io_Flags        0
a723 1
*       io_Flags        0 or IOF_QUICK
d744 3
a746 1
                move.l  #2048,dg_SectorSize(ior)                                ; 2k sectors
d749 1
a749 1
                jsr     MSFtoLSN
d752 1
a752 1
                jsr     MSFtoLSN
d1027 1
a1027 1
******* cd.device/CD_TOC *****************************************************
d1030 1
a1030 1
*       CD_TOC -- Return table of contents information from CD.
a1035 1
*       io_Flags        data format (MSF or LSN)
d1048 2
a1049 1
*       contain information about each individual track.
d1092 1
a1092 2
*       ior->io_Command = CD_TOC;           /* Retrieve TOC information */
*       ior->io_Flags   = IOF_LSNFORM;      /* Set this for LSN format  */
d1118 78
d1197 2
a1198 1
                save    d2-d5
a1199 2
                exec    Forbid

d1204 1
a1205 4
                move.l  IO_LENGTH(ior),d2
                beq     tocexit
                cmp.l   #100,d2
                bhs     tocinvalidlength
d1211 7
a1217 1
                bhs     tocinvalidoffset                                        ; - A1 = Data, D1 = Offset, D2 = Length
d1219 2
a1220 5
                move.l  d1,d4                                                   ; Copy all requested TOC entries
                mulu    #TOCEntry_SIZE,d4
                clr.l   d5
                move.b  db_TOC+TOCS_LastTrack(db),d5
                mulu    #TOCEntry_SIZE,d5
d1222 4
d1227 2
a1228 2
                move.b  db_TOC+TOCE_CtlAdr(db),TOCE_CtlAdr(a1,d4.w)             ; Get CtlAdr and Track index
                move.b  db_TOC+TOCE_Track(db),TOCE_Track(a1,d4.w)
d1230 2
a1231 2
                move.l  db_TOC+TOCE_Position(db),d0                             ; Get start of track (or start of lead-out)
                btst.b  #IOB_LSNFORM,IO_FLAGS(ior)                              ; - Convert to LSN format if requested
d1233 1
a1233 1
                bsr     MSFtoLSN
d1237 4
a1240 4
                cmp.w   d5,d4
                bhi     3$
                add.w   #1,d3
                cmp.w   d2,d3
d1243 3
a1245 1
                move.l  d3,IO_ACTUAL(ior)                                       ; Actual number of entries transferred
a1246 2
                exec    Permit

d1441 1
a1441 1
*       CD_PLAY, CD_PAUSE, CD_SEARCH
d1446 2
a1447 4
                save    d2
                exec    Forbid

                move.w  db_Info+CDINFO_Status(db),d0                            ; Make sure TOC is valid first
d1458 1
d1461 1
a1461 3
                cmp.b   d1,d2
                bls     trackinvalidlength
                sub.b   #1,d2
d1464 1
a1464 1
                add.b   #1,d2
d1470 2
a1471 2
                move.l  TOCE_Position(a0,d1),d0                                 ; Start at this track
                jsr     MSFtoLSN
d1474 2
a1475 2
                move.l  TOCE_Position(a0,d2),d0                                 ; Length of play
                jsr     MSFtoLSN
a1476 3
                sub.l   d1,d2

                exec    Permit
d1489 1
a1489 6

                restore d2
                rts
trackexiterror:
                exec    Permit

d1494 1
a1494 1
                bra     trackexiterror
d1499 1
a1499 1
                bra     trackexiterror
d1502 1
a1502 1
******* cd.device/CD_PLAY ****************************************************
d1505 1
a1505 1
*        CD_PLAY -- Play a selected portion of CD audio.
d1510 1
a1510 2
*       io_Command      CD_PLAY
*       io_Flags        data format (MSF or LSN) 
d1522 1
a1522 1
*       the amount of time to play.
d1534 3
a1536 4
*       ior->io_Command = CD_PLAY;      /* Play CD audio          */
*       ior->io_Flags   = 0;            /* MSF format             */
*       ior->io_Offset  = 0x00143A0A;   /* $14=20, $3A=58, $0A=10 */
*       ior->io_Length  = 0x00020A00;   /* $02=02, $0A=10, $00=00 */
d1539 35
a1573 1
*       or:
d1575 13
a1587 4
*       ior->io_Command = CD_PLAY;      /* Play CD audio           */
*       ior->io_Flags   = IOF_LSNFORM;  /* LSN format              */
*       ior->io_Offset  = 94360;        /* 20*(60*75) + 58*75 + 10 */
*       ior->io_Length  = 9750;         /* 02*(60*75) + 10*75 + 00 */
d1599 2
d1602 3
a1610 1
                add.l   d1,d2
d1612 1
a1612 1
                btst.b  #IOB_LSNFORM,IO_FLAGS(ior)                              ; Convert LSN to MSF?
d1614 3
a1616 2
                move.l  d1,d0                                                   ; - Convert End
                bsr     MSFtoLSN
d1618 3
a1620 1
                move.l  d2,d0                                                   ; - Convert Length
d1623 1
d1625 4
d1643 1
a1643 1
                bne     3$
d1646 1
a1646 1
                IFEMPTY a0,3$
d1649 2
a1650 1
3$
d1655 1
a1655 1
                rts
d1658 1
a1658 1
                rts
d1800 62
a1861 1
******* cd.device/CD_QCODE ***************************************************
d1864 1
a1864 1
*       CD_QCODE -- Report current disk position.
d1869 1
a1869 2
*       io_Command      CD_QCODE
*       io_Flags        data format (MSF or LSN)
d1894 1
a1894 2
*       ior->io_Command = CD_QCODE;     /* Retrieve TOC information */
*       ior->io_Flags   = 0;            /* MSF format               */
d1916 1
a1916 1
*       CD_PLAY, CD_PLAYTRACK, <devices/cd.h>
d1920 2
d1923 3
d1966 1
a1966 1
                btst.b  #IOB_LSNFORM,IO_FLAGS(ior)                              ; Convert to LSN format if requested
d1971 1
a1971 1
                jsr     MSFtoLSN
d1975 1
a1975 1
                jsr     MSFtoLSN
d1978 1
a2080 1
*       io_Flags        0
a2146 1
*       io_Flags        0
@


1.2
log
@all kinds of new stuff.
@
text
@d3 16
a18 16
        INCLUDE "include:exec/types.i"
        INCLUDE "include:exec/nodes.i"
        INCLUDE "include:exec/lists.i"
        INCLUDE "include:exec/ports.i"
        INCLUDE "include:exec/libraries.i"
        INCLUDE "include:exec/tasks.i"
        INCLUDE "include:exec/devices.i"
        INCLUDE "include:exec/memory.i"
        INCLUDE "include:exec/interrupts.i"
        INCLUDE "include:exec/resident.i"
        INCLUDE "include:exec/io.i"
        INCLUDE "include:exec/errors.i"
        INCLUDE "include:exec/execbase.i"
        INCLUDE "include:hardware/intbits.i"
        INCLUDE "include:devices/trackdisk.i"
        INCLUDE "include:exec/ables.i"
d174 1
d858 2
a859 2
*       io_Data         pointer to CDConfig structure
*       io_Length       sizeof(struct CDConfig)
d864 2
a865 2
*       This command sets one or more of the configuration items described
*       in the CDConfig structure.  The structure is defined as:
d867 6
a872 7
*       struct CDConfig {
*                               /*                               Default */
*           UWORD PlaySpeed;    /* Audio play speed               (75)   */
*           UWORD ReadSpeed;    /* Data-rate of CD_READ command   (max)  */
*           UWORD ReadXLSpeed;  /* Data-rate of CD_READXL command (75)   */
*           UWORD SectorSize;   /* Number of bytes per sector     (2048) */
*           }
d893 21
a913 5
*       To change a configuration value, create a CDConfig structure setting
*       the items you want changed to the appropriate values, and the items
*       you do not want changed to -1.  Submit a request to the device driver
*       with io_Data pointing to this structure and io_Length set to the size
*       of CDConfig.
d916 4
a919 3
*       /* Configure ReadXL for double-speed reading */
*
*       struct CDConfig Config;
d921 4
a924 4
*           Config.PlaySpeed   = -1;        /* do not change */
*           Config.ReadSpeed   = -1;        /* do not change */
*           Config.ReadXLSpeed = 150;       /* double speed  */
*           Config.SectorSize  = -1;        /* do not change */
d927 2
a928 2
*           ior->io_Data    = (APTR)&Config;
*           ior->io_Length  = sizeof(struct CDConfig);
d940 1
a940 1
*       CD_INFO
d945 15
a959 3
                move.l  IO_DATA(ior),a0                                         ; Load up registers.  IO_LENGTH nonzero?
                move.l  IO_LENGTH(ior),d1
                beq     99$
d961 7
a967 2
                move.w  0(a0),d0                                                ; Set PlaySpeed if requested
                cmp.w   #-1,d0
d969 2
a970 5
                cmp.w   #75,d0
                beq     1$
                cmp.w   #150,d0
                bne     ErrorConfig
1$              move.w  d0,db_Info+CDINFO_Config+CONFIG_PlaySpeed(db)
d972 6
a977 11
                subq.l  #2,d0                                                   ; Set ReadSpeed if requested
                beq     99$
                bmi     99$
                move.w  2(a0),d0
                cmp.w   #-1,d0
                beq     4$
                cmp.w   #75,d0
                beq     3$
                cmp.w   #150,d0
                bne     ErrorConfig
3$              move.w  d0,db_Info+CDINFO_Config+CONFIG_ReadSpeed(db)
d979 10
a988 25
                subq.l  #2,d0                                                   ; Set ReadXLSpeed if requested
                beq     99$
                bmi     99$
                move.w  4(a0),d0
                cmp.w   #-1,d0
                beq     6$
                cmp.w   #75,d0
                beq     5$
                cmp.w   #150,d0
                bne     ErrorConfig
5$              move.w  d0,db_Info+CDINFO_Config+CONFIG_ReadXLSpeed(db)
6$
                subq.l  #2,d0                                                   ; Set SectorSize if requested
                beq     99$
                bmi     99$
                move.w  6(a0),d0
                cmp.w   #-1,d0
                beq     8$
                cmp.w   #2048,d0
                beq     7$
                cmp.w   #2328,d0
                bne     ErrorConfig
7$              move.w  d0,db_Info+CDINFO_Config+CONFIG_SectorSize(db)
8$
99$             rts
d990 8
a997 3
ErrorConfig:
                move.b  #CDERR_NotSpecified,IO_ERROR(ior)                       ; Invalid value specified
                rts
@


1.1
log
@Initial revision
@
text
@a30 2
        XREF    GetClassAError
        XREF    GetClassDError
d38 4
a41 3
        XREF    MakeXL
        XREF    StartXL
        XREF    GetQCodePacket
d43 2
a47 1

a48 1
        XDEF    AbortCmd
d73 1
a81 3
        XDEF    CmdPlaySpeed   
        XDEF    CmdReadSpeed   
        XDEF    CmdReadXLSpeed 
d107 1
a107 2
                move.l  db_HardwareBase(db),hb
                bsr     CmdReset
d109 1
a109 1
1$              lea     db_ClassACmdPort(db),a0                         ; Check for a new non-disk-access type command
d114 1
a114 1
                move.l  db_ClassDCmd(db),d0                             ; Check status of current disk-access type command
d118 1
a118 1
                move.l  d0,db_ClassDCmd(db)
d121 1
a121 1
                move.l  #WAIT_SIGS,d0                                   ; Wait for something to happen
d123 4
a127 2
                btst    #SIGB_PLAYDONE,d0                               ; Asynchronous command complete?
                beq     1$
d129 1
a129 2
                move.l  db_ClassDCmd(db),d0                             ; Command aborted?
                beq     1$
d131 4
a134 5
                move.l  d0,ior                                          ; Return status (if error, clear actual)
                bsr     GetClassDError
                move.b  d0,IO_ERROR(ior)
                beq     3$
                clr.l   IO_ACTUAL(ior)
d136 3
a138 2
                cmp.b   #CDERR_ABORTED,db_ClassDErr(db)                 ; Reset CD if command was aborted
                bne     3$
d140 5
a144 1
                ; Send STOPPLAY command
d146 7
a152 7
;                tst.w   db_FadeLength(db)                               ; Make sure fade is complete - subcodes are about to stop
;                beq     4$
;                tst.w   db_FadeStepSize(db)
;                bpl     4$
;                clr.w   db_FadeLength(db)
;                move.w  db_FadeTarget(db),db_Attenuation(db)
;                bsr     Attenuate
d154 1
a154 1
                clr.l   db_ClassDCmd(db)                                ; Class D command done
d158 24
d183 3
a187 1
                clr.b   db_ClassDErr(db)
d190 1
a190 2
                clr.b   db_ClassAErr(db)                                ; Reply to command
                move.l  ior,a1
d192 5
d199 2
a202 2
                clr.b   db_ClassAErr(db)
                clr.b   db_ClassDErr(db)
d205 1
a205 1
                tst.b   IO_ERROR(ior)                                   ; Could we start async command?
d208 1
a208 1
                move.w  IO_COMMAND(ior),d0                              ; If this is asynchronous, do not reply yet.
d212 1
a212 1
                btst    #OB_ASYNC,d1
d215 1
a215 1
                clr.l   db_ClassDCmd(db)                                ; Class D command done
d217 1
a217 1
                move.l  ior,a1                                          ; Synchronous command, reply and return
a218 1
                bra     1$
d220 1
a220 43

*
************************************************************************
***
***  DoCmd
***
***     Send a 4510 command and wait for it to complete
***
************************************************************************

        XDEF    DoCmd

DoCmd:
                ; send off command

                move.l  #SIGF_CMDDONE,d0
                exec    Wait

                bsr     GetClassAError                                  ; Retrieve error status
                cmp.b   #CDERR_ABORTED,db_ClassAErr(db)
                beq     AbortCmd

                tst.b   d0                                              ; Return error status
                rts
1$
                jsr     Enable                                          ; Command has already been aborted.

                tst.b   d0                                              ; Return error status
                rts


************************************************************************
***
***  AbortCmd
***
***     Reset the 4510's drive interface and clear signals
***
************************************************************************

AbortCmd:
                ; Reset the CD

                move.l  #SIGF_CMDDONE|SIGF_PLAYDONE,d1                          ; Clear DONE|PLAYDONE signals that may have gotten through
d224 1
a224 32
                move.b  #CDERR_ABORTED,d0                                       ; Command aborted

                rts

*
******* cd.device/CD_RESET ***************************************************
*
*   NAME
*       CD_RESET -- Initialize CD hardware and driver.
*
*   FUNCTION
*       Reset the device driver and CD hardware.  Abort outstanding I/O
*       requests.  Does not alter configuration (modes, speeds).
*
*   IO REQUEST INPUT
*       io_Device       preset by the call to OpenDevice()
*       io_Unit         preset by the call to OpenDevice()
*       io_Command      CD_RESET
*       io_Flags        0 or IOF_QUICK
*
*   IO REQUEST RESULT
*       io_Error - 0 for success, or an error code as defined in
*                  <devices/cd.h>
*   NOTES
*
*   SEE ALSO
*
******************************************************************************

CmdReset:
                rts

a276 4
                ; set read speed

                move.w  #CDCMD_READ,db_CMD(db)                                  ; We're going to read

d281 2
a282 1
                move.l  d0,db_ARG1(db)                                          ; Store start block
d284 1
a284 2
                move.l  IO_LENGTH(ior),d0                                       ; Set expected actual
                move.l  d0,IO_ACTUAL(ior)                 
d286 11
a296 2
                add.l   #BLOCK_SIZE-1,d0                                        ; Convert length to number of blocks
                lsr.l   d1,d0
d298 1
a298 5
                move.l  d0,db_ARG2(db)                                          ; Store length block
                bsr     MakeXL                                                  ; Put together the transfer list

                lea     db_XferNodes(db),a1                                     ; Start the transfer
                bsr     StartXL
d300 3
a302 7
                move.l  #SIGF_CMDDONE,d0                                        ; Wait complete
                exec    Wait

                bsr     GetClassAError                                          ; Set error
                beq     5$                                                      ; - Retry read if error != drive not ready
                cmp.b   #CDERR_ABORTED,db_ClassAErr(db)
                beq     6$
a309 1
                clr.b   db_ClassAErr(db)                                        ; Clear the error for next time
d311 16
a326 3
                bls     1$
5$
                move.b  d0,IO_ERROR(ior)                                        ; Report error
a327 3
6$
                bsr     AbortCmd                                                ; Reset the CD and return
                bra     5$
d343 2
a344 1
*       The spindle motor automatically spins down after three minutes.
d384 1
a384 1
3$:             move.b  d0,IO_ERROR(ior)
d394 1
a394 1
*       CD_SEEK moves the laser to the approximate position specified. The
d417 4
d424 4
a427 1
                move.b  d0,IO_ERROR(ior)
d439 2
a440 2
*       used by the enhanced commands). The disk change counter is incremented
*       each time a disk is inserted or removed from the cd unit.
d464 1
a464 1
*       CD_CHANGESTATE -- check if a disk is currently in a drive.
d467 1
a467 1
*       This command checks to see if there is currently a disk in a drive.
d481 3
d523 1
a523 1
******* cd.device/CD_GETDRIVETYPE ********************************************
a553 2
DRIVE_CDROM equ 5                                                               ; This should be defined in trackdisk.h

d555 1
a555 1
                move.l  #DRIVE_CDROM,IO_ACTUAL(ior)                             ; CD-ROM drive
d560 1
a560 1
******* cd.device/CD_GETNUMTRACKS ********************************************
d604 1
a604 1
*       immediately. From within the interrupt handler, you may only call the
d609 2
a610 2
*       command. The handler then gets linked into the handler chain and
*       gets invoked whenever a disk change happens. You must eventually
d615 1
a615 1
*       is executed with that same IO request. Hence, you must use SendIO()
d848 137
d1150 1
a1150 1
*       io_Length       number of bytes to read (WORD multiple).
d1161 3
a1163 3
*       transfer list.  The total number of bytes to transfer is placed in
*       io_Length.  The address of the transfer list header, or one of its
*       nodes, is placed in io_Data.
d1169 6
a1174 5
*           struct  MinNode Node;       /* double linkage       */
*           char   *Buffer;             /* data (word aligned)  */
*           LONG    Length;             /* must be even # bytes */
*           void    (*DoneFunc)();      /* called when done     */
*           LONG    Actual;             /* bytes transferred    */
d1182 2
a1183 2
*       total amount of data you've requested has been read, or the list
*       has been exhausted.  This command can be aborted with AbortIO().
d1185 2
a1186 2
*       If you fill in the DoneFunc field with a pointer to a call-back
*       function, your routine will be called when the transfer for the node
d1188 4
a1191 4
*       the next node.  You may manipulate the list from within the
*       call-back.  Register A2 will contain a pointer to the CDXL node
*       just completed.  Registers D0,D1,A0,A1 may be trashed, but all other
*       registers must be preserved.  Your code must be brief (this is an
d1195 13
d1227 1
a1227 1
*       CMD_READ, CD_SEEK
a1236 1
                or.l    IO_LENGTH(ior),d0
d1239 2
d1242 3
a1244 3
                move.l  IO_DATA(ior),d0                                         ; Must be word aligned
                btst    #0,d0
                bne     Read_BadAddress
d1246 1
a1246 1
                ; set read speed
d1248 1
a1248 1
                move.w  #CDCMD_READ,db_CMD(db)                                  ; We're going to read
d1250 1
a1250 1
                move.l  IO_OFFSET(ior),db_ARG1(db)                              ; Store start block
d1252 1
a1252 3
                move.l  IO_LENGTH(ior),d0                                       ; Set expected actual
                move.l  d0,IO_ACTUAL(ior)
                move.l  d0,db_ARG2(db)
d1255 6
a1260 10
                bsr     StartXL

                cmp.b   #CDERR_ABORTED,db_ClassAErr(db)                         ; Don't wait on a command that didn't start
                beq     3$

                move.l  #SIGF_CMDDONE,d0                                        ; Wait complete
                exec    Wait
3$
                bsr     GetClassAError                                          ; Get Error
                move.b  d0,IO_ERROR(ior)
d1262 1
a1262 3
                cmp.b   #CDERR_ABORTED,db_ClassAErr(db)                         ; Aborted?
                beq     5$
4$
a1263 3
5$
                bsr     AbortCmd                                                ; Reset the CD and return
                bra     4$
d1274 1
a1274 2
                move.b  d0,db_ClassAErr(db)                                     ; Return Error
                move.b  d0,IO_ERROR(ior)
d1329 1
a1329 1
                beq     playinvalidtoc
d1333 1
a1333 1
                blo     playinvalidoffset
d1335 1
a1335 1
                bhi     playinvalidoffset
d1341 1
a1341 1
                bls     playinvalidlength
d1344 1
a1344 1
                bhi     playinvalidlength
d1362 6
a1367 2
                ; Make sure attenuation is correct

a1373 2
                move.b  d0,IO_ERROR(ior)                                        ; Return status

d1376 1
a1376 1
playexiterror:
d1381 1
a1381 1
playinvalidtoc:
d1383 4
a1386 3
                bra     playexiterror
playinvalidlength:
playinvalidoffset:
d1388 1
a1388 1
                bra     playexiterror
d1448 4
d1457 1
a1457 1
                beq     2$
d1459 1
a1459 1
                bsr     LSNtoMSF
d1461 2
a1462 2
                move.l  d2,d0                                                   ; - Convert Start 
                bsr     LSNtoMSF
d1464 3
a1466 2
2$:
                ; Make sure attenuation is correct
d1468 6
d1479 8
d1488 5
a1492 1
                move.b  d0,IO_ERROR(ior)                                        ; Error?
a1540 11
                bclr    #CDSTSB_PAUSED,d0                                       ; Set or clear pause mode
                clr.w   d1
                tst.l   IO_LENGTH(ior)
                sne.w   d1
                and.w   CDSTSF_PAUSED,d1
                or.w    d1,d0
                move.w  d0,db_Info+CDINFO_Status(db)

                btst    #CDSTSB_PLAYING,d0                                      ; Is there an outstanding request?
                beq     2$

d1547 1
a1547 1
                move.b  #CDCMD_RESUME,db_CMD(db)                                ; Resume play if we were playing
d1555 1
a1555 1
                move.b  #CDCMD_PAUSE,db_CMD(db)                                 ; Pause Play if we are playing
d1569 1
a1569 1
*       io_Data         0
d1627 1
a1627 20
                move.w  db_Info+CDINFO_Status(db),d0                            ; Enable search mode?
                bclr    #CDSTSB_SEARCH,d0
                bclr    #CDSTSB_DIRECTION,d0
                tst.l   IO_LENGTH(ior)
                beq     3$
                bset    #CDSTSB_SEARCH,d0

                cmp.l   #1,IO_LENGTH(ior)                                       ; Which direction do we search?
                beq     3$
                bset    #CDSTSB_DIRECTION,d0
3$
                move.w  d0,db_Info+CDINFO_Status(db)                            ; New status
                
                btst    #CDSTSB_PLAYING,d0                                      ; Are we currently playing audio?
                beq     9$

                jsr     GetQCodePacket                                          ; Get current position if we are still playing
                bne     9$

                move.b  #CDCMD_SETPLAYMODE,db_CMD(db)                           ; Set PlayMode...
a1630 1
9$
d1697 3
a1699 2
                jsr     GetQCodePacket                                          ; Get a valid time-encoded packet
                bne     QCode_notplaying
a1750 4
QCode_notplaying:
                move.b  #CDERR_InvalidState,IO_ERROR(ior)                       ; CD must be playing audio for this to work
                rts

a1841 149
******* cd.device/CD_PLAYSPEED ***********************************************
*
*   NAME
*       CD_PLAYSPEED -- configure the speed of the PLAY/PLAYTRACK command
*
*   IO REQUEST
*       io_Device       preset by the call to OpenDevice()
*       io_Unit         preset by the call to OpenDevice()
*       io_Command      CD_PLAYSPEED
*       io_Data         0
*       io_Length       play rate (75/150)
*
*   RESULTS
*
*   FUNCTION
*       This command configures the play-rate of the PLAY command.
*       There are currently two transfer rates: normal speed and double
*       speed.  Normal speed transfers 75 sectors per second. Double speed
*       transfers 150 sectors per second.  Under most circumstances, you will
*       want to play audio at normal speed (75 frames/second).  Double-speed
*       play is probably only useful for high-speed audio dubbing.
*
*   EXAMPLE
*       /* Configure Play command for double speed mode. */
*       ior->io_Command = CD_PLAYSPEED;
*       ior->io_Data    = NULL;
*       ior->io_Length  = 150;
*       DoIO(ior);
*
*   NOTES
*
*   BUGS
*
*   SEE ALSO
*
******************************************************************************

CmdPlaySpeed:
                move.l  IO_LENGTH(ior),d0                                       ; Set play speed
                move.w  d0,db_Info+CDINFO_PlaySpeed(db)
                rts





*
******* cd.device/CD_READSPEED ***********************************************
*
*   NAME
*       CD_READSPEED -- configure the data-rate of the READ command
*
*   IO REQUEST
*       io_Device       preset by the call to OpenDevice()
*       io_Unit         preset by the call to OpenDevice()
*       io_Command      CD_READSPEED
*       io_Data         0
*       io_Length       data rate (75/150)
*
*   RESULTS
*
*   FUNCTION
*       This command configures the data-rate of the READ command.
*       There are currently two transfer rates: normal speed and double
*       speed.  Normal speed transfers 75 sectors per second. Double speed
*       transfers 150 sectors per second.  The number of sectors per second
*       is equivalent to the frame rate.
*
*   EXAMPLE
*       /* Configure READ command for double speed mode. */
*       ior->io_Command = CD_READSPEED;
*       ior->io_Data    = NULL;
*       ior->io_Length  = 150;
*       DoIO(ior);
*
*   NOTES
*
*   BUGS
*
*   SEE ALSO
*
******************************************************************************

CmdReadSpeed:
                move.l  IO_LENGTH(ior),d0                                       ; Set read speed
                move.w  d0,db_Info+CDINFO_ReadSpeed(db)
                rts





*
******* cd.device/CD_READXLSPEED *********************************************
*
*   NAME
*       CD_READXLSPEED -- configure the data-rate of the READXL command
*
*   IO REQUEST
*       io_Device       preset by the call to OpenDevice()
*       io_Unit         preset by the call to OpenDevice()
*       io_Command      CD_READXLSPEED
*       io_Data         0
*       io_Length       data rate (75/150)
*
*   RESULTS
*
*   FUNCTION
*       This command configures the data-rate of the READXL command.
*       There are currently two transfer rates: normal speed and double
*       speed.  Normal speed transfers 75 sectors per second. Double speed
*       transfers 150 sectors per second.  The number of sectors per second
*       is equivalent to the frame rate.
*
*       The basis for having a separate speed configuration command for the
*       READXL command is because the READXL command is used exclusively for
*       data.  The READ command can be used for both code or data.  The rate
*       at which (for instance) you would want to load animation data may be
*       different from the rate at which you may want to load code.  As drives
*       become more advanced, the default speed of the READ command will
*       increase with the maximum speed of the drive.  The READXL command is
*       used primarily for animations.  It is essential that READXL command's
*       speed not change with timing-dependant applications like this.
*
*   EXAMPLE
*       /* Configure READXL command for double speed mode. */
*       ior->io_Command = CD_READXLSPEED;
*       ior->io_Data    = NULL;
*       ior->io_Length  = 150;
*       DoIO(ior);
*
*   NOTES
*
*   BUGS
*
*   SEE ALSO
*
******************************************************************************

CmdReadXLSpeed:
                move.l  IO_LENGTH(ior),d0                                       ; Set readxl speed
                move.w  d0,db_Info+CDINFO_ReadXLSpeed(db)
                rts





*
d1862 1
a1862 1
*       when CD audio is being played.
d1871 2
a1872 2
*       command. The handler then gets linked into the handler chain and
*       gets invoked whenever a frame event occurs. You must eventually
d1877 1
a1877 1
*       is executed with that same IO request. Hence, you must use SendIO()
d1880 4
d1892 12
a1903 1
                bra     AddRequest
d1906 1
d1938 1
a1938 1
                bra     RemoveRequest                                           ; Remove request from frame list
d1940 5
d1946 2
d1950 1
d1959 1
@
