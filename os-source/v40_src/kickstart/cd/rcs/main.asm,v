head     1.34;
branch   ;
access   ;
symbols  ;
locks    jerryh:1.34; strict;
comment  @* @;


1.34
date     94.02.14.09.48.45;  author jerryh;  state Exp;
branches ;
next     1.33;

1.33
date     93.09.08.14.59.16;  author jerryh;  state Exp;
branches ;
next     1.32;

1.32
date     93.05.18.11.49.06;  author jerryh;  state Exp;
branches ;
next     1.31;

1.31
date     93.04.30.16.52.06;  author jerryh;  state Exp;
branches ;
next     1.30;

1.30
date     93.04.16.14.52.11;  author jerryh;  state Exp;
branches ;
next     1.29;

1.29
date     93.04.13.17.06.37;  author jerryh;  state Exp;
branches ;
next     1.28;

1.28
date     93.04.12.15.48.27;  author jerryh;  state Exp;
branches ;
next     1.27;

1.27
date     93.04.08.11.08.58;  author jerryh;  state Exp;
branches ;
next     1.26;

1.26
date     93.04.08.10.18.12;  author jerryh;  state Exp;
branches ;
next     1.25;

1.25
date     93.04.02.15.41.04;  author jerryh;  state Exp;
branches ;
next     1.24;

1.24
date     93.03.29.13.33.07;  author jerryh;  state Exp;
branches ;
next     1.23;

1.23
date     93.03.24.14.15.57;  author jerryh;  state Exp;
branches ;
next     1.22;

1.22
date     93.03.18.14.48.25;  author jerryh;  state Exp;
branches ;
next     1.21;

1.21
date     93.03.06.12.33.53;  author jerryh;  state Exp;
branches ;
next     1.20;

1.20
date     93.02.23.15.51.55;  author jerryh;  state Exp;
branches ;
next     1.19;

1.19
date     93.02.17.15.31.40;  author jerryh;  state Exp;
branches ;
next     1.18;

1.18
date     93.02.15.10.15.20;  author jerryh;  state Exp;
branches ;
next     1.17;

1.17
date     93.02.11.13.50.54;  author jerryh;  state Exp;
branches ;
next     1.16;

1.16
date     93.02.09.15.50.11;  author jerryh;  state Exp;
branches ;
next     1.15;

1.15
date     93.02.08.16.37.16;  author jerryh;  state Exp;
branches ;
next     1.14;

1.14
date     93.02.03.12.08.53;  author jerryh;  state Exp;
branches ;
next     1.13;

1.13
date     93.02.02.10.52.11;  author jerryh;  state Exp;
branches ;
next     1.12;

1.12
date     93.01.22.12.00.55;  author jerryh;  state Exp;
branches ;
next     1.11;

1.11
date     93.01.15.15.40.03;  author jerryh;  state Exp;
branches ;
next     1.10;

1.10
date     93.01.07.09.36.46;  author jerryh;  state Exp;
branches ;
next     1.9;

1.9
date     92.12.12.17.44.13;  author jerryh;  state Exp;
branches ;
next     1.8;

1.8
date     92.12.11.13.34.06;  author jerryh;  state Exp;
branches ;
next     1.7;

1.7
date     92.12.09.15.20.06;  author jerryh;  state Exp;
branches ;
next     1.6;

1.6
date     92.12.07.11.57.44;  author jerryh;  state Exp;
branches ;
next     1.5;

1.5
date     92.12.05.16.52.27;  author jerryh;  state Exp;
branches ;
next     1.4;

1.4
date     92.12.04.10.18.59;  author jerryh;  state Exp;
branches ;
next     1.3;

1.3
date     92.11.23.09.21.05;  author jerryh;  state Exp;
branches ;
next     1.2;

1.2
date     92.11.02.13.31.28;  author jerryh;  state Exp;
branches ;
next     1.1;

1.1
date     92.10.21.15.02.11;  author jerryh;  state Exp;
branches ;
next     ;


desc
@main device calls for cd.device. (BeginIO, AbortIO, etc...).
Also initialization functions and ROMTag.
@


1.34
log
@Initializes DriveBits field and turns off DBLCAS on the A1200.
@
text
@

        INCLUDE "exec/types.i"
        INCLUDE "exec/nodes.i"
        INCLUDE "exec/lists.i"
        INCLUDE "exec/ports.i"
        INCLUDE "exec/libraries.i"
        INCLUDE "exec/tasks.i"
        INCLUDE "exec/devices.i"
        INCLUDE "exec/memory.i"
        INCLUDE "exec/interrupts.i"
        INCLUDE "exec/resident.i"
        INCLUDE "exec/io.i"
        INCLUDE "exec/errors.i"
        INCLUDE "exec/execbase.i"
        INCLUDE "exec/semaphores.i"
        INCLUDE "exec/ables.i"
        INCLUDE "hardware/intbits.i"
        INCLUDE "devices/trackdisk.i"
        INCLUDE "libraries/configregs.i"
        INCLUDE "libraries/configvars.i"

        INCLUDE "defs.i"
        INCLUDE "cd.i"
        INCLUDE "cdprivate.i"
        INCLUDE "cdgs_hw.i"
        INCLUDE "cd_rev.i"

        OPT     p=68020

*
************************************************************************
***
***  External References
***
************************************************************************

        XREF    CDTask
        XREF    IntrProc
        XREF    XLIntrProc
        XREF    InitIntr
        XREF    InitPort
        XREF    AllocAligned

        XREF    NoCommand      
        XREF    CmdReset       
        XREF    CmdRead        
        XREF    CmdWrite       
        XREF    CmdUpdate      
        XREF    CmdClear       
        XREF    CmdStop        
        XREF    CmdStart       
        XREF    CmdFlush       
        XREF    CmdMotor       
        XREF    CmdSeek        
        XREF    CmdFormat      
        XREF    CmdRemove      
        XREF    CmdChangeNum   
        XREF    CmdChangeState 
        XREF    CmdProtStatus  
        XREF    CmdGetDriveType
        XREF    CmdGetNumTracks
        XREF    CmdAddChangeInt
        XREF    CmdRemChangeInt
        XREF    CmdGetGeometry 
        XREF    CmdEject       
        XREF    CmdInfo        
        XREF    CmdConfig
        XREF    CmdTOCMSF
        XREF    CmdTOCLSN      
        XREF    CmdReadXL      
        XREF    CmdPlayTrack   
        XREF    CmdPlayMSF
        XREF    CmdPlayLSN
        XREF    CmdPause       
        XREF    CmdSearch
        XREF    CmdQCodeMSF
        XREF    CmdQCodeLSN    
        XREF    CmdAttenuate   
        XREF    CmdAddFrameInt 
        XREF    CmdRemFrameInt 

        XDEF    DevName
        XDEF    DevFuncs

        XREF    PutHex
        XREF    PutChar

        INT_ABLES

*
************************************************************************
***
***  Preliminaries
***
***********************************************************************/

                rts

                dc.b    'CD Device Driver',0
                dc.b    'Copyright (c) 1991 Commodore Electronics Ltd.',0
                ds.w    0

************************************************************************
***
***  Resident Tag
***
************************************************************************

        XDEF    ResTag
        XREF    EndCode

ResTag:         dc.w    RTC_MATCHWORD
                dc.l    ResTag
                dc.l    EndCode
                dc.b    RTF_COLDSTART
                dc.b    VERSION
                dc.b    NT_DEVICE
                dc.b    8
                dc.l    DevName
                dc.l    ModIdent
                dc.l    InitDevice

************************************************************************
***
***  Module Strings
***
************************************************************************

ModIdent:       VSTRING
                VERSTAG
                ds.w    0

DevName:        dc.b    'cd.device',0
                ds.w    0

*
************************************************************************
***
***  DEVICE DRIVER INITIALIZATION
***
***     Create and initialize all data structures and hardware.
***
************************************************************************

InitDevice:
                movem.l a2/a3/db/hb,-(sp)

                move.l  #CDHARDWARE,hb                                  ; Hardware base address

                move.b  #0,CDCOMRXCMP(hb)                               ; Reset hardware
                move.b  #0,CDCOMTXCMP(hb)

                move.l  #db_SizeOf,d0                                   ; Create device (library) node
                clear   d1
                lea     DevFuncs(pc),a0
                move.l  d1,a1
                move.l  d1,a2
                exec    MakeLibrary
                tst.l   d0
                beq     99$
                move.l  d0,db
                move.b  #NT_DEVICE,LN_TYPE(db)
                lea     DevName(pc),a0
                move.l  a0,LN_NAME(db)
                move.b  #LIBF_SUMUSED|LIBF_CHANGED,LIB_FLAGS(db)
                move.w  #VERSION,LIB_VERSION(db)
                move.w  #REVISION,LIB_REVISION(db)
                lea     ModIdent(pc),a0
                move.l  a0,LIB_IDSTRING(db)

                move.w  #$7FFF,db_Attenuation(db)                       ; Set volume attenuation
                move.w  #$7FFF,db_TargetAttenuation(db)
                move.w  #$0500,db_DriveBits(db)

                move.l  #STACK_SIZE,d0                                  ; Create I/O task stack
                clear   d1
                exec    AllocMem
                tst.l   d0
                beq     2$
                move.l  d0,a0
                lea     db_Task(db),a1
                move.l  a0,TC_SPLOWER(a1)
                add     #STACK_SIZE,a0
                move.l  a0,TC_SPUPPER(a1)
                move.l  db,-(a0)
                move.l  a0,TC_SPREG(a1)

                move.l  #CDROMPAGESIZE,d0                               ; Allocate ROM data page
                move.l  #MEMF_24BITDMA,d1
                jsr     AllocAligned
                beq     99$
                move.l  d0,db_CDROMPage(db)
                move.l  d0,CDROMHIGH(hb)

                move.l  d0,a0                                           ; Set Invalid mark (status long) in buffers
                clr.l   d0
1$              move.w  #SECSTSF_INVALID,ROM_STATUS+2(a0,d0.l)
                add.w   #$1000,d0
                cmp.w   #(PBXSIZE*$1000)&$FFFF,d0
                bne     1$

                move.l  #CDCOMPAGESIZE,d0                               ; Allocation communications page
                move.l  #MEMF_24BITDMA|MEMF_REVERSE,d1
                jsr     AllocAligned
                beq     98$
                move.l  d0,CDCOMHIGH(hb)

                move.l  d0,db_CDCOMRXPage(db)
                add.l   #$100,d0
                move.l  d0,db_CDSUBPage(db)
                add.l   #$100,d0
                move.l  d0,db_CDCOMTXPage(db)

                move.w  #75,db_Info+CDINFO_PlaySpeed(db)                ; Initialize CDINFO structure
                move.w  #75,db_Info+CDINFO_ReadSpeed(db)
                move.w  #75,db_Info+CDINFO_ReadXLSpeed(db)
                move.w  #2048,db_Info+CDINFO_SectorSize(db)
                move.w  #1,db_Info+CDINFO_XLECC(db)
                move.w  #150,db_Info+CDINFO_MaxSpeed(db)
                move.w  #1,db_Info+CDINFO_AudioPrecision(db)

                lea     db_ChgList(db),a0                               ; Initialize disk change IOR list
                NEWLIST a0

                lea     db_FrameList(db),a0                             ; Initialize frame interrupt callback list
                NEWLIST a0

                moveq.l #INTB_PORTS,d0                                  ; Initialize interrupt server
                moveq.l #32,d1
                lea     IntrProc(pc),a0
                lea     db_StatIntr(db),a1
                bsr     InitIntr

                lea     XLIntrProc(pc),a0                               ; Initialize XL interrupt server
                lea     db_XLIntr(db),a1
                move.b  #NT_INTERRUPT,LN_TYPE(a1)
                move.b  #32,LN_PRI(a1)
                move.l  db,IS_DATA(a1)
                move.l  a0,IS_CODE(a1)  
                lea     DevName(pc),a0
                move.l  a0,LN_NAME(a1)

                moveq   #SIGB_CMDPORT,d0                                ; Initialize non-disk-access message port
                lea     db_ClassACmdPort(db),a0
                bsr     InitPort

                moveq   #SIGB_DISKCMDPORT,d0                            ; Initialize disk-access message port
                lea     db_ClassDCmdPort(db),a0
                bsr     InitPort

                move.b  CDCOMTXINX(hb),db_ComTXInx(db)                  ; Remember Indexes

                move.l  CDCONFIG(hb),d0                                 ; Init CD-ROM registers
    IFD CDGS                                                            ; CDGS uses DBLCAS, A1200 does not
                and.l   #CF_PALNTSC,d0
                or.l    #CF_CDCOMTX|CF_CDCOMRX|CF_DBLCAS|CF_2500Q|CF_PBX,d0
    ELSE
                and.l   #CF_PALNTSC|CF_DBLCAS,d0
                or.l    #CF_CDCOMTX|CF_CDCOMRX|CF_2500Q|CF_PBX,d0
    ENDC
                move.l  d0,CDCONFIG(hb)
                move.b  CDCOMRXINX(hb),d0
                move.b  d0,db_ComRXInx(db)
                add.b   #1,d0
                move.b  d0,CDCOMRXCMP(hb)
                move.b  d0,db_CDCOMRXCMP(db)                            ; - Save in shadow location
                move.b  #0,db_ReceivingCmd(db)
                move.b  #0,CDCOMTXCMP(hb)
                move.l  #INTF_RXDMADONE|INTF_TXDMADONE,CDINT2ENABLE(hb)
                move.b  #$10,db_PacketIndex(db)

                lea     db_NULL(db),a0                                  ; Initialize CD_READ's fake xfer node
                move.l  a0,db_XferNode+MLN_SUCC(db)

                move.l  #-1,d0                                          ; Allocate a signal for us to wait on
                exec    AllocSignal
                move.b  d0,db_InitSignal(db)  

                sub.l   a1,a1                                           ; Find our task
                exec    FindTask
                move.l  d0,db_InitTask(db)

                lea     db_Task(db),a1                                  ; Create I/O Task
                move.b  #NT_TASK,LN_TYPE(a1)
                move.b  #10,LN_PRI(a1)
                lea     DevName(pc),a0
                move.l  a0,LN_NAME(a1)
                lea     CDTask(pc),a2
                sub.l   a3,a3
                exec    AddTask

                move.b  db_InitSignal(db),d1                            ; Wait for task to completely initialize
                move.l  #1,d0
                lsl.l   d1,d0
                exec    Wait

                move.b  db_InitSignal(db),d0                            ; Free signal
                exec    FreeSignal

                move.l  db,a1                                           ; Add to device list
                exec    AddDevice
2$
                move.l  db,d0
                movem.l (sp)+,a2/a3/db/hb
                rts
97$
                move.l  #CDCOMPAGESIZE,d0                               ; Free communications page
                move.l  db_CDSUBPage(db),a1
                exec    FreeMem
98$
                move.l  #CDROMPAGESIZE,d0                               ; Free ROM data page
                move.l  db_CDROMPage(db),a1
                exec    FreeMem
99$
                move.l  db,d0
                movem.l (sp)+,a2/a3/db/hb
                rts




*
******* cd.device/OpenDevice *************************************************
*
*   NAME
*       OpenDevice - Open a CD unit for access
*
*   SYNOPSIS
*       error = OpenDevice("cd.device", UnitNumber, IORequest, flags);
*       D0                 A0           D0          A1         D1
*
*   FUNCTION
*       Opens the cd.device and creates an IORequest for use in accessing
*       the CD.
*
*   INPUTS
*       UnitNumber - Normally zero; however, this is described as:
*                    Ones digit      = Unit (SCSI unit number)
*                    Tens digit      = LUN (disk within disk changer)
*                    Hundreds digit  = Card number (SCSI card)
*                    Thousands digit = Reserved (must be zero)
*       IORequest  - Pointer to a struct(IOStdReq)
*       flags      - Should be zero.
*
*   RESULTS
*       error        0 = success, otherwise this is an error.
*
*   NOTES
*
*   SEE ALSO
*       CloseDevice()
*
******************************************************************************

 FUNCTION Open
                tst.l   d0                                                      ; Only allow unit zero requests
                beq     1$
                moveq.l #CDERR_OPENFAIL,d0
                bra     2$
1$
                bclr.b  #LIBB_DELEXP,LIB_FLAGS(db)                              ; Clear possible pending delayed expunge

                addq.w  #1,LIB_OPENCNT(db)                                      ; Bump unit and device open counters

                move.l  #UNIT_PATTERN,IO_UNIT(a1)                               ; Use a pattern to determine valid I/O requests

                clear   d0                                                      ; Open ok
2$
                move.b  d0,IO_ERROR(a1)                                         ; Return Open status
                rts


*
******* cd.device/CloseDevice ************************************************
*
*   NAME
*       CloseDevice - terminate access to the CD
*
*   SYNOPSIS
*       CloseDevice(IORequest);
*                   A1
*
*   FUNCTION
*       This function will terminate access to the unit openned with
*       OpenDevice().
*
*   INPUTS
*       iORequest - pointer to a struct(IOStdReq)
*
*   RESULTS
*
*   NOTES
*
*   SEE ALSO
*       OpenDevice()
*
******************************************************************************

 FUNCTION Close
                cmp.l   #UNIT_PATTERN,IO_UNIT(a1)                               ; Verify that this is a valid I/O Request
                bne     1$

                moveq.l #-1,d0                                                  ; Invalidate various I/O Request fields
                move.l  d0,IO_UNIT(a1)
                move.l  d0,IO_DEVICE(a1)

                subq.w  #1,LIB_OPENCNT(db)                                      ; Decrement unit and device open counters

1$              clear   d0                                                      ; Prevent expunge
                rts

*
************************************************************************
***
***  EXPUNGE DEVICE
***
***     Never expunge.  Driver doesn't take much space.
***
************************************************************************

 FUNCTION Expunge
 FUNCTION fReserved
                clear   d0                                              ; Never expunge
                rts


*
************************************************************************
***
***  DEVICE FUNCTION/COMMAND ADDRESS TABLE
***
***     This table contains the addresses for device functions
***     and command functions.  It is used by MakeLibrary to
***     initialize the device node.
***
************************************************************************

DevFuncs                
                dc.l    Open            ; -6
                dc.l    Close           ; -12
                dc.l    Expunge         ; -18
                dc.l    fReserved       ; -24
                dc.l    BeginIO         ; -30
                dc.l    AbortIO         ; -36
                dc.l    fReserved       ; -42
                dc.l    fReserved       ; -48

                dc.l    CmdReset        ; 1
                dc.l    CmdRead         ; 2
                dc.l    CmdWrite        ; 3
                dc.l    CmdUpdate       ; 4
                dc.l    CmdClear        ; 5
                dc.l    CmdStop         ; 6
                dc.l    CmdStart        ; 7
                dc.l    CmdFlush        ; 8
                dc.l    CmdMotor        ; 9
                dc.l    CmdSeek         ; 10
                dc.l    CmdFormat       ; 11
                dc.l    CmdRemove       ; 12
                dc.l    CmdChangeNum    ; 13
                dc.l    CmdChangeState  ; 14
                dc.l    CmdProtStatus   ; 15
                dc.l    NoCommand       ; 16
                dc.l    NoCommand       ; 17
                dc.l    CmdGetDriveType ; 18
                dc.l    CmdGetNumTracks ; 19
                dc.l    CmdAddChangeInt ; 20
                dc.l    CmdRemChangeInt ; 21
                dc.l    CmdGetGeometry  ; 22
                dc.l    CmdEject        ; 23

                dc.l    NoCommand       ; 24
                dc.l    NoCommand       ; 25
                dc.l    NoCommand       ; 26
                dc.l    NoCommand       ; 27
                dc.l    NoCommand       ; 28
                dc.l    NoCommand       ; 29
                dc.l    NoCommand       ; 30
                dc.l    NoCommand       ; 31

                dc.l    CmdInfo         ; 32
                dc.l    CmdConfig       ; 33
                dc.l    CmdTOCMSF       ; 34
                dc.l    CmdTOCLSN       ; 35

                dc.l    CmdReadXL       ; 36

                dc.l    CmdPlayTrack    ; 37
                dc.l    CmdPlayMSF      ; 38
                dc.l    CmdPlayLSN      ; 39
                dc.l    CmdPause        ; 40
                dc.l    CmdSearch       ; 41

                dc.l    CmdQCodeMSF     ; 42
                dc.l    CmdQCodeLSN     ; 43
                dc.l    CmdAttenuate    ; 44

                dc.l    CmdAddFrameInt  ; 45
                dc.l    CmdRemFrameInt  ; 46

MAX_CMD         equ                       46

                dc.l    -1              ; end of list

*
************************************************************************
***
***  DEVICE COMMAND OPTION TABLE
***
***     This table contains bits to indicate valid options for
***     each of the device command functions.  Options are:
***
************************************************************************

        XDEF CmdOpts

CmdOpts:
        dc.w  OF_INVALID
        dc.w  OF_QUEUE                                              ; Reset
        dc.w  OF_QUEUE|OF_DISK|OF_DISKACCESS|OF_ROM|OF_ABTD         ; Read
        dc.w  OF_DISK                                               ; Write
        dc.w  0                                                     ; Update
        dc.w  0                                                     ; Clear
        dc.w  0                                                     ; Stop
        dc.w  0                                                     ; Start
        dc.w  0                                                     ; Flush
        dc.w  OF_QUEUE|OF_DISKACCESS                                ; Motor
        dc.w  OF_QUEUE|OF_DISK|OF_DISKACCESS                        ; Seek
        dc.w  OF_DISK|OF_INVALID                                    ; Format
        dc.w  OF_INVALID                                            ; Remove
        dc.w  0                                                     ; ChangeNum
        dc.w  0                                                     ; ChangeState
        dc.w  0                                                     ; ProtStatus
        dc.w  OF_INVALID                                            ; NoCommand
        dc.w  OF_INVALID                                            ; NoCommand
        dc.w  0                                                     ; CmdGetDriveType
        dc.w  0                                                     ; CmdGetNumTracks
        dc.w  OF_NOREPLY                                            ; CmdAddChangeInt
        dc.w  0                                                     ; CmdRemChangeInt
        dc.w  0                                                     ; CmdGetGeometry
        dc.w  OF_QUEUE                                              ; CmdEject
        dc.w  OF_INVALID                                            ; NoCommand
        dc.w  OF_INVALID                                            ; NoCommand
        dc.w  OF_INVALID                                            ; NoCommand
        dc.w  OF_INVALID                                            ; NoCommand
        dc.w  OF_INVALID                                            ; NoCommand
        dc.w  OF_INVALID                                            ; NoCommand
        dc.w  OF_INVALID                                            ; NoCommand
        dc.w  OF_INVALID                                            ; NoCommand

        dc.w  0                                                     ; CmdInfo
        dc.w  OF_QUEUE                                              ; CmdConfig
        dc.w  OF_QUEUE|OF_DISK                                      ; CmdTOCMSF
        dc.w  OF_QUEUE|OF_DISK                                      ; CmdTOCLSN
        dc.w  OF_QUEUE|OF_DISK|OF_DISKACCESS|OF_ROM|OF_ABTD         ; CmdReadXL
        dc.w  OF_QUEUE|OF_DISK|OF_DISKACCESS|OF_MULTITASK|OF_ABTD   ; CmdPlayTrack
        dc.w  OF_QUEUE|OF_DISK|OF_DISKACCESS|OF_MULTITASK|OF_ABTD   ; CmdPlayMSF
        dc.w  OF_QUEUE|OF_DISK|OF_DISKACCESS|OF_MULTITASK|OF_ABTD   ; CmdPlayLSN
        dc.w  OF_QUEUE|OF_DISK                                      ; CmdPause
        dc.w  OF_QUEUE|OF_DISK                                      ; CmdSearch
        dc.w  OF_QUEUE|OF_DISK|OF_ABTQ                              ; CmdQCodeMSF
        dc.w  OF_QUEUE|OF_DISK|OF_ABTQ                              ; CmdQCodeLSN
        dc.w  OF_QUEUE                                              ; CmdAttenuate
        dc.w  OF_NOREPLY                                            ; CmdAddFrameInt
        dc.w  0                                                     ; CmdRemFrameInt
        dc.w  0



*
************************************************************************
***
***  BEGINIO
***
***     Process an I/O request.
***
***     This function is called with:
***             A1 -> IO Request Structure
***             A6 -> Device Node
***
************************************************************************

BeginIO:
                save    a1/ior/hb                                       ; Load up pointers
                move.l  a1,ior
                move.l  #CDHARDWARE,hb

                move.b  #NT_MESSAGE,LN_TYPE(ior)                        ; Initialize request fields
                clr.l   IO_ACTUAL(ior)

                move.b  #CDERR_BadUnitNum,IO_ERROR(ior)                 ; Check that I/O request has been opened
                cmp.l   #UNIT_PATTERN,IO_UNIT(ior)
                bne     bio_done

                move.b  #IOERR_NOCMD,IO_ERROR(ior)                      ; Check command range
                move.w  IO_COMMAND(ior),d0
                ble.s   bio_done
                cmp.w   #MAX_CMD,d0
                bgt.s   bio_done

                clr.b   IO_ERROR(ior)                                   ; Check command options
                lea     CmdOpts(pc),a1
                add.w   d0,d0
                move.w  0(a1,d0.w),d1

                btst    #OB_INVALID,d1
                bne.s   bio_done

                btst    #OB_QUEUE,d1                                    ; Should this command be queued?
                bne.s   bio_queue

                jsr     PerformIO                                       ; Execute the command now and reply (return)
bio_done:
                move.w  IO_COMMAND(ior),d0                              ; Reply (return) the request
                lea     CmdOpts(pc),a1
                add.w   d0,d0
                move.w  0(a1,d0.w),d0
                btst    #OB_NOREPLY,d0
                bne.s   bio_exit
                btst.b  #IOB_QUICK,IO_FLAGS(ior)
                bne.s   bio_exit
                move.l  ior,a1
                exec    ReplyMsg
                bra.s   bio_exit
bio_queue:
                bclr.b  #IOB_QUICK,IO_FLAGS(ior)                        ; Choose a port and queue the command
                lea     db_ClassACmdPort(db),a0
                btst    #OB_DISKACCESS,d1
                beq.s   1$
                lea     db_ClassDCmdPort(db),a0
1$:             move.l  ior,a1
                exec    PutMsg

bio_exit:       restore a1/ior/hb                                       ; All done
                rts

*
************************************************************************
***
***  ABORTIO
***
***     Abort an IO Request that is queued or in progress.
***
************************************************************************

AbortIO:
                save    ior/hb                                          ; Load up pointers
                move.l  a1,ior
                move.l  #CDHARDWARE,hb

                exec    Forbid                                          ; Forbid task switching

                move.l  ior,a1                                          ; Check if I/O is already done
                exec    CheckIO
                tst.l   d0
                bne     99$

                move.l  ior,a1                                          ; Scan both ports for the request
                lea     db_ClassACmdPort(db),a0
                bsr     FindReq
                tst.l   d0
                bne.s   1$
                lea     db_ClassDCmdPort(db),a0
                bsr     FindReq
                tst.l   d0
                beq.s   2$
1$
                move.b  #CDERR_ABORTED,IO_ERROR(ior)                    ; Remove entry from queue and reply (return)
                exec    Remove
                move.l  ior,a1
                exec    ReplyMsg
                clr.l   d0
                bra     99$
2$
                move.b  #CDERR_ABORTED,IO_ERROR(ior)                    ; Abort it and check return code
                bsr     Abort
                clr.l   d0
99$
                save    d0                                              ; Permit task switching again and return
                exec    Permit
                restore d0
                restore ior/hb
                rts

*
*=======================================================================
*==
*==  FindReq
*==
*==     in:     A0 = I/O Port
*==             A1 = I/O Request
*==
*==    out:     D0 = nonzero if found, NULL if not found
*==             A0 = I/O Request
*==
*=======================================================================

FindReq:
                move.l  MP_MSGLIST(a0),a0                               ; Look at message list of port

1$:             move.l  (a0),d0                                         ; End of list?  Exit.
                beq.s   99$

                cmp.l   a0,a1                                           ; If this is the request, return with it
                beq.s   99$

                move.l  d0,a0                                           ; Next entry
                bra.s   1$
99$:
                rts

*
************************************************************************
***
***  Abort
***
***     Abort an I/O command.
***
***             ior -> command I/O request
***             db  -> device base
***             hb  -> hardware base
***
***     Returns value in d0.
***
************************************************************************

Abort:
                move.w  IO_COMMAND(ior),d0                              ; Get command's options
                lea     CmdOpts(pc),a1

                add.w   d0,d0                                           ; Get abort type
                clr.l   d1
                move.w  0(a1,d0.w),d1
                and.w   #$FF00,d1

                cmp.w   #OF_ABTD,d1                                     ; Abort play or read?
                bne     1$

                SIGNAL  SIGF_ABORTDRIVE
                rts
1$
                cmp.w   #OF_ABTQ,d1                                     ; Abort Q-Code?
                bne     2$
                SIGNAL  SIGF_ABORTQCODE
2$
                rts




************************************************************************
***
***  PERFORMIO
***
***     Dispatch to the appropriate command handling code.
***
************************************************************************

 FUNCTION PerformIO
    IFD DEBUG
                jsr     PrintCommand
    ENDC
                lea     CmdOpts(pc),a1                                  ; Check command options
                move.w  IO_COMMAND(ior),d0
                add.w   d0,d0
                move.w  0(a1,d0.w),d1

                btst    #OB_DISK,d1                                     ; If no disk, should we return an error?
                beq.s   1$
                move.b  #CDERR_NoDisk,IO_ERROR(ior)
                move.w  db_Info+CDINFO_Status(db),d0
                btst    #CDSTSB_DISK,d0
                beq.s   99$
1$
                btst    #OB_ROM,d1                                      ; If no CD-ROM disk, should we return an error?
                beq.s   2$
                move.b  #CDERR_BadDataType,IO_ERROR(ior)
                move.w  db_Info+CDINFO_Status(db),d0
                btst    #CDSTSB_CDROM,d0
                beq.s   99$
2$
                clr.b   IO_ERROR(ior)                                   ; Execute Command
                clr.l   d0
                move.w  IO_COMMAND(ior),d0
                addq.l  #8,d0
                muls    #-6,d0
                jsr     0(db,d0.w)
99$
    IFD DEBUG
                move.b  IO_ERROR(ior),d0
                beq     100$
                and.l   #$000000ff,d0
                jsr     PutHex
100$
                move.b  #10,d0
                jsr     PutChar
    ENDC
                rts


    IFD DEBUG


PrintCommand:
                move.b  #'*',d0
                jsr     PutChar
                jsr     PutChar
                jsr     PutChar
                move.b  #'C',d0
                jsr     PutChar
                move.b  #'M',d0
                jsr     PutChar
                move.b  #'D',d0
                jsr     PutChar
                move.b  #' ',d0
                jsr     PutChar
                move.b  #':',d0
                jsr     PutChar
                move.b  #' ',d0
                jsr     PutChar

                clr.l   d0
                move.w  IO_COMMAND(ior),d0
                jsr     PutHex
                move.l  IO_OFFSET(ior),d0
                jsr     PutHex
                move.l  IO_LENGTH(ior),d0
                jsr     PutHex
                move.l  IO_DATA(ior),d0
                jsr     PutHex

                rts

    ENDC
@


1.33
log
@no effective change.
@
text
@a102 2
                dc.b    'Written by Jerry Horanoff',0
                ds.w    0
d174 1
d255 1
d258 4
@


1.32
log
@no effective change.
@
text
@d690 2
a691 1
*==    out:     A0 = I/O Request (if found, NULL otherwise)
@


1.31
log
@Removed adding of CDXL interrupt handler to server chain.
@
text
@a2 1

d756 3
@


1.30
log
@Fake xfer node's successor now points to a NULL instead of being a NULL.
@
text
@d237 1
a237 3
                moveq.l #INTB_PORTS,d0                                  ; Initialize XL interrupt server
                moveq.l #32,d1
                lea     XLIntrProc(pc),a0
d239 6
a244 1
                bsr     InitIntr
@


1.29
log
@No longer modifies PALNTSC bit of CDCONFIG.
@
text
@d266 3
@


1.28
log
@No effective change.
@
text
@d253 4
a256 1
                move.l  #CF_CDCOMTX|CF_CDCOMRX|CF_DBLCAS|CF_2500Q|CF_PBX,CDCONFIG(hb)    ; Init CD-ROM registers
@


1.27
log
@ cd.device driver now defaults to single-speed.
@
text
@d2 2
d726 1
a747 3
    IFD DEBUG
                jsr     PrintCommand
    ENDC
@


1.26
log
@no effective change.
@
text
@d216 1
a216 1
                move.w  #150,db_Info+CDINFO_ReadSpeed(db)
@


1.25
log
@removed debugging code when not in use.
@
text
@a1 2
;DEBUG   SET 1

@


1.24
log
@no effective change.
@
text
@d788 1
a790 1

d821 1
@


1.23
log
@no effective change.
@
text
@d25 1
a26 1
        INCLUDE "cd.i"
@


1.22
log
@Allocate drive communications DMA page in high mem.
@
text
@a253 1
;                move.l  #CF_CDCOMTX|CF_CDCOMRX|CF_2500Q|CF_PBX,CDCONFIG(hb)    ; Init CD-ROM registers
@


1.21
log
@Bumped the task priority to 10.
@
text
@d206 1
a206 1
                move.l  #MEMF_24BITDMA,d1
@


1.20
log
@no effective change.l
@
text
@d275 1
a275 1
                move.b  #5,LN_PRI(a1)
@


1.19
log
@default to DS reading.
@
text
@d2 2
d541 1
a541 1
        dc.w  OF_QUEUE                                              ; CmdInfo
d748 3
a750 3

;                jsr     PrintCommand

d777 9
a785 7
;                move.b  IO_ERROR(ior),d0
;                beq     100$
;                and.l   #$000000ff,d0
;                jsr     PutHex
;100$
;                move.b  #10,d0
;                jsr     PutChar
@


1.18
log
@no effective change.
@
text
@d26 1
a26 1
        INCLUDE "version.i"
d216 1
a216 1
                move.w  #75,db_Info+CDINFO_ReadSpeed(db)
@


1.17
log
@removed debugs.
@
text
@d775 1
a775 1
                move.b  IO_ERROR(ior),d0
@


1.16
log
@removed debug messages.
@
text
@a149 6
                PRINT   0$,"InitDevice"

                move.l  #MEMF_PUBLIC,d1
                exec    AvailMem
                jsr     PutHex

a195 3
                PRINT   1$,"ROMPAGE_="
                jsr     PutHex
                
@


1.15
log
@removed abortIO debug.
@
text
@d756 1
a756 1
                jsr     PrintCommand
d785 6
a790 6
                beq     100$
                and.l   #$000000ff,d0
                jsr     PutHex
100$
                move.b  #10,d0
                jsr     PutChar
@


1.14
log
@internal.i is now cdprivate.i
@
text
@a643 2
                PRINT   1$,"Abort_IO"

@


1.13
log
@DBLCAS added back.
@
text
@d23 1
a23 1
        INCLUDE "internal.i"
@


1.12
log
@Turn on double-cas.
@
text
@d260 2
a261 2
;                move.l  #CF_CDCOMTX|CF_CDCOMRX|CF_DBLCAS|CF_2500Q|CF_PBX,CDCONFIG(hb)    ; Init CD-ROM registers
                move.l  #CF_CDCOMTX|CF_CDCOMRX|CF_2500Q|CF_PBX,CDCONFIG(hb)    ; Init CD-ROM registers
@


1.11
log
@DBLCAS enabled.
@
text
@d260 2
a261 1
                move.l  #CF_CDCOMTX|CF_CDCOMRX|CF_DBLCAS|CF_2500Q|CF_PBX,CDCONFIG(hb)    ; Init CD-ROM registers
d644 2
d758 1
a758 1
;                jsr     PrintCommand
d791 2
a792 2
;                move.b  #10,d0
;                jsr     PutChar
@


1.10
log
@Play commands should be working now.
@
text
@a217 3
                PRINT   2$,"COM_PAGE"
                jsr     PutHex

a223 6

                lea     db_ComRXInx(db),a0
                move.l  a0,d0
                jsr     PutHex


d260 1
a260 1
                move.l  #CF_CDCOMTX|CF_CDCOMRX|CF_2500Q|CF_PBX,CDCONFIG(hb)    ; Init CD-ROM registers
d418 1
a418 1
 FUNCTION Reserved
d438 1
a438 1
                dc.l    Reserved        ; -24
d441 2
a442 2
                dc.l    Reserved        ; -42
                dc.l    Reserved        ; -48
a642 2
                PRINT   1$,"CD__:_AbortIO"

@


1.9
log
@added fields to CDINFO structure.
@
text
@d179 2
a180 2
;                move.w  #$7FFF,db_Attenuation(db)
;                clr.l   db_ClassDReq(db)
a307 4
                move.l  #MEMF_PUBLIC,d1
                exec    AvailMem
                jsr     PutHex

d346 1
a346 1
*                    Thousands digit = Session on disk (multi-session)
d525 1
a525 1
        dc.w  OF_QUEUE|OF_DISK|OF_DISKACCESS|OF_ROM|OF_ABTR         ; Read
d560 4
a563 4
        dc.w  OF_QUEUE|OF_DISK|OF_DISKACCESS|OF_ROM|OF_ABTR         ; CmdReadXL
        dc.w  OF_QUEUE|OF_DISK|OF_DISKACCESS|OF_MULTITASK|OF_ABTP   ; CmdPlayTrack
        dc.w  OF_QUEUE|OF_DISK|OF_DISKACCESS|OF_MULTITASK|OF_ABTP   ; CmdPlayMSF
        dc.w  OF_QUEUE|OF_DISK|OF_DISKACCESS|OF_MULTITASK|OF_ABTP   ; CmdPlayLSN
d652 2
d742 1
a742 1
                cmp.w   #OF_ABTP,d1                                     ; Abort play?
d744 1
a744 1
                SIGNAL  SIGF_PLAYDONE
d747 1
a747 1
                cmp.w   #OF_ABTR,d1                                     ; Abort read?
d749 1
a749 2
                SIGNAL  SIGF_ABORTREAD
                rts
a750 4
                cmp.w   #OF_ABTQ,d1                                     ; Abort Q-Code?
                bne     3$
                SIGNAL  SIGF_ABORTQCODE
3$
d766 1
a766 1
                jsr     PrintCommand
d794 7
a800 2
                move.b  #10,d0
                jsr     PutChar
@


1.8
log
@Error retries.  New debug messages.
@
text
@d237 1
a521 3
***     NODISK  - execute command even when no disk present
***     QUEUE   - serialize (queue) the command for execution
***
d528 47
a574 47
        dc.w  OF_NODISK|OF_QUEUE                                        ; Reset
        dc.w  OF_QUEUE|OF_DISKACCESS|OF_ROM|OF_ABTR                     ; Read
        dc.w  OF_NODISK                                                 ; Write
        dc.w  OF_NODISK                                                 ; Update
        dc.w  OF_NODISK                                                 ; Clear
        dc.w  OF_NODISK                                                 ; Stop
        dc.w  OF_NODISK                                                 ; Start
        dc.w  OF_NODISK                                                 ; Flush
        dc.w  OF_NODISK|OF_QUEUE|OF_DISKACCESS                          ; Motor
        dc.w  OF_QUEUE|OF_DISKACCESS                                    ; Seek
        dc.w  OF_INVALID                                                ; Format
        dc.w  OF_INVALID                                                ; Remove
        dc.w  OF_NODISK                                                 ; ChangeNum
        dc.w  OF_NODISK                                                 ; ChangeState
        dc.w  0                                                         ; ProtStatus
        dc.w  OF_INVALID                                                ; NoCommand
        dc.w  OF_INVALID                                                ; NoCommand
        dc.w  OF_NODISK                                                 ; CmdGetDriveType
        dc.w  0                                                         ; CmdGetNumTracks
        dc.w  OF_NODISK|OF_NOREPLY                                      ; CmdAddChangeInt
        dc.w  OF_NODISK                                                 ; CmdRemChangeInt
        dc.w  0                                                         ; CmdGetGeometry
        dc.w  OF_NODISK|OF_QUEUE                                        ; CmdEject
        dc.w  OF_INVALID                                                ; NoCommand
        dc.w  OF_INVALID                                                ; NoCommand
        dc.w  OF_INVALID                                                ; NoCommand
        dc.w  OF_INVALID                                                ; NoCommand
        dc.w  OF_INVALID                                                ; NoCommand
        dc.w  OF_INVALID                                                ; NoCommand
        dc.w  OF_INVALID                                                ; NoCommand
        dc.w  OF_INVALID                                                ; NoCommand

        dc.w  OF_NODISK                                                 ; CmdInfo
        dc.w  OF_NODISK|OF_QUEUE                                        ; CmdConfig
        dc.w  OF_QUEUE                                                  ; CmdTOCMSF
        dc.w  OF_QUEUE                                                  ; CmdTOCLSN
        dc.w  OF_QUEUE|OF_DISKACCESS|OF_ROM|OF_ABTR                     ; CmdReadXL
        dc.w  OF_QUEUE|OF_DISKACCESS|OF_MULTITASK|OF_ABTP               ; CmdPlayTrack
        dc.w  OF_QUEUE|OF_DISKACCESS|OF_MULTITASK|OF_ABTP               ; CmdPlayMSF
        dc.w  OF_QUEUE|OF_DISKACCESS|OF_MULTITASK|OF_ABTP               ; CmdPlayLSN
        dc.w  OF_NODISK|OF_QUEUE                                        ; CmdPause
        dc.w  OF_NODISK|OF_QUEUE                                        ; CmdSearch
        dc.w  OF_NODISK|OF_QUEUE|OF_ABTQ                                ; CmdQCodeMSF
        dc.w  OF_NODISK|OF_QUEUE|OF_ABTQ                                ; CmdQCodeLSN
        dc.w  OF_NODISK|OF_QUEUE                                        ; CmdAttenuate
        dc.w  OF_NODISK|OF_NOREPLY                                      ; CmdAddFrameInt
        dc.w  OF_NODISK                                                 ; CmdRemFrameInt
d780 2
a781 2
                btst    #OB_NODISK,d1                                   ; If no disk, should we return an error?
                bne.s   1$
d787 1
a787 1
                btst    #OB_ROM,d1                                      ; If no CD-ROM, should we return an error?
@


1.7
log
@added some print statements.
@
text
@d28 2
d86 1
d152 4
d234 1
a234 1
                move.w  #150,db_Info+CDINFO_ReadSpeed(db)
d279 8
d296 8
d307 4
d775 2
d778 1
d803 35
a837 1
                PRINT   1$,"PERFORM_DONE"
@


1.6
log
@init routine only saves registers it has to now.
@
text
@d210 4
d220 6
d263 1
d773 2
@


1.5
log
@clear prefetch in initialization routine.
@
text
@d145 1
a145 1
                movem.l d1-d7/a0-a6,-(sp)
d274 1
a274 1
                movem.l (sp)+,d1-d7/a0-a6
d286 1
a286 1
                movem.l (sp)+,d1-d7/a0-a6
@


1.4
log
@who knows.
@
text
@d198 7
@


1.3
log
@Includes are now indirect.
@
text
@d66 2
a67 1
        XREF    CmdTOC         
d70 2
a71 1
        XREF    CmdPlay        
d74 2
a75 1
        XREF    CmdQCode       
a81 1
        XDEF    CmdOpts
d83 2
d147 2
d151 2
a152 2
;                cmp.l   #'CDTV',CDSK_ID(hb)                             ; Is CDTV hardware present?
;                bne     99$
d194 3
d203 2
d207 8
a214 7
                move.l  d0,db_CDCOMPage(db)
                
                move.b  CDCOMINX(hb),db_ComInx(db)                      ; Initialize hardware
                move.l  #INTF_DRIVECMP,CDINT2ENABLE(hb)
                move.l  #0,CDINT6ENABLE(hb)
                move.l  #CF_DRIVECOM|CF_DATA,CDCONFIG(hb)
                move.l  #PBXMASK,CDPBX(hb)                              ; - Free data buffers
d242 12
d271 1
a271 1
                move.l  db_CDCOMPage(db),a1
d408 1
a408 1
                dc.l    PerformIO       ; -42
d446 2
a447 1
                dc.l    CmdTOC          ; 34
d449 1
a449 1
                dc.l    CmdReadXL       ; 35
d451 12
a462 10
                dc.l    CmdPlayTrack    ; 36
                dc.l    CmdPlay         ; 37
                dc.l    CmdPause        ; 38
                dc.l    CmdSearch       ; 39

                dc.l    CmdQCode        ; 40
                dc.l    CmdAttenuate    ; 41

                dc.l    CmdAddFrameInt  ; 42
                dc.l    CmdRemFrameInt  ; 43
d464 1
a464 1
MAX_CMD         equ                       43
d519 2
a520 1
        dc.w  OF_QUEUE                                                  ; CmdTOC
d523 2
a524 1
        dc.w  OF_QUEUE|OF_DISKACCESS|OF_MULTITASK|OF_ABTP               ; CmdPlay
d527 2
a528 1
        dc.w  OF_NODISK|OF_QUEUE|OF_ABTQ                                ; CmdQCode
d550 1
a550 1
                save    ior/hb                                          ; Load up pointers
d566 3
a568 2
1$
                move.l  db_CmdOpts(db),a1                               ; Check command options
d570 2
a571 1
                move.b  0(a1,d0.w),d1
a574 14
                btst    #OB_NODISK,d1                                   ; If no disk, should we return an error?
                bne.s   2$
                move.b  #CDERR_NoDisk,IO_ERROR(ior)
                move.w  db_Info+CDINFO_Status(db),d0
                btst    #CDSTSB_DISK,d0
                beq.s   bio_done
2$:
                btst    #OB_ROM,d1                                      ; If no CD-ROM, should we return an error?
                beq.s   3$
                move.b  #CDERR_BadDataType,IO_ERROR(ior)
                move.w  db_Info+CDINFO_Status(db),d0
                btst    #CDSTSB_CDROM,d0
                beq.s   bio_done
3$:
d578 1
a578 1
                jsr     PERFORMIO(db)                                   ; Execute the command now and reply (return)
d581 1
a581 1
                move.l  db_CmdOpts(db),a1
d600 1
a600 1
bio_exit:       restore ior/hb                                          ; All done
d694 1
a694 1
                move.l  db_CmdOpts(db),a1
d728 20
a747 1
PerformIO:
d754 1
a754 1

@


1.2
log
@all kinds of new stuff.
@
text
@d2 19
a20 19
        INCLUDE "include:exec/types.i"
        INCLUDE "include:exec/nodes.i"
        INCLUDE "include:exec/lists.i"
        INCLUDE "include:exec/ports.i"
        INCLUDE "include:exec/libraries.i"
        INCLUDE "include:exec/tasks.i"
        INCLUDE "include:exec/devices.i"
        INCLUDE "include:exec/memory.i"
        INCLUDE "include:exec/interrupts.i"
        INCLUDE "include:exec/resident.i"
        INCLUDE "include:exec/io.i"
        INCLUDE "include:exec/errors.i"
        INCLUDE "include:exec/execbase.i"
        INCLUDE "include:exec/semaphores.i"
        INCLUDE "include:exec/ables.i"
        INCLUDE "include:hardware/intbits.i"
        INCLUDE "include:devices/trackdisk.i"
        INCLUDE "include:libraries/configregs.i"
        INCLUDE "include:libraries/configvars.i"
@


1.1
log
@Initial revision
@
text
@a0 13
************************************************************************
***                                                                  ***
***                    -= CDTV DEVICE DRIVER =-                      ***
***                                                                  ***
************************************************************************
***                                                                  ***
***     CONFIDENTIAL and PROPRIETARY                                 ***
***     Copyright (c) 1990 by Commodore-Amiga, Inc.                  ***
***     Created by Carl Sassenrath, Sassenrath Research, Ukiah, CA   ***
***                                                                  ***
***     Modified 6/1/91: Jerry Horanoff                              ***
***                                                                  ***
************************************************************************
d37 1
d65 1
a73 3
        XREF    CmdPlaySpeed   
        XREF    CmdReadSpeed   
        XREF    CmdReadXLSpeed 
d146 1
a146 1
;                bne     9$
d155 1
a155 1
                beq     9$
a165 1
;                move.l  hb,db_HardwareBase(db)
d167 1
a167 1
;                clr.l   db_ClassDCmd(db)
d185 1
a185 1
                beq     9$
a186 1
                lsl.l   #8,d0
d192 4
a195 1
                beq     8$
a196 2
                lsl.l   #8,d0
                move.l  d0,CDCOMHIGH(hb)
d198 6
a209 14
                lea     db_XferNodes(db),a1                             ; Create 3 XL Nodes
                move.l  a1,d0
                add.l   CDXL_SIZE,d0
                move.l  d0,MLN_SUCC(a1)
                add.l   CDXL_SIZE,d0
                move.l  d0,CDXL_SIZE+MLN_SUCC(a1)
                clr.l   (CDXL_SIZE*2)+MLN_SUCC(a1)

                move.l  #SKIP_BYTES,d0                                  ; Create skip buffer for CDXL
                move.l  #MEMF_24BITDMA,d1
                exec    AllocMem
                move.l  d0,db_SkipBuf(db)
                beq     7$

d216 7
a222 1
                moveq   #SIGB_SYNCPORT,d0                               ; Initialize non-disk-access message port
d226 1
a226 1
                moveq   #SIGB_ASYNCPORT,d0                              ; Initialize disk-access message port
d245 1
a245 1
7$
d249 1
a249 1
8$
d253 1
a253 1
9$
d421 2
a422 1
                dc.l    CmdTOC          ; 33
d424 1
a424 1
                dc.l    CmdReadXL       ; 34
d426 10
a435 14
                dc.l    CmdPlayTrack    ; 35
                dc.l    CmdPlay         ; 36
                dc.l    CmdPause        ; 37
                dc.l    CmdSearch       ; 38

                dc.l    CmdQCode        ; 39
                dc.l    CmdAttenuate    ; 40

                dc.l    CmdPlaySpeed    ; 41
                dc.l    CmdReadSpeed    ; 42
                dc.l    CmdReadXLSpeed  ; 43

                dc.l    CmdAddFrameInt  ; 44
                dc.l    CmdRemFrameInt  ; 45
d437 1
a437 1
MAX_CMD         equ                       45
d491 1
d494 2
a495 2
        dc.w  OF_QUEUE|OF_DISKACCESS|OF_ASYNC|OF_ABTP                   ; CmdPlayTrack
        dc.w  OF_QUEUE|OF_DISKACCESS|OF_ASYNC|OF_ABTP                   ; CmdPlay
d498 1
a498 1
        dc.w  OF_NODISK|OF_QUEUE                                        ; CmdQCode
a499 3
        dc.w  OF_NODISK|OF_QUEUE                                        ; CmdPlaySpeed
        dc.w  OF_NODISK|OF_QUEUE                                        ; CmdReadSpeed
        dc.w  OF_NODISK|OF_QUEUE                                        ; CmdReadXLSpeed
d522 1
a522 1
                move.l  db_HardwareBase(db),hb
d597 1
a597 1
                move.l  db_HardwareBase(db),hb
d604 1
a604 1
                bne     abortExit
d614 4
a617 6
                bne.s   1$

                bsr     Abort                                           ; Abort it and check return code
                bra     2$
1$:
                exec    Remove                                          ; Remove entry from queue and reply (return)
d620 2
d623 2
a624 1
                move.b  #CDERR_ABORTED,IO_ERROR(ior)                    ; Success
d626 1
a626 1
abortExit:
d649 1
a649 1
                beq.s   9$
d652 1
a652 1
                beq.s   9$
d656 1
a656 1
9$:
d684 4
a687 2
                beq     AbortPlay

d689 2
a690 2
                beq     AbortRead

d692 5
a696 9


*
*****i* AbortPlay ******************************************************

AbortPlay:
                move.b  #CDERR_ABORTED,db_ClassDErr(db)                 ; Set error status

                SIGNAL  SIGF_PLAYDONE                                   ; Send back reply
a698 8

*****i* AbortRead ******************************************************

AbortRead:
                move.b  #CDERR_ABORTED,db_ClassAErr(db)                 ; Set error status

                SIGNAL  SIGF_CMDDONE                                    ; Send back reply
                rts
@
