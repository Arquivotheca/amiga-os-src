head     1.35;
branch   ;
access   ;
symbols  ;
locks    jerryh:1.35; strict;
comment  @* @;


1.35
date     94.02.14.09.51.28;  author jerryh;  state Exp;
branches ;
next     1.34;

1.34
date     93.11.18.09.07.39;  author jerryh;  state Exp;
branches ;
next     1.33;

1.33
date     93.11.17.13.53.22;  author jerryh;  state Exp;
branches ;
next     1.32;

1.32
date     93.09.24.15.39.08;  author jerryh;  state Exp;
branches ;
next     1.31;

1.31
date     93.09.08.10.42.53;  author jerryh;  state Exp;
branches ;
next     1.30;

1.30
date     93.04.30.16.53.33;  author jerryh;  state Exp;
branches ;
next     1.29;

1.29
date     93.04.21.11.28.52;  author jerryh;  state Exp;
branches ;
next     1.28;

1.28
date     93.04.12.15.51.19;  author jerryh;  state Exp;
branches ;
next     1.27;

1.27
date     93.04.08.10.20.49;  author jerryh;  state Exp;
branches ;
next     1.26;

1.26
date     93.03.29.13.35.33;  author jerryh;  state Exp;
branches ;
next     1.25;

1.25
date     93.03.26.10.28.43;  author jerryh;  state Exp;
branches ;
next     1.24;

1.24
date     93.03.23.09.26.16;  author jerryh;  state Exp;
branches ;
next     1.23;

1.23
date     93.03.19.13.45.45;  author jerryh;  state Exp;
branches ;
next     1.22;

1.22
date     93.03.18.14.52.32;  author jerryh;  state Exp;
branches ;
next     1.21;

1.21
date     93.03.16.13.23.12;  author jerryh;  state Exp;
branches ;
next     1.20;

1.20
date     93.03.06.12.36.23;  author jerryh;  state Exp;
branches ;
next     1.19;

1.19
date     93.03.01.14.54.33;  author jerryh;  state Exp;
branches ;
next     1.18;

1.18
date     93.02.26.14.26.51;  author jerryh;  state Exp;
branches ;
next     1.17;

1.17
date     93.02.23.15.54.18;  author jerryh;  state Exp;
branches ;
next     1.16;

1.16
date     93.02.17.15.32.45;  author jerryh;  state Exp;
branches ;
next     1.15;

1.15
date     93.02.09.15.52.41;  author jerryh;  state Exp;
branches ;
next     1.14;

1.14
date     93.02.08.16.40.00;  author jerryh;  state Exp;
branches ;
next     1.13;

1.13
date     93.02.04.11.07.30;  author jerryh;  state Exp;
branches ;
next     1.12;

1.12
date     93.02.04.10.26.16;  author jerryh;  state Exp;
branches ;
next     1.11;

1.11
date     93.02.03.12.10.28;  author jerryh;  state Exp;
branches ;
next     1.10;

1.10
date     93.01.22.12.02.03;  author jerryh;  state Exp;
branches ;
next     1.9;

1.9
date     93.01.15.15.42.16;  author jerryh;  state Exp;
branches ;
next     1.8;

1.8
date     93.01.07.09.40.42;  author jerryh;  state Exp;
branches ;
next     1.7;

1.7
date     92.12.11.13.37.12;  author jerryh;  state Exp;
branches ;
next     1.6;

1.6
date     92.12.09.15.22.53;  author jerryh;  state Exp;
branches ;
next     1.5;

1.5
date     92.12.07.11.59.28;  author jerryh;  state Exp;
branches ;
next     1.4;

1.4
date     92.12.05.16.54.54;  author jerryh;  state Exp;
branches ;
next     1.3;

1.3
date     92.12.04.10.20.11;  author jerryh;  state Exp;
branches ;
next     1.2;

1.2
date     92.11.23.09.23.50;  author jerryh;  state Exp;
branches ;
next     1.1;

1.1
date     92.11.02.13.33.57;  author jerryh;  state Exp;
branches ;
next     ;


desc
@read command (deserves its own special module because
of its complexity).
@


1.35
log
@Replaces drive light on and off commands with a jsr to LightOn/OFF.
@
text
@ 

        INCLUDE "exec/types.i"
        INCLUDE "exec/nodes.i"
        INCLUDE "exec/lists.i"
        INCLUDE "exec/ports.i"
        INCLUDE "exec/memory.i"
        INCLUDE "exec/interrupts.i"
        INCLUDE "exec/libraries.i"
        INCLUDE "exec/tasks.i"
        INCLUDE "exec/devices.i"
        INCLUDE "exec/execbase.i"
        INCLUDE "exec/io.i"
        INCLUDE "hardware/intbits.i"
        INCLUDE "exec/ables.i"

        INCLUDE "defs.i"
        INCLUDE "cd.i"
        INCLUDE "cdprivate.i"
        INCLUDE "cdgs_hw.i"

        OPT     p=68020

************************************************************************
*                                                                      *
*   External References                                                *
*                                                                      *
************************************************************************

        XREF    MSFBINtoBCD
        XREF    MSFBCDtoBIN
        XREF    LSNtoMSFPOS
        XREF    MSFtoLSNPOS
        XREF    LSNtoMSF
        XREF    MSFtoLSN
        XREF    BCDtoBIN
        XREF    BINtoBCD

        XREF    DoPacket
        XREF    SendPacket
        XREF    WaitPacket
        XREF    DoECC

        XREF    MuteCD
        XREF    Attenuate
        XREF    LightOn
        XREF    LightOff

        XREF    PutHex
        XREF    PutChar

        XDEF    ClearPrefetch
        XDEF    ClearPrefetchIfError

        INT_ABLES

*
************************************************************************
*                                                                      *
*   READ - Read CD-ROM data from disk                                  *
*                                                                      *
*       in:     ARG1 = Start position offset (word aligned)            *
*               ARG2 = Address                                         *
*               ARG3 = XLDMACount                                      *
*               ARG4 = Speed                                           *
*               ARG5 = MaxTransfer                                     *
*               IOR  = IORequest                                       *
*                                                                      *
************************************************************************

 FUNCTION READ
                save    d2-d7/a2-a3                                     ; Save all used registers
                move.l  db_CDROMPage(db),a3                             ; A3 = CDROMPage

                move.l  db_ARG1(db),d2                                  ; Calculate sector and index
                clr.l   d0
                move.w  db_Info+CDINFO_SectorSize(db),d0
                divul.l d0,d1:d2
                move.l  d2,db_ARG1(db)
                move.l  d1,db_SectorIndex(db)

                move.l  db_XferEntry(db),a0                             ; Make sure first XLDMACount is <= MaxTransfer
                move.l  CDXL_Length(a0),d0
                cmp.l   db_ARG5(db),d0
                bls     1$
                move.l  db_ARG5(db),db_ARG3(db)
1$
                clr.b   db_ReadError(db)                                ; No error just yet

                move.w  db_ARG4+2(db),d0                                ; If speed of requests are different, stop prefetching
                cmp.w   db_CurrentSpeed(db),d0
                beq     ReadData
                clr.w   d0
                jsr     StopRead

*************** Start a brand new READ *********************************

ReadData:
                jsr     GetSector                                       ; Get the sector we requested

                tst.l   d1                                              ; ECC problem?
                beq     1$
                move.b  #CDERR_BadSecSum,db_ReadError(db)
1$
                cmp.l   #-103,d0                                        ; CD-ROM Data?
                bne     2$
                restore d2-d7/a2-a3
                move.w  #CDERR_BadDataType,d0
                rts
2$
                cmp.l   #-104,d0                                        ; Read aborted?
                bne     TransferData
                restore d2-d7/a2-a3
                move.w  #CDERR_ABORTED,d0
                rts


*************** Transfer 'till end of XL node **************************

TransferData:
                jsr     TransferFromSector                              ; Transfer all or part of the sector
                bmi     TransferComplete

                bne     2$                                              ; If all of the sector was transferred...
                move.l  d3,d0                                           ; ... free the buffer and start on next sector
                jsr     FreeSectorBuffer
                addq.l  #1,db_ARG1(db)
2$
                tst.l   db_ARG3(db)                                     ; End of transfer?
                beq     TransferEntryComplete
                bra     ReadData

*
*************** Transfer of CDXL entry is complete *********************

TransferEntryComplete:
                move.l  db_XferEntry(db),a0                             ; Report actual amount transferred
                move.l  CDXL_Length(a0),d0
                cmp.l   db_ARG5(db),d0
                bls     1$
                move.l  db_ARG5(db),d0
1$              move.l  d0,CDXL_Actual(a0)
                add.l   d0,IO_ACTUAL(ior)
                sub.l   d0,db_ARG5(db)

                tst.l   CDXL_IntCode(a0)                                ; If an XL interrupt is defined, call it
                beq     2$
                lea     db_XLIntr(db),a1
                exec    Cause
2$
                move.l  db_XferEntry(db),a0                             ; Transfer complete?
                move.l  MLN_SUCC(a0),a0                                 ; - End of list?
                tst.l   MLN_SUCC(a0)
                beq     TransferComplete
                move.l  CDXL_Length(a0),d0                              ; - Node length 0?
                beq     TransferComplete
                tst.l   db_ARG5(db)                                     ; - Max length exhausted?
                beq     TransferComplete

                move.l  a0,db_XferEntry(db)                             ; New node
                clr.l   CDXL_Actual(a0)

                cmp.l   db_ARG5(db),d0                                  ; Set new address and length
                bls     3$
                move.l  db_ARG5(db),d0
3$              move.l  d0,db_ARG3(db)
                move.l  CDXL_Buffer(a0),db_ARG2(db)

                bra     ReadData                                        ; Resume transferring data


*************** Transfer is complete ***********************************

TransferComplete:
                restore d2-d7/a2-a3                                     ; Report read status
                clr.w   d0
                move.b  db_ReadError(db),d0
                rts



*
*=======================================================================
*=                                                                     =
*=  TransferFromSector - Transfer as much data from sector as possible =
*=                                                                     =
*=======================================================================

TransferFromSector:
                move.b  ROM_HEADER+3(a3,d3.l),d0                        ; Determine mode of sector
                cmp.b   #1,d0
                bne     1$

                move.l  #2048,d1                                        ; Mode 1 (no SH w/2048)
                lea     ROM_DATA(a3,d3.l),a1

                cmp.w   db_Info+CDINFO_SectorSize(db),d1                ; Are the sector sizes equal?
                bne     Error_BadSectorType
                bra     BeginTransfer
1$
                cmp.b   #2,d0                                           ; Mode 2?
                bne     ErrorUnknownMode

                cmp.w   #2048,db_Info+CDINFO_SectorSize(db)             ; Are we expecting a mode 1 sector?
                bne     2$

                move.b  ROM_HEADER+6(a3,d3.l),d0                        ; Get a valid "Submode" byte
                btst    #5,d0                                           ; - Test "FORM" bit of "Submode" byte of "SUBHEADER".
                bne     Error_BadSectorType

                lea     ROM_DATA+8(a3,d3.l),a1                          ; Mode 2 Form 1 (SH w/2048)
                move.l  #2048,d1
                bra     BeginTransfer
2$
                clr.l   d1                                              ; Default to Mode 2 Form 2 (SH w/2328)
                move.w  db_Info+CDINFO_SectorSize(db),d1
                lea     ROM_DATA+8(a3,d3.l),a1
                cmp.w   #2336,d1                                        ; - Alternate Mode 2 Form 2 (SH w/2336)
                bne     BeginTransfer
                lea     ROM_DATA(a3,d3.l),a1
                bra     BeginTransfer

ErrorUnknownMode:
                move.b  #CDERR_BadSecID,db_ReadError(db)                ; Unknown mode
                move.w  db_Info+CDINFO_SectorSize(db),d1                ; - use requested size
                bra     BeginTransfer

Error_BadSectorType:
                move.b  #CDERR_BadSecID,db_ReadError(db)                ; Abort read
                move.w  #-1,d0
                rts


*
*************** Mode/Form determined.  A1=Address, D1=Length ***********

BeginTransfer:
                sub.l   db_SectorIndex(db),d1                           ; Subtract amount of data already transferred D1 = remain
                add.l   db_SectorIndex(db),a1                           ; - Add in current sector index               A1 = source
                move.l  db_ARG2(db),a0                                  ; - Destination address                       A0 = dest

                clr.l   d2                                              ; Don't transfer more data than requested
                move.l  d1,d0
                cmp.l   db_ARG3(db),d0
                bls     1$
                move.l  db_ARG3(db),d0
                move.l  db_SectorIndex(db),d2                           ; - D0 = Transfer size
                add.l   d0,d2                                           ; - D2 = next sector index
1$
                move.l  d2,db_SectorIndex(db)                           ; Next time, index will equal this
                add.l   d0,db_ARG2(db)                                  ; - Next time, start at this address
                sub.l   d0,db_ARG3(db)                                  ; - Less data to transfer next time

                cmp.l   #44,d0                                          ; Is there enough data to do a big copy?
                blo     3$

                movem.l d2-d7/a2-a6,-(sp)                               ; Copy data in 44 byte chunks
2$              movem.l (a1)+,d2-d7/a2-a6
                movem.l d2-d7/a2-a6,(a0)
                add.l   #44,a0
                sub.l   #44,d0
                cmp.l   #44,d0
                bhs     2$
                movem.l (sp)+,d2-d7/a2-a6
3$
                tst.w   d0                                              ; Any data to transfer?
                beq     5$

4$              move.w  (a1)+,(a0)+                                     ; Move words at a time
                subq.w  #2,d0
                bne     4$
5$
                tst.l   db_SectorIndex(db)                              ; Are we done with this sector?
                rts



*
*=======================================================================
*=                                                                     =
*=  WithinRange - See if data is or is approaching data requested      =
*=                                                                     =
*=      in:     D0.l = Sector we have just read                        =
*=              D2.l = Sector we are trying to read                    =
*=                                                                     =
*=     out:                                                            =
*=              z flag = true or false                                 =
*=                                                                     =
*=    note:     D1 is trashed                                          =
*=                                                                     =
*=======================================================================

WithinRange:
                cmp.l   d2,d0                                           ; Are we past where we want to be?
                beq     3$
                bmi     2$
1$              clr.w   d1                                              ; - Not within range
                rts
2$
                move.l  d0,d1                                           ; Are we way short of where we want to be?
                add.l   #10,d1
                cmp.l   d2,d1
                bmi     1$
3$              move.w  #1,d1
                rts



*=======================================================================
*=                                                                     =
*=  ClearPrefetch - Free all prefetch buffers so drive can use them    =
*=                                                                     =
*=======================================================================

ClearPrefetch:
                save    a3
                move.l  db_CDROMPage(db),a3                             ; A3 = CDROMPage

                clr.l   d0                                              ; Set Invalid mark (status word) in buffers
1$              move.w  #SECSTSF_INVALID,ROM_STATUS+2(a3,d0.l)

                add.w   #$1000,d0
                cmp.w   #(PBXSIZE*$1000)&$FFFF,d0
                bne     1$

                move.w  #$FFFF,CDPBX(hb)                                ; Clear all buffers
                restore a3
                rts


*=======================================================================
*=                                                                     =
*=  ClearPrefetchIfError - Free prefetch if next sector has an error   =
*=                                                                     =
*=======================================================================

ClearPrefetchIfError:
                save    a3/d3
                move.l  db_CDROMPage(db),a3                             ; A3 = CDROMPage

                jsr     GetNextSectorBufferECC                          ; Clear prefetch if next sector has an error
                tst.l   d1
                beq     1$
                jsr     ClearPrefetch
1$
                restore a3/d3
                rts


*
*=======================================================================
*=                                                                     =
*=  GetSector - Get sector requested (from prefetch or by reading)     =
*=                                                                     =
*=      out:                                                           =
*=              D0.l = Sector requested                                =
*=                     -103 if not CD-ROM data                         =
*=                     -104 aborted                                    =
*=                                                                     =
*=              D1.l = Non-Zero = ECC failed                           =
*=                                                                     =
*=              D3.l = Index into buffer                               =
*=                                                                     =
*=======================================================================

GetSector:
                move.l  db_ARG1(db),d0                                  ; Do we need to remap this sector?
                cmp.l   db_Remap(db),d0
                bhs     1$
                add.l   db_RemapStart(db),d0
1$
                move.l  d0,d2                                           ; Get oldest new sector (if one is available)
                jsr     GetNextSectorBufferECC
                cmp.l   #-100,d0
                bne     4$

                tst.b   db_Reading(db)                                  ; If we are no longer reading, start reading again
                bne     2$

                jsr     StartRead                                       ; Begin reading new data
                beq     2$

                clr.l   d1                                              ; Bad data type encountered
                move.l  #-103,d0
                rts
2$
                move.l  #SIGF_CMDDONE|SIGF_PBX|SIGF_ABORTDRIVE,d0       ; Wait for data or read abort
                exec    Wait

                btst    #SIGB_CMDDONE,d0                                ; If we reached EOD before our sector, seek back
                beq     3$
                sub.l   #8,db_SeekAdjustment(db)
                bra     7$
3$
                btst    #SIGB_ABORTDRIVE,d0                             ; If read was aborted, stop reading and return
                beq     GetSector
                clr.w   d0
                jsr     StopRead
                clr.l   d1
                move.l  #-104,d0
                rts
4$
                tst.l   d1                                              ; If ECC failed, report error
                bne     5$

                cmp.l   d0,d2                                           ; If this is the sector we requested, return it
                bne     6$
                cmp.b   #1,db_Reading(db)                               ; - We are now reading requested data
                bne     5$
                move.b  #2,db_Reading(db)                               
5$              rts
6$
                tst.b   db_Reading(db)                                  ; If we are doing a read attempt, see if the drive went
                beq     8$                                              ;   where it was supposed to.
                jsr     WithinRange
                bne     8$

                cmp.b   #1,db_Reading(db)                               ; Adjust read if we are searching, otherwise, just reseek
                bne     7$
                move.l  d2,d1
                sub.l   d0,d1
                sub.l   #2,d1                                           ; - A bit more for good measure
                add.l   d1,db_SeekAdjustment(db)
7$
                clr.w   d0                                              ; Stop current read and try reading again
                jsr     StopRead
                jsr     ClearPrefetch
                bra     GetSector
8$
                move.l  d3,d0                                           ; We don't want this sector, free it and try another
                jsr     FreeSectorBuffer
                bra     GetSector

*
*=======================================================================
*=                                                                     =
*=  GetNextSectorBufferECC - Find oldest new sector.  Return LSN/ERROR =
*=                                                                     =
*=       in:    D2.l = Sector we are trying to find                    =
*=                                                                     =
*=      out:                                                           =
*=              D0.l = Sector (LSN)                                    =
*=                     -100 if no data                                 =
*=                                                                     =
*=              D1.l = Non-Zero = ECC failed                           =
*=                                                                     =
*=              D3.l = Index into buffer                               =
*=                                                                     =
*=======================================================================

GetNextSectorBufferECC:
                jsr     GetNextSectorBuffer                             ; Find oldest new sector's address

                cmp.l   #-100,d0                                        ; Data available?
                beq     2$

                move.l  d0,d3                                           ; Perform ECC on data.  Return error if data is bad
                lea     0(a3,d3.l),a0
                jsr     DoECC
                beq     1$

                jsr     1$                                              ; ECC failed
                move.l  #1,d1
                rts
1$
                move.l  ROM_HEADER(a3,d3.l),d0                          ; Figure out the logical sector number
                lsr.l   #8,d0
                jsr     MSFBCDtoBIN
                jsr     MSFtoLSNPOS
2$
                clr.l   d1                                              ; No ECC error
                rts


*
*=======================================================================
*=                                                                     =
*=  GetNextSectorBuffer - Find oldest new sector and return index      =
*=                                                                     =
*=      out:                                                           =
*=              D0.l = Index into CDROMPage or -100 if no data         =
*=                                                                     =
*=======================================================================

GetNextSectorBuffer:
                clr.l   d0                                              ; Traverse buffers to find the next sector
1$              move.l  ROM_STATUS(a3,d0.l),d1
                btst    #SECSTSB_INVALID,d1                             ; - Is this the next sector?
                bne     2$
                and.l   #SECSTSF_CNT,d1
                cmp.b   db_BufferCount(db),d1
                bne     2$

                tst.l   d0
                rts                                                     ; - Return index into CDROMPage
2$
                add.w   #$1000,d0                                       ; Try next buffer
                cmp.w   #(PBXSIZE*$1000)&$FFFF,d0
                bne     1$

                move.l  #-100,d0                                        ; No new sectors in buffer
                rts



*=======================================================================
*=                                                                     =
*=  FreeSectorBuffer - Free up CDROMPage buffer                        =
*=                                                                     =
*=      in:                                                            =
*=              D0.l = CDROMPage buffer index                          =
*=                                                                     =
*=======================================================================

FreeSectorBuffer:
                move.w  #SECSTSF_INVALID,ROM_STATUS+2(a3,d0.l)          ; Set invalid flag of sector

                divu    #$1000,d0                                       ; Free the buffer
                clr.w   d1
                bset    d0,d1
                move.w  d1,CDPBX(hb)

                add.b   #1,db_BufferCount(db)                           ; Next buffer should contain the new count
                and.b   #$1F,db_BufferCount(db)

                rts


*
*=======================================================================
*=                                                                     =
*=  StartRead - Start drive playing and enable CD-ROM decoding         =
*=                                                                     =
*=      in:     D2.l = Sector to begin read                            =
*=                                                                     =
*=======================================================================

StartRead:
                jsr     ClearPrefetch                                   ; Free all buffers

                jsr     MuteCD                                          ; Mute CD audio

                jsr     LightOn                                         ; Turn on drive light

                move.l  #$80000004,d1                                   ; ROM mode, no Q-Codes
                cmp.l   #150,db_ARG4(db)
                blo     1$
                bset    #22,d1
                cmp.l   #150,db_ARG4(db)
1$              move.l  d1,db_Packet+7(db)
                move.w  db_ARG4+2(db),db_CurrentSpeed(db)
                move.b  #0,db_Packet+11(db)

                move.l  db_TOC+TOCS_LeadOut(db),d0                      ; Set up read
                jsr     MSFBINtoBCD
                move.l  d0,db_Packet+3(db)
                move.l  d2,d0
                add.l   db_SeekAdjustment(db),d0
                jsr     LSNtoMSFPOS
                jsr     MSFBINtoBCD
                move.l  d0,db_Packet(db)
                move.b  #CHCMD_SETPLAY,db_Packet(db)

                jsr     DoPacket                                        ; Send SETPLAY command, abort if error
                bmi     4$

                btst    #1,d0                                           ; Start the disk spinning if stopped
                beq     2$
                move.w  db_Info+CDINFO_Status(db),d0
                btst    #CDSTSB_SPIN,d0
                bne     3$
2$              move.b  #CHCMD_PLAY,db_Packet(db)
                jsr     DoPacket
                bmi     4$
                or.w    #CDSTSF_SPIN,db_Info+CDINFO_Status(db)
3$
                move.b  #1,db_Reading(db)                               ; We are now attempting to read data

                move.b  #0,db_BufferCount(db)                           ; Next expected buffer count

                or.l    #CF_CDROM,CDCONFIG(hb)                          ; Turn on CD-ROM hardware
                or.l    #INTF_PBX,CDINT2ENABLE(hb)

                clr.w   d0                                              ; Success
                rts
4$
                clr.w   d0                                              ; Return an error if the play was not successful
                jsr     StopRead
                move.w  #1,d0
                rts


*
*=======================================================================
*=                                                                     =
*=  StopRead - Stop decoding of CD-ROM data and pause drive            =
*=                                                                     =
*=  in:     D0.w = no response?                                        =
*=                                                                     =
*=======================================================================

 FUNCTION StopRead
                save    d0

                and.l   #-1-(INTF_PBX|INTF_OVERFLOW),CDINT2ENABLE(hb)   ; Turn off CD-ROM hardware
                and.l   #-1-CF_CDROM,CDCONFIG(hb)

                jsr     LightOff                                        ; Turn off drive light

                tst.b   db_Reading(db)                                  ; Make sure we don't pause what is already paused
                beq     1$

                clr.b   db_Reading(db)                                  ; No longer reading

                move.b  #CHCMD_PAUSE,db_Packet(db)                      ; Pause the drive
                restore d0
                save    d0
                jsr     SendPacket
                restore d1
                save    d1
                tst.w   d1
                bne     1$
                jsr     WaitPacket
1$
                restore d0
                rts





@


1.34
log
@Error if time of read is negative.
@
text
@d46 2
d543 1
a543 2
                move.w  #$0581,db_Packet(db)                            ; Turn on drive light
                jsr     DoPacket
d608 1
a608 3
                clr.w   d0                                              ; Turn off drive light
                move.w  #$0500,db_Packet(db)
                jsr     SendPacket
@


1.33
log
@If read goes negative, CDI disks are screwed.  return
an error when trying to access sectors that close to beginning of disk.
@
text
@a557 1
                bmi     4$
@


1.32
log
@If the speed of a read command has changed, the prefetching
is forced to stop so another read command is issued.
@
text
@d558 1
@


1.31
log
@Wait for a response packet for drive light before doing a setplay.
@
text
@d88 5
@


1.30
log
@Removed setting of cause flag.
@
text
@d536 2
a537 3
                clr.w   d0
                move.w  #$0501,db_Packet(db)                            ; Turn on drive light
                jsr     SendPacket
@


1.29
log
@Fixed ReadXL command.
@
text
@a140 1
                move.w  #1,db_XLCause(db)
@


1.28
log
@Bumped read window from 40 down to 10 (requires T24 firmware or greater).
@
text
@d163 1
a163 1
                bra     TransferData                                    ; Resume transferring data
@


1.27
log
@Overflow interrupt coded properly.
@
text
@d295 1
a295 4
;                add.l   #10,d1

                add.l   #40,d1

d537 1
a537 1
                move.w  #1,d0
d604 2
a605 2
                move.w  #1,d0
                move.w  #$0500,db_Packet(db)                            ; Turn off drive light
@


1.26
log
@no effective change.
@
text
@d212 1
a212 1
                cmp.w   #2336,d1                                        ; - Alternate Mode 2 Form 2 (SH 2/2336)
d581 1
a581 4
;
                or.l    #INTF_PBX,CDINT2ENABLE(hb)                      ; puthex ... replace with below
;
;                or.l    #INTF_PBX|INTF_OVERFLOW,CDINT2ENABLE(hb)
@


1.25
log
@no effective change.
@
text
@d18 1
a19 1
        INCLUDE "cd.i"
@


1.24
log
@The proper register was not being loaded before a test of CDXL_Length(a0)
@
text
@d581 4
a584 1
                or.l    #INTF_PBX,CDINT2ENABLE(hb)
@


1.23
log
@Does not check sector integrety when requesting sectors bigger
than 2048 bytes.  This checking (should take place in my
opinion, but we have an example of one disk which has been
pressed with the wrong information, confusing the device driver).
@
text
@d80 2
a81 1
                move.l  CDXL_Length(a0),d0                              ; Make sure first XLDMACount is <= MaxTransfer
@


1.22
log
@*** empty log message ***
@
text
@a182 3
                move.l  #2328,d1                                        ; Default to Mode 2 Form 2 (SH w/2328)
                lea     ROM_DATA+8(a3,d3.l),a1

d187 1
a187 1
                move.w  #2048,d1                                        ; Mode 1 (no SH w/2048)
d189 3
d197 3
d202 10
d213 1
a213 2

                move.w  #2048,d1                                        ; Mode 2 Form 1 (SH w/2048)
d221 5
a230 3
                cmp.w   db_Info+CDINFO_SectorSize(db),d1                ; Are the sector sizes equal?
                bne     Error_BadSectorType

a268 4
Error_BadSectorType:
                move.b  #CDERR_BadSecID,db_ReadError(db)                ; Abort read
                move.w  #-1,d0
                rts
a270 1

a419 3

                move.l  d1,d0
                jsr     PutHex
@


1.21
log
@Openned up seek window to 40 sectors.
@
text
@d285 4
a288 1
                add.l   #40,d1                                          ; - This number shouldn't need to be this big
d411 3
@


1.20
log
@Made reads complete the transfer even after an error has been detected.
(for non-caring CDXL reads).
@
text
@d284 2
a285 2
                move.l  d0,d1
                add.l   #26,d1                                          ; Are we way short of where we want to be?
a403 1

@


1.19
log
@ReadXL modified to use a list.
@
text
@d1 1
a2 1

d93 2
a94 2
                cmp.l   #-101,d0                                        ; ECC problem?
                bne     1$
d97 1
a97 1
                cmp.l   #-103,d0                                          ; CD-ROM Data?
d103 1
a103 1
                cmp.l   #-104,d0                                          ; Read aborted?
d206 2
a207 2
                move.w  #-1,d0                                          ; - Abort now
                rts
d326 2
a327 2
                cmp.l   #-101,d0
                bne     1$
a340 1
*=                     -101 if ECC failed                              =
d344 2
d367 2
a368 1
                move.l  #-103,d0                                        ; Bad data type encountered
d383 1
d387 2
a388 2
                cmp.l   #-101,d0                                        ; If ECC failed, report error
                beq     5$
a401 8
;                save    d0
;                jsr     PutHex
;                move.l  d2,d0
;                jsr     PutHex
;                move.l  ROM_HEADER(a3,d3.l),d0
;                jsr     PutHex
;                restore d0

d429 2
a430 1
*=                     -101 if ECC failed                              =
d446 3
a448 1
                move.l  #-101,d0
d456 1
@


1.18
log
@Now allows for maximum transfer length.
@
text
@d145 2
a146 1
                move.l  MLN_SUCC(a0),d0                                 ; - Last node?
a147 1
                move.l  d0,a0
@


1.17
log
@Retries reads if drive spins down.
@
text
@d64 1
d80 5
d131 4
a134 1
                move.l  d0,CDXL_Actual(a0)
d136 1
d139 1
a139 1
                beq     1$
d143 3
a145 3
1$
                move.l  db_XferEntry(db),a0                             ; If this is the last transfer node, transfer complete
                move.l  MLN_SUCC(a0),d0
d148 3
a150 1
                move.l  CDXL_Length(a0),d0
d156 4
a159 1
                move.l  d0,db_ARG3(db)                                  ; Set new address and length
@


1.16
log
@no effective change.
@
text
@d289 2
a290 1
1$              move.w  #$FFFF,ROM_STATUS+2(a3,d0.l)
d337 1
a337 1
                bhs     0$
d339 1
a339 1
0$
d343 1
a343 1
                bne     2$
d346 1
a346 1
                bne     1$
d349 1
a349 1
                beq     1$
d353 2
a354 2
1$
                move.l  #SIGF_PBX|SIGF_ABORTDRIVE,d0                    ; Wait for data or read abort
d357 5
d368 1
a368 1
2$
d370 1
a370 1
                beq     3$
d373 1
a373 1
                bne     4$
d375 1
a375 1
                bne     3$
d377 2
a378 2
3$              rts
4$
d380 1
a380 1
                beq     6$                                              ;   where it was supposed to.
d382 10
a391 1
                bne     6$
d393 2
a394 1
                bne     5$
d399 1
a399 1
5$
d404 1
a404 1
6$
d538 1
a538 1
                bmi     3$
d540 3
a542 1
                move.w  db_Info+CDINFO_Status(db),d0                    ; Start the disk spinning if stopped
d544 2
a545 2
                bne     2$
                move.b  #CHCMD_PLAY,db_Packet(db)
d547 1
a547 1
                bmi     3$
d549 1
a549 1
2$
d559 1
a559 1
3$
a575 1

@


1.15
log
@reworked read command a bit.  Works in double-speed now.
@
text
@a42 1
        XREF    IsError
@


1.14
log
@Fixed problem with accessing first few sectors on disk.
@
text
@d52 1
d253 2
a254 1
*=      in:     D2.l = Sector we are trying to read                    =
d265 1
d267 1
a267 2
                beq     2$
1$              clr.w   d1
d274 1
a274 1
                move.w  #1,d1
d286 1
d296 20
d340 1
a340 1
                move.l  d0,d2                                           ; Get oldest new sector
a341 1

d351 1
a351 1
                move.l  #-103,d0                                          ; Bad data type encountered
a358 1

d364 1
a364 1
                cmp.l   #-102,d0                                          ; Do we need to reseek?
d366 2
a367 1
                cmp.b   #2,db_Reading(db)                               ; - Are we reading the data requested?
d369 16
a384 3
                jsr     WithinRange                                     ; - Is this the data we now want?
                bne     4$
3$
d389 1
a389 4
4$
                cmp.l   d2,d0                                           ; If this is the sector we want, start transferring
                beq     5$

a392 3
5$
                tst.l   d0                                              ; Report sector or error status
                rts
a404 1
*=                     -102 if Reseek Required                         =
d414 1
a414 1
                beq     3$
a426 12

                cmp.b   #1,db_Reading(db)                               ; If we are doing a read attempt, see if the drive went
                bne     2$                                              ;   where it was supposed to.
                jsr     WithinRange
                bne     2$
                move.l  d2,d1                                           ; Calculate adjustment
                sub.l   d0,d1
                sub.l   #2,d1                                           ; - A bit more for good measure
                add.l   d1,db_SeekAdjustment(db)

                move.l  #-102,d0
                rts
a427 4
                tst.b   db_Reading(db)                                  ; We have successfully read the sector we asked for
                beq     3$
                move.b  #2,db_Reading(db)
3$
@


1.13
log
@relocating sectors now.  Multi-session now working!
@
text
@d87 1
a87 1
                cmp.l   #-2,d0                                          ; ECC problem?
d91 1
a91 1
                cmp.l   #-4,d0                                          ; CD-ROM Data?
d97 1
a97 1
                cmp.l   #-5,d0                                          ; Read aborted?
d263 2
a264 1
                bls     2$
d271 1
a271 1
                blo     1$
d303 3
a305 3
*=                     -2 if ECC failed                                =
*=                     -4 if not CD-ROM data                           =
*=                     -5 aborted                                      =
d320 1
a320 1
                cmp.l   #-1,d0
d329 1
a329 1
                move.l  #-4,d0                                          ; Bad data type encountered
d340 1
a340 1
                move.l  #-5,d0
d343 1
a343 1
                cmp.l   #-3,d0                                          ; Do we need to reseek?
d374 3
a376 3
*=                     -1 if no data                                   =
*=                     -2 if ECC failed                                =
*=                     -3 if Reseek Required                           =
d385 1
a385 1
                cmp.l   #-1,d0                                          ; Data available?
d392 1
a392 1
                move.l  #-2,d0
d408 2
a409 1
                move.l  #-3,d0
d425 1
a425 1
*=              D0.l = Index into CDROMPage or -1 if no data           =
d445 1
a445 1
                move.l  #-1,d0                                          ; No new sectors in buffer
a503 1

d510 2
a511 1
                jsr     DoPacket                                        ; Send SETPLAY command
d513 8
a520 4
                bmi     2$                                              ; Abort if there is an error
                cmp.b   #CDERR_NoDisk,IO_ERROR(ior)
                beq     2$

d530 4
a533 2
2$
                move.w  #1,d0                                           ; Return an error if the play was not successful
d553 4
a560 4

                move.w  #1,d0
                move.w  #$0500,db_Packet(db)                            ; Turn off drive light
                jsr     SendPacket
@


1.12
log
@no effective change.
@
text
@d97 1
a97 1
                cmp.l   #-5,d0
a111 1

d252 3
a254 1
*=      in:                                                            =
d262 1
a262 1
                cmp.l   db_ARG1(db),d0                                  ; Are we past where we want to be?
d269 1
a269 1
                cmp.l   db_ARG1(db),d1
d311 7
a317 1
                jsr     GetNextSectorBufferECC                          ; Get oldest new sector
d354 1
a354 1
                cmp.l   db_ARG1(db),d0                                  ; If this is the sector we want, start transferring
d369 2
a381 1

d403 1
a403 1
                move.l  db_ARG1(db),d1                                  ; Calculate adjustment
d476 2
d501 1
a501 1
                move.l  db_ARG1(db),d0
@


1.11
log
@internal.i is now cdprivate.i
@
text
@d64 1
@


1.10
log
@Major mods to read for adaptive seek position.
@
text
@d18 1
a18 1
        INCLUDE "internal.i"
@


1.9
log
@massive changed to prefetching.
@
text
@a67 3
;                move.b  #'b',d0
;                jsr     PutChar

d111 1
a152 3
;                move.b  #'t',d0
;                jsr     PutChar

d246 1
d250 1
a250 1
*=  AdjustSeek - Recalculate seek adjustment                           =
d253 1
a253 1
*=              D0.l = First sector obtained after issuing play cmd    =
d255 2
d259 13
a271 6
AdjustSeek:
                move.l  db_ARG1(db),d1                                  ; Calculate new adjustment
                sub.l   d0,d1
                sub.l   #2,d1                                           ; - A bit more for good measure
                add.l   d1,db_SeekAdjustment(db)
                rts
a308 3
;                move.b  #'g',d0
;                jsr     PutChar

a310 2
;                jsr     PutHex

a313 3
;                move.b  #'e',d0
;                jsr     PutChar

a322 3
;                move.b  #'w',d0
;                jsr     PutChar

a328 3
;                move.b  #'a',d0
;                jsr     PutChar

d335 8
a342 1
                bne     3$
a343 3

                clr.w   d0
                jsr     StopRead
d345 1
a345 1
3$
d347 1
a347 1
                beq     4$
d352 1
a352 1
4$
d374 2
a375 1
                cmp.l   #-1,d0
d390 9
a398 6
                cmp.l   db_ARG1(db),d0                                  ; If this is the sector we wanted, start transferring
                beq     3$

                blo     2$            
;                bsr     AdjustSeek                                      ; If we are past where we want to be...
                move.l  #-3,d0                                          ; ... adjust seek and try READ again
d401 3
a403 6
                move.l  d0,d1
                add.l   #16,d1                                          ; If we are way short, modify adjustment for next time...
                cmp.l   db_ARG1(db),d1                                  ; ... but don't restart this read
                bhi     3$
;                bsr     AdjustSeek
                move.l  #-3,d0
a404 1
                tst.l   d0                                              ; Return the sector or error
d426 2
a448 5
;                save    d0
;                move.b  #'f',d0
;                jsr     PutChar
;                restore d0

d474 3
a476 6
;                move.b  #'r',d0
;                jsr     PutChar

;                move.w  #1,d0
;                move.w  #$0501,db_Packet(db)                            ; Turn on drive light
;                jsr     SendPacket
a478 1
                move.l  #-2,db_SeekAdjustment(db)
d482 1
a482 1
                move.l  #-6,db_SeekAdjustment(db)
a499 5

;                move.b  #'R',d0
;                jsr     PutChar


d528 1
a530 3
;                move.b  #'s',d0
;                jsr     PutChar

d534 3
d539 3
a541 6
;                move.w  #1,d0
;                move.w  #$0500,db_Packet(db)                            ; Turn off drive light
;                jsr     SendPacket

                cmp.b   #CDERR_NoDisk,IO_ERROR(ior)                     ; If no disk in drive, do not pause it
                beq     1$
@


1.8
log
@Abort of read command should work.
@
text
@d68 3
a81 13
1$
                jsr     GetNextSectorBuffer                             ; Is there a sector in the prefetch buffer?
                cmp.l   #-1,d0
                beq     ReadNew
                move.l  d0,d3

                lea     0(a3,d3.l),a0                                   ; Is the requested sector in prefetch buffer?
                move.l  ROM_HEADER(a0),d0
                lsr.l   #8,d0
                jsr     MSFBCDtoBIN
                jsr     MSFtoLSNPOS
                cmp.l   db_ARG1(db),d0
                bne     2$
a82 2
                jsr     DoECC                                           ; If there is an error on this sector, reread it
                bne     ReadNew
d84 1
a84 4
                bra     ProcessBlock                                    ; Sector is here, copy it from buffer
2$
                jsr     FreeSectorBuffer                                ; Try the next buffer
                bra     1$
d86 2
d89 3
a91 7
*************** Start a brand new READ *********************************

ReadNew:
                tst.b   db_Reading(db)                                  ; If we are prefetching, turn it off
                beq     1$
                clr.w   d0
                jsr     StopRead
d93 3
a95 6
                jsr     ClearPrefetch                                   ; Clear the prefetch buffer

                jsr     StartRead                                       ; Begin reading data
                beq     2$

                restore d2-d7/a2-a3                                     ; Not CD-ROM data
a97 3

*
*************** Find the first sector of the transfer ******************
d99 2
a100 7
                move.l  #SIGF_PBX|SIGF_ABORTDRIVE,d0                    ; Wait for data or read abort
                exec    Wait

                btst    #SIGB_ABORTDRIVE,d0                             ; If read was aborted, stop reading and return
                beq     3$
                clr.w   d0
                jsr     StopRead
a103 32
3$
                move.w  #-1,d7                                          ; Initialize ignore count
4$
                addq.w  #1,d7                                           ; If we have ignored too many sectors...
                cmp.w   #40,d7                                          ; ... retry the READ with new adjustment
                bhs     ReadNew

                jsr     GetNextSectorBuffer                             ; Find oldest new sector's address
                cmp.l   #-1,d0
                beq     2$

                lea     0(a3,d3.l),a0                                   ; Copy last 16 bits of C2P0
                move.w  ROM_STATUS(a0),ROM_C2P0+292(a0)

                move.l  d0,d3                                           ; There is a sector available.  Is the header valid?
                lea     0(a3,d3.l),a0
                move.w  ROM_C2P0(a0),d0
                and.w   #$000F,d0
                beq     5$

                lea     0(a3,d3.l),a0                                   ; Perform ECC on data.
                jsr     DoECC

                lea     0(a3,d3.l),a0                                   ; Ignore if still bad.
                move.w  ROM_C2P0(a0),d0
                and.w   #$000F,d0
                bne     7$
5$
                move.l  ROM_HEADER(a3,d3.l),d0                          ; Figure out the logical sector number
                lsr.l   #8,d0
                jsr     MSFBCDtoBIN
                jsr     MSFtoLSNPOS
a104 31
                cmp.l   db_ARG1(db),d0                                  ; If this is the sector we wanted, start transferring
                beq     ProcessBlock

                tst.w   d7                                              ; If this is the first sector received, do some checking
                bne     7$

                cmp.l   db_ARG1(db),d0                                  ; If we are past where we want to be...
                blo     6$                                              ; ... adjust seek and try READ again
                bsr     AdjustSeek
                bra     ReadNew
6$
                move.l  d0,d1
                add.l   #16,d1                                          ; If we are way short, modify adjustment for next time...
                cmp.l   db_ARG1(db),d1                                  ; ... but don't restart this read
                bhi     7$
                bsr     AdjustSeek
7$
                move.l  d3,d0                                           ; Free the buffer and ignore the sector
                jsr     FreeSectorBuffer
                bra     4$

*
*************** Process and error correct block ************************

ProcessBlock:
                lea     0(a3,d3.l),a0                                   ; Perform ECC on data.
                jsr     DoECC

                beq     TransferData                                    ; Report an error if this sector is bad
                move.b  #CDERR_BadSecSum,db_ReadError(db)

d110 1
a110 1
                bmi     Error_Stop
d119 1
a119 22
3$
                jsr     GetNextSectorBuffer                             ; Find oldest new sector's address
                move.l  d0,d3
                cmp.l   #-1,d0
                bne     ProcessBlock

                tst.b   db_Reading(db)                                  ; Begin reading again
                beq     ReadNew

                move.l  #SIGF_PBX|SIGF_ABORTDRIVE,d0                    ; Wait for data or read abort
                exec    Wait

                btst    #SIGB_ABORTDRIVE,d0                             ; If read was aborted, stop reading and return
                beq     3$
                move.b  #CDERR_ABORTED,db_ReadError(db)
Error_Stop:
                clr.w   d0
                jsr     StopRead                                        ; Read could not be completed
                restore d2-d7/a2-a3
                clr.w   d0
                move.b  db_ReadError(db),d0
                rts
d155 6
a160 7
                tst.b   db_ReadError(db)                                ; Report read status
                beq     1$
                tst.b   IO_ERROR(ior)
                bne     1$
                move.b  db_ReadError(db),IO_ERROR(ior)
1$
                restore d2-d7/a2-a3
a187 8
                lea     0(a3,d3.l),a0
                move.b  ROM_C2P0+2(a0),d2                               ; - Status of all 8 subheader bytes
                btst    #5,d2                                           ; - check C2P0 bit of first submode
                beq     2$
                btst    #1,d2                                           ; - check C2P0 bit of second submode
                bne     ErrorBadHeader
                move.b  ROM_HEADER+10(a3,d3.l),d0
2$
a198 3
ErrorBadHeader:
                move.b  #CDERR_BadHdrSum,db_ReadError(db)               ; Bad header
                move.w  db_Info+CDINFO_SectorSize(db),d1                ; - Current sector size
d264 1
a264 1
                sub.l   #2,d1                                           ; - One more for good measure
d278 1
a278 1
                clr.l   d0                                              ; Set Invalid mark (status long) in buffers
d291 125
d452 5
d478 2
d482 17
d503 1
d510 5
a514 7
                move.l  #$80000004,d1                                   ; ROM mode, no Q-Codes
                cmp.l   #150,db_ARG4(db)
                blo     1$
                bset    #22,d1
1$              move.l  d1,db_Packet+7(db)
                move.w  db_ARG4+2(db),db_CurrentSpeed(db)
                move.b  #0,db_Packet+11(db)
a515 1
                jsr     DoPacket                                        ; Send SETPLAY command
d535 1
a535 1

d545 5
d555 4
d563 1
d567 1
d572 1
@


1.7
log
@Removed debug messages.
Optimized with an 020 instruction here and there.
@
text
@d41 1
d45 3
d122 1
a122 1
                move.l  #SIGF_PBX|SIGF_ABORTREAD,d0                     ; Wait for data or read abort
d125 1
a125 1
                btst    #SIGB_ABORTREAD,d0                              ; If read was aborted, stop reading and return
a180 3

                move.b  #'X',d0
                jsr     PutChar
d219 1
a219 1
                move.l  #SIGF_PBX|SIGF_ABORTREAD,d0                     ; Wait for data or read abort
d222 1
a222 1
                btst    #SIGB_ABORTREAD,d0                              ; If read was aborted, stop reading and return
d472 2
d484 1
a484 1
                move.l  #$80000000,d1                                   ; ROM mode, no Q-Codes
d494 3
a496 5
                bpl     2$                                              ; Return an error if the play was not successful
                move.w  #1,d0
                rts
2$
                move.b  #0,db_BufferCount(db)                           ; Next expected buffer count
d500 2
d507 3
d527 3
d531 8
a538 5
                tst.w   d0
                bne     SendPacket
                jmp     DoPacket


@


1.6
log
@minor mods.
@
text
@d22 2
d42 1
d47 2
a63 2
                PRINT   0$,"READ"

d67 5
a71 4
                move.l  db_ARG1(db),d1                                  ; Calculate index
                divu    db_Info+CDINFO_SectorSize(db),d1
                clr.w   d1
                swap    d1
a73 6
                move.l  db_ARG1(db),d1                                  ; Calculate sector
                move.w  db_Info+CDINFO_SectorSize(db),d0
                divu    d0,d1
                and.l   #$0000FFFF,d1
                move.l  d1,db_ARG1(db)

d81 1
a81 1
                lea     0(a3,d3.l),a0                                   ; Is the requested sector the first in prefetch buffer?
d87 4
a90 1
                beq     ProcessBlock
d92 2
a100 2
                PRINT   0$,"READ_NEW"

d148 1
a148 1
                lea     ROM_C2P0(a0),a0                                 ; Perform ECC on data.
d173 1
a173 1
                add.l   #4,d1                                           ; If we are way short, modify adjustment for next time...
d189 1
a189 1
                lea     ROM_C2P0(a0),a0                                 ; Perform ECC on data.
a384 7
                PRINT   1$,"ADJUST_SEEK"
                save    d0
                jsr     PutHex
                move.l  db_ARG1(db),d0
                jsr     PutHex
                restore d0

d387 1
a387 1
                sub.l   #1,d1                                           ; - One more for good measure
d399 2
a470 2
                PRINT   1$,"START_READ"

@


1.5
log
@made drive stop when prefetch is full.
Read routine actually works now!

@
text
@d54 1
d83 2
a84 1
                move.l  ROM_HEADER(a3,d3.l),d0                          ; Is the requested sector the first in prefetch buffer?
d98 2
d102 1
d122 1
a140 5
                save    d0
                move.b  #'S',d0
                jsr     PutChar
                restore d0

d176 3
a187 6
                move.l  ROM_HEADER(a3,d3.l),d0                          ; Store Sector number in data block
                lsr.l   #8,d0
                jsr     MSFBCDtoBIN
                jsr     MSFtoLSN
                move.l  d0,ROM_LSNPOS(a3,d3.l)

d224 1
d373 1
a373 1

d385 1
d389 1
d398 17
a466 17
*=======================================================================
*=                                                                     =
*=  ClearPrefetch - Free all prefetch buffers so drive can use them    =
*=                                                                     =
*=======================================================================

ClearPrefetch:
                clr.l   d0                                              ; Set Invalid mark (status long) in buffers
1$              move.w  #$FFFF,ROM_STATUS+2(a3,d0.l)
                add.w   #$1000,d0
                cmp.w   #(PBXSIZE*$1000)&$FFFF,d0
                bne     1$

                move.w  #$FFFF,CDPBX(hb)                                ; Clear all buffers
                rts


d488 1
a488 1
                cmp.w   #150,db_CurrentSpeed(db)
d492 1
d494 1
a494 1
                clr.b   d0
d503 2
a507 2
                move.b  #1,db_Reading(db)                               ; We are now attempting to read data

d512 1
a512 1
*
d517 2
a524 4
                move.b  #CHCMD_PAUSE,db_Packet(db)                      ; Pause the drive
                move.b  db_Packet(db),d0                                ; - Ignore response to this command
                jsr     SendPacket

a525 1
                rts
d527 4
@


1.4
log
@all kinds of changes.  kinda works now.
@
text
@a271 2
                and.l   #-1-INTF_PBX,CDINT2ENABLE(hb)                   ; Turn off CD-ROM interrupts (keep overflow int. enabled)

d449 17
d492 1
d518 2
a519 1
                PRINT   1$,"STOPREAD"
d522 2
a523 5
;                jsr     SendPacket
;
;                move.b  db_Packet(db),db_IgnoreResponse(db)             ; Ignore response to this command

                jsr     DoPacket
a524 3
                and.l   #-1-(INTF_PBX|INTF_OVERFLOW),CDINT2ENABLE(hb)   ; Turn off CD-ROM hardware
                and.l   #-1-CF_CDROM,CDCONFIG(hb)

a527 17


*=======================================================================
*=                                                                     =
*=  ClearPrefetch - Free all prefetch buffers so drive can use them    =
*=                                                                     =
*=======================================================================

ClearPrefetch:
                clr.l   d0                                              ; Set Invalid mark (status long) in buffers
1$              move.w  #$FFFF,ROM_STATUS+2(a3,d0.l)
                add.w   #$1000,d0
                cmp.w   #(PBXSIZE*$1000)&$FFFF,d0
                bne     1$

                move.w  #$FFFF,CDPBX(hb)                                ; Clear all buffers
                rts
@


1.3
log
@who knows.
@
text
@d42 1
d51 1
a51 1
*       in:     ARG1 = Start position (byte - word aligned)            *
a69 1
                lsr.l   #1,d1
a70 1
                lsr.w   #1,d0
d72 1
a72 1
                lsl.l   #3,d1
d76 1
a76 1

d78 1
d82 1
a82 1
                move.l  ROM_HEADER(a3,d3.w),d0                          ; Is the requested sector the first in prefetch buffer?
d85 1
a85 1
                jsr     MSFtoLSN
d87 1
a87 3
                bne     ReadNew

                PRINT   1$,"Loading_From_Prefetch"
d89 2
a90 1
                bra     ProcessBlock                                    ; Begin transferring the data
a95 1
                PRINT   0$,"READNEW"
d129 1
d132 8
d141 1
a141 1
                lea     0(a3,d3.w),a0
d149 1
a149 1
                lea     0(a3,d3.w),a0                                   ; Ignore if still bad.
d154 1
a154 1
                move.l  ROM_HEADER(a3,d3.w),d0                          ; Figure out the logical sector number
d157 1
a157 1
                jsr     MSFtoLSN
d165 3
a167 2
                blo     6$                                              ; If we are past where we want to be...
                bsr     AdjustSeek                                      ; ... adjust seek and try READ again
d173 1
a173 1
                blo     7$
d176 1
a176 1
                move.w  d3,d0                                           ; Free the buffer and ignore the sector
d184 1
a184 1
                move.l  ROM_HEADER(a3,d3.w),d0                          ; Store Sector number in data block
d188 1
a188 1
                move.l  d0,ROM_LSNPOS(a3,d3.w)
a189 9
                btst    #SECSTSB_SHORTSECTOR,d0                         ; Should we attempt error correction on this sector?
                bne     TransferData
                and.w   #SECSTSF_C2P0|SECSTSF_EDC1|SECSTSF_EDC2,d0
                beq     TransferData

                swap    d0                                              ; Copy last 16 bits of C2P0 into proper location
                lea     0(a3,d3.w),a0
                move.w  d0,ROM_C2P0+292(a0)

d193 2
a194 4
                bne     TransferData                                    ; If the error was corrected, clear the error bits
                move.l  ROM_STATUS(a3,d3.w),d0
                and.l   #-1-(SECSTSF_C2P0|SECSTSF_EDC1|SECSTSF_EDC2),d0
                move.l  d0,ROM_STATUS(a3,d3.w)
a199 5
                move.l  ROM_STATUS(a3,d3.w),d0                          ; Report an error if this sector is bad
                and.l   #SECSTS_ERROR,d0
                beq     1$
                move.b  #CDERR_BadSecSum,db_ReadError(db)
1$
d204 1
a204 1
                move.w  d3,d0                                           ; ... free the buffer and start on next sector
d213 1
d217 1
a217 1
                bne     ReadNew
d272 1
a272 5
                DISABLE                                                 ; Turn off CD-ROM interrupts (keep overflow int. enabled)
                move.l  CDINT2ENABLE(hb),d0
                bclr    #INTB_PBX,d0
                move.l  d0,CDINT2ENABLE(hb)
                ENABLE
d288 1
a288 1
                lea     ROM_DATA+8(a3,d3.w),a1
d290 1
a290 1
                move.b  ROM_HEADER+3(a3,d3.w),d0                        ; Determine mode of sector
d295 1
a295 1
                lea     ROM_DATA(a3,d3.w),a1
d301 2
a302 2
                move.b  ROM_HEADER+6(a3,d3.w),d0                        ; Get a valid "Submode" byte
                lea     0(a3,d3.w),a0
d308 1
a308 1
                move.b  ROM_HEADER+10(a3,d3.w),d0
d364 2
a365 1
                dbne    d0,4$
d387 5
d394 1
a395 1
                sub.l   #1,db_SeekAdjustment(db)                        ; - One more for good measure
d405 1
a405 1
*=              D0.w = Index into CDROMPage or NULL if no data         =
d410 4
a413 5
                clr.w   d0                                              ; Traverse buffers to find the next sector
1$              move.l  ROM_STATUS(a3,d0.w),d1

                btst    #SECSTSB_INVALID,d1                             ; Is this the next sector?
                beq     2$
d417 1
a417 2

                rts                                                     ; Return index into CDROMPage
d423 1
a423 1
                clr.l   d0                                              ; No new sectors in buffer
d433 1
a433 1
*=              D0.w = CDROMPage buffer index                          =
d438 1
a438 1
                move.w  #$FFFF,ROM_STATUS+2(a3,d0.w)                    ; Set invalid flag of sector
d440 1
a440 4
                swap    d0
                clr.w   d0
                swap    d0
                divu    #$1000,d0
d471 1
a471 1
                move.l  #$80000004,d1                                   ; ROM mode, no Q-Codes
d479 2
a480 9
                move.b  #CHCMD_PLAY,db_Packet(db)                       ; - bug with drive, send PLAY command too
                jsr     DoPacket

                PRINT   2$,"BEGINNING_READ"
                tst.b   d0

                bpl     2$                                              ; Was play successful?

                move.w  #1,d0                                           ; Error
d483 1
a483 1
                clr.b   db_BufferCount(db)                              ; Next expected buffer count
d504 7
a513 5
                move.b  #CHCMD_PAUSE,db_Packet(db)                      ; Pause the drive
                jsr     SendPacket

                move.b  db_Packet(db),db_IgnoreResponse(db)             ; Ignore response to this command

d526 2
a527 4
                PRINT   1$,"CLEAR_PREFETCH"

                clr.w   d0                                              ; Set Invalid mark (status long) in buffers
1$              move.w  #$FFFF,ROM_STATUS+2(a3,d0.w)
a532 2

                clr.l   db_SectorIndex(db)                              ; Clear sector index
@


1.2
log
@Includes now relative, not absolute.
@
text
@d30 2
d41 2
d57 2
a75 4
                move.l  db_TOC+TOCE_Position+TOCEntry_SIZE(db),d0       ; Add in start of first track
                jsr     MSFtoLSN
                add.l   d0,db_ARG1(db)

d89 2
d97 1
d212 2
a213 1
                jsr     FreeSectorBuffer                                ; ... free the buffer and start on next sector
d447 5
a451 4
                clr.l   d0                                              ; Tell the hardware that the buffer is free
                move.w  d3,d0
                divu    #1000,d0
                clr.l   d1
d453 1
a453 1
                move.l  d1,CDPBX(hb)
d469 2
d476 1
a476 1
                jsr     LSNtoMSF
d481 1
a481 1
                move.l  #$80000000,d1                                   ; ROM mode
d487 1
d489 5
a493 1
                jsr     DoPacket                                        ; Send SETPLAY command
d495 1
a495 3
                move.l  d0,a0                                           ; Was play successful?
                tst.b   1(a0)
                bpl     2$
d502 2
a503 8
                DISABLE                                                 ; Turn on CD-ROM hardware
                move.l  CDCONFIG(hb),d0
                bset    #CB_CDROM,d0
                move.l  d0,CDCONFIG(hb)
                move.l  CDINT2ENABLE(hb),d0
                or.l    #INTF_PBX|INTF_OVERFLOW,d0
                move.l  d0,CDINT2ENABLE(hb)
                ENABLE
d519 4
a522 8
                DISABLE                                                 ; Turn off CD-ROM hardware
                move.l  CDINT2ENABLE(hb),d0
                and.l   #$FFFFFFFF-(INTF_PBX|INTF_OVERFLOW),d0
                move.l  d0,CDINT2ENABLE(hb)
                move.l  CDCONFIG(hb),d0
                bclr    #CB_CDROM,d0
                move.l  d0,CDCONFIG(hb)
                ENABLE
d541 2
d549 1
a549 1
                move.l  #PBXMASK,CDPBX(hb)                              ; Clear all buffers
@


1.1
log
@Initial revision
@
text
@d3 13
a15 13
        INCLUDE "include:exec/types.i"
        INCLUDE "include:exec/nodes.i"
        INCLUDE "include:exec/lists.i"
        INCLUDE "include:exec/ports.i"
        INCLUDE "include:exec/memory.i"
        INCLUDE "include:exec/interrupts.i"
        INCLUDE "include:exec/libraries.i"
        INCLUDE "include:exec/tasks.i"
        INCLUDE "include:exec/devices.i"
        INCLUDE "include:exec/execbase.i"
        INCLUDE "include:exec/io.i"
        INCLUDE "include:hardware/intbits.i"
        INCLUDE "include:exec/ables.i"
d57 1
a57 1
                divu    db_Info+CDINFO_Config+CONFIG_SectorSize(db),d1
d64 1
a64 1
                move.w  db_Info+CDINFO_Config+CONFIG_SectorSize(db),d0
d70 4
d328 1
a328 1
                move.w  db_Info+CDINFO_Config+CONFIG_SectorSize(db),d1  ; - Current sector size
d334 1
a334 1
                cmp.w   db_Info+CDINFO_Config+CONFIG_SectorSize(db),d1  ; Are the sector sizes equal?
@
