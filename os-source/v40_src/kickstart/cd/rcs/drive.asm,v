head     1.41;
branch   ;
access   ;
symbols  ;
locks    jerryh:1.41; strict;
comment  @* @;


1.41
date     94.03.24.09.46.49;  author jerryh;  state Exp;
branches ;
next     1.40;

1.40
date     94.03.07.10.02.59;  author jerryh;  state Exp;
branches ;
next     1.39;

1.39
date     94.03.04.09.39.37;  author jerryh;  state Exp;
branches ;
next     1.38;

1.38
date     94.03.04.09.34.26;  author jerryh;  state Exp;
branches ;
next     1.37;

1.37
date     94.02.14.09.50.25;  author jerryh;  state Exp;
branches ;
next     1.36;

1.36
date     93.11.03.17.22.24;  author jerryh;  state Exp;
branches ;
next     1.35;

1.35
date     93.10.11.15.50.22;  author jerryh;  state Exp;
branches ;
next     1.34;

1.34
date     93.09.08.10.42.01;  author jerryh;  state Exp;
branches ;
next     1.33;

1.33
date     93.06.01.13.54.33;  author jerryh;  state Exp;
branches ;
next     1.32;

1.32
date     93.05.19.16.58.12;  author jerryh;  state Exp;
branches ;
next     1.31;

1.31
date     93.04.30.16.52.47;  author jerryh;  state Exp;
branches ;
next     1.30;

1.30
date     93.04.27.15.45.20;  author jerryh;  state Exp;
branches ;
next     1.29;

1.29
date     93.04.16.14.53.05;  author jerryh;  state Exp;
branches ;
next     1.28;

1.28
date     93.04.12.15.49.50;  author jerryh;  state Exp;
branches ;
next     1.27;

1.27
date     93.04.08.10.19.10;  author jerryh;  state Exp;
branches ;
next     1.26;

1.26
date     93.04.02.10.29.55;  author jerryh;  state Exp;
branches ;
next     1.25;

1.25
date     93.03.30.14.36.49;  author jerryh;  state Exp;
branches ;
next     1.24;

1.24
date     93.03.29.13.34.01;  author jerryh;  state Exp;
branches ;
next     1.23;

1.23
date     93.03.26.10.26.43;  author jerryh;  state Exp;
branches ;
next     1.22;

1.22
date     93.02.23.15.53.14;  author jerryh;  state Exp;
branches ;
next     1.21;

1.21
date     93.02.16.15.59.25;  author jerryh;  state Exp;
branches ;
next     1.20;

1.20
date     93.02.15.10.17.10;  author jerryh;  state Exp;
branches ;
next     1.19;

1.19
date     93.02.11.13.51.16;  author jerryh;  state Exp;
branches ;
next     1.18;

1.18
date     93.02.09.15.51.39;  author jerryh;  state Exp;
branches ;
next     1.17;

1.17
date     93.02.08.16.38.38;  author jerryh;  state Exp;
branches ;
next     1.16;

1.16
date     93.02.04.11.06.21;  author jerryh;  state Exp;
branches ;
next     1.15;

1.15
date     93.02.04.10.25.25;  author jerryh;  state Exp;
branches ;
next     1.14;

1.14
date     93.02.03.12.09.41;  author jerryh;  state Exp;
branches ;
next     1.13;

1.13
date     93.02.03.12.01.54;  author jerryh;  state Exp;
branches ;
next     1.12;

1.12
date     93.02.02.17.07.48;  author jerryh;  state Exp;
branches ;
next     1.11;

1.11
date     93.02.02.10.52.56;  author jerryh;  state Exp;
branches ;
next     1.10;

1.10
date     93.01.15.15.41.05;  author jerryh;  state Exp;
branches ;
next     1.9;

1.9
date     93.01.07.09.38.50;  author jerryh;  state Exp;
branches ;
next     1.8;

1.8
date     92.12.12.17.45.18;  author jerryh;  state Exp;
branches ;
next     1.7;

1.7
date     92.12.11.13.35.39;  author jerryh;  state Exp;
branches ;
next     1.6;

1.6
date     92.12.09.15.21.28;  author jerryh;  state Exp;
branches ;
next     1.5;

1.5
date     92.12.07.11.58.41;  author jerryh;  state Exp;
branches ;
next     1.4;

1.4
date     92.12.05.16.53.54;  author jerryh;  state Exp;
branches ;
next     1.3;

1.3
date     92.12.04.10.19.38;  author jerryh;  state Exp;
branches ;
next     1.2;

1.2
date     92.11.23.09.22.39;  author jerryh;  state Exp;
branches ;
next     1.1;

1.1
date     92.11.02.13.32.33;  author jerryh;  state Exp;
branches ;
next     ;


desc
@device driver -> hardware communications module.
@


1.41
log
@Fixed multisession problem introduced by Philips 3.1 firmware bug patch.
@
text
@
        INCLUDE "include:exec/types.i"
        INCLUDE "include:exec/nodes.i"
        INCLUDE "include:exec/lists.i"
        INCLUDE "include:exec/ports.i"
        INCLUDE "include:exec/memory.i"
        INCLUDE "include:exec/interrupts.i"
        INCLUDE "include:exec/libraries.i"
        INCLUDE "include:exec/tasks.i"
        INCLUDE "include:exec/devices.i"
        INCLUDE "include:exec/execbase.i"
        INCLUDE "include:exec/io.i"
        INCLUDE "include:hardware/intbits.i"
        INCLUDE "include:exec/ables.i"

        INCLUDE "defs.i"
        INCLUDE "cd.i"
        INCLUDE "cdprivate.i"
        INCLUDE "cdgs_hw.i"

        OPT     p=68020

************************************************************************
*                                                                      *
*   External References                                                *
*                                                                      *
************************************************************************

        XREF    MSFBINtoBCD
        XREF    MSFBCDtoBIN
        XREF    LSNtoMSFPOS
        XREF    MSFtoLSNPOS
        XREF    LSNtoMSF
        XREF    MSFtoLSN
        XREF    BCDtoBIN
        XREF    BINtoBCD

        XREF    MuteCD
        XREF    LightOn
        XREF    LightOff
        XREF    Attenuate
        XREF    StartTransfer
        XREF    SetSubcodeInterrupt
        XREF    ClearSubcodeInterrupt

        XREF    PutHex
        XREF    PutChar

        XREF    READ
        XREF    ClearPrefetchIfError

        XDEF    READTOC
        XDEF    ID_PACKET

        INT_ABLES

************************************************************************
*                                                                      *
*   DoCmd - emulate microcontroller command.                           *
*                                                                      *
*       out:  D0.w = error                                             *
*                                                                      *
************************************************************************

 FUNCTION DoCmd
                lea     DriveCMD(pc),a0                                 ; Call command routine
                move.w  db_CMD(db),d0
                lsl.l   #2,d0
                move.l  0(a0,d0.w),a1
                jsr     (a1)

                clr.w   db_CMD(db)                                      ; Command complete, report error
                tst.b   IO_ERROR(ior)
                bne     1$
                move.b  d0,IO_ERROR(ior)

1$              clr.w   d0                                              ; Set/Clear error flag
                move.b  IO_ERROR(ior),d0
                rts


DriveCMD:
                dc.l    SPIN
                dc.l    STOP
                dc.l    READTOC
                dc.l    SEEK
                dc.l    PLAY
                dc.l    READ
                dc.l    PAUSE
                dc.l    RESUME
                dc.l    SETPLAYMODE
                dc.l    Q_CODE
                dc.l    ID_PACKET



****************************************************************************
*                                                                          *
*   SPIN - Motor on                                                        *
*                                                                          *
****************************************************************************

SPIN:
                move.w  db_Info+CDINFO_Status(db),d0                        ; Read the table of contents if not read yet
                btst    #CDSTSB_TOC,d0
                beq     READTOC

                move.b  #CHCMD_PAUSE,db_Packet(db)                          ; Start the disk spinning
                jsr     DoPacket
                bmi     99$

                or.w    #CDSTSF_DISK|CDSTSF_SPIN,db_Info+CDINFO_Status(db)  ; Disk is spinning

                clr.w   d0                                                  ; Spin successful
                rts
99$
                move.w  #CDERR_NoDisk,d0                                    ; Could not spin up disk
                rts


****************************************************************************
*                                                                          *
*   STOP - Motor off                                                       *
*                                                                          *
****************************************************************************

STOP:
                move.l  #(CHCMD_STOP<<24)|$010000,db_Packet(db)             ; Stop the disk from spinning
                jsr     DoPacket

                and.w   #-1-CDSTSF_SPIN,db_Info+CDINFO_Status(db)           ; Disk is not spinning

                clr.w   d0                                                  ; Stop successful
                rts



****************************************************************************
*                                                                          *
*   READTOC - Read table of contents                                       *
*                                                                          *
****************************************************************************

READTOC:
                move.l  #SIGF_TOCDONE,d1                                    ; Make sure our signal bits are clear
                clear   d0
                exec    SetSignal

                move.w  db_Info+CDINFO_Status(db),d0                        ; Has the TOC already been read?
                btst    #CDSTSB_TOC,d0
                beq     1$
                clr.w   d0
                rts
1$
                jsr     ReadTOC                                             ; Read TOC information
                bne     99$

                move.w  db_Info+CDINFO_Status(db),d0                        ; Is this a data disk?
                btst    #CDSTSB_CDROM,d0
                beq     98$

                save    d2                                                  ; Is this a multi-session disk?
                tst.l   db_MultiSession(db)
                beq     97$
                move.l  db_RemapStart(db),d0
                beq     97$

                add.l   #16,d0                                              ; Start with sector 16 of this session
                move.l  d0,d2

                jsr     ReadVolDscType                                      ; Is first VDT 1?  If not, not a bridge-disk
                cmp.w   #1,d0
                bne     97$
2$
                add.l   #1,d2                                               ; Search sectors until terminator is found
                move.l  d2,d0
                jsr     ReadVolDscType
                bmi     97$
                cmp.w   #$FF,d0
                bne     2$

                sub.l   db_RemapStart(db),d2                                ; Store first sector NOT to remap
                add.l   #1,d2
                move.l  d2,db_Remap(db)
97$
                restore d2
98$
                clr.w   d0                                                  ; Return status of TOC
99$             rts


*===========================================================================
*=                                                                         =
*=  ReadTOC - Read TOC information, traverse multiple TOCs                 =
*=                                                                         =
*=      in:     D0 = Sector offset of VolDscType to read                   =
*=                                                                         =
*===========================================================================

ReadTOC:
                clr.l   db_TOCNext(db)                                      ; No next pointer (not a multi-session disk) yet
                clr.l   db_MultiSession(db)
                clr.l   db_Remap(db)
                clr.l   db_RemapStart(db)

                lea     db_TOC(db),a0                                       ; Clear out all other entries
                move.w  #TOCEntry_SIZE,d0
1$              move.b  #0,TOCE_Track(a0,d0.w)
                add.w   #TOCEntry_SIZE,d0
                cmp.w   #TOCEntry_SIZE*101,d0
                bne     1$

                move.b  #1,db_TOC+TOCS_FirstTrack(db)                       ; Clear out summary information
                clr.b   db_CDICount(db)
NextSession:
                move.b  db_TOC+TOCS_LastTrack(db),db_MSLastTrackTemp(db)    ; Initialize multi-session variables
                clr.b   db_TOC+TOCS_LastTrack(db)
                move.l  db_TOC+TOCS_LeadOut(db),db_MSLeadOutTemp(db)
                clr.l   db_TOC+TOCS_LeadOut(db)

                jsr     LightOn                                             ; Turn on drive light
                clr.b   db_FlickerLight(db)

                jsr     MuteCD                                              ; Mute CD audio

                move.l  db_TOCNext(db),d0                                   ; If we are not trying to read session 0, try
                move.l  d0,d1                                               ;    playing 30 seconds into the lead-in area.
                beq     1$
                jsr     MSFBCDtoBIN
                jsr     MSFtoLSN
                sub.l   #30*75,d0
                move.l  d0,d1
                add.l   #30*75,d1
1$
                jsr     LSNtoMSF
                jsr     MSFBINtoBCD
                move.l  d0,db_Packet(db)                                    ; Set up play command
                move.l  d1,d0
                jsr     LSNtoMSF
                jsr     MSFBINtoBCD
                lsl.l   #8,d0
                move.l  d0,db_Packet+4(db)
                move.l  #0,db_Packet+8(db)
                move.l  #0,db_Packet+12(db)
                move.b  #CHCMD_SETPLAY,db_Packet(db)                        ; - Play TOC
                move.b  #%00000011,db_Packet+7(db)                          ; - Mute audio
                move.b  #%00000000,db_Packet+10(db)                         ; - Enable Q-Code packets
                move.w  #75,db_CurrentSpeed(db)                             ; - Remember our speed

                move.b  #1,db_ReadingTOC(db)                                ; We are now attempting to read the TOC

                jsr     DoPacket                                            ; Start the read
                bpl     2$

                tst.l   db_MultiSession(db)                                 ; If there is an error, figure out what to do
                bne     DoneReadingTOC
                bra     toc_error
2$
                move.l  db_TOCNext(db),d0                                   ; Make note of position of first track of last session
                jsr     MSFBCDtoBIN
                jsr     MSFtoLSNPOS
                add.l   #150,d0
                move.l  d0,db_RemapStart(db)

                clr.l   db_TOCNext(db)                                      ; Reinitialize next pointer

                move.w  db_Info+CDINFO_Status(db),d0                        ; Read the table of contents if not read yet
                btst    #CDSTSB_SPIN,d0
                bne     5$
3$
                move.b  #CHCMD_PLAY,db_Packet(db)                           ; Start the disk spinning
                jsr     DoPacket
                bpl     4$
                and.b   #$F8,d0                                             ; - CLV error?  Retry
                cmp.b   #CH_ERR_NODISK,d0
                beq     toc_error
                cmp.b   #CH_ERR_DISKUNREADABLE,d0
                beq     toc_error
                bra     3$
4$
                or.w    #CDSTSF_DISK|CDSTSF_SPIN,db_Info+CDINFO_Status(db)  ; Disk is spinning
5$
                move.l  #SIGF_CMDDONE|SIGF_TOCDONE|SIGF_ABORTDRIVE,d0       ; Wait for TOC to finish
                exec    Wait

                btst    #SIGB_TOCDONE,d0                                    ; Was the read of the TOC successful?
                beq     toc_error

                move.l  db_TOCNext(db),d0                                   ; Could there be another session on the disk?
                or.l    d0,db_MultiSession(db)
                tst.l   db_TOCNext(db)
                bne     NextSession
DoneReadingTOC:
                tst.l   db_MultiSession(db)                                 ; Seek back to beginning if multi-session disk
                beq     1$
                clr.l   db_Packet(db)
                clr.l   db_Packet+4(db)
                clr.l   db_Packet+8(db)
                clr.l   db_Packet+12(db)
                move.b  #CHCMD_SETPLAY,db_Packet(db)
                move.b  #%00000011,db_Packet+7(db)
                jsr     DoPacket

                move.b  db_MSLastTrackTemp(db),db_TOC+TOCS_LastTrack(db)    ; Restore destroyed TOC information
                move.l  db_MSLeadOutTemp(db),db_TOC+TOCS_LeadOut(db)
1$
                move.b  #CHCMD_PAUSE,db_Packet(db)                          ; Pause play
                jsr     DoPacket

                clr.b   db_ReadingTOC(db)                                   ; No longer reading TOC

                DISABLE a1
                move.w  db_Info+CDINFO_Status(db),d0                        ; Modify status
                move.b  db_TOC+TOCEntry_SIZE+TOCE_CtlAdr(db),d1             ; - Is this a data disk?
                and.b   #CTLADR_CTLMASK,d1
                cmp.b   #CTL_DATA,d1
                bne     2$
                bset    #CDSTSB_CDROM,d0
2$
                bset    #CDSTSB_TOC,d0                                      ; TOC is now valid
                move.w  d0,db_Info+CDINFO_Status(db)
                ENABLE  a1

                jsr     LightOff                                            ; Turn off drive light

                clr.w   d0                                                  ; ReadTOC successful
                rts
toc_error:
                jsr     LightOff                                            ; Turn off drive light

                clr.b   db_ReadingTOC(db)                                   ; No longer reading TOC

                move.w  #CDERR_NoDisk,d0                                    ; ReadTOC not successful
                rts


*===========================================================================
*=                                                                         =
*=  ReadVolDscType - Read a word of data from a PVD sector                 =
*=                                                                         =
*=      in:     D0 = Sector offset of VolDscType to read                   =
*=                                                                         =
*===========================================================================

ReadVolDscType:
                save    d2/d3                                               ; Calculate offset and reset retry counter
                move.l  d0,d2
                mulu.l  #2048,d2
                move.w  #5,d3
1$
                move.w  #CDCMD_READ,db_CMD(db)                              ; Read data

                lea     db_XferNode(db),a1                                  ; Create transfer entry
                move.l  a1,db_XferEntry(db)
                move.l  d2,db_ARG1(db)                                      ; - Store start block
                lea     db_VolDscType(db),a0
                move.l  a0,db_ARG2(db)                                      ; - Start of XL node
                move.l  a0,CDXL_Buffer(a1)
                move.l  #2,db_ARG3(db)
                move.l  #2,CDXL_Length(a1)
                move.l  #75,db_ARG4(db)                                     ; - Set desired drive speed
                move.l  #2,db_ARG5(db)
                clr.l   CDXL_IntCode(a1)
                clr.l   CDXL_Actual(a1)
                move.b  #1,db_ECC(db)                                       ; - Enable ECC of data
                lea     db_IOR(db),ior
                clr.b   IO_ERROR(ior)
                clr.l   IO_ACTUAL(ior)

                jsr     READ                                                ; Do the read

                bne     99$                                                 ; If no error, return PVD type
                restore d2/d3
                clr.l   d0
                move.b  db_VolDscType(db),d0
                tst.w   d0
                rts
99$
                jsr     ClearPrefetchIfError
                subq.l  #1,d3                                               ; Retry?
                bne     1$

                restore d2/d3
                move.w  #-1,d0                                              ; Error, set negative flag
                rts



************************************************************************
*                                                                      *
*   SEEK - Seek to specified position                                  *
*                                                                      *
*       in:     ARG1 = Seek position                                   *
*                                                                      *
************************************************************************

SEEK:
                move.l  db_ARG1(db),d0                                  ; Set up play command
                jsr     LSNtoMSFPOS
                jsr     MSFBINtoBCD
                move.l  d0,db_Packet(db)
                move.b  #CHCMD_SETPLAY,db_Packet(db)
                move.l  #$FFFFFF8F,db_Packet+4(db)                      ; - Pause and mute after seek (end = end of disk)
                move.l  #$00000400,d1                                   ; - Current speed, no Q-Codes.
                cmp.w   #150,db_CurrentSpeed(db)
                blo     1$
                bset    #30,d1
1$              move.l  d1,db_Packet+8(db)
                jsr     DoPacket

                clr.w   d0                                              ; Seek successful
                rts



************************************************************************
*                                                                      *
*   PLAY - Play audio                                                  *
*                                                                      *
*       in:     ARG1    = Start Position                               *
*               ARG2    = Stop Position                                *
*                                                                      *
************************************************************************

PLAY:
                save    d2

                jsr     MuteCD                                          ; MuteCD for now

                jsr     LightOn                                         ; Turn on drive light

                move.l  db_ARG1(db),d0                                  ; Set up play command (start & end)
                jsr     LSNtoMSFPOS
                jsr     MSFBINtoBCD
                move.l  d0,db_PlayStart(db)
                move.l  d0,d1
                move.l  db_ARG2(db),d0
                sub.l   #1,d0
                jsr     LSNtoMSFPOS
                jsr     MSFBINtoBCD
                move.l  d0,db_PlayStop(db)
                move.l  d0,d2

                move.w  db_Info+CDINFO_Status(db),d0                    ; Swap start/stop addresses if in reverse mode
                btst    #CDSTSB_SEARCH,d0
                beq     1$
                btst    #CDSTSB_DIRECTION,d0
                beq     1$
                exg     d1,d2
1$
                move.l  d2,db_Packet+3(db)
                move.l  d1,db_Packet(db)
                move.l  d1,db_LastQPos(db)
                clr.w   db_LastQState(db)
                move.b  #CHCMD_SETPLAY,db_Packet(db)

                move.l  #$00000004,d1                                   ; Set search mode and speed
                btst    #CDSTSB_SEARCH,d0
                beq     3$
                btst    #CDSTSB_DIRECTION,d0
                bne     2$
                bset    #26,d1
                bra     3$
2$              bset    #27,d1
3$              cmp.w   #150,db_Info+CDINFO_PlaySpeed(db)
                blo     4$
                bset    #22,d1
4$              move.l  d1,db_Packet+7(db)
                move.w  db_Info+CDINFO_PlaySpeed(db),db_CurrentSpeed(db)
                move.b  #0,db_Packet+11(db)

                jsr     DoPacket                                        ; Send SETPLAY command
                bmi     90$

                btst    #1,d0                                           ; Start the disk spinning if stopped
                beq     5$
                move.w  db_Info+CDINFO_Status(db),d0
                btst    #CDSTSB_SPIN,d0
                bne     6$
5$              move.b  #CHCMD_PLAY,db_Packet(db)
                jsr     DoPacket
                bmi     90$
                or.w    #CDSTSF_SPIN,db_Info+CDINFO_Status(db)
6$
                move.w  db_Info+CDINFO_Status(db),d0                    ; If pause mode is set, pause immediately
                btst    #CDSTSB_PAUSED,d0
                beq     7$
                move.b  #CHCMD_PAUSE,db_Packet(db)
                jsr     DoPacket
7$
                move.w  db_Attenuation(db),d0                           ; Set desired attenuation
                jsr     Attenuate

                restore d2                                              ; Play started successfully
                clr.w   d0
                rts
90$
                jsr     LightOff                                        ; Turn off drive light

                restore d2                                              ; Play could not start, probably bad data
                move.w  #CDERR_BadDataType,d0
                rts



*
************************************************************************
*                                                                      *
*   PAUSE - Place drive in pause mode                                  *
*                                                                      *
************************************************************************

PAUSE:
                move.w  db_Info+CDINFO_Status(db),d0                    ; Are we playing audio?
                btst    #CDSTSB_PLAYING,d0
                beq     1$

                jsr     ClearSubcodeInterrupt                           ; Turn off frame interrupts

                move.b  #CHCMD_PAUSE,db_Packet(db)                      ; Pause the audio
                jsr     DoPacket
1$
                or.w    #CDSTSF_PAUSED,db_Info+CDINFO_Status(db)        ; We are now in pause mode

                clr.w   d0                                              ; Pause successful
                rts




************************************************************************
*                                                                      *
*   RESUME - Take drive out of pause mode                              *
*                                                                      *
************************************************************************

RESUME:
                and.w   #-1-CDSTSF_PAUSED,db_Info+CDINFO_Status(db)     ; We are no longer in pause mode

                move.w  db_Info+CDINFO_Status(db),d0                    ; Are we playing audio?
                btst    #CDSTSB_PLAYING,d0
                beq     1$

                move.b  #CHCMD_PLAY,db_Packet(db)                       ; Pause the audio
                jsr     DoPacket

                jsr     SetSubcodeInterrupt                             ; Restart frame interrupts (if necessary)
1$
                clr.w   d0                                              ; Resume successful
                rts




****************************************************************************************
*                                                                                      *
*   SETPLAYMODE - Switch the mode of play                                              *
*                                                                                      *
*       in:     ARG1 = PlayMode                                                        *
*                                                                                      *
****************************************************************************************

SETPLAYMODE:
                move.w  db_Info+CDINFO_Status(db),d0                                    ; Are we currently playing audio?
                btst    #CDSTSB_PLAYING,d0
                beq     6$

                jsr     Q_CODE                                                          ; Get current pos if we are still playing
                bne     6$

                jsr     MuteCD                                                          ; Turn off audio for a bit

                move.l  db_PlayStop(db),d0                                              ; SETPLAY from current pos to end of play
                cmp.l   #CDMODE_FREV,db_ARG1(db)
                bne     1$
                move.l  db_PlayStart(db),d0
1$              move.l  d0,db_Packet+3(db)
                move.l  db_QCode+9(db),d0
                and.l   #$00FFFFFF,d0
                move.l  d0,db_Packet(db)
                move.l  d0,db_LastQPos(db)
                move.b  #CHCMD_SETPLAY,db_Packet(db)

                move.l  #$00000004,d1                                                   ; Set search mode and direction
                move.l  db_ARG1(db),d0
                beq     3$
                cmp.l   #CDMODE_FFWD,d0
                bne     2$
                bset    #26,d1
                bra     3$
2$              bset    #27,d1
3$
                cmp.w   #150,db_Info+CDINFO_PlaySpeed(db)                               ; Set play speed
                blo     4$
                bset    #22,d1
4$              move.l  d1,db_Packet+7(db)
                move.b  #0,db_Packet+11(db)

                jsr     DoPacket                                                        ; Send SETPLAY command

                move.w  db_Info+CDINFO_Status(db),d0                                    ; Pause audio if in paused mode
                btst    #CDSTSB_PAUSED,d0
                beq     5$
                move.b  #CHCMD_PAUSE,db_Packet(db)
                jsr     DoPacket
5$
                move.w  db_Attenuation(db),d0                                           ; Reset desired attenuation
                jsr     Attenuate
6$
                and.w   #-1-(CDSTSF_SEARCH|CDSTSF_DIRECTION),db_Info+CDINFO_Status(db)  ; Enable search mode?
                tst.l   db_ARG1(db)
                beq     7$
                or.w    #CDSTSF_SEARCH,db_Info+CDINFO_Status(db)

                cmp.l   #1,db_ARG1(db)                                                  ; Which direction do we search?
                beq     7$
                or.w    #CDSTSF_DIRECTION,db_Info+CDINFO_Status(db)
7$
                clr.w   d0                                                              ; SetPlayMode successful
                rts



************************************************************************
*                                                                      *
*   QCODE - Retrieve a Q-Code packet                                   *
*                                                                      *
************************************************************************

Q_CODE:
                move.w  db_Info+CDINFO_Status(db),d0                    ; Are we playing audio?
                btst    #CDSTSB_PLAYING,d0
                beq     99$

                move.w  db_Info+CDINFO_Status(db),d0                    ; Have we already reported a packet in pause mode?
                and.w   db_LastQState(db),d0
                btst    #CDSTSB_PAUSED,d0
                bne     1$                                              ; - Then report the same packet again

                move.b  #CHCMD_QCODE,db_Packet(db)                      ; Get me a Q-Code packet
                jsr     DoPacket

                save    d0                                              ; Reissue pause command if paused.
                move.w  db_Info+CDINFO_Status(db),d0
                and.w   #(CDSTSF_PLAYING|CDSTSF_PAUSED),d0
                cmp.w   #(CDSTSF_PLAYING|CDSTSF_PAUSED),d0
                bne     0$
                move.b  #CHCMD_PAUSE,db_Packet(db)
                jsr     DoPacket
0$              restore d0
                tst.b   d0
                bmi     4$
1$
                tst.b   db_QCode+2(db)                                  ; Was the command successful?
                bne     4$

                move.b  db_QCode+3(db),d0                               ; Is this a position packet?
                and.b   #CTLADR_ADRMASK,d0
                cmp.b   #ADR_POSITION,d0
                bne     4$

                move.l  db_QCode+9(db),d1                               ; Get Q-Code absolute position
                and.l   #$00FFFFFF,d1

                move.w  db_Info+CDINFO_Status(db),d0                    ; What direction are we playing?
                and.w   #(CDSTSF_SEARCH|CDSTSF_DIRECTION),d0
                cmp.w   #(CDSTSF_SEARCH|CDSTSF_DIRECTION),d0
                beq     2$

                cmp.l   db_LastQPos(db),d1                              ; Playing forward, are the numbers increasing?
                bhs     3$

                move.l  db_LastQPos(db),d0                              ; Did someone bump the drive?
                sub.l   d1,d0
                cmp.l   #75,d0
                blo     4$

                move.l  d1,db_LastQPos(db)                              ; This is now the last Q position and state
                move.w  db_Info+CDINFO_Status(db),db_LastQState(db)

                clr.b   db_AutoQ(db)                                    ; Turn off QCode interrupts (if they happened to be on)
                jsr     SetSubcodeInterrupt

                move.w  #CDERR_SeekError,d0                             ; Unexpected seek
                rts
2$
                cmp.l   db_LastQPos(db),d1                              ; Playing backwards, are the numbers decreasing?
                bhi     4$
3$
                move.l  d1,db_LastQPos(db)                              ; This is now the last Q position and state
                move.w  db_Info+CDINFO_Status(db),db_LastQState(db)

                clr.b   db_AutoQ(db)                                    ; Turn off QCode interrupts (if they happened to be on)
                jsr     SetSubcodeInterrupt

                clr.w   d0                                              ; Command successful
                rts
4$
                move.l  db_ClassDReq(db),a0
                cmp.b   #CDERR_NoDisk,IO_ERROR(a0)                      ; Was the disk ejected?
                beq     99$

                move.b  #1,db_AutoQ(db)                                 ; Make Q-Code get reissued at next subcode interrupt
                jsr     SetSubcodeInterrupt

                move.l  #SIGF_QCODE|SIGF_ABORTQCODE,d0                  ; Wait to reissue new packet or play to be complete
                or.l    #SIGF_PLAYDONE|SIGF_ABORTDRIVE,d0
                exec    Wait

                btst    #SIGB_PLAYDONE,d0                               ; If the play is complete, reissue playdone signal
                beq     5$
                save    d0
                SIGNAL  SIGF_PLAYDONE
                restore d0
5$
                btst    #SIGB_ABORTDRIVE,d0                             ; If the play was aborted, reissue the abort signal
                beq     6$
                save    d0
                SIGNAL  SIGF_ABORTDRIVE
                restore d0
6$
                btst    #SIGB_ABORTQCODE,d0                             ; Was this command aborted?
                bne     99$
                btst    #SIGB_ABORTDRIVE,d0
                bne     99$

                btst    #SIGB_PLAYDONE,d0                               ; If the play is not complete, reissue Q-Code packet
                beq     Q_CODE
99$
                clr.b   db_AutoQ(db)                                    ; Turn off auto QCode interrupts
                jsr     SetSubcodeInterrupt

                move.w  #CDERR_InvalidState,d0                          ; Audio is not playing
                rts




************************************************************************
*                                                                      *
*   ID_PACKET - Get drive ID packet                                    *
*                                                                      *
************************************************************************

ID_PACKET:
                jsr     LightOff                                        ; Turn off drive light

                clr.w   d0                                              ; Get ID packet
                move.b  #CHCMD_SENDID,db_Packet(db)
                jsr     SendPacket

                save    d2                                              ; Check for timeout
                clr.l   d2
1$              clr.l   d0
                move.l  #SIGF_CMDDONE,d1
                exec    SetSignal
                add.l   #1,d2
                cmp.l   #1000,d2
                bhs     4$
                tst.l   d0
                beq     1$
                SIGNAL  SIGF_CMDDONE                                    ; Echo the signal
                restore d2

                jsr     WaitPacket
                bmi     3$

                save    d0                                              ; Is drive door closed?
                and.b   #$03,d0
                move.b  d0,db_OpenState(db)
                beq     2$
                or.w    #CDSTSF_CLOSED,db_Info+CDINFO_Status(db)
2$              restore d0
3$
                rts
4$
                restore d2
                move.b  #1,db_NoHardware(db)
                rts




************************************************************************


************************************************************************
*                                                                      *
*   SendPacket - Transmit command packet to drive                      *
*                                                                      *
*   in:     D0.w = Ignore response?                                    *
*                                                                      *
************************************************************************

 FUNCTION SendPacket
                tst.b   db_NoHardware(db)                               ; Is drive present?
                beq     0$
                rts
0$
                save    d0                                              ; Save input

                DISABLE a0
    IFD DEBUG
                move.l  #'[',d0
                jsr     PutChar
    ENDC
                move.b  db_Packet(db),d0                                ; Reset response ignoring if new command is last ignored
                and.b   #$0F,d0
                move.b  db_IgnoreResponse(db),d1
                and.b   #$0F,d1
                cmp.b   d0,d1
                bne     2$
                clr.b   db_IgnoreResponse(db)
2$
                save    d2/d3                                           ; Get length of packet
                lea     db_Packet(db),a0
                move.b  (a0),d0
                and.w   #$000f,d0
                lea     PacketLen(pc),a1
                move.b  0(a1,d0.w),d2

                or.b    db_PacketIndex(db),d0                           ; Insert packet index and increment
                move.b  d0,(a0)
3$              add.b   #$10,db_PacketIndex(db)
                beq     3$

                move.l  db_CDCOMTXPage(db),a1                           ; Copy and checksum packet
                clr.w   d3
                move.b  db_ComTXInx(db),d3
                clr.w   d1
                clr.l   d0
                move.b  #-1,d0
4$              move.b  0(a0,d1.w),0(a1,d3.w)
    IFD DEBUG
                save    d0
                clr.w   d0
                move.b  0(a0,d1.w),d0
                jsr     PutHex
                restore d0
    ENDC
                sub.b   0(a0,d1.w),d0
                addq.b  #1,d1
                addq.b  #1,d3
                cmp.b   d1,d2
                bne     4$
    IFD DEBUG
                jsr     PutHex
    ENDC
                move.b  d0,0(a1,d3.w)                                   ; Store checksum
                addq.b  #1,d3
                move.b  d3,db_ComTXInx(db)
                move.b  d3,CDCOMTXCMP(hb)
                restore d2/d3
    IFD DEBUG
                move.l  #']',d0
                jsr     PutChar
                move.l  #10,d0
                jsr     PutChar
    ENDC
                restore d0                                              ; Ignore response to this command?
                tst.w   d0
                beq     5$
                move.b  db_Packet(db),db_IgnoreResponse(db)
5$
                ENABLE  a0

                or.l    #INTF_TXDMADONE,CDINT2ENABLE(hb)                ; Enable transmit DMA interrupt
                rts

PacketLen:      dc.b    1,2,1,1,12,2,1,1,4,1,0,0,0,0,0,0




************************************************************************
*                                                                      *
*   WaitPacket - Wait for response from drive                          *
*                                                                      *
*          out: status =  success                                      *
*               d0.b   =  error                                        *
*                                                                      *
************************************************************************

 FUNCTION WaitPacket
                tst.b   db_NoHardware(db)                               ; Is drive present?
                beq     0$
                move.b  #-1,d0
                rts
0$
                move.l  #SIGF_CMDDONE,d0                                ; Wait for a response
                exec    Wait

                move.l  db_CDCOMRXPage(db),a0                           ; Check for Philips 3.1 bad command error
                clr.w   d0
                move.b  db_PacketAddress(db),d0
                add.b   #1,d0
                move.b  0(a0,d0.w),d0
                and.b   #$F8,d0
                cmp.b   #CH_ERR_BADCOMMAND,d0                           ; - If "bad command" error, do patch
                beq     1$
                tst.b   db_ReadingTOC(db)                               ; - do further tests if not reading TOC
                bne     9$
                cmp.b   #CH_ERR_ABNORMALSEEK,d0
                beq     1$
                cmp.b   #CH_ERR_TRACKJUMP,d0
                bne     9$
1$
                move.b  db_Packet(db),d0                                ; Stop the drive and resend the last command
                and.b   #$0F,d0                                         ; - Do not recurse on STOP command
                cmp.b   #CHCMD_STOP,d0
                beq     9$
                move.l  db_Packet(db),-(sp)
                move.b  #CHCMD_STOP,db_Packet(db)
                move.b  #0,db_Packet+1(db)
                jsr     DoPacket
                move.l  (sp)+,db_Packet(db)
                jsr     DoPacket
9$
                move.l  db_CDCOMRXPage(db),a0                           ; Return status byte in d0
                clr.w   d0
                move.b  db_PacketAddress(db),d0
                add.b   #1,d0
                move.b  0(a0,d0.w),d0
                rts


************************************************************************
*                                                                      *
*   DoPacket - Transmit a packet to drive and wait for it to complete  *
*                                                                      *
************************************************************************

 FUNCTION DoPacket
                clr.w   d0
                jsr     SendPacket                                      ; Send a packet and wait for response
                jsr     WaitPacket
                rts












@


1.40
log
@When new patch is triggered, it will no longer recurse.
SendPacket will now mask out command index to 0.
@
text
@d899 4
a905 2
                beq     1$
                cmp.b   #CH_ERR_BADCOMMAND,d0
@


1.39
log
@*** empty log message ***
@
text
@d906 5
a910 1
                move.l  db_Packet(db),-(sp)                             ; Stop the drive and resend the last command
@


1.38
log
@Added a patch to correct for Philips drive bug in old 3.1 firmware.
@
text
@a22 2
DEBUG SET 1

a905 3
                move.l  db_Packet(db),d0
                jsr     PutHex

a910 4

                move.l  db_Packet(db),d0
                jsr     PutHex

@


1.37
log
@Replaces drive light on and off commands with a jsr to LightOn/OFF.
@
text
@d23 2
a818 1
                clr.w   d0
d820 1
d895 27
@


1.36
log
@Added code for CDI disk detection.
@
text
@d39 2
d221 1
a221 2
                move.w  #$0581,db_Packet(db)                                ; Turn on drive light
                jsr     DoPacket
d224 2
a251 2
                jsr     MuteCD                                              ; Mute CD audio

d324 1
a324 3
                clr.w   d0                                                  ; Turn off drive light
                move.w  #$0500,db_Packet(db)
                jsr     SendPacket
d329 1
a329 3
                clr.w   d0                                                  ; Turn off drive light
                move.w  #$0500,db_Packet(db)
                jsr     SendPacket
d430 1
a430 2
                move.w  #$0581,db_Packet(db)                            ; Turn on drive light
                jsr     DoPacket
d498 1
a498 3
                clr.w   d0                                              ; Turn off drive light
                move.w  #$0500,db_Packet(db)
                jsr     SendPacket
d746 1
a746 3
                clr.w   d0                                              ; Turn off drive light
                move.w  #$0500,db_Packet(db)
                jsr     SendPacket
@


1.35
log
@Checks for multi-session disks on data disks only.
@
text
@d156 1
a156 1
                move.w  db_Info+CDINFO_Status(db),d0                        ; Has the TOC already been read?
d212 1
@


1.34
log
@Wait for a response packet for drive light before doing a setplay.
@
text
@d156 4
d162 1
a162 1
                beq     98$
d164 1
a164 1
                beq     98$
d171 1
a171 1
                bne     98$
d176 1
a176 1
                bmi     98$
d183 2
a185 1
                restore d2
@


1.33
log
@Added pause command after Q-Code command to eliminate out-of-spec
Q-Code packet length on door-open.
@
text
@d213 2
a214 3
                clr.w   d0                                                  ; Turn on drive light
                move.w  #$0501,db_Packet(db)
                jsr     SendPacket
d427 2
a428 3
                clr.w   d0                                              ; Turn on drive light
                move.w  #$0501,db_Packet(db)
                jsr     SendPacket
@


1.32
log
@Turns off drive light when cd.device is initialized.
@
text
@d644 10
@


1.31
log
@No effective change.
@
text
@d738 4
@


1.30
log
@CD_SEARCH command no longer screws up attenuator if not playing.
@
text
@a1 1

d540 2
a550 2
                and.w   #-1-CDSTSF_PAUSED,db_Info+CDINFO_Status(db)     ; We are no longer in pause mode

@


1.29
log
@ReadVolDsc type does not clear MLN_SUCC of xlnode now.
@
text
@d569 1
a569 1
                beq     5$
d572 1
a572 1
                bne     5$
d612 1
a612 1

d615 1
a615 1
                beq     6$
d619 1
a619 1
                beq     6$
d621 1
a621 1
6$
@


1.28
log
@Wait on abort signal removed from WaitPacket().
@
text
@a363 1
                move.l  #0,MLN_SUCC(a1)
@


1.27
log
@Fixed CDI multi-session support (now that error correction works).
@
text
@a1 1
;DEBUG   set 1
d475 1
a475 1
                bmi     99$
d484 1
a484 1
                bmi     99$
d499 1
a499 1
99$
d882 1
a882 1
                move.l  #SIGF_CMDDONE|SIGF_ABORTDRIVE,d0                ; Wait for a response
a884 7
                btst    #SIGB_ABORTDRIVE,d0                             ; Reissue abort signal to make sure all commands abort
                beq     1$
                move.b  db_Packet(db),db_IgnoreResponse(db)
                SIGNAL  SIGF_ABORTDRIVE
                move.b  #-1,d0
                rts
1$
@


1.26
log
@*** empty log message ***
@
text
@d50 1
d346 5
d355 1
a355 2
                mulu.l  #2048,d0
                move.l  d0,db_ARG1(db)                                      ; - Store start block
d359 1
a360 1
                move.l  #2,db_ARG3(db)
d362 1
d374 1
d380 5
d480 1
a480 1
                move.w  db_Info+CDINFO_Status(db),d0                    ; Start the disk spinning if stopped
@


1.25
log
@Put in retry for gold disk spin-backward problem when reading
the table of contents.
@
text
@d511 2
a517 2
                jsr     ClearSubcodeInterrupt                           ; Turn off frame interrupts

d537 2
a540 2

                jsr     SetSubcodeInterrupt                             ; Restart frame interrupts (if necessary)
@


1.24
log
@Q-Code packets will now return an error of the drive
is bumped causing the Q-Code packets to go out of sequence.
@
text
@d208 1
a208 1
2$
d221 1
a221 1
                beq     3$
d227 1
a227 1
3$
d248 1
a248 1
                bpl     4$
d251 1
a251 1
                bne     6$
d253 1
a253 1
4$
d265 1
a265 1

d268 8
a275 2
                bmi     toc_error

d287 2
a288 2
                bne     2$
6$
d290 1
a290 1
                beq     7$
d301 1
a301 1
7$
d312 1
a312 1
                bne     8$
d314 1
a314 1
8$
@


1.23
log
@Recoded to potentially handle CHECKSUM errors better.
@
text
@d19 1
a20 1
        INCLUDE "cd.i"
d648 5
d654 9
a662 1
                bra     3$
d664 1
a664 1
                cmp.l   db_LastQPos(db),d1
@


1.22
log
@does not attempt to talk to drive if now HW is present.
@
text
@d374 1
a374 1
*   SEEK - Seek to specified position (but return immediately)         *
d392 1
a392 3

                move.w  #1,d0                                           ; Don't wait for completion
                jsr     SendPacket
d769 5
a773 6
                lea     db_Packet(db),a0                                ; If this is a play command, reset response ignoring
                clr.w   d0
                move.b  (a0),d0
                cmp.b   #CHCMD_SETPLAY,d0
                beq     1$
                cmp.b   #CHCMD_PLAY,d0
d775 1
a775 1
1$              move.b  #0,db_IgnoreResponse(db)
d778 3
@


1.21
log
@Cleared TOC signal at more appropriate time.
@
text
@d2 1
a213 5
                move.b  #10,d0
                jsr     PutChar
                move.b  #10,d0
                jsr     PutChar

d462 2
d466 2
a467 2
                bne     5$
                move.b  #CHCMD_PLAY,db_Packet(db)
d471 1
a471 1
5$
d474 1
a474 1
                beq     6$
d477 1
a477 1
6$
d712 19
a730 3
                move.b  #CHCMD_SENDID,db_Packet(db)                     ; Get ID packet
                jsr     DoPacket
                bmi     2$
d735 1
a735 1
                beq     1$
d737 6
a742 2
1$              restore d0
2$
a747 1

d760 4
d767 4
a770 4

;                move.l  #'[',d0
;                jsr     PutChar

d796 7
a802 7

;                save    d0
;                clr.w   d0
;                move.b  0(a0,d1.w),d0
;                jsr     PutHex
;                restore d0

d808 3
a810 3

;                jsr     PutHex

d816 6
a821 6

;                move.l  #']',d0
;                jsr     PutChar
;                move.l  #10,d0
;                jsr     PutChar

d847 5
@


1.20
log
@ReadTOC now seems to not attempt to read TOC twice.
@
text
@d143 4
a315 4

                move.l  #SIGF_TOCDONE,d1                                    ; Clear TOCDONE signal that may have been duplicated
                clear   d0
                exec    SetSignal
@


1.19
log
@no effective change.
@
text
@d143 6
d164 1
a164 1
1$
d170 1
a170 1
                bne     1$
d211 2
a244 3
                move.b  #'1',d0
                jsr     PutChar

a300 3
                move.b  #'0',d0
                jsr     PutChar

a329 3
                move.b  #'0',d0
                jsr     PutChar

d720 1
@


1.18
log
@frame interrupts not generated when cd is paused.
@
text
@d237 3
d296 3
d327 3
@


1.17
log
@make disk commands unstop automatically.
@
text
@d43 1
d506 2
d529 2
@


1.16
log
@relocating sectors now.  Multi-session now working!
No effective change to this file.
@
text
@d103 2
a104 3
                bne     1$
                jsr     READTOC
1$
d379 1
a379 1
                move.l  d0,db_Packet(db)                
d382 1
a382 1
                move.l  #$00000000,d1                                   ; - Current speed, no Q-Codes.
d457 8
d467 1
a467 1
                beq     5$
d470 1
a470 1
5$
d806 3
d817 1
a817 1
                save    d0
a818 1
                restore d0
a826 1

@


1.15
log
@TOC command now determines which sectors should be remapped.
@
text
@a168 4
                move.l  d2,d0
                jsr     PutHex
                move.l  db_RemapStart(db),d0
                jsr     PutHex
d173 9
@


1.14
log
@internal.i is now cdprivate.i
@
text
@d143 36
d181 2
d193 1
a193 1
                move.b  db_TOC+TOCS_LastTrack(db),db_MSLastTrackTemp(db)
a228 1
                clr.l   db_TOCNext(db)                                      ; - Reinitialize next pointer
d241 8
d319 42
@


1.13
log
@Ok.... We can now read the TOC of multi-session disks.  Still need to do
CD-ROM code though.
@
text
@d18 1
a18 1
        INCLUDE "internal.i"
@


1.12
log
@Adding light flickering and multisession support.
@
text
@d143 20
a167 17
                clr.l   db_TOCNext(db)                                      ; No next pointer yet (not multi-session)
1$
                move.b  #10,d0
                jsr     PutChar

                lea     db_TOC(db),a0

                clr.b   db_TOC+TOCS_FirstTrack(db)                          ; Clear out summary information
                clr.b   db_TOC+TOCS_LastTrack(db)

                move.w  #TOCEntry_SIZE,d0                                   ; Clear out all other entries
                lea     db_TOC(db),a0
2$              move.b  #0,TOCE_Track(a0,d0.w)
                add.w   #TOCEntry_SIZE,d0
                cmp.w   #TOCEntry_SIZE*101,d0
                bne     2$

d173 1
a173 1
;                add.l   #30*75,d0
a178 1
                jsr     PutHex
a182 1
                jsr     PutHex
d198 1
a198 1
                bmi     toc_error
d200 4
d206 1
a206 1
                bne     4$
d213 2
a214 2
4$
                move.l  #SIGF_PLAYDONE|SIGF_TOCDONE|SIGF_ABORTDRIVE,d0      ; Wait for TOC to finish
d220 14
a233 2
                tst.l   db_TOCNext(db)                                      ; Could there be another session on the disk?
                bne     1$
d235 3
d248 1
a248 1
                bne     5$
d250 1
a250 1
5$
@


1.11
log
@multi-session support is now attempted (does not work yet).
@
text
@d143 5
d166 2
a167 1
                beq     3$                                                  ;    playing 30 seconds into the lead-in area.
d170 4
a173 1
                add.l   #30*75,d0
d176 1
a176 1
3$
d178 6
a183 1
                move.l  #$FFFFFF00,db_Packet+4(db)
d239 4
d246 4
d299 2
a300 1
                move.w  #$0501,db_Packet(db)                            ; Turn on drive light
d359 2
a360 1
                move.w  #$0500,db_Packet(db)                            ; Turn off drive light
@


1.10
log
@Stuff for drive light added.
@
text
@d40 1
d143 5
d155 1
a155 1
1$              move.b  #0,TOCE_Track(a0,d0.w)
d158 1
a158 1
                bne     1$
d160 10
a169 2
                move.l  #0,db_Packet(db)                                    ; Set up play command
                move.l  #0,db_Packet+4(db)
d176 1
d182 1
a182 1
                jsr     DoPacket
d187 1
a187 1
                bne     2$
d194 1
a194 1
2$
d201 3
d214 1
a214 1
                bne     3$
d216 1
a216 1
3$
d275 2
d305 3
a307 6
                move.l  #$00000004,d1                                   ; Set pause mode, search mode, and speed
                btst    #CDSTSB_PAUSED,d0
                beq     2$
                or.l    #$0C000000,d1
2$              btst    #CDSTSB_SEARCH,d0
                beq     4$
d309 1
a309 1
                bne     3$
d311 4
a314 4
                bra     4$
3$              bset    #27,d1
4$              cmp.w   #150,db_Info+CDINFO_PlaySpeed(db)
                blo     5$
d316 1
a316 2
5$
                move.l  d1,db_Packet+7(db)
d323 11
a333 2
                restore d2
                clr.w   d0                                              ; Play started successfully
d336 5
a340 2
                restore d2
                move.w  #CDERR_BadDataType,d0                           ; Play could not start, probably bad data
d401 1
a401 1
                beq     6$
d404 3
a406 1
                bne     6$
a416 1
                clr.w   db_LastQState(db)
d419 3
a421 8
                move.l  #$00000004,d1                                                   ; Set pause mode
                move.w  db_Info+CDINFO_Status(db),d0
                btst    #CDSTSB_PAUSED,d0
                beq     2$
                or.l    #$0C000000,d1
2$
                move.l  db_ARG1(db),d0                                                  ; Set search mode and direction
                beq     4$
d423 1
a423 1
                bne     3$
d425 3
a427 3
                bra     4$
3$              bset    #27,d1
4$
d429 1
a429 1
                blo     5$
d431 1
a431 1
5$              move.l  d1,db_Packet+7(db)
d435 10
a444 1
6$
d447 1
a447 1
                beq     7$
d451 1
a451 1
                beq     7$
d453 1
a453 1
7$
d588 1
a588 1
                DISABLE
d649 1
a649 1
                ENABLE
@


1.9
log
@Play commands should work now.  Search command should work too.
@
text
@d255 6
a260 2
                save    d2                                              ; Set up play command (start & end)
                move.l  db_ARG1(db),d0
d553 1
d555 1
a555 1
                save    d0                                              ; Save input
d610 1
a610 1
;
d616 2
a618 1

d621 1
a621 1
PacketLen:      dc.b    1,2,1,1,12,1,1,1,4,1,0,0,0,0,0,0
@


1.8
log
@Modified Q-Code and SETPLAY commands.
@
text
@d39 1
a68 2
                tst.w   d0
                beq     2$
d73 3
a75 2
1$              tst.w   d0                                              ; Set/Clear error flag
2$              rts
a86 1
                dc.l    STOPPLAY
d165 2
d180 1
a180 1
                move.l  #SIGF_PLAYDONE|SIGF_TOCDONE,d0                      ; Wait for TOC to finish
d210 2
d255 7
a261 1
                move.l  db_ARG2(db),d0                                  ; Set up play command (start & end)
d266 13
a278 6
                move.l  d0,db_Packet+3(db)
                move.l  db_ARG1(db),d0
                jsr     LSNtoMSFPOS
                jsr     MSFBINtoBCD
                move.l  d0,db_PlayStart(db)
                move.l  d0,db_Packet(db)
a281 1
                move.w  db_Info+CDINFO_Status(db),d0
d283 1
a283 1
                beq     1$
d285 2
a286 2
1$              btst    #CDSTSB_SEARCH,d0
                beq     3$
d288 1
a288 1
                bne     2$
d290 4
a293 4
                bra     3$
2$              bset    #27,d1
3$              cmp.w   #150,db_Info+CDINFO_PlaySpeed(db)
                blo     4$
d295 2
a296 1
4$              move.l  d1,db_Packet+7(db)
d303 1
d307 1
d358 7
a364 28
************************************************************************
*                                                                      *
*   STOPPLAY - terminate a play command if one is outstanding          *
*                                                                      *
************************************************************************

STOPPLAY:
                move.w  db_Info+CDINFO_Status(db),d0                    ; Are we playing audio?
                btst    #CDSTSB_PLAYING,d0
                beq     1$

                move.b  #CHCMD_PAUSE,db_Packet(db)                      ; Stop playing audio
                jsr     DoPacket

                SIGNAL  SIGF_PLAYDONE                                   ; Play is complete
1$
                clr.w   d0                                              ; StopPlay successful
                rts



************************************************************************
*                                                                      *
*   SETPLAYMODE - Switch the mode of play                              *
*                                                                      *
*       in:     ARG1 = PlayMode                                        *
*                                                                      *
************************************************************************
d367 1
a367 12
                move.w  db_Info+CDINFO_Status(db),d0                    ; Enable search mode?

                and.w   #-1-CDSTSF_SEARCH,db_Info+CDINFO_Status(db)
                tst.l   IO_LENGTH(ior)
                beq     1$
                or.w    #CDSTSF_SEARCH,db_Info+CDINFO_Status(db)

                cmp.l   #1,IO_LENGTH(ior)                               ; Which direction do we search?
                beq     1$
                or.w    #CDSTSF_DIRECTION,db_Info+CDINFO_Status(db)
1$
                move.w  db_Info+CDINFO_Status(db),d0                    ; Are we currently playing audio?
d369 1
a369 1
                beq     7$
d371 2
a372 2
                jsr     Q_CODE                                          ; Get current position if we are still playing
                bne     7$
d374 1
a374 1
                move.l  db_PlayStop(db),d0                              ; SETPLAY from current position to limit of play
d376 1
a376 1
                bne     2$
d378 1
a378 1
2$              move.l  d0,db_Packet+3(db)
a380 1
                jsr     MSFBINtoBCD
d382 2
d386 1
a386 1
                move.l  #$00000000,d1                                   ; Set pause mode, search mode, and speed
d389 1
a389 1
                beq     3$
d391 5
a395 4
3$              btst    #CDSTSB_SEARCH,d0
                beq     5$
                btst    #CDSTSB_DIRECTION,d0
                bne     4$
d397 5
a401 4
                bra     5$
4$              bset    #27,d1
5$              cmp.w   #150,db_Info+CDINFO_PlaySpeed(db)
                blo     6$
d403 1
a403 1
6$              move.l  d1,db_Packet+7(db)
d406 10
a415 1
                jsr     DoPacket                                        ; Send SETPLAY command
d417 1
a417 1
                clr.w   d0                                              ; SetPlayMode successful
d433 5
d440 2
a441 2
                bmi     1$

d443 1
a443 1
                bne     1$
d448 19
a466 1
                bne     1$
d473 4
a476 2
1$
                PRINT   1$,"BAD_PACKET"
d481 2
a482 1
                move.l  #SIGF_QCODE|SIGF_PLAYDONE|SIGF_ABORTQCODE,d0    ; Wait to reissue new packet or play to be complete
d485 2
a486 2
                btst    #SIGB_PLAYDONE,d0                               ; If the play is complete, reissue play
                beq     2$
d490 7
a496 1
2$
d499 2
d503 1
a503 4
                bne     99$

                PRINT   2$,"AutoQ"
                bra     Q_CODE
d605 1
a605 1

d626 2
a627 2
WaitPacket:
                move.l  #SIGF_CMDRESPONSE,d0                            ; Wait for a response
d630 8
a643 12
                rts


************************************************************************
*                                                                      *
*   WaitPlayPacket - Wait for response to play command from drive      *
*                                                                      *
************************************************************************

WaitPlayPacket:
                move.l  #SIGF_PLAYDONE,d0                               ; Wait for play to complete
                exec    Wait
@


1.7
log
@Added ID packet command.
@
text
@d50 2
a100 2
                PRINT   1$,"SPIN"

a125 2
                PRINT   1$,"STOP"

a142 3

                PRINT   1$,"READTOC"

a144 3
                move.l  a0,d0
                jsr     PutHex
                
a165 2
;                PRINT   2$,"SETPLAY"

d167 1
a167 1
                bmi     99$
a172 2
;                PRINT   7$,"SPIN"

d175 1
a175 1
                bmi     99$
d183 1
a183 3
                beq     99$

;                PRINT   4$,"PAUSING"
a187 2
                PRINT   5$,"PAUSED"

d190 1
d200 1
d208 1
a208 1
99$
a238 3
99$
                move.w  #CDERR_NoDisk,d0                                ; Could not spin up disk
                rts
a251 2
                PRINT   1$,"PLAY"

a268 2

                PRINT   2$,"PLAY_IN_PAUSE_MODE"
a286 2
                or.w    #CDSTSF_PLAYING,db_Info+CDINFO_Status(db)       ; Play is in progress

d290 1
a290 1
                move.w  #CDERR_NoDisk,d0                                ; Could not spin up disk
d332 1
a332 1
                and.w   #-1-CDSTSF_PAUSED,CDINFO_Status(db)             ; We are no longer in pause mode
d371 2
a372 2
                bclr    #CDSTSB_SEARCH,d0
                bclr    #CDSTSB_DIRECTION,d0
d375 1
a375 1
                bset    #CDSTSB_SEARCH,d0
d379 1
a379 1
                bset    #CDSTSB_DIRECTION,d0
d381 2
a382 3
                move.w  d0,db_Info+CDINFO_Status(db)                    ; New status

                btst    #CDSTSB_PLAYING,d0                              ; Are we currently playing audio?
d439 1
a439 1
                tst.b   2(a0)                                           ; Was the command successful?
d442 1
a442 1
                move.b  3(a0),d0                                        ; Is this a position packet?
d447 2
a448 5
                lea     db_QCode(db),a1                                 ; Copy result to Q-Code packet
                move.l  (a0),(a1)
                move.l  4(a0),4(a1)
                move.l  8(a0),8(a1)
                move.l  12(a0),12(a1)
d453 2
d468 1
a468 1
                bne     98$
d471 5
a475 2
                beq     Q_CODE
98$
d478 1
a478 1
99$
@


1.6
log
@Added much printing.  Fixed some drive communications things.
@
text
@d22 2
d48 1
d88 1
d92 5
a96 5
************************************************************************
*                                                                      *
*   SPIN - Motor on                                                    *
*                                                                      *
************************************************************************
d101 1
a101 1
                move.w  db_Info+CDINFO_Status(db),d0                    ; Read the table of contents if not read yet
d106 1
a106 1
                move.b  #CHCMD_PAUSE,db_Packet(db)                      ; Start the disk spinning
d110 1
a110 4
                move.w  db_Info+CDINFO_Status(db),d0                    ; Disk is spinning
                bset    #CDSTSB_DISK,d0
                bset    #CDSTSB_SPIN,d0
                move.w  d0,db_Info+CDINFO_Status(db)
d112 1
a112 1
                clr.w   d0                                              ; Spin successful
d115 1
a115 1
                move.w  #CDERR_NoDisk,d0                                ; Could not spin up disk
d119 5
a123 5
************************************************************************
*                                                                      *
*   STOP - Motor off                                                   *
*                                                                      *
************************************************************************
d128 1
a128 1
                move.l  #(CHCMD_STOP<<24)|$010000,db_Packet(db)         ; Stop the disk from spinning
d131 1
a131 8
                move.w  db_Info+CDINFO_Status(db),d0                    ; Disk is not spinning
                bclr    #CDSTSB_SPIN,d0
                move.w  d0,db_Info+CDINFO_Status(db)

                clr.w   d0                                              ; Stop successful
                rts


d133 10
a142 5
************************************************************************
*                                                                      *
*   READTOC - Read table of contents                                   *
*                                                                      *
************************************************************************
d153 1
a153 1
                clr.b   db_TOC+TOCS_FirstTrack(db)                      ; Clear out summary information
d156 1
a156 1
                move.w  #TOCEntry_SIZE,d0                               ; Clear out all other entries
d163 1
a163 1
                move.l  #0,db_Packet(db)                                ; Set up play command
d167 4
a170 4
                move.b  #CHCMD_SETPLAY,db_Packet(db)                    ; - Play TOC
                move.b  #%00000011,db_Packet+7(db)                      ; - Mute audio
                move.b  #%00000000,db_Packet+10(db)                     ; - Enable Q-Code packets
                move.w  #75,db_CurrentSpeed(db)                         ; - Remember our speed
d172 1
a172 1
                move.b  #1,db_ReadingTOC(db)                            ; We are now attempting to read the TOC
d179 1
a179 1
                move.w  db_Info+CDINFO_Status(db),d0                    ; Read the table of contents if not read yet
d185 1
a185 1
                move.b  #CHCMD_PLAY,db_Packet(db)                       ; Start the disk spinning
d189 1
a189 4
                move.w  db_Info+CDINFO_Status(db),d0                    ; Disk is spinning
                bset    #CDSTSB_SPIN,d0
                bset    #CDSTSB_DISK,d0
                move.w  d0,db_Info+CDINFO_Status(db)
d191 1
a191 1
                move.l  #SIGF_PLAYDONE|SIGF_TOCDONE,d0                  ; Wait for TOC to finish
d194 1
a194 1
                btst    #SIGB_TOCDONE,d0                                ; Was the read of the TOC successful?
d199 1
a199 1
                move.b  #CHCMD_PAUSE,db_Packet(db)                      ; Pause play
d204 1
a204 1
                clr.b   db_ReadingTOC(db)                               ; No longer reading TOC
d206 2
a207 2
                move.w  db_Info+CDINFO_Status(db),d0                    ; Modify status
                move.b  db_TOC+TOCE_CtlAdr(db),d1                       ; - Is this a data disk?
d210 1
a210 1
                beq     3$
d213 1
a213 1
                bset    #CDSTSB_TOC,d0                                  ; TOC is now valid
d216 1
a216 1
                move.l  #SIGF_TOCDONE,d1                                ; Clear TOCDONE signal that may have been duplicated
d220 1
a220 1
                clr.w   d0                                              ; ReadTOC successful
d223 1
a223 1
                move.w  #CDERR_NoDisk,d0                                ; ReadTOC not successful
a250 4
                move.w  db_Info+CDINFO_Status(db),d0                    ; Disk is spinning
                bset    #CDSTSB_SPIN,d0
                move.w  d0,db_Info+CDINFO_Status(db)
2$
d308 1
a308 3
                move.w  db_Info+CDINFO_Status(db),d0                    ; Play is in progress
                bset    #CDSTSB_PLAYING,d0
                move.w  d0,db_Info+CDINFO_Status(db)
d333 1
a333 3
                move.w  db_Info+CDINFO_Status(db),d0                    ; We are now in pause mode
                bset    #CDSTSB_PAUSED,d0
                move.w  d0,db_Info+CDINFO_Status(db)
d355 1
a355 3
                move.w  db_Info+CDINFO_Status(db),d0                    ; We are no longer in pause mode
                bclr    #CDSTSB_PAUSED,d0
                move.w  d0,db_Info+CDINFO_Status(db)
d406 1
a406 2
                move.w  db_Info+CDINFO_Status(db),d0                    ; Are we currently playing audio?
                btst    #CDSTSB_PLAYING,d0
d507 22
d545 2
a546 2
                move.l  #'[',d0
                jsr     PutChar
d563 2
a564 1
                add.b   #$10,db_PacketIndex(db)
d572 1
a572 1
3$              move.b  0(a0,d1.w),0(a1,d3.w)
d574 5
a578 5
                save    d0
                clr.w   d0
                move.b  0(a0,d1.w),d0
                jsr     PutHex
                restore d0
d584 1
a584 1
                bne     3$
d586 1
a586 1
                jsr     PutHex
d594 4
a597 4
                move.l  #']',d0
                jsr     PutChar
                move.l  #10,d0
                jsr     PutChar
d601 1
a601 1
                beq     4$
d603 1
a603 1
4$
@


1.5
log
@modified response ignoring.
@
text
@a102 1
                clr.b   d0
a127 1
                clr.b   d0
d173 3
a175 1
                PRINT   2$,"SETPLAY"
a176 1
                clr.b   d0
a179 2
                PRINT   3$,"DONESETPLAY"

d184 1
a184 1
                PRINT   7$,"SPIN"
a186 1
                clr.b   d0
a189 2
                PRINT   6$,"DONESPIN"

a194 2
                move.b  #1,db_ReadingTOC(db)                            ; We are now attempting to read the TOC

d201 1
a201 1
                PRINT   4$,"PAUSING"
a203 1
                clr.b   d0
d252 1
a252 9
                clr.b   d0                                              ; Don't wait for completion
                jsr     SendPacket

                move.w  db_Info+CDINFO_Status(db),d0                    ; If the disk is not spinning, make it go
                btst    #CDSTSB_SPIN,d0
                bne     2$
                jsr     WaitPacket
                move.b  #CHCMD_PLAY,db_Packet(db)
                move.b  db_Packet(db),d0                                ; - Ignore response to this command
a254 4
                move.l  d0,a0                                           ; Was spin successful?
                tst.b   1(a0)
                bmi     99$

d310 1
d313 1
a313 2
                clr.b   d0                                              ; Send SETPLAY command
                jsr     DoPacket
a315 12
;                move.w  db_Info+CDINFO_Status(db),d0                    ; If the disk is not spinning, make it go
;                btst    #CDSTSB_SPIN,d0
;                bne     5$
;                move.b  #CHCMD_PLAY,db_Packet(db)
;                clr.b   d0
;                jsr     DoPacket
;                bmi     99$
;
;                move.w  db_Info+CDINFO_Status(db),d0                    ; Disk is spinning
;                bset    #CDSTSB_SPIN,d0
;                move.w  d0,db_Info+CDINFO_Status(db)
;5$
a340 1
                clr.b   d0
a364 1
                clr.b   d0
a388 1
                clr.b   d0
d456 1
a456 2
                clr.b   d0                                              ; Send SETPLAY command
                jsr     DoPacket
a474 1
                clr.b   d0
d530 1
a530 1
*   in:     D0.b = Ignore response? (d0.b = cmd if yes)                *
d538 1
a538 1
                move.b  #'[',d0
d586 4
a589 1
                PRINT   2$,"]"
d591 6
a596 2
                restore d0                                              ; Ignore response to this command
                move.b  d0,db_IgnoreResponse(db)
a597 2
                bset.b  #(INTB_TXDMADONE-24),CDINT2ENABLE(hb)           ; Enable transmit DMA interrupt

d618 2
a619 1
                move.b  1(a0,d0.w),d0
d643 1
@


1.4
log
@modified printing of command packets.
@
text
@d103 1
d129 1
a129 1

d177 1
d190 1
d212 1
d261 2
a262 1
                jsr     SendPacket                                      ; Don't wait for completion
d269 1
a271 2
                move.b  db_Packet(db),db_IgnoreResponse(db)             ; Ignore response to this command
                
d333 2
a334 1
                jsr     DoPacket                                        ; Send SETPLAY command
d341 1
d374 1
d399 1
d424 1
d492 2
a493 1
                jsr     DoPacket                                        ; Send SETPLAY command
d512 1
d568 2
d574 2
d625 3
@


1.3
log
@who knows.
@
text
@d41 1
d560 4
d609 1
a609 1
                PRINT   1$,"SendingPacket"
@


1.2
log
@Access to CONFIG_ data is now different.
@
text
@d30 2
d40 2
d44 1
d94 7
a102 3

                move.l  d0,a0                                           ; Was spin successful?
                tst.b   1(a0)
d106 1
a109 5
                move.w  db_Info+CDINFO_Status(db),d0                    ; Read the table of contents if not read yet
                btst    #CDSTSB_TOC,d0
                bne     1$
                jsr     READTOC
1$
d124 4
a127 1
                move.w  #(CHCMD_STOP<<8)|$01,db_Packet(db)              ; Stop the disk from spinning
d146 7
d158 1
a158 1
                lea     db_TOC,a0
d170 1
a170 1
                move.b  #%00000100,db_Packet+10(db)                     ; - Enable Q-Code packets
d172 15
d188 10
d205 2
d210 4
d218 1
a218 1
                beq     2$
d220 1
a220 1
2$
d245 1
a245 1
                jsr     LSNtoMSF
d288 1
a288 1
*               ARG2    = Length                                       *
d293 3
a295 2
                move.l  db_ARG2(db),d0                                  ; Set up play command (start - end)
                add.l   db_ARG1(db),d0
d297 1
a297 1
                jsr     LSNtoMSF
d302 1
a302 1
                jsr     LSNtoMSF
d308 1
a308 1
                move.l  #$00000000,d1                                   ; Set pause mode, search mode, and speed
d312 2
a328 13

                move.l  d0,a0                                           ; Was play successful?
                tst.b   1(a0)
                bmi     99$

                move.w  db_Info+CDINFO_Status(db),d0                    ; If the disk is not spinning, make it go
                btst    #CDSTSB_SPIN,d0
                bne     5$
                move.b  #CHCMD_PLAY,db_Packet(db)
                jsr     DoPacket

                move.l  d0,a0                                           ; Was spin successful?
                tst.b   1(a0)
d331 11
a341 4
                move.w  db_Info+CDINFO_Status(db),d0                    ; Disk is spinning
                bset    #CDSTSB_SPIN,d0
                move.w  d0,db_Info+CDINFO_Status(db)
5$
d388 1
a388 1
                bne     1$
d502 1
d504 1
a504 4
                move.l  d0,a0                                           ; Was the command successful?
                tst.b   1(a0)
                bmi     1$
                tst.b   2(a0)
d559 3
a561 2
                clr.w   d0                                              ; If this is a play command, reset response ignoring
                move.b  db_Packet(db),d0
d568 4
a571 2
                save    d2
                move.b  d0,d2
d573 1
a573 1
                move.b  d0,db_Packet(db)
d576 3
a578 1
                move.b  #-1,d0                                          ; Checksum packet
d580 14
a593 3
3$              sub.b   0(db,d1),d0
                addq.w  #1,d1
                cmp.b   PacketLen(pc,d2),d1
d596 7
a602 2
                move.b  d0,0(db,d1)                                     ; Store checksum
                restore d2
d604 1
a604 1
                ;       Transmit the packet and checksum
d606 2
d610 2
a611 1
PacketLen:      dc.b    1,1,1,1,12,1,1,1,4,1,0,0,0,0,0,0
d614 1
d625 5
a629 1
                move.l  db_PacketAddress(db),d0                         ; Return address of response
@


1.1
log
@Initial revision
@
text
@d273 1
a273 1
3$              cmp.w   #150,db_Info+CDINFO_Config+CONFIG_PlaySpeed(db)
d433 1
a433 1
5$              cmp.w   #150,db_Info+CDINFO_Config+CONFIG_PlaySpeed(db)
@
