head     36.4;
branch   ;
access   ;
symbols  V40_4:36.4 V37_2:36.4 V36_177:36.4 V36_176:36.4 V36_175:36.4 V36_174:36.3 V36_172:36.2 V36_171:36.2 V36_167:36.2 V36_166:36.2 V36_161:36.2 V36_160:36.2 V36_159:36.2 V36_158:36.2 V36_134:36.1 V36_78:36.0 V36_76:36.0 V36_54:36.0 V36_50:36.0;
locks    ; strict;
comment  @*   @;


36.4
date     90.04.13.11.28.44;  author kodiak;  state Exp;
branches ;
next     36.3;

36.3
date     90.04.02.11.06.41;  author kodiak;  state Exp;
branches ;
next     36.2;

36.2
date     89.04.14.16.27.03;  author kodiak;  state Exp;
branches ;
next     36.1;

36.1
date     89.04.09.19.01.54;  author kodiak;  state Exp;
branches ;
next     36.0;

36.0
date     89.01.30.16.29.35;  author kodiak;  state Exp;
branches ;
next     ;


desc
@MapANSI function
@


36.4
log
@use Id instead of Header for 4.x rcs
@
text
@/*********************************************************************
*
*			--------------
*   mapansi.c		KEYMAP LIBRARY	ANSI to IECLASS_RAWKEY
*			--------------
*
*   Copyright 1988 Commodore-Amiga Inc.
*
*   $Id$
*
*********************************************************************/
#include	"exec/types.h"
#include	"devices/inputevent.h"

#include	"kldata.h"
#include	"keymap.h"

#define	D(a)

/****** keymap.library/MapANSI ***************************************
*
*    NAME
*	MapANSI - decrypt ANSI to keycodes
*
*    SYNOPSIS
*	actual = MapANSI(string, count, buffer, length, keyMap)
*	D0               A0      D0     A1      D1      A2
*
*    FUNCTION
*	This console function converts an ANSI byte string to the
*	ie_Code/ie_Qualifier pairs of type IECLASS_RAWKEY that would
*	generate the string and places those pairs in a buffer.
*
*    INPUTS
*	string - the ANSI string to convert.
*	count - the number of characters in the string.
*	buffer - a byte buffer large enough to hold all anticipated
*	    ie_Code/ie_Qualifier pairs generated by this conversion.
*	length - maximum anticipation, i.e. the buffer size in bytes
*	    divided by four (the size of the ie_Code/ie_Qualifier
*	    pair).
*	keyMap - a KeyMap structure pointer, or null if the default
*	    key map is to be used.
*
*    RESULTS
*	actual - the number of ie_Code/ie_Qualifier pairs in the
*	    buffer, or negative to describe an error (see below).
*
*    ERRORS
*	if actual is 0, a character in the string was not generatable
*	    from the keyMap.
*	if actual is -1, a buffer overflow condition was detected.
*	if actual is -2, an internal error occurred (e.g. no memory)
*
*    SEE ALSO
*	devices/inputevent.h, devices/keymap.h
*
*********************************************************************/
short QualifierOnesCount[] = {
    /* number of bits set in a nibble */
    0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4
};
short QualifierExtraBytes[] = {
    /* number of extra bytes associated with non-special qualifier patterns */
    0, 0, 0, 0, 0, 0, 0, 0,	/* the last is the special VANILLA case */
    0, 0, 0, 8, 0, 8, 8, 16
};
UWORD Type2QualifierMap[] = {
    /* map from type to input event qualifier */
    0, IEQUALIFIER_LSHIFT, IEQUALIFIER_LALT,
    IEQUALIFIER_LSHIFT+IEQUALIFIER_LALT,
    IEQUALIFIER_CONTROL, IEQUALIFIER_LSHIFT+IEQUALIFIER_CONTROL,
    IEQUALIFIER_LALT+IEQUALIFIER_CONTROL,
    IEQUALIFIER_LSHIFT+IEQUALIFIER_LALT+IEQUALIFIER_CONTROL
};


struct KeyPair {
    UBYTE   k_Code;
    UBYTE   k_Qual;
};


MaxDeadIndex(type, entry, deadFactor, doubleDeadFactor)
UBYTE type;
UBYTE *entry;
int *deadFactor;
int *doubleDeadFactor;
{
    int cnt;
    int index;
    int i;

    if ((type & KCF_DEAD) && (!(type & KCF_NOP))) {
	/* dead or deadable */
	/* there are 2 bytes for each qualifier combination at *entry */
	cnt = 1<<(QualifierOnesCount[type & 0xf]+1);
	if (type & KCF_DOWNUP)
	    /* up keys can not supply indices */
	    cnt >>= 1;
	for (i = 0; i < cnt; i+=2) {
	    if (entry[i] & DPF_DEAD) {
		/* see if this index is a maximum */
		index = entry[i+1] & DP_2DINDEXMASK;
		if (*deadFactor < index)
		    *deadFactor = index;
		if ((entry[i+1] >> DP_2DFACSHIFT) &&
		    /* this index participates in double dead keys */
			(*doubleDeadFactor < index))
		    /* this participant in double dead keys is a maximum */
		    *doubleDeadFactor = index;
	    }
	}
    }
}


UBYTE
IndexedType(type, index)
UBYTE type, index;
{
    UBYTE result;
    UBYTE mask;

    result = 0;
    mask = 1;
    while (index) {
	while ((type & mask) == 0)
	    mask <<= 1;
	type &= ~mask;
	if (index & 1) {
	    result |= mask;
	}
	index >>= 1;
    }
    return(result);
}


FindDeadPairs(type, entry, code, deadPairs)
UBYTE type;
UBYTE *entry;
int code;
struct KeyPair *deadPairs;
{
    int cnt;
    int index;
    int i, i2;

    if ((type & KCF_DEAD) && (!(type & KCF_NOP))) {
	/* dead or deadable */
	cnt = 1<<QualifierOnesCount[type & 0xf];
	if (type & KCF_DOWNUP)
	    /* up keys can not supply indices */
	    cnt >>= 1;
	for (i = 0; i < cnt; i++) {
	    /* there are 2 bytes for each qualifier combination at *entry */
	    i2 = i*2;
	    if (entry[i2] & DPF_DEAD) {
		index = (entry[i2+1] & DP_2DINDEXMASK) - 1;
		if (deadPairs[index].k_Code != 0xff) {
		    /* check for better qualifier situation */
		    if (QualifierOnesCount[i] >=
			    QualifierOnesCount[deadPairs[index].k_Qual])
			continue;
		}
		deadPairs[index].k_Code = code;
		deadPairs[index].k_Qual = IndexedType(type, i);
	    }
	}
    }
}


ScanMap(type, entry, code, string, count, buffer, length, bestPairs, bestWidth,
	deadPairs, deadFactor, doubleDeadFactor)
UBYTE type;
ULONG entry;
UBYTE code;
UBYTE *string;
int count;
struct KeyPair *buffer;
int length;
int *bestPairs;
int *bestWidth;
struct KeyPair *deadPairs;
int deadFactor;
int doubleDeadFactor;
{
    UBYTE *entryp, *p;
    UBYTE local[4];
    int cnt, size;
    int i, i2, j;

    if (type & KCF_NOP) {
	/* NOP */
	return;
    }

    entryp = (UBYTE *) entry;

    if (type & KCF_STRING) {
	/* string */
	/* there are 2 bytes for each qualifier combination at *entry */
	cnt = 1<<QualifierOnesCount[type & 0xf];
	for (i = 0; i < cnt; i++) {
	    i2 = i*2;
	    size = entryp[i2];
	    if (size == 0)
		continue;
	    if (*bestWidth > size)
		continue;
	    if (count < size)
		continue;
	    p = entryp + entryp[i2+1];
	    for (j = 0; j < size; j++)
		if (string[j] != p[j])
		    goto nextString;
	    /* match */
	    if ((*bestWidth == size) && (*bestPairs == 1) &&
		    (QualifierOnesCount[i] >=
		    QualifierOnesCount[buffer[0].k_Qual]))
		/* but not as good a match */
		continue;
	    *bestPairs = 1;
	    *bestWidth = size;
	    buffer[0].k_Code = code;
	    buffer[0].k_Qual = IndexedType(type, i);
	    D(("ScanMap KCF_STRING code: 0x%lx, qual 0x%lx\n",
		    code, buffer[0].k_Qual));
nextString:
	}
	return;
    }

    if (*bestWidth > 1)
	/* cannot beat this width */
	return;

    if (type & KCF_DEAD) {
	/* dead or deadable */
	cnt = 1<<QualifierOnesCount[type & 0xf];
	for (i = 0; i < cnt; i++) {
	    /* there are 2 bytes for each qualifier combination at *entry */
	    i2 = i*2;
	    if (entryp[i2] == 0) {
		if (entryp[i2+1] == *string) {
		    /* match w/ character here */
		    if ((*bestPairs == 1) &&
			    (QualifierOnesCount[i] >=
			    QualifierOnesCount[buffer[0].k_Qual]))
			/* but not as good a match */
			continue;
		    *bestPairs = 1;
		    *bestWidth = 1;
		    buffer[0].k_Code = code;
		    buffer[0].k_Qual = IndexedType(type, i);
		    D(("ScanMap KCF_DEAD simple code: 0x%lx, qual 0x%lx\n",
			    code, buffer[0].k_Qual));
		    return;
		}
	    }
	    /* find any more interesting references */
	    else if (entryp[i2] & DPF_MOD) {
		p = entryp + entryp[i2+1];
		if (*p == *string) {
		    /* match w/ un-dead character here */
		    if ((*bestPairs == 1) &&
			    (QualifierOnesCount[i] >=
			    QualifierOnesCount[buffer[0].k_Qual]))
			/* but not as good a match */
			continue;
		    *bestPairs = 1;
		    *bestWidth = 1;
		    buffer[0].k_Code = code;
		    buffer[0].k_Qual = IndexedType(type, i);
		    D(("ScanMap DPF_MOD un-dead code: 0x%lx, qual 0x%lx\n",
			    code, buffer[0].k_Qual));
		    return;
		}
		if (*bestPairs == 1)
		    /* cannot beat this pair with a dead key */
		    continue;
		for (j = 1; j < deadFactor; j++) {
		    if (p[j] == *string) {
			/* match w/ single dead character here */
			if ((*bestWidth != 0) && (*bestPairs == 2) &&
				(QualifierOnesCount[i] >=
				QualifierOnesCount[buffer[1].k_Qual]))
			    /* but not as good a match */
			    continue;
			*bestPairs = 2;
			if (length < 2)
			    goto deadContinue;
			*bestWidth = 1;
			buffer[0].k_Code = deadPairs[j-1].k_Code;
			buffer[0].k_Qual = deadPairs[j-1].k_Qual;
			buffer[1].k_Code = code;
			buffer[1].k_Qual = IndexedType(type, i);
			D(("ScanMap DPF_MOD dead code: 0x%lx, qual 0x%lx\n",
				buffer[0].k_Code, buffer[0].k_Qual));
			D(("    code: 0x%lx, qual 0x%lx\n",
				code, buffer[1].k_Qual));
			return;
		    }
		}
		if (*bestPairs == 2)
		    /* cannot beat these pairs with a double dead key */
		    continue;
		for (; j < doubleDeadFactor; j++) {
		    if ((j % deadFactor) == 0)
			/* cannot reach this character */
			continue;
		    if (p[j] == *string) {
			/* match w/ double dead character here */
			if ((*bestWidth != 0) && (*bestPairs == 3) &&
				(QualifierOnesCount[i] >=
				QualifierOnesCount[buffer[2].k_Qual]))
			    /* but not as good a match */
			    goto deadContinue;
			*bestPairs = 3;
			if (length < 3)
			    goto deadContinue;
			*bestWidth = 1;
			buffer[0].k_Code = deadPairs[(j/deadFactor)-1].k_Code;
			buffer[0].k_Qual = deadPairs[(j/deadFactor)-1].k_Qual;
			buffer[1].k_Code = deadPairs[(j%deadFactor)-1].k_Code;
			buffer[1].k_Qual = deadPairs[(j%deadFactor)-1].k_Qual;
			buffer[2].k_Code = code;
			buffer[2].k_Qual = IndexedType(type, i);
			D(("ScanMap DPF_MOD dead2 code: 0x%lx, qual 0x%lx\n",
				buffer[0].k_Code, buffer[0].k_Qual));
			D(("    dead code: 0x%lx, qual 0x%lx\n",
				buffer[1].k_Code, buffer[1].k_Qual));
			D(("    code: 0x%lx, qual 0x%lx\n",
				code, buffer[2].k_Qual));
			return;
		    }
		}
	    }
deadContinue:
	}
	return;
    }

    if (QualifierExtraBytes[type & 0xf] == 0) {
	local[0] = entry;
	local[1] = entry>>8;
	local[2] = entry>>16;
	local[3] = entry>>24;
	entryp = local;
    }
    if (type == KC_VANILLA)
	cnt = 4;
    else
	cnt = 1<<QualifierOnesCount[type & 0xf];
    for (i = 0; i < cnt; i++) {
	if (entryp[i] == *string) {
	    if ((*bestPairs == 1) && (QualifierOnesCount[i] >=
		    QualifierOnesCount[buffer[0].k_Qual]))
		/* but not as good a match */
		continue;
	    *bestPairs = 1;
	    *bestWidth = 1;
	    buffer[0].k_Code = code;
	    buffer[0].k_Qual = IndexedType(type, i);
	    D(("ScanMap code: 0x%lx, qual 0x%lx\n",
		    code, buffer[0].k_Qual));
	}
	if (type == KC_VANILLA) {
	    if ((entryp[i] & 0xc0) == 0x40) {
		if ((entryp[i] & 0x1f) == *string) {
		    if ((*bestPairs == 1) && ((QualifierOnesCount[i]+1) >=
			    QualifierOnesCount[buffer[0].k_Qual]))
			/* but not as good a match */
			continue;
		    *bestPairs = 1;
		    *bestWidth = 1;
		    buffer[0].k_Code = code;
		    buffer[0].k_Qual = IndexedType(type, i) | KCF_CONTROL;
		    D(("ScanMap control code: 0x%lx, qual 0x%lx\n",
			    code, buffer[0].k_Qual));
		}
		if (((entryp[i] & 0x1f) | 0x80) == *string) {
		    if ((*bestPairs == 1) && ((QualifierOnesCount[i]+2) >=
			    QualifierOnesCount[buffer[0].k_Qual]))
			/* but not as good a match */
			continue;
		    *bestPairs = 1;
		    *bestWidth = 1;
		    buffer[0].k_Code = code;
		    buffer[0].k_Qual = IndexedType(type, i) |
			    KCF_ALT | KCF_CONTROL;
		    D(("ScanMap alt control code: 0x%lx, qual 0x%lx\n",
			    code, buffer[0].k_Qual));
		}
	    }
	}
    }
}


int
MapANSI(count, length, string, buffer, km, kl)
UBYTE *string;
int count;
struct KeyPair *buffer;
int length;
struct KeyMap *km;
struct KeyMapLibrary *kl;
{
    int deadFactor;		/* to determine size of lookup tables at end */
    int doubleDeadFactor;	/* (only used for double dead keys) */
    struct KeyPair *deadPairs;	/* pairs to generate dead indices */
    int bestPairs;		/* pairs used in bestPair */
    int bestWidth;		/* characters in string bestPair represents */
    int actual;
    short i;

    D(("MapANSI(str: 0x%02lx..., cnt: %ld, buf: 0x%lx, len: %ld, kM: 0x%lx)\n", 
	    *string, count, buffer, length, km));
    if (km == 0) {
        km = kl->kl_KMDefault;
    }

    /* first need to find the number of dead keys */
    deadFactor = doubleDeadFactor = 0;
    deadPairs = 0;
    for (i = 0; i < 0x40; i++) {
	MaxDeadIndex(km->km_LoKeyMapTypes[i], km->km_LoKeyMap[i],
		&deadFactor, &doubleDeadFactor);
    }
    for (i = 0; i < 0x38; i++) {
	MaxDeadIndex(km->km_HiKeyMapTypes[i], km->km_HiKeyMap[i],
		&deadFactor, &doubleDeadFactor);
    }
    if (deadFactor) {
	deadPairs = (struct KeyPair *)
		AllocMem(deadFactor*sizeof(struct KeyPair), 0);
	if (deadPairs == 0)
	    return(-2);
	for (i = 0; i < deadFactor; i++)
	    deadPairs[i].k_Code = 0xff;
	for (i = 0; i < 0x40; i++) {
	    FindDeadPairs(km->km_LoKeyMapTypes[i], km->km_LoKeyMap[i], i,
		    deadPairs);
	}
	for (i = 0; i < 0x38; i++) {
	    FindDeadPairs(km->km_HiKeyMapTypes[i], km->km_HiKeyMap[i], i+0x40,
		    deadPairs);
	}
	deadFactor++;
	if (doubleDeadFactor)
	    doubleDeadFactor = deadFactor * (doubleDeadFactor + 1);
    }

    actual = 0;
    while ((count > 0) && (length > 0)) {
	bestPairs = 0;
	bestWidth = 0;
	/* scan the keymaps */
	for (i = 0; i < 0x40; i++) {
	    ScanMap(km->km_LoKeyMapTypes[i], km->km_LoKeyMap[i], i, string,
		    count, buffer+actual, length, &bestPairs, &bestWidth,
		    deadPairs, deadFactor, doubleDeadFactor);
	}
	for (i = 0; i < 0x38; i++) {
	    ScanMap(km->km_HiKeyMapTypes[i], km->km_HiKeyMap[i], i+0x40, string,
		    count, buffer+actual, length, &bestPairs, &bestWidth,
		    deadPairs, deadFactor, doubleDeadFactor);
	}
	if (bestPairs > length) {
	    /* not enough room for this solution */
	    actual = -1;
	    goto mapDone;
	}
	if (bestPairs == 0) {
	    /* cannot generate this string */
	    actual = 0;
	    goto mapDone;
	}
	length -= bestPairs;
	actual += bestPairs;
	string += bestWidth;
	count -= bestWidth;
    }
    if (count > 0)
	/* not enough room to continue */
	actual = -1;
    for (i = 0; i < actual; i++) {
	if (buffer[i].k_Qual & KCF_DOWNUP)
	    buffer[i].k_Code |= IECODE_UP_PREFIX;
	buffer[i].k_Qual = Type2QualifierMap[buffer[i].k_Qual & 0x7];
    }
mapDone:
    if (deadPairs) {
	FreeMem(deadPairs, (deadFactor-1)*sizeof(struct KeyPair));
    }
    D(("    actual: %ld\n", actual));
    return(actual);
}
@


36.3
log
@for rcs 4.x header change
@
text
@d9 1
a9 1
*   $Header: /usr2/kodiak/src/KS/keymap/RCS/mapansi.c.doc,v 36.2 89/04/14 16:27:03 kodiak Exp Locker: kodiak $
@


36.2
log
@keep around as documentation of MapANSI
@
text
@d9 1
a9 1
*   $Header: mapansi.c,v 36.1 89/04/09 19:01:54 kodiak Exp $
@


36.1
log
@debugged MapANSI
@
text
@d9 1
a9 1
*   $Header: mapansi.c,v 36.0 89/01/30 16:29:35 kodiak Exp $
@


36.0
log
@initial release
@
text
@d9 1
a9 1
*   $Header$
d12 2
d15 5
d50 2
d53 1
a53 3
*	if actual is -2, a character in the string was not generatable
*	    from the keyMap.
*	if actual is -3, an internal error occurred (e.g. no memory)
a58 6
#include	"exec/types.h"
#include	"devices/inputevent.h"

#include	"kldata.h"
#include	"keymap.h"

d79 2
a80 2
    UWORD   k_Code;
    UWORD   k_Qual;
d90 1
a90 1
    int count;
d97 1
a97 1
	count = 1<<(QualifierOnesCount[type & 0xf]+1);
d100 2
a101 2
	    count >>= 1;
	for (i = 0; i < count; i+=2) {
d136 1
d146 1
a146 1
    int count;
d148 1
a148 1
    int i;
d152 1
a152 2
	/* there are 2 bytes for each qualifier combination at *entry */
	count = 1<<(QualifierOnesCount[type & 0xf]+1);
d155 7
a161 5
	    count >>= 1;
	for (i = 0; i < count; i+=2) {
	    if (entry[i] & DPF_DEAD) {
		index = (entry[i+1] & DP_2DINDEXMASK) - 1;
		if (deadPairs[index].k_Code != 0xffff) {
d180 1
a180 1
char *string;
d192 2
a193 2
    int count, size;
    int i, j;
d205 4
a208 3
	count = 1<<(QualifierOnesCount[type & 0xf]+1);
	for (i = 0; i < count; i+=2) {
	    size = entryp[i];
d213 3
a215 1
	    p = entryp + entryp[i+1];
d218 1
a218 1
		    continue;
d229 3
d242 21
a262 3
	/* there are 2 bytes for each qualifier combination at *entry */
	count = 1<<(QualifierOnesCount[type & 0xf]+1);
	for (i = 0; i < count; i+=2) {
d264 2
a265 2
	    if (entryp[i] & DPF_MOD) {
		p = entryp + entryp[i+1];
d277 2
d284 2
a285 2
		for (i = 1; i < deadFactor; i++) {
		    if (p[i] == *string) {
d296 2
a297 2
			buffer[0].k_Code = deadPairs[i-1].k_Code;
			buffer[0].k_Qual = deadPairs[i-1].k_Qual;
d300 4
d310 2
a311 2
		for (; i < doubleDeadFactor; i++) {
		    if ((i % deadFactor) == 0)
d314 1
a314 1
		    if (p[i] == *string) {
d325 4
a328 4
			buffer[0].k_Code = deadPairs[(i/deadFactor)-1].k_Code;
			buffer[0].k_Qual = deadPairs[(i/deadFactor)-1].k_Qual;
			buffer[1].k_Code = deadPairs[(i%deadFactor)-1].k_Code;
			buffer[1].k_Qual = deadPairs[(i%deadFactor)-1].k_Qual;
d331 6
d354 1
a354 1
	count = 4;
d356 2
a357 2
	count = 1<<QualifierOnesCount[type & 0xf];
    for (i = 0; i < count; i++) {
d367 2
d371 26
a396 9
	    if ((entryp[i] & 0x40) && ((entryp[i] & 0x9f) == *string)) {
		if ((*bestPairs == 1) && ((QualifierOnesCount[i]+1) >=
			QualifierOnesCount[buffer[0].k_Qual]))
		    /* but not as good a match */
		    continue;
		*bestPairs = 1;
		*bestWidth = 1;
		buffer[0].k_Code = code;
		buffer[0].k_Qual = IndexedType(type, KCF_CONTROL+i);
d405 1
a405 1
char *string;
d420 3
a422 1
    if (km == 0)
d424 1
d429 1
a429 1
    for (i = 0; i < 64; i++) {
d433 1
a433 1
    for (i = 0; i < 40; i++) {
d441 1
a441 1
	    return(-3);
d443 2
a444 2
	    deadPairs[i].k_Code = 0xffff;
	for (i = 0; i < 64; i++) {
d448 2
a449 2
	for (i = 0; i < 40; i++) {
	    FindDeadPairs(km->km_HiKeyMapTypes[i], km->km_HiKeyMap[i], i,
d457 1
a457 1
    actual == 0;
d462 1
a462 1
	for (i = 0; i < 64; i++) {
d467 2
a468 2
	for (i = 0; i < 40; i++) {
	    ScanMap(km->km_LoKeyMapTypes[i], km->km_LoKeyMap[i], i, string,
d479 1
a479 1
	    actual = -2;
d496 1
a496 1
    if (deadPairs)
d498 2
@
