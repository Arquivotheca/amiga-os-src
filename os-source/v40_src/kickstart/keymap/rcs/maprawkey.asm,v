head     36.12;
branch   ;
access   ;
symbols  V40_4:36.12 V37_2:36.11 V36_177:36.9 V36_176:36.9 V36_175:36.9 V36_174:36.8 V36_172:36.7 V36_171:36.7 V36_167:36.7 V36_166:36.7 V36_161:36.7 V36_160:36.7 V36_159:36.6 V36_158:36.5 V36_134:36.5 V36_78:36.4 V36_76:36.4 V36_54:36.3 V36_50:36.2 V36_46:36.2 L36_44:36.1 L36_34:36.1;
locks    ; strict;
comment  @*   @;


36.12
date     92.09.17.15.17.42;  author darren;  state Exp;
branches ;
next     36.11;

36.11
date     91.02.05.12.34.47;  author darren;  state Exp;
branches ;
next     36.10;

36.10
date     91.02.05.12.30.54;  author darren;  state Exp;
branches ;
next     36.9;

36.9
date     90.04.13.11.28.02;  author kodiak;  state Exp;
branches ;
next     36.8;

36.8
date     90.04.02.11.06.55;  author kodiak;  state Exp;
branches ;
next     36.7;

36.7
date     89.06.05.18.18.10;  author kodiak;  state Exp;
branches ;
next     36.6;

36.6
date     89.06.05.13.11.34;  author kodiak;  state Exp;
branches ;
next     36.5;

36.5
date     89.04.09.19.02.07;  author kodiak;  state Exp;
branches ;
next     36.4;

36.4
date     89.03.17.15.54.38;  author kodiak;  state Exp;
branches ;
next     36.3;

36.3
date     89.02.16.16.57.33;  author kodiak;  state Exp;
branches ;
next     36.2;

36.2
date     89.01.27.17.53.28;  author kodiak;  state Exp;
branches ;
next     36.1;

36.1
date     88.03.29.15.53.40;  author kodiak;  state Exp;
branches ;
next     36.0;

36.0
date     88.03.29.15.49.53;  author kodiak;  state Exp;
branches ;
next     ;


desc
@convert raw key events to ANSI/ASCII codes under keymap control
@


36.12
log
@example code error fixed
@
text
@**
**	$Id: maprawkey.asm,v 36.11 91/02/05 12:34:47 darren Exp Locker: darren $
**
**      keymap IECLASS_RAWKEY to ANSI conversion
**
**      (C) Copyright 1985,1989 Commodore-Amiga, Inc.
**          All Rights Reserved
**

	SECTION	keymap

*------ Included Files -----------------------------------------------

	INCLUDE	"kldata.i"

	INCLUDE	"devices/inputevent.i"


*------ Exported Names -----------------------------------------------

	XDEF	MapRawKey


******* keymap.library/MapRawKey *************************************
*
*   NAME
*	MapRawKey -- Decode single raw key input event to an ANSI
*	             string. (V36)
*
*   SYNOPSIS
*	actual = MapRawKey(event, buffer, length, keyMap)
*	D0                 A0     A1      D1      A2
*
*	WORD MapRawKey( struct InputEvent *, STRPTR, WORD,
*	    struct Keymap * );
*
*   FUNCTION
*	This console function converts input events of type
*	IECLASS_RAWKEY to ANSI bytes, based on the keyMap, and
*	places the result into the buffer.
*
*   INPUTS
*	event -  an InputEvent structure pointer.  The event list is
*	    not traversed.
*	buffer - a byte buffer large enough to hold all anticipated
*	    characters generated by this conversion.
*	length - maximum anticipation, i.e. the buffer size in bytes.
*	keyMap - a KeyMap structure pointer, or null if the default
*	    key map is to be used.
*
*   RESULT
*	actual - the number of characters in the buffer, or -1 if
*	    a buffer overflow was about to occur.
*
*   EXAMPLE
*	...
*	#define	BUFFERLEN	80	\* length of longest expected mapping \*
*	char buffer[BUFFERLEN];
*	struct InputEvent ie;
*	...
*	    KeymapBase = OpenLibrary("keymap.library", 0);
*	    ...
*	    ie.ie_Class = IECLASS_RAWKEY;
*	    ie.ie_SubClass = 0;
*	    for (;;) {
*		WaitPort(window->UserPort);
*		while (im = (struct IntuiMessage *) GetMsg(window->UserPort)) {
*		    switch (im->Class) {
*			case RAWKEY:
*			    ie.ie_Code = im->Code;
*			    ie.ie_Qualifier = im->Qualifier;
*			    \* recover dead key codes & qualifiers *\
*			    ie.ie_EventAddress = (APTR *) *((ULONG *)im->IAddress);
*			    actual = MapRawKey(&ie, buffer, BUFFERLEN, 0);
*			    for (i = 0; i < actual; i++)
*				ReportChar(buffer[i]);
*			    break;
*			...
*		    }
*		    ...
*		}
*	    }
*
*   ERRORS
*	if actual is -1, a buffer overflow condition was detected.
*	Not all of the characters in the buffer are valid.
*
*   SEE ALSO
*	devices/inputevent.h, devices/keymap.h
*
**********************************************************************


*   Both the previous down and the previous previous down keycode are kept for
*   translation.  Double dead keys *can* use both.  If a dead key has effect
*   in the double old (previous previous) position, it not only has an index
*   (i.e. the value in the low nibble under DP_2DINDEXMASK), but also
*   1.  flags that it can be effective in the double old position by having
*       a value in the high nibble (shifted into place with DP_2DFACSHIFT).
*   2.  holds the total number of dead keys + 1 in the keymap in the high
*       nibble so that that number can be used as a factor in accessing the
*       dead keys.
*   Once you've figured out this is a double dead qualifier, you end up
*   multiplying the two nibbles together to get a second (double dead
*   contribution) offset into the dead key translation table.  This table
*   has <number of dead keys+1> times <number of double dead keys+1> entries,
*   arranged in <number of double dead keys+1> rows of <number of dead keys+1>
*   entries.

MapRawKey:
		MOVEM.L D2/A2,-(A7)
		MOVE.L	D1,D2		; save maximum buffered
		MOVE.L	A2,D0		; check keyMap
		BNE.S	convertIt
		move.l	kl_KMDefault(a6),a2

convertIt:
	;-- check if this is a raw keycode to begin with
		MOVEQ	#0,D0		; show nothing buffered
		CMP.B	#IECLASS_RAWKEY,ie_Class(A0)
		bne.s  	rcRts

		movem.w	ie_Code(a0),d0/d1
		BSR.S	convertKey

rcRts:
		MOVEM.L (A7)+,D2/A2
		RTS


;------	convertKey ---------------------------------------------------
;
;	D0	ie_Code
;	D1	ie_Qualifier
;	D2	bufferSize (zero, look for dead keys, is only used in recursion)
;	A0	input event (only used at top level of recursion)
;	A1	buffer
;	A2	keyMap
;
;   RESULT
;	D0	buffer actual: -1 if overflow
;	D1	dead key index associated w/ this code if non-zero
;	A0	input event (unchanged)
;	A1	updated buffer address
;
convertKey:
		MOVEM.L	D2-D7/A2-A5,-(A7)
		MOVE.W	D0,D6
		MOVE.W	D1,D7
		MOVE.L	D2,A4
		MOVE.L	A2,A5		; working keymap
		AND.W	#~IECODE_UP_PREFIX,D0
		CMP.W	#IECODE_KEY_CODE_LAST,D0
		BHI	nullConvert	; don't handle communications
		MOVE.W	D0,D4		; get keycode bit index
		MOVE.W	D0,D5		;
		AND.W	#$00007,D4	;
		LSR.W	#3,D5		;
		AND.W	#$00007,D5	;   lose part associated w/ > $40

	;-- check keycode conversion type

		CMPI.W	#$40,D0
	IFNE	km_LoKeyMapTypes
	FAIL	"km_LoKeyMapTypes is not zero, need to explicitly LEA it."
	ENDC
		BLT.S	checkRepeat
		LEA	km_HiKeyMapTypes(A5),A5

checkRepeat:
		BTST	#IEQUALIFIERB_REPEAT,D7
		BEQ.S	buildType
		MOVE.L	km_LoRepeatable(A5),A3
		BTST	D4,0(A3,D5.W)
		BEQ	nullConvert

buildType:
		MOVE.L	(A5),A3		; km_LoKeyMapTypes(a5)
		MOVE.W	D0,D1
		ANDI.W	#$03F,D1
		MOVE.B	0(A3,D1.W),D2
	    ;------ check if the type of key is nop
		BTST	#KCB_NOP,D2
		BNE	nullConvert
	;------ build type bits
		MOVEQ	#0,D3
	    ;------ check if the key is an up transition
		CMP.W	D6,D0
		BEQ.S	chkShift
	    ;---------- an up transition
		BTST	#KCB_DOWNUP,D2
		BEQ	nullConvert		; only want down reports
		ADDQ.W	#KCF_DOWNUP,D3
chkShift:
		MOVE.W	D7,D0
		AND.W	#IEQUALIFIER_LSHIFT+IEQUALIFIER_RSHIFT,D0
		BEQ.S	chkAlt
		ADDQ.W	#KCF_SHIFT,D3
chkAlt:
		MOVE.W	D7,D0
		AND.W	#IEQUALIFIER_LALT+IEQUALIFIER_RALT,D0
		BEQ.S	chkCaps
		ADDQ.W	#KCF_ALT,D3
chkCaps:
	    ;------ check if key affected by caps lock
		BTST	#IEQUALIFIERB_CAPSLOCK,D7
		BEQ.S	chkCtrl
		MOVE.L	km_LoCapsable(A5),A3
		BTST	D4,0(A3,D5.W)
		BEQ.S	chkCtrl
		OR.W	#KCF_SHIFT,D3			; ensure shift bit
chkCtrl:
		BTST	#IEQUALIFIERB_CONTROL,D7
		BEQ.S	getMap
	    ;---------- the control key is set
		ADDQ.W	#KCF_CONTROL,D3

getMap:
		MOVE.L	km_LoKeyMap(A5),A3
		LSL	#2,D1			; make a long offset
		MOVE.L	0(A3,D1.W),D5

		;------	get the index within the map entry based on the state
		;	of those qualifier bits that affect this map lookup
		MOVEQ	#0,D4			; resulting index
		MOVEQ	#0,D0			; bit to test
		MOVEQ	#1,D1			; weight of bit
1$
		BTST	D0,D2			; check if this bit significant
		BEQ.S	3$			;   (no)
		BTST	D0,D3			; check if this bit set in qual
		BEQ.S	2$			;   (no)
		ADD.W	D1,D4			; update index
2$
		ADD.W	D1,D1			; double the weight
3$
		ADDQ.W	#1,D0			; increment the bit to test
		CMP.W	#4,D0
		BLT.S	1$

	    ;------ figure out how to interpret this
		BCLR	#KCB_DEAD,D2
		BNE	deadHead

		BTST	#KCB_STRING,D2		; check for string offsets
		BNE.S	simpleString

		CMPI.B	#KC_VANILLA,D2
		BEQ.S	vanillaKey

		CMP.W	#4,D1			; check index weight
		BLE.S	indexedRotate

indexedByte:
		;------ indirect indexed byte
		MOVE.L	D5,A3
		MOVE.B	0(A3,D4.W),D5		; get the byte at the offset
		BRA.S	gotByte

indexedRotate:
		;------ indexed byte from long word already gotten
		LSL	#3,D4			; rotation for indexed word
		ROR.L	D4,D5
		BRA.S	gotByte

vanillaKey:
		;------ get the key value as a vanilla byte
		LSL	#3,D4
		ROR.L	D4,D5
		BTST	#KCB_CONTROL,D3	; check ctrl key
		BEQ.S	gotByte

		MOVEQ	#3,D0
chkCtrlable:
		MOVE.B	D5,D1		; check if code is ctrlable
		AND.W	#$C0,D1		;
		CMP.W	#$40,D1		;
		BEQ.S	haveCtrl	;   yes, use it
		ROR.L	#8,D5		;   no, try the next
		DBF	D0,chkCtrlable
		BRA.S	gotByte		; use original key

haveCtrl:
		AND.W	#$1F,D5		; mask to control code
		BTST	#KCB_ALT,D3	;   check if ALT control
		BEQ.S	gotByte
		OR.W	#$80,D5		; set ALT control

gotByte:
		MOVE.L	A4,D0
		BEQ.S	buffOverflow	; (after all that time!)
		MOVE.B	D5,(A1)+
		MOVEQ	#1,D0
		BRA.S	endStdConvert

buffOverflow:
		MOVEQ	#-1,D0		; show overflow
		BRA.S	endStdConvert

		;------ get the key stream as a string
simpleString:
		BSR.S	twinBytes
		CMP.L	A4,D0
		BGT.S	buffOverflow		;   not enough buffer
		EXT.W	D1			; sign extend offset
		ADD.W	D1,A3			;
		MOVE.W	D0,D1
		BRA.S	2$
1$
		MOVE.B	(A3)+,(A1)+
2$
		DBF	D1,1$
		BRA.S	endStdConvert

nullConvert:
		MOVEQ	#0,D0

endStdConvert:
		MOVEQ	#0,D1

endConvert:
		MOVEM.L	(A7)+,D2-D7/A2-A5
		RTS


twinBytes:
		ADD.W	D4,D4			; offsets are two bytes
		MOVE.L	D5,A3
		MOVEQ	#0,D0
		MOVEQ	#0,D1
		MOVE.B	0(A3,D4),D0		; length | deadhead
		MOVE.B	1(A3,D4),D1		; offset | data
		RTS

deadHead:
		BSR.S	twinBytes

		BTST	#DPB_DEAD,D0
		BNE.S	deadDead

		BTST	#DPB_MOD,D0
		BNE.S	deadMod

		;------ this qualifier not associated with 'deadness'
		MOVE.B	D1,D5
		BRA.S	gotByte

deadDead:
		;------ just return the dead index
		MOVEQ	#0,D0
		BRA.S	endConvert

deadMod:
		;------ this is the biggie, recurse! recurse!
		MOVE.L	A4,D0
		BEQ.S	buffOverflow	; (after all that time!)

		MOVE.L	A3,D5		; construct new origin
		EXT.W	D1		;
		EXT.L	D1
		ADD.L	D1,D5		;

		MOVEQ	#0,D4		; index is going to be dead stuff

		MOVEQ	#0,D0		; get most recent dead candidate
		MOVE.B	ie_X(A0),D0	;   code
		MOVEQ	#0,D1		;   &
		MOVE.B	ie_X+1(A0),D1	;   low byte of qualifier
		MOVEQ	#0,D2		; show no conversion buffer
		BSR	convertKey	; recurse!
		TST.W	D1		; check for dead index
		beq	indexedByte	;   zero: we've got all we're going to
		MOVE.W	D1,D4		; save index
		AND.W	#DP_2DINDEXMASK,D4
		LSR.W	#DP_2DFACSHIFT,D1
		beq	indexedByte	; zero: second dead key is useless
		MULU	D1,D4		; multiply index times the factor

		MOVEQ	#0,D0		; get less recent dead candidate
		MOVE.B	ie_Y(A0),D0	;   code
		MOVEQ	#0,D1		;   &
		MOVE.B	ie_Y+1(A0),D1	;   low byte of qualifier
		MOVEQ	#0,D2		; show no conversion buffer
		BSR	convertKey	; recurse!
		AND.W	#DP_2DINDEXMASK,D1
		ADD.W	D1,D4		; add it to index already got
		bra	indexedByte

	END
@


36.11
log
@*** empty log message ***
@
text
@d2 1
a2 1
**	$Id: maprawkey.asm,v 36.10 91/02/05 12:30:54 darren Exp Locker: darren $
d73 1
a73 1
*			    ie.ie_EventAddress = (APTR *) *im->IAddress;
@


36.10
log
@Add (V36) to autodocs.
@
text
@d2 1
a2 1
**	$Id: maprawkey.asm,v 36.9 90/04/13 11:28:02 kodiak Exp Locker: darren $
d28 1
a28 1
*                    string. (V36)
@


36.9
log
@use Id instead of Header for 4.x rcs
@
text
@d2 1
a2 1
**	$Id$
d27 2
a28 1
*	MapRawKey -- Decode single raw key input event to an ANSI string.
@


36.8
log
@for rcs 4.x header change
@
text
@d2 1
a2 1
**	$Header: /usr2/kodiak/src/KS/keymap/RCS/maprawkey.asm,v 36.7 89/06/05 18:18:10 kodiak Exp Locker: kodiak $
@


36.7
log
@assembler version
@
text
@d2 1
a2 1
**	$Header: maprawkey.asm,v 36.6 89/06/05 13:11:34 kodiak Exp $
@


36.6
log
@autodoc changes
@
text
@d2 1
a2 4
**      $Filename maprawkey.asm $
**      $Release: 1.4 $
**      $Revision: 36.5 $
**      $Date: 89/04/09 19:02:07 $
a8 1
**	$Header: maprawkey.asm,v 36.5 89/04/09 19:02:07 kodiak Exp $
d14 1
a14 3
	INCLUDE		"exec/types.i"
	INCLUDE		"devices/inputevent.i"
	INCLUDE		"kldata.i"
d16 1
d18 1
d21 1
a21 1
	XDEF		_MapRawKey
d109 1
a109 1
_MapRawKey:
d388 1
a388 1
		END
@


36.5
log
@enabled dead key code
@
text
@d4 2
a5 2
**      $Revision: 36.4 $
**      $Date: 89/03/17 15:54:38 $
d12 1
a12 1
**	$Header: maprawkey.asm,v 36.4 89/03/17 15:54:38 kodiak Exp $
d30 2
a31 2
*    NAME
*	MapRawKey - decode raw input classes
d33 1
a33 1
*    SYNOPSIS
d37 4
a40 1
*    FUNCTION
d45 1
a45 1
*    INPUTS
d54 1
a54 1
*    RESULTS
d58 30
a87 1
*    ERRORS
d91 1
a91 1
*    SEE ALSO
@


36.4
log
@checkin coinciding w/ JSR->BSR for "C" modules
@
text
@d4 2
a5 2
**      $Revision: 36.0 $
**      $Date: 89/02/17 13:33:42 $
d12 1
a12 1
**	$Header: ramlib.asm,v 36.0 89/02/17 13:33:42 kodiak Exp $
d149 1
a149 1
		MOVE.L	km_LoKeyMapTypes(A5),A3
d343 1
a343 1
		bra	indexedByte	;   zero: we've got all we're going to
d347 1
a347 1
		bra	indexedByte	; zero: second dead key is useless
@


36.3
log
@fix error for dead_mod offsets
add comments
@
text
@d1 13
a13 11
**********************************************************************
*
*			--------------
*   maprawkey.asm	KEYMAP LIBRARY	IECLASS_RAWKEY to ANSI
*			--------------
*
*   Copyright 1985,1988 Commodore-Amiga Inc.
*
*   $Header: maprawkey.asm,v 36.2 89/01/27 17:53:28 kodiak Exp $
*
**********************************************************************
@


36.2
log
@RawKeyConvert -> MapRawKey
@
text
@d9 1
a9 1
*   $Header$
d62 17
d329 2
a330 1
		ADD.W	D1,D5		;
@


36.1
log
@remove references to dead string conversion
@
text
@a0 1
	TTL    '$Header: rawconvert.asm,v 36.0 88/03/29 15:49:53 kodiak Exp $'
a1 11
*								     *
*   Copyright 1985, Commodore-Amiga Inc.   All rights reserved.	     *
*   No part of this program may be reproduced, transmitted,	     *
*   transcribed, stored in retrieval system, or translated into	     *
*   any language or computer language, in any form or by any	     *
*   means, electronic, mechanical, magnetic, optical, chemical,	     *
*   manual or otherwise, without the prior written permission of     *
*   Commodore-Amiga Incorporated, 983 University Ave. Building #D,   *
*   Los Gatos, California, 95030				     *
*								     *
**********************************************************************
d3 3
a5 1
*	Raw Input Event to Ansi translation
d7 1
a7 3
*   Source Control
*   --------------
*   $Header: rawconvert.asm,v 36.0 88/03/29 15:49:53 kodiak Exp $
d9 1
a9 1
*   $Locker: kodiak $
a10 11
*   $Log:	rawconvert.asm,v $
*   Revision 36.0  88/03/29  15:49:53  kodiak
*   new from V34
*   
*   Revision 35.1  88/01/19  16:00:39  kodiak
*   fix ALT CTRL bug
*   
*   Revision 35.0  87/10/26  11:13:37  kodiak
*   initial from V34, but w/ stripped log
*   
*
d12 1
a13 2
	SECTION		rawinput

d23 1
a23 1
	XDEF		_RawKeyConvert
d26 1
a26 1
******* console.device/function/RawKeyConvert **********************************
d29 1
a29 1
*	RawKeyConvert - decode raw input classes
d32 2
a33 2
*	actual = RawKeyConvert(event, buffer, length, keyMap)
*	D0       	       A0     A1      D1      A2
a34 2
*	ConsoleDevice in A6 if called from Assembly Language.
*
d41 2
a42 1
*	event -  an InputEvent structure pointer.
d47 1
a47 1
*	    console device key map is to be used.
a56 11
*    NOTES
*	This function is different from standard device commands in
*	that it is a function in the console device library vectors.
*	In order to obtain a valid library base pointer for the
*	console device (a.k.a. ConsoleDevice) call
*	OpenDevice("console.device", -1, IOStdReq, 0),
*	and then grab the io_Device pointer field out of the IOStdReq
*	and use as ConsoleDevice.
*
*    BUGS
*
d58 1
a58 2
*	console.device/function/OpenDevice, exec/io.h,
*	    devices/inputevent.h, devices/keymap.h
d60 4
a63 4
********************************************************************************

_RawKeyConvert:
		MOVEM.L D2-D3/A2,-(A7)
a64 1
		MOVEQ	#0,D3		; show nothing buffered
d66 2
a67 2
		BNE.S	convertLoop
		LEA	kl_KM(A6),A2
d69 1
a69 1
convertLoop:
d71 1
d73 1
a73 1
		BNE  	chkNext
d75 1
a75 2
		MOVE.W	ie_Code(A0),D0
		MOVE.W	ie_Qualifier(A0),D1
a76 4
		TST.L	D0
		BMI.S	rcRts		; buffer overflow: stop now
		SUB.L	D0,D2		; fewer buffer slots remaining
		ADD.L	D0,D3		; update actual
a77 6
chkNext:
		MOVE.L	(A0),D0
		MOVE.L	D0,A0
		BNE	convertLoop

		MOVE.W	D3,D0		; return actual
d79 1
a79 1
		MOVEM.L (A7)+,D2-D3/A2
@


36.0
log
@new from V34
@
text
@d1 1
a1 1
	TTL    '$Header: rawconvert.asm,v 35.1 88/01/19 16:00:39 kodiak Exp $'
d19 1
a19 1
*   $Header: rawconvert.asm,v 35.1 88/01/19 16:00:39 kodiak Exp $
d21 1
a21 1
*   $Locker:  $
d24 3
a344 2
		BTST	#KCB_STRING,D3
		BNE.S	1$			; set up string from here
a346 6
1$
		MOVE.L	A3,D5
		EXT.W	D1
		ADD.W	D1,D5
		MOVEQ	#0,D4
		BRA.S	simpleString
d371 1
a371 1
		BEQ.S	haveDeadIndex	;   zero: we've got all we're going to
d375 1
a375 1
		BEQ.S	haveDeadIndex	; zero: second dead key is useless
d386 1
a386 5

haveDeadIndex:
		BTST	#KCB_STRING,D3	; check how to use dead index
		BNE	simpleString	;   as a string index
		BRA	indexedByte	;   or as a byte index
@
