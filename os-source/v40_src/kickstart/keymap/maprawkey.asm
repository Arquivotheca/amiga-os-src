**
**	$Id: maprawkey.asm,v 36.12 92/09/17 15:17:42 darren Exp $
**
**      keymap IECLASS_RAWKEY to ANSI conversion
**
**      (C) Copyright 1985,1989 Commodore-Amiga, Inc.
**          All Rights Reserved
**

	SECTION	keymap

*------ Included Files -----------------------------------------------

	INCLUDE	"kldata.i"

	INCLUDE	"devices/inputevent.i"


*------ Exported Names -----------------------------------------------

	XDEF	MapRawKey


******* keymap.library/MapRawKey *************************************
*
*   NAME
*	MapRawKey -- Decode single raw key input event to an ANSI
*	             string. (V36)
*
*   SYNOPSIS
*	actual = MapRawKey(event, buffer, length, keyMap)
*	D0                 A0     A1      D1      A2
*
*	WORD MapRawKey( struct InputEvent *, STRPTR, WORD,
*	    struct Keymap * );
*
*   FUNCTION
*	This console function converts input events of type
*	IECLASS_RAWKEY to ANSI bytes, based on the keyMap, and
*	places the result into the buffer.
*
*   INPUTS
*	event -  an InputEvent structure pointer.  The event list is
*	    not traversed.
*	buffer - a byte buffer large enough to hold all anticipated
*	    characters generated by this conversion.
*	length - maximum anticipation, i.e. the buffer size in bytes.
*	keyMap - a KeyMap structure pointer, or null if the default
*	    key map is to be used.
*
*   RESULT
*	actual - the number of characters in the buffer, or -1 if
*	    a buffer overflow was about to occur.
*
*   EXAMPLE
*	...
*	#define	BUFFERLEN	80	\* length of longest expected mapping \*
*	char buffer[BUFFERLEN];
*	struct InputEvent ie;
*	...
*	    KeymapBase = OpenLibrary("keymap.library", 0);
*	    ...
*	    ie.ie_Class = IECLASS_RAWKEY;
*	    ie.ie_SubClass = 0;
*	    for (;;) {
*		WaitPort(window->UserPort);
*		while (im = (struct IntuiMessage *) GetMsg(window->UserPort)) {
*		    switch (im->Class) {
*			case RAWKEY:
*			    ie.ie_Code = im->Code;
*			    ie.ie_Qualifier = im->Qualifier;
*			    \* recover dead key codes & qualifiers *\
*			    ie.ie_EventAddress = (APTR *) *((ULONG *)im->IAddress);
*			    actual = MapRawKey(&ie, buffer, BUFFERLEN, 0);
*			    for (i = 0; i < actual; i++)
*				ReportChar(buffer[i]);
*			    break;
*			...
*		    }
*		    ...
*		}
*	    }
*
*   ERRORS
*	if actual is -1, a buffer overflow condition was detected.
*	Not all of the characters in the buffer are valid.
*
*   SEE ALSO
*	devices/inputevent.h, devices/keymap.h
*
**********************************************************************


*   Both the previous down and the previous previous down keycode are kept for
*   translation.  Double dead keys *can* use both.  If a dead key has effect
*   in the double old (previous previous) position, it not only has an index
*   (i.e. the value in the low nibble under DP_2DINDEXMASK), but also
*   1.  flags that it can be effective in the double old position by having
*       a value in the high nibble (shifted into place with DP_2DFACSHIFT).
*   2.  holds the total number of dead keys + 1 in the keymap in the high
*       nibble so that that number can be used as a factor in accessing the
*       dead keys.
*   Once you've figured out this is a double dead qualifier, you end up
*   multiplying the two nibbles together to get a second (double dead
*   contribution) offset into the dead key translation table.  This table
*   has <number of dead keys+1> times <number of double dead keys+1> entries,
*   arranged in <number of double dead keys+1> rows of <number of dead keys+1>
*   entries.

MapRawKey:
		MOVEM.L D2/A2,-(A7)
		MOVE.L	D1,D2		; save maximum buffered
		MOVE.L	A2,D0		; check keyMap
		BNE.S	convertIt
		move.l	kl_KMDefault(a6),a2

convertIt:
	;-- check if this is a raw keycode to begin with
		MOVEQ	#0,D0		; show nothing buffered
		CMP.B	#IECLASS_RAWKEY,ie_Class(A0)
		bne.s  	rcRts

		movem.w	ie_Code(a0),d0/d1
		BSR.S	convertKey

rcRts:
		MOVEM.L (A7)+,D2/A2
		RTS


;------	convertKey ---------------------------------------------------
;
;	D0	ie_Code
;	D1	ie_Qualifier
;	D2	bufferSize (zero, look for dead keys, is only used in recursion)
;	A0	input event (only used at top level of recursion)
;	A1	buffer
;	A2	keyMap
;
;   RESULT
;	D0	buffer actual: -1 if overflow
;	D1	dead key index associated w/ this code if non-zero
;	A0	input event (unchanged)
;	A1	updated buffer address
;
convertKey:
		MOVEM.L	D2-D7/A2-A5,-(A7)
		MOVE.W	D0,D6
		MOVE.W	D1,D7
		MOVE.L	D2,A4
		MOVE.L	A2,A5		; working keymap
		AND.W	#~IECODE_UP_PREFIX,D0
		CMP.W	#IECODE_KEY_CODE_LAST,D0
		BHI	nullConvert	; don't handle communications
		MOVE.W	D0,D4		; get keycode bit index
		MOVE.W	D0,D5		;
		AND.W	#$00007,D4	;
		LSR.W	#3,D5		;
		AND.W	#$00007,D5	;   lose part associated w/ > $40

	;-- check keycode conversion type

		CMPI.W	#$40,D0
	IFNE	km_LoKeyMapTypes
	FAIL	"km_LoKeyMapTypes is not zero, need to explicitly LEA it."
	ENDC
		BLT.S	checkRepeat
		LEA	km_HiKeyMapTypes(A5),A5

checkRepeat:
		BTST	#IEQUALIFIERB_REPEAT,D7
		BEQ.S	buildType
		MOVE.L	km_LoRepeatable(A5),A3
		BTST	D4,0(A3,D5.W)
		BEQ	nullConvert

buildType:
		MOVE.L	(A5),A3		; km_LoKeyMapTypes(a5)
		MOVE.W	D0,D1
		ANDI.W	#$03F,D1
		MOVE.B	0(A3,D1.W),D2
	    ;------ check if the type of key is nop
		BTST	#KCB_NOP,D2
		BNE	nullConvert
	;------ build type bits
		MOVEQ	#0,D3
	    ;------ check if the key is an up transition
		CMP.W	D6,D0
		BEQ.S	chkShift
	    ;---------- an up transition
		BTST	#KCB_DOWNUP,D2
		BEQ	nullConvert		; only want down reports
		ADDQ.W	#KCF_DOWNUP,D3
chkShift:
		MOVE.W	D7,D0
		AND.W	#IEQUALIFIER_LSHIFT+IEQUALIFIER_RSHIFT,D0
		BEQ.S	chkAlt
		ADDQ.W	#KCF_SHIFT,D3
chkAlt:
		MOVE.W	D7,D0
		AND.W	#IEQUALIFIER_LALT+IEQUALIFIER_RALT,D0
		BEQ.S	chkCaps
		ADDQ.W	#KCF_ALT,D3
chkCaps:
	    ;------ check if key affected by caps lock
		BTST	#IEQUALIFIERB_CAPSLOCK,D7
		BEQ.S	chkCtrl
		MOVE.L	km_LoCapsable(A5),A3
		BTST	D4,0(A3,D5.W)
		BEQ.S	chkCtrl
		OR.W	#KCF_SHIFT,D3			; ensure shift bit
chkCtrl:
		BTST	#IEQUALIFIERB_CONTROL,D7
		BEQ.S	getMap
	    ;---------- the control key is set
		ADDQ.W	#KCF_CONTROL,D3

getMap:
		MOVE.L	km_LoKeyMap(A5),A3
		LSL	#2,D1			; make a long offset
		MOVE.L	0(A3,D1.W),D5

		;------	get the index within the map entry based on the state
		;	of those qualifier bits that affect this map lookup
		MOVEQ	#0,D4			; resulting index
		MOVEQ	#0,D0			; bit to test
		MOVEQ	#1,D1			; weight of bit
1$
		BTST	D0,D2			; check if this bit significant
		BEQ.S	3$			;   (no)
		BTST	D0,D3			; check if this bit set in qual
		BEQ.S	2$			;   (no)
		ADD.W	D1,D4			; update index
2$
		ADD.W	D1,D1			; double the weight
3$
		ADDQ.W	#1,D0			; increment the bit to test
		CMP.W	#4,D0
		BLT.S	1$

	    ;------ figure out how to interpret this
		BCLR	#KCB_DEAD,D2
		BNE	deadHead

		BTST	#KCB_STRING,D2		; check for string offsets
		BNE.S	simpleString

		CMPI.B	#KC_VANILLA,D2
		BEQ.S	vanillaKey

		CMP.W	#4,D1			; check index weight
		BLE.S	indexedRotate

indexedByte:
		;------ indirect indexed byte
		MOVE.L	D5,A3
		MOVE.B	0(A3,D4.W),D5		; get the byte at the offset
		BRA.S	gotByte

indexedRotate:
		;------ indexed byte from long word already gotten
		LSL	#3,D4			; rotation for indexed word
		ROR.L	D4,D5
		BRA.S	gotByte

vanillaKey:
		;------ get the key value as a vanilla byte
		LSL	#3,D4
		ROR.L	D4,D5
		BTST	#KCB_CONTROL,D3	; check ctrl key
		BEQ.S	gotByte

		MOVEQ	#3,D0
chkCtrlable:
		MOVE.B	D5,D1		; check if code is ctrlable
		AND.W	#$C0,D1		;
		CMP.W	#$40,D1		;
		BEQ.S	haveCtrl	;   yes, use it
		ROR.L	#8,D5		;   no, try the next
		DBF	D0,chkCtrlable
		BRA.S	gotByte		; use original key

haveCtrl:
		AND.W	#$1F,D5		; mask to control code
		BTST	#KCB_ALT,D3	;   check if ALT control
		BEQ.S	gotByte
		OR.W	#$80,D5		; set ALT control

gotByte:
		MOVE.L	A4,D0
		BEQ.S	buffOverflow	; (after all that time!)
		MOVE.B	D5,(A1)+
		MOVEQ	#1,D0
		BRA.S	endStdConvert

buffOverflow:
		MOVEQ	#-1,D0		; show overflow
		BRA.S	endStdConvert

		;------ get the key stream as a string
simpleString:
		BSR.S	twinBytes
		CMP.L	A4,D0
		BGT.S	buffOverflow		;   not enough buffer
		EXT.W	D1			; sign extend offset
		ADD.W	D1,A3			;
		MOVE.W	D0,D1
		BRA.S	2$
1$
		MOVE.B	(A3)+,(A1)+
2$
		DBF	D1,1$
		BRA.S	endStdConvert

nullConvert:
		MOVEQ	#0,D0

endStdConvert:
		MOVEQ	#0,D1

endConvert:
		MOVEM.L	(A7)+,D2-D7/A2-A5
		RTS


twinBytes:
		ADD.W	D4,D4			; offsets are two bytes
		MOVE.L	D5,A3
		MOVEQ	#0,D0
		MOVEQ	#0,D1
		MOVE.B	0(A3,D4),D0		; length | deadhead
		MOVE.B	1(A3,D4),D1		; offset | data
		RTS

deadHead:
		BSR.S	twinBytes

		BTST	#DPB_DEAD,D0
		BNE.S	deadDead

		BTST	#DPB_MOD,D0
		BNE.S	deadMod

		;------ this qualifier not associated with 'deadness'
		MOVE.B	D1,D5
		BRA.S	gotByte

deadDead:
		;------ just return the dead index
		MOVEQ	#0,D0
		BRA.S	endConvert

deadMod:
		;------ this is the biggie, recurse! recurse!
		MOVE.L	A4,D0
		BEQ.S	buffOverflow	; (after all that time!)

		MOVE.L	A3,D5		; construct new origin
		EXT.W	D1		;
		EXT.L	D1
		ADD.L	D1,D5		;

		MOVEQ	#0,D4		; index is going to be dead stuff

		MOVEQ	#0,D0		; get most recent dead candidate
		MOVE.B	ie_X(A0),D0	;   code
		MOVEQ	#0,D1		;   &
		MOVE.B	ie_X+1(A0),D1	;   low byte of qualifier
		MOVEQ	#0,D2		; show no conversion buffer
		BSR	convertKey	; recurse!
		TST.W	D1		; check for dead index
		beq	indexedByte	;   zero: we've got all we're going to
		MOVE.W	D1,D4		; save index
		AND.W	#DP_2DINDEXMASK,D4
		LSR.W	#DP_2DFACSHIFT,D1
		beq	indexedByte	; zero: second dead key is useless
		MULU	D1,D4		; multiply index times the factor

		MOVEQ	#0,D0		; get less recent dead candidate
		MOVE.B	ie_Y(A0),D0	;   code
		MOVEQ	#0,D1		;   &
		MOVE.B	ie_Y+1(A0),D1	;   low byte of qualifier
		MOVEQ	#0,D2		; show no conversion buffer
		BSR	convertKey	; recurse!
		AND.W	#DP_2DINDEXMASK,D1
		ADD.W	D1,D4		; add it to index already got
		bra	indexedByte

	END
