
/* Code generated by Toolmaker V1.13 */

#include <stdlib.h>
#include <exec/types.h>
#include <intuition/intuition.h>
#include <intuition/gadgetclass.h>
#include <libraries/gadtools.h>
#include <exec/memory.h>
#include <graphics/view.h>
#include <graphics/displayinfo.h>

#include "CAMDPrefs.h"

#include <clib/exec_protos.h>
#include <clib/intuition_protos.h>
#include <clib/gadtools_protos.h>

#include <pragmas/exec_pragmas.h>
#include <pragmas/intuition_pragmas.h>
#include <pragmas/gadtools_pragmas.h>

static BOOL TM_WindowSignal(struct TMData *);
static VOID TM_RemoveWindow(struct TMWindowInfo *);
static BOOL WindowIDCMP_MIDIPREF(struct TMData *, struct IntuiMessage *);

UWORD WaitPointer[36] =
  {
  0x0000, 0x0000,
  0x0400, 0x07C0,
  0x0000, 0x07C0,
  0x0100, 0x0380,
  0x0000, 0x07E0,
  0x07C0, 0x1FF8,
  0x1FF0, 0x3FEC,
  0x3FF8, 0x7FDE,
  0x3FF8, 0x7FBE,
  0x7FFC, 0xFF7F,
  0x7EFC, 0xFFFF,
  0x7FFC, 0xFFFF,
  0x3FF8, 0x7FFE,
  0x3FF8, 0x7FFE,
  0x1FF0, 0x3FFC,
  0x07C0, 0x1FF8,
  0x0000, 0x07E0,
  0x0000, 0x0000,
  };

struct NewMenu newmenu_MIDIPREF[] =
  {
  {NM_TITLE, (UBYTE *)MENUTEXT_PROJECT,	NULL,	0,	0,	NULL},
  {NM_ITEM,  (UBYTE *)ITEMTEXT_OPEN,	(UBYTE *)"O",	0,	0,	(APTR) &tmobjectdata_OPEN},
  {NM_ITEM,  (UBYTE *)ITEMTEXT_SAVEAS,	(UBYTE *)"A",	0,	0,	(APTR) &tmobjectdata_SAVEAS},
  {NM_ITEM,  NM_BARLABEL,	NULL,	0,	0,	NULL},
  {NM_ITEM,  (UBYTE *)ITEMTEXT_ABOUT,	NULL,	0,	0,	(APTR) &tmobjectdata_ABOUT},
  {NM_ITEM,  NM_BARLABEL,	NULL,	0,	0,	NULL},
  {NM_ITEM,  (UBYTE *)ITEMTEXT_QUIT,	(UBYTE *)"Q",	0,	0,	(APTR) &tmobjectdata_QUIT},
  {NM_TITLE, (UBYTE *)MENUTEXT_EDIT,	NULL,	0,	0,	NULL},
  {NM_ITEM,  (UBYTE *)ITEMTEXT_RESET,	(UBYTE *)"D",	0,	0,	(APTR) &tmobjectdata_RESET},
  {NM_ITEM,  (UBYTE *)ITEMTEXT_LASTSAVE,	(UBYTE *)"L",	0,	0,	(APTR) &tmobjectdata_LASTSAVE},
  {NM_ITEM,  (UBYTE *)ITEMTEXT_RESTORE,	(UBYTE *)"R",	0,	0,	(APTR) &tmobjectdata_RESTORE},
  {NM_TITLE, (UBYTE *)MENUTEXT_SETTINGS,	NULL,	0,	0,	NULL},
  {NM_ITEM,  (UBYTE *)ITEMTEXT_ICONS,	(UBYTE *)"I",	CHECKIT | CHECKED | MENUTOGGLE,	0,	(APTR) &tmobjectdata_ICONS},
  {NM_END,   NULL,	NULL,	0,	0,	NULL}
  };


struct TextAttr topaz8 =
  {
  (STRPTR)"topaz.font",
  8,
  FS_NORMAL,
  0x0
  };

/****** CAMDPrefs_tm.c/TM_Request *****************************
*
*   NAME
*	TM_Request -- display a message in a system requester.
*
*   SYNOPSIS
*	num = TM_Request(Window, Title, TextFormat, GadgetFormat,
*	                 IDCMP_ptr, Arg1, Arg2, ...)
*
*	LONG TM_Request(struct Window *, UBYTE *, UBYTE *, UBYTE *,
*	                ULONG *, APTR, ...);
*
*   FUNCTION
*	Calls EasyRequestArgs to display a message in a system
*	requester without having to fill in an EasyStruct structure.
*	This function uses a varargs calling convention.
*
*	EasyRequestArgs has the capability to display more than one
*	gadget by separating the GadgetText with the '|' character.
*	Also printf style formatting may be used in the TextFormat
*	and GadgetFormat strings.  The formatting arguments should
*	be added first for the TextFormat, then for the GadgetFormat.
*
*   INPUTS
*	Window = pointer to window (passed to EasyRequestArgs()).
*	Title = title bar string (passed to EasyRequestArgs()).
*	TextFormat = body text (passed to EasyRequestArgs()).
*	GadgetFormat = gadget text (passed to EasyRequestArgs()).
*	IDCMP_ptr = IDCMP value (passed to EasyRequestArgs()).
*	Args = arguments (passed to EasyRequestArgs()).
*
*   RESULT
*	num = gadget number returned by EasyRequestArgs().
*
*   EXAMPLE
*	To display a requester with two choices:
*
*	result = TM_Request(NULL, "Question", "Are you sure?",
*	                    "OK|Cancel", NULL, NULL);
*
*   NOTES
*	The intuition library must be open before calling this
*	function.
*
*   BUGS
*
*   SEE ALSO
*	intuition.library/EasyRequestArgs()
*
**************************************************************
*
*/
LONG TM_Request(struct Window *Window, UBYTE *Title, UBYTE *TextFormat, UBYTE *GadgetFormat, ULONG *IDCMP_ptr, APTR Arg1, ...)
  {
  struct EasyStruct es;

  es.es_StructSize = sizeof(struct EasyStruct);
  es.es_Flags = 0;
  es.es_Title = Title;
  es.es_TextFormat = TextFormat;
  es.es_GadgetFormat = GadgetFormat;

  return(EasyRequestArgs(Window, &es, IDCMP_ptr, &Arg1));
  }

/****** CAMDPrefs_tm.c/TM_Open *****************************
*
*   NAME
*	TM_Open -- initialize user-interface data.
*
*   SYNOPSIS
*	TMData = TM_Open(ErrorCode)
*
*	struct TMData *TM_Open(ULONG *error);
*
*   FUNCTION
*	Creates an initializes a TMData structure.  This
*	includes allocating memory for a TMData structure,
*	creating a message port for window IDCMP messages,
*	and opening any fonts on disk.
*
*   INPUTS
*	error = pointer to ULONG to store an error number.
*	        Error numbers are defined in the _tm.h file.
*
*   RESULT
*	TMData = pointer to an initialized TMData structure
*	         or NULL if an error occurred.
*
*   EXAMPLE
*	if(!(TMData = TM_Open(&error)))
*	  {
*	  switch(error)
*	    {
*	    case TMERR_MEMORY:
*	      TM_Request(NULL, "Error", "Out of memory", "Abort", NULL, NULL);
*	      break;
*	    case TMERR_MSGPORT:
*	      TM_Request(NULL, "Error", "Error creating\nmessage port", "Abort", NULL, NULL);
*	      break;
*	    }
*	  CleanExit(NULL, RETURN_FAIL);
*	  }
*
*   NOTES
*	The intuition and gadtools libraries must be open before
*	calling this function.  If any fonts other than topaz 8
*	and topaz 9 are used, the diskfont and graphics libraries
*	must also be open.
*
*   BUGS
*
*   SEE ALSO
*	TM_Close()
*
**************************************************************
*
*/
struct TMData *TM_Open(ULONG *error)
  {
  struct TMData *tmdata;

  if(tmdata = AllocMem(sizeof(struct TMData), MEMF_CLEAR))
    {
    tmdata->Size = sizeof(struct TMData);

    if(tmdata->WaitPointer = AllocMem(36*sizeof(UWORD), MEMF_CHIP))
      {
      CopyMem(WaitPointer, tmdata->WaitPointer, 36*sizeof(UWORD));

      if(tmdata->WindowMsgPort = CreateMsgPort())
        {
        *error = TMERR_OK;
        return(tmdata);
        }
      else
        {
        *error = TMERR_MSGPORT;
        }
      FreeMem(tmdata->WaitPointer, 36*sizeof(UWORD));
      }
    else
      {
      *error = TMERR_MEMORY;
      }
    FreeMem(tmdata, sizeof(struct TMData));
    }
  else
    {
    *error = TMERR_MEMORY;
    }

  return(NULL);
  }

/****** CAMDPrefs_tm.c/TM_Close *****************************
*
*   NAME
*	TM_Close -- frees user-interface data.
*
*   SYNOPSIS
*	TM_Close(TMData)
*
*	VOID TM_Close(struct TMData *TMData);
*
*   FUNCTION
*	Frees resources allocated by TM_Open().
*
*   INPUTS
*	TMData = pointer to TMData structure returned by TM_Open.
*
*   RESULT
*
*   EXAMPLE
*	if(TMData) TM_Close(TMData);
*
*   NOTES
*
*   BUGS
*
*   SEE ALSO
*	TM_Open()
*
**************************************************************
*
*/
VOID TM_Close(struct TMData *TMData)
  {
  if(TMData)
    {
    if(TMData->WindowMsgPort) DeleteMsgPort(TMData->WindowMsgPort);
    if(TMData->WaitPointer) FreeMem(TMData->WaitPointer, 36*sizeof(UWORD));
    FreeMem(TMData, TMData->Size);
    }
  }

/****** CAMDPrefs_tm.c/TM_EventLoop *****************************
*
*   NAME
*	TM_EventLoop -- waits for all events.
*
*   SYNOPSIS
*	TM_EventLoop(TMData)
*
*	VOID TM_EventLoop(struct TMData *);
*
*   FUNCTION
*	Waits for any events to signal program.  All IDCMP, ARexx,
*	and a user signal messages received are sent to the
*	appropriate signal function.  A return value of TRUE from
*	any of the signal functions will terminate the loop.
*
*   INPUTS
*	TMData = pointer to TMData structure returned by TM_Open.
*
*   RESULT
*
*   EXAMPLE
*	TM_EventLoop(TMData);
*
*   NOTES
*	An event signal must be set up before calling TM_EventLoop.
*	Either a window must be open, the SimpleRexx option selected,
*	or a user signal set up.
*
*   BUGS
*
*   SEE ALSO
*	TM_WindowSignal(), TM_ARexxSignal(), exec.library/Wait()
*
**************************************************************
*
*/
VOID TM_EventLoop(struct TMData *TMData)
  {
  BOOL done=FALSE, result;
  ULONG windowsignal, signals;

  windowsignal = 1L << TMData->WindowMsgPort->mp_SigBit;

  while(!done)
    {
    signals = Wait(windowsignal);

    if(signals & windowsignal)
      {
      if(result = TM_WindowSignal(TMData)) done = result;
      }
    }
  }

/****** CAMDPrefs_tm.c/OpenScreen_Workbench *****************************
*
*   NAME
*	OpenScreen_Workbench -- Use the default public screen.
*
*   SYNOPSIS
*	success = OpenScreen_Workbench(TMData)
*
*	BOOL OpenScreen_Workbench(struct TMData *);
*
*   FUNCTION
*	Locks the default public screen and gets its visual info.  If the
*	screen was already locked, it will be brought to front.
*
*   INPUTS
*	TMData = pointer to the TMData structure returned by TM_Open.
*
*   RESULT
*	success = TRUE if command was successfully completed.
*	          FALSE if not.
*
*   EXAMPLE
*	if(!(OpenScreen_Workbench(TMData)))
*	  {
*	  TM_Request(NULL, "Error", "Error opening screen", "Abort", NULL, NULL);
*	  CleanExit(TMData, RETURN_FAIL);
*	  }
*
*   NOTES
*
*   BUGS
*
*   SEE ALSO
*	CloseScreen_Workbench()
*
**************************************************************
*
*/
BOOL OpenScreen_Workbench(struct TMData *TMData)
  {
  if(ScreenInfo_Workbench.Screen)
    {
    ScreenToFront(ScreenInfo_Workbench.Screen);
    return(TRUE);
    }
  else
    {
    if(ScreenInfo_Workbench.Screen = LockPubScreen(NULL))
      {
      if(ScreenInfo_Workbench.VisualInfo = GetVisualInfo(ScreenInfo_Workbench.Screen, TAG_DONE))
        {
        return(TRUE);
        }
      UnlockPubScreen(NULL, ScreenInfo_Workbench.Screen);
      }
    }

  return(FALSE);
  }

/****** CAMDPrefs_tm.c/CloseScreen_Workbench *****************************
*
*   NAME
*	CloseScreen_Workbench -- Free the default public screen.
*
*   SYNOPSIS
*	CloseScreen_Workbench(TMData)
*
*	VOID CloseScreen_Workbench(struct TMData *);
*
*   FUNCTION
*	Unlocks the default public screen and frees the visual info.
*	It's ok to re-close a screen that is already closed.
*
*   INPUTS
*	TMData = pointer to the TMData structure returned by TM_Open.
*
*   RESULT
*
*   EXAMPLE
*	CloseScreen_Workbench(TMData);
*
*   NOTES
*
*   BUGS
*
*   SEE ALSO
*	OpenScreen_Workbench()
*
**************************************************************
*
*/
VOID CloseScreen_Workbench(struct TMData *TMData)
  {
  if(ScreenInfo_Workbench.VisualInfo)
    {
    FreeVisualInfo(ScreenInfo_Workbench.VisualInfo);
    ScreenInfo_Workbench.VisualInfo = NULL;
    }
  if(ScreenInfo_Workbench.Screen)
    {
    UnlockPubScreen(NULL, ScreenInfo_Workbench.Screen);
    ScreenInfo_Workbench.Screen = NULL;
    }
  }

/****** CAMDPrefs_tm.c/OpenWindow_MIDIPREF *****************************
*
*   NAME
*	OpenWindow_MIDIPREF -- Open window "MIDIPREF".
*
*   SYNOPSIS
*	success = OpenWindow_MIDIPREF(TMData)
*
*	BOOL OpenWindow_MIDIPREF(struct TMData *);
*
*   FUNCTION
*	Opens the window with label "MIDIPREF"
*	along with any gadgets it contains.  If the window was already
*	open, it will be brought to front.
*
*   INPUTS
*	TMData = pointer to the TMData structure returned by TM_Open.
*
*   RESULT
*	success = TRUE if command was successfully completed.
*	          FALSE if not.
*
*   EXAMPLE
*	if(!OpenWindow_MIDIPREF(TMData))
*	  {
*	  TMRequest(NULL, "Error", "Error opening window", "Abort", NULL, NULL);
*	  CleanExit(TMData, RETURN_FAIL);
*	  }
*   NOTES
*
*   BUGS
*
*   SEE ALSO
*	CloseWindow_MIDIPREF()
*
**************************************************************
*
*/
BOOL OpenWindow_MIDIPREF(struct TMData *TMData)
  {
  ULONG lasttag;
  struct NewGadget ng;

  if(WindowInfo_MIDIPREF.Window)
    {
    WindowToFront(WindowInfo_MIDIPREF.Window);
    ActivateWindow(WindowInfo_MIDIPREF.Window);
    return(TRUE);
    }
  else
    {
    WindowInfo_MIDIPREF.FirstGadget = NULL;
    WindowInfo_MIDIPREF.ContextGadget = CreateContext(&WindowInfo_MIDIPREF.FirstGadget);

    ng.ng_VisualInfo = ScreenInfo_Workbench.VisualInfo;

    ng.ng_LeftEdge = 214;
    ng.ng_TopEdge = 49+ScreenInfo_Workbench.Screen->BarHeight;
    ng.ng_Width = 32;
    ng.ng_Height = 18;
    ng.ng_Flags = PLACETEXT_IN;
    ng.ng_TextAttr = &topaz8;
    ng.ng_GadgetText = (UBYTE *)GADGETTEXT_DESELECT;
    ng.ng_GadgetID = ID_DESELECT;
    ng.ng_UserData = (APTR) &tmobjectdata_DESELECT;
    lasttag = GadgetInfo_DESELECT.MoreTags ? TAG_MORE : TAG_DONE;
    GadgetInfo_DESELECT.Gadget = CreateGadget(BUTTON_KIND, WindowInfo_MIDIPREF.ContextGadget, &ng,
		lasttag, GadgetInfo_DESELECT.MoreTags);

    ng.ng_TopEdge = 21+ScreenInfo_Workbench.Screen->BarHeight;
    ng.ng_GadgetText = (UBYTE *)GADGETTEXT_SELECT;
    ng.ng_GadgetID = ID_SELECT;
    ng.ng_UserData = (APTR) &tmobjectdata_SELECT;
    lasttag = GadgetInfo_SELECT.MoreTags ? TAG_MORE : TAG_DONE;
    GadgetInfo_SELECT.Gadget = CreateGadget(BUTTON_KIND, GadgetInfo_DESELECT.Gadget, &ng,
		lasttag, GadgetInfo_SELECT.MoreTags);

    ng.ng_LeftEdge = 252;
    ng.ng_TopEdge = 15+ScreenInfo_Workbench.Screen->BarHeight;
    ng.ng_Width = 196;
    ng.ng_Height = 64;
    ng.ng_Flags = PLACETEXT_ABOVE;
    ng.ng_GadgetText = (UBYTE *)GADGETTEXT_DRIVERSI;
    ng.ng_GadgetID = ID_DRIVERSI;
    ng.ng_UserData = (APTR) &tmobjectdata_DRIVERSI;
    lasttag = GadgetInfo_DRIVERSI.MoreTags ? TAG_MORE : TAG_DONE;
    GadgetInfo_DRIVERSI.Gadget = CreateGadget(LISTVIEW_KIND, GadgetInfo_SELECT.Gadget, &ng,
		GTLV_ShowSelected, 0,
		lasttag, GadgetInfo_DRIVERSI.MoreTags);

    ng.ng_LeftEdge = 399;
    ng.ng_TopEdge = 95+ScreenInfo_Workbench.Screen->BarHeight;
    ng.ng_Width = 49;
    ng.ng_Height = 14;
    ng.ng_Flags = PLACETEXT_LEFT;
    ng.ng_GadgetText = (UBYTE *)GADGETTEXT_SYSEXQUE;
    ng.ng_GadgetID = ID_SYSEXQUE;
    ng.ng_UserData = (APTR) &tmobjectdata_SYSEXQUE;
    lasttag = GadgetInfo_SYSEXQUE.MoreTags ? TAG_MORE : TAG_DONE;
    GadgetInfo_SYSEXQUE.Gadget = CreateGadget(INTEGER_KIND, GadgetInfo_DRIVERSI.Gadget, &ng,
		GA_Disabled, TRUE,
		GTIN_Number, 2048,
		STRINGA_Justification, GACT_STRINGRIGHT,
		lasttag, GadgetInfo_SYSEXQUE.MoreTags);

    ng.ng_TopEdge = 79+ScreenInfo_Workbench.Screen->BarHeight;
    ng.ng_GadgetText = (UBYTE *)GADGETTEXT_MSGQUEUS;
    ng.ng_GadgetID = ID_MSGQUEUS;
    ng.ng_UserData = (APTR) &tmobjectdata_MSGQUEUS;
    lasttag = GadgetInfo_MSGQUEUS.MoreTags ? TAG_MORE : TAG_DONE;
    GadgetInfo_MSGQUEUS.Gadget = CreateGadget(INTEGER_KIND, GadgetInfo_SYSEXQUE.Gadget, &ng,
		GA_Disabled, TRUE,
		GTIN_Number, 512,
		STRINGA_Justification, GACT_STRINGRIGHT,
		lasttag, GadgetInfo_MSGQUEUS.MoreTags);

    ng.ng_LeftEdge = 362;
    ng.ng_TopEdge = 133+ScreenInfo_Workbench.Screen->BarHeight;
    ng.ng_Width = 86;
    ng.ng_Flags = PLACETEXT_IN;
    ng.ng_GadgetText = (UBYTE *)GADGETTEXT_CANCEL;
    ng.ng_GadgetID = ID_CANCEL;
    ng.ng_UserData = (APTR) &tmobjectdata_CANCEL;
    lasttag = GadgetInfo_CANCEL.MoreTags ? TAG_MORE : TAG_DONE;
    GadgetInfo_CANCEL.Gadget = CreateGadget(BUTTON_KIND, GadgetInfo_MSGQUEUS.Gadget, &ng,
		lasttag, GadgetInfo_CANCEL.MoreTags);

    ng.ng_LeftEdge = 188;
    ng.ng_Width = 84;
    ng.ng_GadgetText = (UBYTE *)GADGETTEXT_USE;
    ng.ng_GadgetID = ID_USE;
    ng.ng_UserData = (APTR) &tmobjectdata_USE;
    lasttag = GadgetInfo_USE.MoreTags ? TAG_MORE : TAG_DONE;
    GadgetInfo_USE.Gadget = CreateGadget(BUTTON_KIND, GadgetInfo_CANCEL.Gadget, &ng,
		lasttag, GadgetInfo_USE.MoreTags);

    ng.ng_LeftEdge = 10;
    ng.ng_GadgetText = (UBYTE *)GADGETTEXT_SAVE;
    ng.ng_GadgetID = ID_SAVE;
    ng.ng_UserData = (APTR) &tmobjectdata_SAVE;
    lasttag = GadgetInfo_SAVE.MoreTags ? TAG_MORE : TAG_DONE;
    GadgetInfo_SAVE.Gadget = CreateGadget(BUTTON_KIND, GadgetInfo_USE.Gadget, &ng,
		lasttag, GadgetInfo_SAVE.MoreTags);

    ng.ng_LeftEdge = 76;
    ng.ng_TopEdge = 111+ScreenInfo_Workbench.Screen->BarHeight;
    ng.ng_Width = 172;
    ng.ng_Flags = PLACETEXT_LEFT;
    ng.ng_GadgetText = (UBYTE *)GADGETTEXT_COMMENT;
    ng.ng_GadgetID = ID_COMMENT;
    ng.ng_UserData = (APTR) &tmobjectdata_COMMENT;
    lasttag = GadgetInfo_COMMENT.MoreTags ? TAG_MORE : TAG_DONE;
    GadgetInfo_COMMENT.Gadget = CreateGadget(STRING_KIND, GadgetInfo_SAVE.Gadget, &ng,
		GA_Disabled, TRUE,
		GTST_MaxChars, 34,
		lasttag, GadgetInfo_COMMENT.MoreTags);

    ng.ng_LeftEdge = 110;
    ng.ng_TopEdge = 95+ScreenInfo_Workbench.Screen->BarHeight;
    ng.ng_Width = 138;
    ng.ng_GadgetText = (UBYTE *)GADGETTEXT_OUTPUTNA;
    ng.ng_GadgetID = ID_OUTPUTNA;
    ng.ng_UserData = (APTR) &tmobjectdata_OUTPUTNA;
    lasttag = GadgetInfo_OUTPUTNA.MoreTags ? TAG_MORE : TAG_DONE;
    GadgetInfo_OUTPUTNA.Gadget = CreateGadget(STRING_KIND, GadgetInfo_COMMENT.Gadget, &ng,
		GA_Disabled, TRUE,
		GTST_MaxChars, 32,
		lasttag, GadgetInfo_OUTPUTNA.MoreTags);

    ng.ng_TopEdge = 79+ScreenInfo_Workbench.Screen->BarHeight;
    ng.ng_GadgetText = (UBYTE *)GADGETTEXT_INPUTNAM;
    ng.ng_GadgetID = ID_INPUTNAM;
    ng.ng_UserData = (APTR) &tmobjectdata_INPUTNAM;
    lasttag = GadgetInfo_INPUTNAM.MoreTags ? TAG_MORE : TAG_DONE;
    GadgetInfo_INPUTNAM.Gadget = CreateGadget(STRING_KIND, GadgetInfo_OUTPUTNA.Gadget, &ng,
		GA_Disabled, TRUE,
		GTST_MaxChars, 32,
		lasttag, GadgetInfo_INPUTNAM.MoreTags);

    ng.ng_LeftEdge = 372;
    ng.ng_TopEdge = 111+ScreenInfo_Workbench.Screen->BarHeight;
    ng.ng_Width = 76;
    ng.ng_GadgetText = (UBYTE *)GADGETTEXT_IDSTRING;
    ng.ng_GadgetID = 0;
    ng.ng_UserData = NULL;
    lasttag = GadgetInfo_IDSTRING.MoreTags ? TAG_MORE : TAG_DONE;
    GadgetInfo_IDSTRING.Gadget = CreateGadget(TEXT_KIND, GadgetInfo_INPUTNAM.Gadget, &ng,
		GTTX_Border, TRUE,
		GTTX_Text, GTTX_Text_IDSTRING,
		lasttag, GadgetInfo_IDSTRING.MoreTags);

    ng.ng_LeftEdge = 12;
    ng.ng_TopEdge = 15+ScreenInfo_Workbench.Screen->BarHeight;
    ng.ng_Width = 196;
    ng.ng_Height = 64;
    ng.ng_Flags = PLACETEXT_ABOVE;
    ng.ng_GadgetText = (UBYTE *)GADGETTEXT_DRIVER;
    ng.ng_GadgetID = ID_DRIVER;
    ng.ng_UserData = (APTR) &tmobjectdata_DRIVER;
    lasttag = GadgetInfo_DRIVER.MoreTags ? TAG_MORE : TAG_DONE;
    GadgetInfo_DRIVER.Gadget = CreateGadget(LISTVIEW_KIND, GadgetInfo_IDSTRING.Gadget, &ng,
		GTLV_ShowSelected, 0,
		lasttag, GadgetInfo_DRIVER.MoreTags);

    if(GadgetInfo_DRIVER.Gadget)
      {
      lasttag = WindowInfo_MIDIPREF.MoreTags ? TAG_MORE : TAG_DONE;

      if((WindowInfo_MIDIPREF.Window = OpenWindowTags(NULL,
		WA_PubScreen, ScreenInfo_Workbench.Screen,
		WA_Title, WINDOWTEXT_MIDIPREF,
		WA_IDCMP, NULL,
		WA_Gadgets, WindowInfo_MIDIPREF.FirstGadget,
		WA_Left, 80,
		WA_Top, 45,
		WA_InnerWidth, 452,
		WA_InnerHeight, 149,
		WA_DragBar, TRUE,
		WA_DepthGadget, TRUE,
		WA_Activate, TRUE,
		WA_SimpleRefresh, TRUE,
		lasttag, WindowInfo_MIDIPREF.MoreTags)))
        {
        if((WindowInfo_MIDIPREF.Menu = CreateMenus(newmenu_MIDIPREF, TAG_DONE)))
          {
          if((LayoutMenus(WindowInfo_MIDIPREF.Menu, ScreenInfo_Workbench.VisualInfo, TAG_DONE)))
            {
            if((SetMenuStrip(WindowInfo_MIDIPREF.Window, WindowInfo_MIDIPREF.Menu)))
              {
              WindowInfo_MIDIPREF.Window->UserPort = TMData->WindowMsgPort;
              ModifyIDCMP(WindowInfo_MIDIPREF.Window,
			IDCMP_REFRESHWINDOW |
			BUTTONIDCMP |
			LISTVIEWIDCMP |
			INTEGERIDCMP |
			STRINGIDCMP |
			IDCMP_GADGETDOWN |
			IDCMP_GADGETUP |
			IDCMP_MENUPICK);
              GT_RefreshWindow(WindowInfo_MIDIPREF.Window, NULL);
              WindowInfo_MIDIPREF.Flags |= TMWF_OPENED;
              return(TRUE);
              }
            }
          FreeMenus(WindowInfo_MIDIPREF.Menu);
          }
        CloseWindow(WindowInfo_MIDIPREF.Window);
        }
      FreeGadgets(WindowInfo_MIDIPREF.FirstGadget);
      }
    }
  return(FALSE);
  }

/****** CAMDPrefs_tm.c/CloseWindow_MIDIPREF *****************************
*
*   NAME
*	CloseWindow_MIDIPREF -- Close window "MIDIPREF".
*
*   SYNOPSIS
*	CloseWindow_MIDIPREF(TMData)
*
*	VOID CloseWindow_MIDIPREF(struct TMData *);
*
*   FUNCTION
*	Closes the window with label "MIDIPREF"
*	and frees its resources.  It's ok to re-close a window
*	that is already closed.
*
*   INPUTS
*	TMData = pointer to the TMData structure returned by TM_Open.
*
*   RESULT
*
*   EXAMPLE
*
*   NOTES
*
*   BUGS
*
*   SEE ALSO
*	OpenWindow_MIDIPREF()
*
**************************************************************
*
*/
VOID CloseWindow_MIDIPREF(struct TMData *TMData)
  {
  TM_RemoveWindow(&WindowInfo_MIDIPREF);
  }

/****** CAMDPrefs_tm.c/DisableWindow_MIDIPREF *****************************
*
*   NAME
*	DisableWindow_MIDIPREF -- disable input to window "MIDIPREF".
*
*   SYNOPSIS
*	DisableWindow_MIDIPREF(TMData)
*
*	VOID DisableWindow_MIDIPREF(struct TMData *);
*
*   FUNCTION
*	Disables all input to window with label "MIDIPREF"
*	and changes its mouse pointer.
*
*   INPUTS
*	TMData = pointer to the TMData structure returned by TM_Open.
*
*   RESULT
*
*   EXAMPLE
*
*   NOTES
*
*   BUGS
*
*   SEE ALSO
*	EnableWindow_MIDIPREF()
*
**************************************************************
*
*/
VOID DisableWindow_MIDIPREF(struct TMData *TMData)
  {
  if((WindowInfo_MIDIPREF.DisableCount == 0) && (WindowInfo_MIDIPREF.Flags & TMWF_OPENED))
    {
    InitRequester(&WindowInfo_MIDIPREF.Requester);
    if(Request(&WindowInfo_MIDIPREF.Requester, WindowInfo_MIDIPREF.Window))
      {
      WindowInfo_MIDIPREF.Flags |= TMWF_DISABLED;
      SetPointer(WindowInfo_MIDIPREF.Window, TMData->WaitPointer, 16, 16, -6, 0);
      }
    }
  WindowInfo_MIDIPREF.DisableCount++;
  }

/****** CAMDPrefs_tm.c/EnableWindow_MIDIPREF *****************************
*
*   NAME
*	EnableWindow_MIDIPREF -- enable input to window "MIDIPREF".
*
*   SYNOPSIS
*	EnableWindow_MIDIPREF(TMData)
*
*	VOID EnableWindow_MIDIPREF(struct TMData *);
*
*   FUNCTION
*	Enables input to window with label "MIDIPREF"
*	and clears its mouse pointer.
*
*   INPUTS
*	TMData = pointer to the TMData structure returned by TM_Open.
*
*   RESULT
*
*   EXAMPLE
*
*   NOTES
*
*   BUGS
*
*   SEE ALSO
*	DisableWindow_MIDIPREF()
*
**************************************************************
*
*/
VOID EnableWindow_MIDIPREF(struct TMData *TMData)
  {
  WindowInfo_MIDIPREF.DisableCount--;
  if((WindowInfo_MIDIPREF.DisableCount == 0) && (WindowInfo_MIDIPREF.Flags & (TMWF_DISABLED | TMWF_OPENED)))
    {
    EndRequest(&WindowInfo_MIDIPREF.Requester, WindowInfo_MIDIPREF.Window);
    WindowInfo_MIDIPREF.Flags &= ~TMWF_DISABLED;
    ClearPointer(WindowInfo_MIDIPREF.Window);
    }
  }

static BOOL TM_WindowSignal(struct TMData *TMData)
  {
  BOOL done=FALSE;
  BOOL result;
  struct IntuiMessage *imessage;

  while(imessage = GT_GetIMsg(TMData->WindowMsgPort))
    {
    if(imessage->IDCMPWindow == WindowInfo_MIDIPREF.Window)
      {
      WindowInfo_MIDIPREF.GT_IMsg = imessage;
      if(result = WindowIDCMP_MIDIPREF(TMData, imessage)) done = result;
      if(WindowInfo_MIDIPREF.GT_IMsg)
        {
        GT_ReplyIMsg(WindowInfo_MIDIPREF.GT_IMsg);
        WindowInfo_MIDIPREF.GT_IMsg = NULL;
        }
      }
    }

  return(done);
  }

static BOOL WindowIDCMP_MIDIPREF(struct TMData *TMData, struct IntuiMessage *imessage)
  {
  BOOL done=FALSE;
  BOOL result;

  switch(imessage->Class)
    {
    case IDCMP_REFRESHWINDOW:
      GT_BeginRefresh(WindowInfo_MIDIPREF.Window);
      GT_EndRefresh(WindowInfo_MIDIPREF.Window, TRUE);
      break;

    case IDCMP_MENUPICK:
      if(result = Window_MIDIPREF_MENUPICK(TMData, imessage)) done = result;
      break;

    case IDCMP_GADGETDOWN:
      if(result = Window_MIDIPREF_GADGETDOWN(TMData, imessage)) done = result;
      break;

    case IDCMP_GADGETUP:
      if(result = Window_MIDIPREF_GADGETUP(TMData, imessage)) done = result;
      break;

    }

  return(done);
  }

static VOID TM_RemoveWindow(struct TMWindowInfo *TMWindowInfo)
  {
  struct IntuiMessage *imessage;
  struct Node *succ;

  if(TMWindowInfo->Window)
    {
    if(TMWindowInfo->Menu)
      {
      ClearMenuStrip(TMWindowInfo->Window);
      FreeMenus(TMWindowInfo->Menu);
      TMWindowInfo->Menu = NULL;
      }

    if(TMWindowInfo->GT_IMsg)
      {
      GT_ReplyIMsg(TMWindowInfo->GT_IMsg);
      TMWindowInfo->GT_IMsg = NULL;
      }

    if(TMWindowInfo->Window->UserPort)
      {
      Forbid();
      imessage = (struct IntuiMessage *) TMWindowInfo->Window->UserPort->mp_MsgList.lh_Head;
      while(succ = imessage->ExecMessage.mn_Node.ln_Succ)
        {
        if(imessage->IDCMPWindow == TMWindowInfo->Window)
          {
          Remove((struct Node *) imessage);
          ReplyMsg((struct Message *) imessage);
          }
        imessage = (struct IntuiMessage *) succ;
        }
      TMWindowInfo->Window->UserPort = NULL;
      ModifyIDCMP(TMWindowInfo->Window, 0L);
      Permit();
      }

    CloseWindow(TMWindowInfo->Window);
    TMWindowInfo->Window = NULL;
    TMWindowInfo->Flags = 0;
    }

  if(TMWindowInfo->FirstGadget)
    {
    FreeGadgets(TMWindowInfo->FirstGadget);
    TMWindowInfo->FirstGadget = NULL;
    }
  }

