TITLE	FDISK  -  COPYRIGHT (C) 1986 Commodore Electronics Limited
PAGE	60,132
;******************************************************************************
;
;	ADISK : THIS PROGRAM PERFORMS THE USER TO CREATE OR DELETE
;		AMIGA PARTITIONS ON FIXED DISK.
;
;		ADISK READS THE PARTITION TABLE (PAT) FROM THE FIRST
;		SECTOR OF THE FIXED DISK,
;		DISPLAYS IT,
;		ALTERS SOME BITS,
;		WRITES THE NEW PAT AT THE FIXED DISK AND
;		REBOOTS THE SYSTEM, IF SOMETHING CHANGE,
;		ELSE RETURNS PROGRAM CONTROL TO DOS.
;
; 	Update: 1.6.87 TB - correct calculation of last track
;
;******************************************************************************

CSEG	SEGMENT PARA PUBLIC 'CODE'
	ASSUME	CS:CSEG,DS:CSEG
	ASSUME	SS:CSEG,ES:CSEG 	;ALREADY SET BY DOS LOADER

	ORG	50H
DOS	LABEL	FAR			; VECTOR FOR DOS FUNCTION CALL

	ORG	100H			;SKIP TO END OF THE PSP
ENTRY:	JMP	START			;COM FILE ENTRY ALWAYS AT 100H
	DB	8,8,8,'ADISK  Rel. 1.3',1AH   ; REVISION


;******************************************************************************

INCLUDE 	ADISK.mes		; MESSAGE BLOCK
;INCLUDE	 STDREPLY.ASM		; USER REPLYS :  YES, NO, ...
yeschr	=  'y'
   
;******************************************************************************
;
;	PARTITION TABLE :  READ VIA INT 13;2

PAT	LABEL	BYTE			; SPACE FOR PARTITION TABLE
	DB	512 DUP (?)

PART0	LABEL	BYTE			; RESET PARTITION 
	DB	1			; INSTALLED (0/PART.NR.)
	DB	'N'			; AKTIVE (A/N)
	DB	'     ',0		; TYPE (" DOS "/"AMIGA"/"OTHER")
	DW	0			; START CYLINDER
	DW	0			; END CYLINDER
	DW	0			; PARTITION SIZE

PART1	LABEL	BYTE			; PARTITION 1
	DB	1
	DB	13 DUP (?)		; SAME AS PART0

PART2	LABEL	BYTE			; PARTITION 2
	DB	2
	DB	13 DUP (?)		; SAME AS PART0

PART3	LABEL	BYTE			; PARTITION 3
	DB	3
	DB	13 DUP (?)		; SAME AS PART0

PART4	LABEL	BYTE			; PARTITION 4
	DB	4
	DB	13 DUP (?)		; SAME AS PART0


					; PARTITON PARAMETERS OFFSET
INSTALLED	EQU	0
AKTIVE		EQU	1
XTYPE		EQU	2
STARTCYL	EQU	8
ENDCYL		EQU    10
SIZEPART	EQU    12

;******************************************************************************
;
;	DRIVE PARAMETERS :  READ VIA INT 13;8

MAX_DRIVE DB	0
MAX_HEAD DB	0
MAX_CYL DW	0
MAX_SEC DB	0


;******************************************************************************
;
;	VARIABLES :  USED BY ADISK


CUR_DRIVE DB	0			; CURRENT DRIVE NUMBER

PART_COUNT DB	1			; NUMBER OF INSTALLED PARTITIONS

PATNUM	DB	0			; NUMBER OF MID-PARTITION

STARTCYL1 DW	0			; LOWEST PARTITION
ENDCYL1   DW	0
STARTCYL2 DW	0			; MID-PARTITION
ENDCYL2   DW	0
STARTCYL3 DW	0			; HIGHEST PARTITION
ENDCYL3   DW	0

A_CYL_1 DW	0			; SPACE BETWEEN 0-STARTCYL1
S_CYL_1 DW	0
A_CYL_2 DW	0			; SPACE BETWEEN STCYL1-STCYL2
S_CYL_2 DW	0
A_CYL_3 DW	0			; SPACE BETWEEN STCYL2-STCYL3
S_CYL_3 DW	0
A_CYL_4 DW	0			; SPACE BETWEEN ENDCYL3-MAX_CYL
S_CYL_4 DW	0

A_CYL	DW	0			; MAX. AVAILABLE CYLINDERS
S_CYL	DW	0			; STARTING CYLINDER

P_SIZE	DW	0			; SIZE OF THE NEW DOS PARTITION
P_START DW	0			; START OF THIS NEW DOS PART.

DOSVER	DB	0			; CURRENT DOS VERSION

FIRST	DB	0			; START/RESTART MARKER 

CHANGE	DB	0			; NOT NULL IF SOMETHING CHANGE IN PAT
					; =>REBOOT SYSTEM
				
;******************************************************************************
;
;	PARAMETERS :  USED BY PDISK

CR		EQU	0DH	   
LF		EQU	0AH
BS		EQU	08H
ESCKEY		EQU	1BH
BELL		EQU	07H
DOS12		EQU	01H		; DOS PARTITION MARKERS
DOS16		EQU	04H				       
AMIGA		EQU	0AH		; AMIGA PART. MARKERS (COULD BE MORE)
VIDEO		EQU	10H		; BIOS INTERRUPT VECTORS
DISK		EQU	13H
BOOT		EQU	19H
WRITE_TTY	EQU	0EH
FUNCTION	EQU	21H		; DOS FUNCTION CALL VECTOR
SECTORLENGTH	EQU    200H		; 512 BYTE/SECTOR
REBOOT		EQU  0E05BH		; RESET VECTOR
BIOSSEC 	EQU  0F000H		

;******************************************************************************
;
;	VECTOR TO DOS FUNCTION CALL ROUTINE
 
DOSFUNCTION	LABEL	DWORD
DOSOFF		DW	DOS		; OFFSET POINTS TO PSP
DOSSEGM		DW	0		; MUST BE FILLED WITH 
					; CURRENT SEGMENT
RESET		LABEL	DWORD
		DW	REBOOT		; OFFSET POINTS TO POWERUP ROUTINE
		DW	BIOSSEC 	; SEGMENT OF BIOS ROUTINES

;******************************************************************************
;
;	PROGRAM STARTS HERE
;
;******************************************************************************

START	PROC	NEAR

	MOV	AX,CS			; ASSUME DOS SEGMENT TO
	MOV	DOSSEGM,AX		; CURRENT CODE SEGMENT
	MOV	FIRST,0 		; START MARKER 

FD1:
	XOR	CX,CX			; SET SCREEN SIZE
	MOV	DX,1950H
	CALL	CLS			; CLEAR SCREEN

	MOV	BH,0
	MOV	AX,0200H		; SET CURSOR
	MOV	DX,0000H		; TO R0,C0
	INT	VIDEO
 
	MOV	SI,OFFSET MHEAD1
	CALL	PRINT			; PRINT HEADER

	CMP	FIRST,0 		; START OR RESTART ?
	JNE	FD14

	MOV	FIRST,0A5H		; SET RESTART MARKER 
	MOV	AH,30H			; DOS FUNCTION VECTOR
	CALL	DOSFUNCTION		; GET CURRENT DOS VERSION
	MOV	DOSVER,AL
	CMP	AL,02			; VERSION 2.00 OR HIGHER ?
	JNB	FD12
	MOV	SI,OFFSET MERRV
	CALL	PRINT			; PRINT ERROR MESSAGE
	JMP	FDRET			; AND RETURN TO DOS

FD12:
	CALL	DRIVE			; LOAD DRIVE PARAMETERS
	JNC	FD13			; ERROR HAPPENED ?
	MOV	SI,OFFSET MERRD
	CALL	PRINT			; PRINT ERROR MESSAGE
	JMP	FDRET			; AND RETURN TO DOS

FD13:
	CALL	L_PAT			; LOAD PARTITION TABLE
	JNC	FD11			; ERROR HAPPENED ?
	MOV	SI,OFFSET MERRP
	CALL	PRINT			; PRINT ERROR MESSAGE
	JMP	FDRET			; AND RETURN TO DOS

FD11:
	MOV	BX,OFFSET PAT		; BX POINT TO START OF PAT
	CMP	WORD PTR [BX+01FEH],0AA55H	
	JE	FD14
	MOV	SI,OFFSET MPAT		; PRINT MESSAGE
	CALL	PRINT
	MOV	AX,0700H
	CALL	DOSFUNCTION		; WAIT FOR INPUT
	JMP	FD8					  

FD14:
	CALL	SHOW			; PREPARE PARTITION DATAS  
	CALL	SHOWHEAD		; DISPLAY HEAD

FD2:
	CALL	MENUE			; DISPLAY MENUE

FD3:
	MOV	AX,0700H		; SET FUNCTION
	CALL	DOSFUNCTION		; READ KEYBOARD (CHAR IN AL)
	CMP	AL,ESCKEY		; <ESC>?
	JNE	FD4
	JMP	SHORT FDRET		; RETURN TO DOS

FD4:   
	CMP	AL,31H			; < 1 >?
	JL	FD3			; TRY AGAIN
	JA	FD5
	CALL	TOGGLE			; TOGGLE CURRENT DRIVE NUMBER
	JMP	FD1 

FD5:   
	CMP	AL,32H			; < 2 >?
	JNE	FD6
	CALL	STATUS			; CHANGE AKTIVE STATUS
	JC	FD2			; RETURN TO MENUE
	JMP	FD1  

FD6:  
	CMP	AL,33H			; < 3 >?
	JNE	FD7
	CALL	CREATE			; CREATE NEW DOS PARTITION
	JC	FD2			; RETURN TO MENUE
	MOV	CHANGE,5AH
	JMP	FD1 

FD7:  
	CMP	AL,34H			; < 4 >?
	JNE	FD3
	CALL	DELETE			; DELETE DOS PARTITION
	JC	FD2			; RETURN TO MENUE
	MOV	CHANGE,5AH
	JMP	FD1 

FD8:
	CALL	BUILDBOOT		; BUILD UP THE FIRST PHYSICAL
					; SECTOR ON HARD DISK
	CALL	S_PAT			; AND TRANSFER IT TO HD
	JMP	FD1			; LOAD NEW PAT

FDRET:
	CALL	S_PAT			; SAVE NEW PAT
	CMP	CHANGE,0		; RETURN TO DOS, IF 
	JNE	FDBOOT			; NOTHING CHANGE IN
	RET				; PARTITION TABLE

FDBOOT:
	CALL	SETUP
	MOV	SI,OFFSET MBOOT
	CALL	PRINT			; PRINT REBOOT MESSAGE
	MOV	AX,0700H		; SET FUNCTION
	CALL	DOSFUNCTION		; READ KEYBOARD (CHAR IN AL)
	JMP	RESET			; JMP TO BIOS POWERUP

START	ENDP


;******************************************************************************
;
;	CLEAR SREEN
;
;******************************************************************************

CLS	PROC	NEAR		; CLEAR SCREEN

	PUSH	AX
	PUSH	BX
	MOV	AX,0700H	; SET MODE
	MOV	BH,07H		; NORMAL VIDEO
	INT	VIDEO
	POP	BX
	POP	AX
	RET

CLS	ENDP


;******************************************************************************
;
;	DRIVE :  READ DRIVE PARAMETERS	    
;		 EXSPECTS CUR_DRIVE #
;		 SAVE ALL REGISTERS
;		 SET CARRY IF ERROR
;
;******************************************************************************

DRIVE	PROC	NEAR		; READ DRIVE PARAMETERS

	PUSH	AX
	PUSH	BX
	PUSH	CX
	PUSH	DX

	MOV	CX,10		; NUMBER OF RETRYS
DR1:
	PUSH	CX
	MOV	DL,CUR_DRIVE	; SET DRIVE NUMBER
	OR	DL,80H
	XOR	AX,AX
	INT	DISK		; RESET DISK
	MOV	AH,08H		; SET MODE
	INT	DISK		; READ DISK PARAMETERS

	MOV	MAX_DRIVE,DL
	MOV	MAX_HEAD,DH
	MOV	BL,CL
	AND	BL,3FH		; MASK MAX_SEC
	MOV	MAX_SEC,BL
	MOV	BH,CL		; BUILD MAX_CYL
	MOV	CL,6
	SHR	BH,CL
	MOV	BL,CH
;	ADD	BX,1		; V1.3 TB  
	MOV	MAX_CYL,BX	; SAVE IT
       
	POP	CX		; RESTORE COUNTER
	OR	AH,AH		; ERROR ? (INCLUDE RESET C-FLAG)
	JZ	DR2
	LOOP	DR1		; TRY IT AGAIN

	STC			; SET C-FLAG FOR ERROR
DR2:
	POP	DX
	POP	CX
	POP	BX
	POP	AX
	RET

DRIVE	ENDP


;******************************************************************************
;
;	LOAD PARTITION TABLE INTO MEMORY
;
;	EXSPECTS CUR_DRIVE #
;	SAVES ALL REGISTERS
;	SET CARRY IF ERROR
;
;******************************************************************************

L_PAT	PROC	NEAR

	PUSH	AX
	PUSH	BX
	PUSH	CX
	PUSH	DX

	MOV	CX,10		; NUMBER OF RETRYS
L1:
	PUSH	CX
	MOV	DL,CUR_DRIVE   ; SET DRIVE NUMBER
	OR	DL,80H
;	XOR	AX,AX
;	INT	DISK		; RESET DISK

	MOV	BX,OFFSET PAT	; RESERVED MEMORY
	MOV	CX,0001H	; READ SECTOR 1 , CYLINDER 0
	SUB	DH,DH		; HEAD 0
	MOV	AL,1		; READ ONE SECTOR
	MOV	AH,02H		; SET MODE
	INT	DISK		; READ DISK SECTOR    

	POP	CX		; RESTORE COUNTER
	CLC
	OR	AH,AH		; ERROR ? (INCLUDE RESET C-FLAG)
	JZ	L2 
	XOR	AX,AX
	INT	DISK		; RESET DISK AND
	LOOP	L1		; TRY IT AGAIN

	STC			; SET C-FLAG FOR ERROR
L2: 
	POP	DX
	POP	CX
	POP	BX
	POP	AX
	RET

L_PAT	ENDP


;******************************************************************************
;
;	STORE PARTITON TABLE
;
;	EXSPECTS CUR_DRIVE #
;	SAVE ALL REGISTERS
;	SET CARRY IF ERROR
;
;******************************************************************************

S_PAT	PROC	NEAR

	PUSH	AX
	PUSH	BX
	PUSH	CX
	PUSH	DX

	MOV	CX,10		; NUMBER OF RETRYS
S1:
	PUSH	CX
	MOV	DL,CUR_DRIVE	; SET DRIVE NUMBER
	OR	DL,80H
	XOR	AX,AX
	INT	DISK		; RESET DISK

	MOV	BX,OFFSET PAT	; RESERVED MEMORY
	MOV	CX,0001H	; WRITE SECTOR 1 , CYLINDER 0
	SUB	DH,DH		; HEAD 0
	MOV	AL,1		; WRITE ONE SECTOR
	MOV	AH,03H		; SET MODE
	INT	DISK		; WRITE DISK SECTOR    
 
	POP	CX		; RESTORE COUNTER
	OR	AH,AH		; ERROR ? (INCLUDE RESET C-FLAG)
	JZ	S2 
	LOOP	S1		; TRY IT AGAIN

	STC			; SET C-FLAG FOR ERROR
S2: 
	POP	DX
	POP	CX
	POP	BX
	POP	AX
	RET

S_PAT	ENDP


;******************************************************************************
;
;	SHOW :	PREPARES PARTITION PARAMETERS FOR PRINT OUT
;
;******************************************************************************

SHOW	PROC	NEAR

	PUSH	AX
	PUSH	BX
	PUSH	CX
	PUSH	DX
	PUSH	SI
	PUSH	DI
	PUSH	BP


	MOV	DI,OFFSET PART1 	; RESET PARAMETERS
	MOV	SI,OFFSET PART0
	MOV	CX,14
REP	MOVSB

	MOV	BX,OFFSET PAT
SW1:
	MOV	CX,4			; MAX. PARTITION NUMBER
	MOV	PART_COUNT,0		; RESET NUMBER OF PARTITONS
	ADD	BX,30H			; BX POINTS TO 1.PART. OF PAT
	MOV	BP,OFFSET PART1 	; BP POINTS TO 1.PART. IN MEMORY

SW2:
	MOV	AX,WORD PTR [BX+01CAH]		
	MOV	DX,WORD PTR [BX+01CBH]
	OR	AX,DX			; TEST FOR NULL 
	JZ	SW5			; JUMP, IF NO PARTITION HERE

	PUSH	CX			; SAVE LOOP COUNTER
	ADD	PART_COUNT,1
	MOV	SI,OFFSET OTHERSTR
	CMP	BYTE PTR [BX+01C2H],DOS12  ; LOOKS ABOUT PART. TYPE
	JE	SW31			; FOUND DOS <3.00 (12BIT FAT)
	CMP	BYTE PTR [BX+01C2H],DOS16  ; OR DOS 3.00     (16BIT FAT)
	JNE	SW3			; FOUND OTHER OS
SW31:
	MOV	SI,OFFSET DOSSTR
SW3:
	CMP	BYTE PTR [BX+01C2H],AMIGA  ; OR AMIGA PARTITION 	   
	JNE	SW32			; NO		  
	MOV	SI,OFFSET AMIGASTR
SW32:
	MOV	DI,BP	
	ADD	DI,2
	MOV	CX,5			; LOAD COUNTER
	REP	MOVSB			; MOVES 5-BYTE STRING
			       
	MOV	BYTE PTR CS:[BP+1],'A'
	CMP	BYTE PTR [BX+01BEH],80H ; BOOTABLE PARTITION ?
	JE	SW4
	MOV	BYTE PTR CS:[BP+1],'N'

SW4:
	MOV	DH,BYTE PTR [BX+01C0H]	; BUILD START CYL.
	MOV	CL,6
	SHR	DH,CL
	MOV	DL,BYTE PTR [BX+01C1H]
	MOV	CS:STARTCYL[BP],DX	; SAVE IT

	MOV	AH,BYTE PTR [BX+01C4H]	; BUILD END CYL.
	MOV	CL,6
	SHR	AH,CL
	MOV	AL,BYTE PTR [BX+01C5H]
	MOV	CS:ENDCYL[BP],AX	; SAVE IT

	SUB	AX,DX			; BUILD SIZE CYL.
	ADD	AX,1
	MOV	CS:SIZEPART[BP],AX	; SAVE IT
	POP	CX			; RESTORE COUNTER
	ADD	BP,14			; BP POINTS TO NEXT PART. IN MEM.

SW5:
	SUB	BX,10H			; BX POINTS TO NEXT PART. OF PAT
	LOOP	SW2

	POP	BP
	POP	DI
	POP	SI
	POP	DX
	POP	CX
	POP	BX
	POP	AX
	RET

SHOW	ENDP


;******************************************************************************
;
;	SHOWHEAD :  PRINTS HEADLINE, HDISK PARAMETERS, PARTITION PARAMETERS
;
;******************************************************************************

SHOWHEAD	PROC	NEAR

	MOV	SI,OFFSET MHEAD2
	CALL	PRINT
	MOV	DH,CUR_DRIVE
	CALL	PRINT_BYTE		; PRINT DRIVE NUMBER
	MOV	SI,OFFSET MHEAD3
	CALL	PRINT
	MOV	DX,MAX_CYL
	inc     dx			; V1.3 TB 
	CALL	PRINT_DEC		; PRINT NUMBER OF CYLINDERS
	MOV	SI,OFFSET MHEAD4
	CALL	PRINT
	CMP	PART_COUNT,0		; ANY PARTITION INSTALLED
	JNE	SH01
	MOV	SI,OFFSET MERRN 	; PRINT ERROR MESSAGE
	CALL	PRINT
	JMP	SHORT SH2

SH01:					; PRINT PARTITION DATAS
	SUB	CH,CH
	MOV	CL,PART_COUNT
	OR	CL,CL
	JNZ	SH0
	MOV	CL,1

SH0:
	MOV	DI,OFFSET PART1
SH1:
	PUSH	CX			; SAVE LOOP COUNTER

	MOV	AL,5			; PRINT PARTITION NUMBER
	CALL	RELCURSOR
	SUB	DH,DH
	MOV	DL,INSTALLED[DI]
	CALL	PRINT_DEC 

	MOV	AL,16			; PRINT STATUS
	CALL	RELCURSOR
	MOV	AL,AKTIVE[DI]
	CALL	SEND_BYTE

	MOV	AL,24			; PRINT TYPE
	CALL	RELCURSOR
	MOV	SI,DI			
	ADD	SI,2			; POINT TO PART. TYPE
	CALL	PRINT

	MOV	AL,35			; PRINT START
	CALL	RELCURSOR
	MOV	DX,STARTCYL[DI]
	CALL	PRINT_DEC

	MOV	AL,44			; PRINT END
	CALL	RELCURSOR
	MOV	DX,ENDCYL[DI]
	CALL	PRINT_DEC

	MOV	AL,52			; PRINT SIZE
	CALL	RELCURSOR
	MOV	DX,SIZEPART[DI]
	CALL	PRINT_DEC

	ADD	DI,14			; DI POINTS TO NEXT PART. DATAS
	MOV	SI,OFFSET CRLF		; SET CURSOR TO NEXT LINE
	CALL	PRINT
	POP	CX			; RESTORE LOOP COUNTER
	LOOP	SH1

SH2: 
	RET

SHOWHEAD	ENDP

	
;******************************************************************************
;
;	RELCURSOR :  SET CURSOR TO NEW POSITION IN AL AT THE SAME LINE 
;		  
;******************************************************************************

RELCURSOR	PROC	NEAR

	PUSH	DX
	PUSH	AX

	MOV	AH,3			; READ CURRENT POSITION
	MOV	BH,0
	INT	VIDEO
	POP	AX
	MOV	DL,AL			; ADD DESTINATION      
	MOV	AH,2
	INT	VIDEO			; SET NEW POSITION

	POP	DX
	RET

RELCURSOR	ENDP

	
;******************************************************************************
;
;	CURSOR :  SET CURSOR TO NEW POSITION,
;		  EXSPECTS ROW/COLUMN IN DH/DL.
;		  
;******************************************************************************

CURSOR		PROC	NEAR

	PUSH	AX
	PUSH	BX
	XOR	BX,BX			; SET PAGE 0
	MOV	AH,2
	INT	VIDEO			; SET NEW POSITION
	POP	BX
	POP	AX
	RET

CURSOR		ENDP


;******************************************************************************
;
;	PRINT MAIN MENUE
;
;******************************************************************************

MENUE	PROC	NEAR

	CALL	SETUP			; CLS AND SET CURSOR 

	MOV	SI,OFFSET MMENUE	; PRINT MAIN MENUE
	CALL	PRINT
	RET

MENUE	ENDP

    
;*****************************************************************************
;
;	TOGGLE :  CHANGE # OF CURRENT HDISK,
;		  PRINTS ERROR MESSAGE AND SET CARRY
;		  IF ONLY ONE HDISK PRESENT.
;
;*****************************************************************************

TOGGLE	PROC	NEAR

	CALL	SETUP			; CLS AND SET CURSOR

	CMP	MAX_DRIVE,1		; ONLY ONE FIXED DISK ?
	JNE	T2 
	MOV	SI,OFFSET MERRT
	CALL	PRINT			; PRINT ERROR MESSAGE
	MOV	SI,OFFSET MESC
	CALL	PRINT

T1:
	MOV	AX,0700H		; SET FUNCTION
	CALL	DOSFUNCTION		; READ KEYBOARD (CHAR IN AL)
	CMP	AL,ESCKEY		; <ESC>?
	JNE	T1 
	STC
	RET				; THEN RETURN TO MENUE

T2:	
	MOV	FIRST,0 		; RESET LOAD MARKE
	CALL	S_PAT			; STORE PAT ON HARDDISK
	NOT	CUR_DRIVE
	AND	CUR_DRIVE,1		; TOGGLE LSB
	CLC
	RET

TOGGLE	ENDP


;******************************************************************************
;
;	STATUS :  PRINT MENUE,
;		  CHANGE AKTIVE PARTITON,
;		  PRINTS ERROR MESSAGE AND SET CARRY,
;		  IF PARTITION COUDN'T CHANGE.
;
;******************************************************************************

STATUS	PROC	NEAR

	CALL	SETUP			; CLS AND SET CURSOR
 
	MOV	SI,OFFSET MSTATUS
	CALL	PRINT			; PRINT USER MESSAGE
	MOV	SI,OFFSET MESC
	CALL	PRINT

ST1:
	MOV	AX,0700H		; SET FUNCTION
	CALL	DOSFUNCTION		; READ KEYBOARD (CHAR IN AL)
	CMP	AL,ESCKEY		; <ESC>?
	JNE	ST2 
	STC
	RET				; RETURN TO MENUE
  
ST2:	 
	SUB	AL,30H			; CONVERT ASCII TO HEX
	CMP	AL,PART_COUNT
	JA	ST1			; THIS PARTITION IS NOT INSTALLED
 
	MOV	BX,OFFSET PAT		; POINTS TO PAT 	  
	ADD	BX,30H			; POINTS TO FIRST PARTITION
	SUB	CX,CX			; CLEAR LOOP COUNTER

ST3:
	MOV	DX,WORD PTR [BX+01CAH]	; PARTITION INSTALLED ?
	OR	DX,WORD PTR [BX+01CBH]	; TEST FOR NULL
	JZ	ST4			; JUMP, IF NO PARTITION HERE
	ADD	CL,1
	CMP	AL,CL			; PARTITON TO MAKE AKTIVE ?
	JNE	ST4
	CMP	BYTE PTR [BX+01C2H],AMIGA
	JNE	ST5
	CALL	SETUP
	MOV	SI,OFFSET MERR4 	; FOUND AMIGA PARTITION
	CALL	PRINT
ST6:
	MOV	AX,0700H		; SET FUNCTION
	CALL	DOSFUNCTION		; READ KEYBOARD (CHAR IN AL)
	CMP	AL,ESCKEY		; <ESC>?
	JNE	ST6 
	STC
	RET				; RETURN TO MENUE
 
ST5:
	push	bx
	mov	bx,offset pat
	MOV	BYTE PTR [BX+01BEH],0	; MAKE PARTITION 4 INAKTIVE
	MOV	BYTE PTR [BX+01CEH],0	; MAKE PARTITION 3 INAKTIVE
	MOV	BYTE PTR [BX+01DEH],0	; MAKE PARTITION 2 INAKTIVE
	MOV	BYTE PTR [BX+01EEH],0	; MAKE PARTITION 1 INAKTIVE
	pop	bx

	MOV	BYTE PTR [BX+01BEH],80H ; MAKE PARTITION AKTIVE

ST4:	
	SUB	BX,10H			; POINTS TO NEXT PARTITION
	CMP	CL,PART_COUNT
	JNA	ST3

	CLC
	RET

STATUS	ENDP


;******************************************************************************
;
;	CREATE A NEW DOS PARTITION,
;	IF ENAUGH SPACE ON HDISK AND
;	NO DOS PARTITION IS ALREADY CREATED.
;
;******************************************************************************

CREATE	PROC	NEAR

	CALL	SETUP			; CLS AND SET CURSOR
  
	MOV	SI,OFFSET MERR3 	; FOUR PARTITIONS ON HD ?
	CMP	PART_COUNT,4
	JL	C4
	CALL	PRINT			; PRINT ERROR MESSAGE
C3:
	MOV	AX,0700H		; SET FUNCTION
	CALL	DOSFUNCTION		; READ KEYBOARD (CHAR IN AL)
	CMP	AL,ESCKEY		; <ESC>?
	JNE	C3 
	STC
	RET

C4:
	CALL	PLACE			; FOUND MAX. AVAILABLE PLACE
	CMP	PART_COUNT,0		; ANY PARTITION INSTALLED ?
	JE	C5 
	JMP	C6

C5:
	MOV	SI,OFFSET MCREATE0
	CALL	PRINT			; PRINT QUESTION
	MOV	AX,0700H		; SET FUNCTION
	CALL	DOSFUNCTION		; READ KEYBOARD (CHAR IN AL)
	OR	AL,20H			; CONVERT UPPER TO LOWER
	CMP	AL,YESCHR		; < y,Y >?
	JE	C7

C6:
	CALL	SETUP			; CLS AND SET CURSOR
	MOV	SI,OFFSET MCREATE1
	CALL	PRINT			; PRINT USER MESSAGE
	MOV	DX,A_CYL
	CALL	PRINT_DEC		; PRINT AVAIL. CYLINDERS
	MOV	SI,OFFSET MCREATE2
	CALL	PRINT
	MOV	DX,S_CYL
	CALL	PRINT_DEC		; PRINT START CYLINDER
	MOV	SI,OFFSET MCREATE3
	CALL	PRINT
	MOV	SI,OFFSET MCREATE4
	CALL	PRINT
	MOV	SI,OFFSET MESC
	CALL	PRINT

	MOV	DX,131DH		; SET CURSOR TO R19,C29
	CALL	CURSOR
	MOV	BX,A_CYL		; SET DEFAULT VALUE
	CALL	INPUT			; LINE INPUT
	JC	C10			; <ESC> ?
	CMP	BX,A_CYL		; SYNTAX OK ?
	JA	C8			; TO BIG
	CMP	BX,0			; >0 ?
	JNA	C8
	MOV	AX,BX
	PUSH	AX

	MOV	DX,141DH		; SET CURSOR TO R20,C29
	CALL	CURSOR
	MOV	BX,S_CYL		; SET DEFAULT VALUE
	CALL	INPUT			; LINE INPUT
	JC	C10			; <ESC> ?
	POP	AX
	CMP	BX,S_CYL		; SYNTAX OK ?
	JL	C9			; TO LOW
	ADD	BX,AX
	MOV	CX,A_CYL
	ADD	CX,S_CYL
	CMP	BX,CX			; TO HIGH
	JA	C9
	SUB	BX,AX
	MOV	S_CYL,BX		; SYNTAX OK !
	MOV	A_CYL,AX

C7:
	CALL	P_BUILD 		; BUILD UP NEW PARTITON TABLE
	CLC

C10:
	RET				; RETURN TO MENUE


C8:
	MOV	SI,OFFSET MERR1
	JMP	SHORT C11
C9:
	MOV	SI,OFFSET MERR2
C11:
	CALL	PRINT
	MOV	AX,0700H		; SET FUNCTION
	CALL	DOSFUNCTION		; READ KEYBOARD (CHAR IN AL)
	JMP	C6

CREATE	ENDP


;******************************************************************************
;
;	P_BUILD :  BUILD UP NEW DOS PARTITION
;		   - DOS MARKER
;		   - BEGIN = S_CYL (SPECIAL IF S_CYL=0)
;		   - END   = S_CYL+A_CYL
;		   - REL S = HEAD*SEC*S_CYL+1
;		   - # SEC = HAED*SEC*A_CYL-1
;
;
;******************************************************************************

P_BUILD PROC	NEAR

	MOV	CL,4				; MAX SPACE IN PAT
	XOR	CH,CH
	MOV	BX,OFFSET PAT
	ADD	BX,40H
PB0:
	SUB	BX,10H				; LOOK FOR SPACE FOR THE NEW
	MOV	AX,WORD PTR [BX+01CAH]		; PARTITION
	MOV	DX,WORD PTR [BX+01CBH]
	OR	AX,DX				; TEST FOR NULL 
	JZ	PB1				; JUMP, IF NO PARTITION HERE
	LOOP	PB0				; BX POINTS TO PAT
   
PB1:
	MOV	BYTE PTR [BX+01BEH],00H 	; NOT BOOTABLE MARKER
	MOV	BYTE PTR [BX+01C2H],AMIGA	; AMIGA MARKER
 
	MOV	AX,S_CYL 
	MOV	BYTE PTR [BX+01C1H],AL		; SCYL (LSB)
	MOV	CL,6				; ADJUST THE TWO 
	SHL	AH,CL				; HIGH ORDER BITS OF S_CYL
	INC	AH				; NORMALY PARTITIONS
						; STARTS AT SEC1,TRACK0
	MOV	DL,0				; DL = TRACK#
	CMP	AL,0				; SPECIAL PROCEDURE FOR
	JNE	PB3				; PARTITION ,WHICH STARTS
						; AT CYLINDER 0 !

	INC	AH				; SKIP BOOTSECTOR
	CMP	DOSVER,3			; WITH DOS 2.XX THE STARTPOINT 
	JNE	PB3				; OF THE CYL0 PARTITION IS AT
	DEC	AH				; SEC2,TRACK0.
	INC	DL				; WITH DOS 3.00 IT STARTS
						; AT SEC1,TRACK1 !.
PB3:
	MOV	BYTE PTR [BX+01C0H],AH		; SSEC
	MOV	BYTE PTR [BX+01BFH],DL		; SHEAD 
	MOV	AL,MAX_HEAD
	MOV	BYTE PTR [BX+01C3H],AL		; EHEAD
	MOV	AX,A_CYL
	ADD	AX,S_CYL
	PUSH	AX				; SAVE ECYL
	DEC	AX
	MOV	BYTE PTR [BX+01C5H],AL		; ECYL (LSB)
	MOV	CL,6				; ADJUST THE TWO 
	SHL	AH,CL				; HIGH ORDER BITS OF E_CYL
	ADD	AH,MAX_SEC			; PARTITION END        
	MOV	BYTE PTR [BX+01C4H],AH		; ESEC

	XOR	DX,DX
	MOV	AL,MAX_HEAD
	INC	AL
	CBW
	MOV	DX,AX
	MOV	AL,MAX_SEC
	CBW
	MUL	DX	 
	PUSH	AX				; SAVE SEC*TRACK
	MUL	S_CYL
	CMP	S_CYL,0
	JNE	PB4
	INC	AX				; PAT REQUIERES ONE SECTOR
	CMP	DOSVER,3			; SIXTEEN SECTORS ARE NOT
	JNE	PB4				; AVIALABLE WITH DOS 3.00
	ADD	AX,16	

PB4:
	MOV	WORD PTR [BX+01C6H],AX		; REL SEC
	MOV	WORD PTR [BX+01C8H],DX
	MOV	SI,AX
	MOV	DI,DX

	XOR	DX,DX
	POP	AX				; RESTORE SEC*TRACK
	POP	CX				; RESTORE ECYL
	MUL	CX     
	CLC					; CLEAR CARRY FOR SUBTRACTION 
	SUB	AX,SI
	SBB	DX,DI
	MOV	WORD PTR [BX+01CAH],AX		; # OF SEC
	MOV	WORD PTR [BX+01CCH],DX	 

	RET

P_BUILD ENDP


;******************************************************************************
;
;	PLACE :  FIND OUT MOST AVAILABLE SPACE FOR NEW PARTITION 
;		 - SEARCH FOR END OF LAST PARTITION (EOLP),
;		 - S_CYL = STARTING POINT OF NEW PARTITION
;		 - A_CYL = AVAILABLE SPACE FOR NEW PARTITON
;
;		 SAVE ALL REGISTER.
;
;******************************************************************************

PLACE	PROC	NEAR

	PUSH	AX
	PUSH	BX
	PUSH	CX
	PUSH	DX
	PUSH	SI

	CMP	PART_COUNT,0
	JNE	PL1
	MOV	AX,MAX_CYL
	MOV	A_CYL,AX
	MOV	S_CYL,1 			; Can't use track 0 for Amiga
	JMP	PLR				; partitions !

PL1:						; LOOK FOR HIGHEST PART.
	SUB	CX,CX				; CLEAR REGISTERS
	MOV	ENDCYL3,CX			; PRESET 
	MOV	CL,PART_COUNT			; SET LOOPCOUNT
	MOV	SI,OFFSET PART0
PL2:   
	ADD	SI,14
	MOV	BX,ENDCYL[SI]
	CMP	ENDCYL3,BX
	JA	PL21
	ADD	PATNUM,CL			; STORE HIGHEST PART#
	MOV	ENDCYL3,BX 
	MOV	AX,STARTCYL[SI]
	MOV	STARTCYL3,AX
	MOV	STARTCYL1,AX
PL21:
	LOOP	PL2
	CMP	PART_COUNT,1			; ONLY ONE PARTITION
	JE	PL4
						; LOOK FOR LOWEST PART.
	SUB	CX,CX				; CLEAR REGISTERS
	PUSH	MAX_CYL 			; PRESET LOWEST PART.
	POP	STARTCYL1
	MOV	CL,PART_COUNT			; SET LOOPCOUNT
	MOV	SI,OFFSET PART0

PL3:
	ADD	SI,14
	MOV	BX,STARTCYL[SI]
	CMP	STARTCYL1,BX
	JL	PL31
	ADD	PATNUM,CL			; STORE LOWEST PART#
	MOV	STARTCYL1,BX 
	MOV	AX,ENDCYL[SI]
	MOV	ENDCYL1,AX
PL31:
	LOOP	PL3	 
	CMP	PART_COUNT,2			; ONLY TWO PARTITIONS ?
	JE	PL4
						; LOOK FOR MID PART.
	SUB	CX,CX				; CLEAR REGISTERS
	PUSH	STARTCYL3			; PRESET PART.
	POP	ENDCYL2   
	PUSH	ENDCYL1
	POP	STARTCYL2
	MOV	CL,PART_COUNT			; SET LOOPCOUNT
	MOV	SI,OFFSET PART0

PL9:
	ADD	SI,14
	MOV	BX,STARTCYL[SI]
	CMP	STARTCYL2,BX
	JA	PL91   
	MOV	AX,ENDCYL[SI]
	CMP	ENDCYL2,AX
	JL	PL91
	MOV	STARTCYL2,BX			; STORE MID PARTITION
	MOV	AX,ENDCYL[SI]
	MOV	ENDCYL2,AX
PL91:
	LOOP	PL9	 

PL4:
	MOV	BX,MAX_CYL
	SUB	BX,ENDCYL3
	MOV	A_CYL_4,BX			; AVAILABLE FREE SPACE4

	CMP	STARTCYL1,0
	JE	PL5
	DEC	STARTCYL1
PL5:
	MOV	A_CYL_3,0
	CMP	PART_COUNT,3
	JL	PL6 
	MOV	AX,STARTCYL3			; THREE PARTITIONS FOUND
	SUB	AX,ENDCYL2
	DEC	AX
	MOV	A_CYL_3,AX			; AVAILABLE FREE SPACE3
	MOV	AX,STARTCYL2
	SUB	AX,ENDCYL1
	DEC	AX
	MOV	A_CYL_2,AX			; AVAILABLE FREE SPACE2
	JMP	SHORT PL11			; WITH THREE PARTITIONS 

PL6:
	MOV	AX,STARTCYL3
	SUB	AX,ENDCYL1
	DEC	AX				; new in adisk !
	MOV	A_CYL_2,AX			; AVAILABLE FREE SPACE2
						; WITH TWO PARTITIONS
PL11:
	MOV	DX,STARTCYL1			; AVAILABLE FREE SPACE1
	CMP	DX,A_CYL_4			; WHICH SPACE IS GREATER ?
	JL	PL7
	CMP	DX,A_CYL_3
	JL	PL12
	CMP	DX,A_CYL_2
	JL	PL8
	MOV	A_CYL,DX			; IT'S SPACE1 !
	MOV	S_CYL,0
	JMP	SHORT PLR

PL7:		   
	MOV	DX,A_CYL_4
	CMP	DX,A_CYL_3
	JL	PL12
	CMP	DX,A_CYL_2
	JL	PL8
	MOV	A_CYL,DX			; IT'S SPACE4 !
	MOV	DX,ENDCYL3
	INC	DX
	MOV	S_CYL,DX
	JMP	SHORT PLR

PL12:
	MOV	DX,A_CYL_3
	CMP	DX,A_CYL_2
	JL	PL8
	MOV	A_CYL,DX			; IT'S SPACE3 !
	MOV	DX,ENDCYL2
	INC	DX
	MOV	S_CYL,DX
	JMP	PLR

PL8:
	MOV	DX,ENDCYL1			; IT'S SPACE2 !
	INC	DX
	MOV	S_CYL,DX
	PUSH	A_CYL_2     
	POP	A_CYL

PLR:
	cmp	s_cyl,0 
	jne	not_null
	inc	s_cyl
not_null:
	POP	SI
	POP	DX
	POP	CX
	POP	BX
	POP	AX
	RET

PLACE	ENDP


;******************************************************************************
;
;	INPUT :  READS A 3-DIGIT NUMBER FROM INPUT LINE TO BX,
;		 ONLY <CR> LEAVES DEFAULT NUMBER IN BX,
;		 SETS CARRY IF <ESC>,
;		 SAVE ALL REGISTERS.
;
;******************************************************************************
 
INPUT	PROC	NEAR

	PUSH	AX
	PUSH	DX
	PUSH	SI
	PUSH	BX

	MOV	SI,0				; CLEAR BUFCOUNT
NEXT:
	MOV	AH,7				; CONSOLE INPUT
	CALL	DOSFUNCTION
	CMP	AL,'0'				; NUMBER ?
	JL	DOCR
	CMP	AL,'9' 
	JA	NEXT
	INC	SI   
	CMP	SI,5				; BUFFER FULL ?
	JAE	DOBELL
	MOV	DL,AL
	MOV	AH,2				; DISPLAY OUTPUT
	CALL	DOSFUNCTION
	SUB	AL,'0'	
	MOV	OFFSET NUMBUF[SI-1],AL		; SAVE IT
	JMP	NEXT

DOBELL:
	MOV	DL,BELL 			; INIT BELL
	MOV	AH,2				; OUTPUT
	CALL	DOSFUNCTION
	DEC	SI    
	JMP	NEXT

DOCR:
	CMP	AL,ESCKEY			; <ESC> ?
	JE	DOESC
	CMP	AL,CR				; <CR> ?
	JNE	DOBS

	CMP	SI,0				; GET DEFAULT VALUE
	JNE	CON1				; IF BUFFER EMTY
	POP	BX
	PUSH	BX
	MOV	DX,BX
	CALL	PRINT_DEC			; PRINT DEFAULT VALUE
	POP	BX
	JMP	SHORT RETURN

CON1:						; CONVERT BUFFER TO DECIMAL 
	MOV	CX,SI				; LOAD LOOPCOUNT WITH BUFCOUNT
	XOR	BX,BX				; CLEAR 
	MOV	SI,BX				; SI POINT TO NUMBUF START

CON2:
	MOV	AL,OFFSET NUMBUF[SI]		; RESTORE
	XOR	AH,AH
	XCHG	AX,BX				; CONVERT NUMBUF TO DECIMAL
	XOR	DX,DX	     
	MUL	TEN
	ADD	BX,AX				; BX CONTAINS DECIMAL NUMBER
	INC	SI
	LOOP	CON2		 
	POP	DX				; CLEAR STACK
	JMP	SHORT RETURN

DOBS:
	CMP	AL,BS				; <BACKSPACE> ?
	JNE	NEXT
	CMP	SI,0				; BUFFER EMPTY ?
	JE	NEXT
						; DELETE LAST CHAR
	DEC	SI				; SETUP BUFFER POINTER
	MOV	DL,AL
	MOV	AH,2				; DISPLAY OUTPUT
	CALL	DOSFUNCTION
	MOV	DL,20H				; DISPLAY SPACE
	CALL	DOSFUNCTION
	MOV	DL,BS				; BACKSPACE
	CALL	DOSFUNCTION
	JMP	NEXT

DOESC:
	STC
	POP	BX				; CLEAR STACK
RETURN:
	POP	SI
	POP	DX
	POP	AX
	RET

NUMBUF	LABEL	BYTE
	DB	4 DUP (?)			; 4-BYTE BUFFER

INPUT	ENDP


;******************************************************************************
;
;	BUILDBOOT :  CREATE THE FIRST SECTOR OF HARD DISK AND AN EMTY
;		     PARTITION TABLE INCLUDE THE PAT-MARKER (55AAH).
;
;******************************************************************************

BUILDBOOT PROC	NEAR

	MOV	SI,OFFSET HDBOOT
	MOV	DI,OFFSET PAT
	MOV	CX,SECTORLENGTH
	CLD
REP	MOVSB	    
	RET

HDBOOT	LABEL	BYTE			; THIS ROUTINE WILL BE LOADED
					; TO THE FIRST PHYSICALLY SECTOR
					; OF THE HARD DISK

DB   0FAH,0BEH,000H,07CH,08BH,0E6H,02BH,0DBH			;600
DB   08EH,0D3H,08EH,0C3H,08EH,0DBH,0FBH,0FCH
DB   0B9H,000H,002H,0BFH,000H,006H,0F3H,0A4H
DB   0EAH,01DH,006H,000H,000H,0B9H,004H,000H
DB   0BEH,000H,006H,081H,0C6H,0EEH,001H,080H
DB   03CH,080H,074H,00CH,080H,03CH,000H,075H
DB   037H,083H,0EEH,010H,0E2H,0F1H,0CDH,018H
DB   0B9H,00AH,000H,051H,08BH,04CH,002H,08BH
DB   014H,0BBH,000H,07CH,0B8H,001H,002H,0CDH
DB   013H,059H,073H,00CH,02BH,0C0H,0CDH,013H			;648
DB   0E2H,0E9H,0BEH,09EH,006H,0EBH,018H,090H			;650
DB   08BH,0FEH,0BEH,0BFH,006H,081H,03EH,0FEH,007H,055H		;658
DB   0AAH,075H,00AH,08BH,0F7H,0EAH,000H,07CH,000H,000H		;662
DB   0BEH,07EH,006H,0FCH,02EH,0ACH,00AH,0C0H			;66C
DB   074H,0C0H,0B4H,00EH,033H,0DBH,0CDH,010H			;674
DB   0EBH,0F1H,00DH,00AH,020H,042H,06FH,06FH
DB   074H,02FH,050H,061H,072H,074H,069H,074H
DB   069H,06FH,06EH,020H,062H,06CH,06FH,063H
DB   06BH,020H,065H,072H,072H,06FH,072H,020H
DB   021H,000H,00DH,00AH,020H,046H,069H,078H
DB   065H,064H,020H,064H,069H,073H,06BH,020H
DB   072H,065H,061H,064H,02FH,077H,072H,069H
DB   074H,065H,020H,065H,072H,072H,06FH,072H
DB   020H,021H,000H,00DH,00AH,020H,04EH,06FH
DB   020H,062H,06FH,06FH,074H,061H,062H,06CH
DB   065H,020H,06FH,070H,065H,072H,061H,074H
DB   069H,06EH,067H,020H,073H,079H,073H,074H
DB   065H,06DH,020H,06FH,06EH,020H,066H,069H
DB   078H,065H,064H,020H,064H,069H,073H,06BH
DB   020H,021H,000H,020H,043H,06FH,070H,079H
DB   072H,069H,067H,068H,074H,020H,028H,043H
DB   029H,020H,020H,020H,031H,039H,038H,035H,020H,020H,043H
DB   06FH,06DH,06DH,06FH,064H,06FH,072H,065H
DB   020H,045H,06CH,065H,063H,074H,072H,06FH
DB   06EH,069H,063H,073H,020H,04CH,069H,06DH,069H
DB   074H,065H,064H,020H,020H,020H,056H,045H,052H,031H
DB   02EH,031H,030H,020H,054H,042H,020H,000H
DB   000H,000H,000H,000H,000H,000H,000H,000H
DB   000H,000H,000H,000H,000H,000H,000H,000H
DB   000H,000H,000H,000H,000H,000H,000H,000H
DB   000H,000H,000H,000H,000H,000H,000H,000H
DB   000H,000H,000H,000H,000H,000H,000H,000H
DB   000H,000H,000H,000H,000H,000H,000H,000H
DB   000H,000H,000H,000H,000H,000H,000H,000H
DB   000H,000H,000H,000H,000H,000H,000H,000H
DB   000H,000H,000H,000H,000H,000H,000H,000H
DB   000H,000H,000H,000H,000H,000H,000H,000H
DB   000H,000H,000H,000H,000H,000H,000H,000H
DB   000H,000H,000H,000H,000H,000H,000H,000H
DB   000H,000H,000H,000H,000H,000H,000H,000H
DB   000H,000H,000H,000H,000H,000H,000H,000H
DB   000H,000H,000H,000H,000H,000H,000H,000H
DB   000H,000H,000H,000H,000H,000H,000H,000H
DB   000H,000H,000H,000H,000H,000H,000H,000H
DB   000H,000H,000H,000H,000H,000H,000H,000H
DB   000H,000H,000H,000H,000H,000H,000H,000H
DB   000H,000H,000H,000H,000H,000H,000H,000H
DB   000H,000H,000H,000H,000H,000H,000H,000H
DB   000H,000H,000H,000H,000H,000H,000H,000H
DB   000H,000H,000H,000H,000H,000H,000H,000H
DB   000H,000H,000H,000H,000H,000H,000H,000H
DB   000H,000H,000H,000H,000H,000H,000H,000H			;7F2
DB   000H,000H,000H,000H,055H,0AAH				;7FA

BUILDBOOT ENDP 


;******************************************************************************
;
;	DELETE :  PRINTS WARNING,
;		  DELETES ONE AMIGA PARTITION.
;
;****************************************************************************

DELETE	PROC	NEAR

	CALL	SETUP			; CLS AND SET CURSOR
  
	MOV	SI,OFFSET MDELNUM
	CALL	PRINT			; PRINT USER MESSAGE
	MOV	SI,OFFSET MESC
	CALL	PRINT
D0: 
	MOV	AX,0700H		; SET FUNCTION
	CALL	DOSFUNCTION		; READ KEYBOARD (CHAR IN AL)
	CMP	AL,ESCKEY		; <ESC>?
	JNE	D2  
	STC
	RET				; RETURN TO MENUE

D2:	
	SUB	AL,30H			; CONVERT ASCII TO HEX
	CMP	AL,PART_COUNT
	JA	D0			; THIS PARTITION IS NOT INSTALLED
    
	MOV	BX,OFFSET PAT  
	ADD	BX,40H			; POINT TO FIRST PARTITION + 10H
	XOR	CH,CH 
	XCHG	CL,AL
D1:
	SUB	BX,10H
	LOOP	D1

	MOV	DX,WORD PTR [BX+01CAH]	; PARTITION INSTALLED ?
	OR	DX,WORD PTR [BX+01CBH]	; TEST FOR NULL
	JNZ	D6			; JUMP, IF PARTITION HERE
	SUB	BX,10H
	MOV	DX,WORD PTR [BX+01CAH]	; PARTITION INSTALLED ?
	OR	DX,WORD PTR [BX+01CBH]	; TEST FOR NULL
	JNZ	D6			; JUMP, IF PARTITION HERE
	SUB	BX,10H

D6:
	MOV	DI,BX
	ADD	DI,01BEH		; DI POINTS NOW TO DELETABLE PARTITION

	CMP	BYTE PTR [BX+01C2H],AMIGA  ; LOOKS ABOUT PART. TYPE
	JE	D3			; FOUND AMIGA

	CALL	SETUP
	MOV	SI,OFFSET ODELERROR
	CALL	PRINT			; PRINT ERROR MESSAGE
D4:
	MOV	AX,0700H		; SET FUNCTION
	CALL	DOSFUNCTION		; READ KEYBOARD (CHAR IN AL)
	CMP	AL,ESCKEY		; <ESC>?
	JNE	D4
	STC
	RET				; RETURN TO MENUE
 
D3:
	CALL	SETUP
	MOV	SI,OFFSET MDELETE
	CALL	PRINT			; PRINT USER MESSAGE
   
	MOV	AX,0700H		; SET FUNCTION
	CALL	DOSFUNCTION		; READ KEYBOARD (CHAR IN AL)
	OR	AL,20H			; CONVERT UPPER TO LOWER
	CMP	AL,YESCHR		; < y,Y >?
	JE	D5
	STC
	RET				; RETURN TO MENUE
D5: 
	MOV	CX,000FH   
	SUB	AX,AX
REP	STOSB				; DELETE PARTITION


	CLC
	RET

DELETE	ENDP


;*******************************************************************
;
;	SETUP :  CLEARS SCREEN AND SET CURSOR 
;		 TO START OF MENUE  
;
;*******************************************************************

SETUP	PROC	NEAR

	MOV	CX,0E00H		; SET SCREEN SIZE
	MOV	DX,1850H
	CALL	CLS			; CLEAR SCREEN

	MOV	BH,0
	MOV	AX,0200H		; SET CURSOR
	MOV	DX,0F00H		; TO R14,C0
	INT	VIDEO

	RET

SETUP	ENDP


;*****************************************************************
;
;	       ROUTINES TO DISPLAY BYTES, WORDS, STRINGS.
;	  
;
;*****************************************************************
;
; PRINT_WORD - OUTPUTS WORD IN DX TO DISPLAY AS HEX ASCII.
; ----------
;
; PRINT_BYTE - OUTPUTS BYTE IN DH TO DISPLAY AS HEX ASCII.
; ----------
;
; PRINT_DEC  - OUTPUTS WORD IN DX TO DISPLY AS DECIMAL ASCII.
; ---------
;
;	       ALTERS AX,BX,CX,DX.
;
;****************************************************************
;
; PRINT -  DISPLAYS 0-TERMINATED STRING @ CS:SI
; -----    ON TERMINAL. ALTERS AX,BX,SI.
;
;****************************************************************
;
;	PRINT_WORD   ( ENTRY )
;
;	PRINT_BYTE   ( ENTRY )
;
;****************************************************************

PRINT_WORD PROC NEAR
	MOV	CX,4			; PRINT 4 NYBBLES
	JMP	SHORT	PRINT_NYBBLES

PRINT_BYTE LABEL NEAR
	MOV	CX,2			; PRINT 2 NYBBLES

PRINT_NYBBLES LABEL NEAR
	PUSH	CX
	MOV	CL,04
	ROL	DX,CL			; SHIFT HI NYBBLE TO LO NYBBLE POSN
	MOV	AL,DL
	CALL	DIGIT			; ..CONVERT TO HEX ASCII IN AL
	POP	CX
	LOOP	PRINT_NYBBLES
	RET
PRINT_WORD ENDP


;****************************************************************
;
;	DIGIT - CONVERTS LOW NYBBLE OF AL TO ASCII HEX IN AL.
;
;****************************************************************

DIGIT	PROC	NEAR
	AND	AL,0FH			; MASK OUT LOW NYBBLE
	ADD	AL,'0'
	CMP	AL,'9'
	JLE	SEND_BYTE
	ADD	AL,(('A')-(1+'9'))
DIGIT	ENDP				; FALL INTO SEND_BYTE

 
;****************************************************************
;
;	SEND_BYTE - SENDS BYTE IN AL TO DISPLAY
;	---------   ALTERS AH, BX.
;
;****************************************************************

SEND_BYTE PROC	NEAR
	MOV	AH,WRITE_TTY		; ..WRITE TTY
	XOR	BX,BX
	INT	VIDEO
	RET
SEND_BYTE ENDP


;*******************************************************************
;
;	OUT_STRING   ( ENTRY )
;
;*******************************************************************

OUT_STR PROC	NEAR
	CALL	SEND_BYTE

PRINT:	    
	CLD
	LODS	CS:BYTE PTR [SI]
	OR	AL,AL			; END OF STRING?
	JNE	OUT_STR
	RET
OUT_STR ENDP

;******************************************************************
;
;	PRINT-DEC :
;
;	PRINT UNSIGNED WORD IN DECIMAL FORM, LEADING ZEROS SUPPRESSED
;	METHOD: DIVIDE BY TEN UNTIL WORD IS 0
;	SAVE REMAINDERS OF DIVISION ON STACK (LSD FIRST)
;	POP REMAINDERS FROM STACK (MSD FIRST) AND PRINT LOW BYTE DIGITS
;
;******************************************************************************

PRINT_DEC PROC	NEAR			; PRINT DECIMAL WORD IN DX
	SUB	CX,CX			; DIGIT COUNTER
	MOV	AX,DX			; AX:DX NUMERATOR WORD
PD1:	SUB	DX,DX			; CLEAR REG FOR MULTIPLY 
	DIV	CS:TEN			; DIVIDE BY TEN
	PUSH	DX			; REMAINDER IN DX IS DIGIT WANTED
	INC	CX			; SAVE AND MARK
	OR	AX,AX			; NEW NUMERATOR ALREADY 0 ?
	JNZ	PD1			; DO UNTIL SO
					; AT LEAST ONE DIGIT IS ON STACK NOW
PD2:	POP	AX			; GET MORE SIGNIFICANT DIGIT
	CALL	DIGIT			; CONVERT TO ASCII & PRINT
	LOOP	PD2			; UNTIL ALL DIGITS ARE DONE
					; STACK NOW OK
	RET				; ALL DONE

TEN	LABEL	WORD
	DW	10			; NUMBER BASE

PRINT_DEC ENDP


;******************************************************************************

CSEG	ENDS
	END ENTRY
