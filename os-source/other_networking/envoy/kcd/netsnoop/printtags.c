/* The function that prints out all the interesting stuff in a 
   taglist returned by NIPCInquiry().

   Note that most of the code is generated by an arexx script,
   as it's exceedingly boring to write, and very easy to make
   lots of typos when writing it.
*/

#include <exec/types.h>
#include <exec/lists.h>
#include <exec/libraries.h>
#include <exec/execbase.h>       /* for attnflags */
#include <graphics/gfxbase.h>    /* for chiprevbits */
#include <dos/dos.h>
#include <dos/rdargs.h>          /* for tagstruct.h */
#include <utility/tagitem.h>
#include <utility/hooks.h>       /* for tagstruct.h */
#include <envoy/nipc.h>
#include <clib/exec_protos.h>
#include <clib/dos_protos.h>
#include <clib/utility_protos.h>

#include "tagstruct.h"

/* protos */
VOID printTagArray(struct TagItem *tagArr);
static VOID printChipFlags(ULONG);
static VOID printAttnFlags(ULONG);
extern STRPTR addrFromULong(ULONG);


extern struct Globals *g;  /* netsnoop.c.  struct defined in tagstruct.h. */

/* dos and exec must already be open, as usual */

/* printTagArray ==================================================================
   Boring, big function to print out stuff returned by NipcInquiry.
*/
VOID printTagArray(struct TagItem *tagArr) {
    struct TagItem *ti, *tagState;        /* TagItem tracking */
    STRPTR atmp;                          /* for ip addresses */
    ULONG tmpRev, tmpVer;                 /* for Version.Revision printing */

    if (!tagArr)
        return;

    tagState = tagArr;

    while (ti = NextTagItem(&tagState)) {
        if (ti->ti_Tag == TAG_DONE) {
            break;
        }

        if (CheckSignal(SIGBREAKF_CTRL_C))
            return;

    /* LONG BORING BUNCH OF PRINTF()s .......................................... */
    /* ALL THIS STUFF IS GENERATED BY boreswitch.rexx WITH FILE "T2"             */
    /* to get #ifdef DEBUG stuff, "rx >tmpfile boreswitch debug"                 */
    /* Note that the AttnFlags & ChipRevBit stuff is done by hand.               */
    /* and some tweaking of the libvers stuff which was giving enforcer hits     */

        switch (ti->ti_Tag) {

            case QUERY_IPADDR:
                if (g->pr_ipaddr) {
                    if (atmp = addrFromULong(ti->ti_Data)) {
                        Printf("query_ipaddr: '%s'\n", atmp);
                        FreeVec(atmp);
                    }
                }
                break;

            case MATCH_IPADDR:
                if (g->pr_ipaddr) {
                    if (atmp = addrFromULong(ti->ti_Data)) {
                        Printf("match_ipaddr: '%s'\n", atmp);
                        FreeVec(atmp);
                    }
                }
                break;

            case QUERY_REALMS:
                Printf("query_realms: '%s'\n", ti->ti_Data);
                break;

            case MATCH_REALM:
                Printf("match_realm: '%s'\n", ti->ti_Data);
                break;

            case QUERY_HOSTNAME:
                Printf("query_hostname: '%s'\n", ti->ti_Data);
                break;

            case MATCH_HOSTNAME:
                Printf("match_hostname: '%s'\n", ti->ti_Data);
                break;

            case QUERY_SERVICE:
                Printf("query_service: '%s'\n", ti->ti_Data);
                break;

            case MATCH_SERVICE:
                Printf("match_service: '%s'\n", ti->ti_Data);
                break;

            case QUERY_ENTITY:
                Printf("query_entity: '%s'\n", ti->ti_Data);
                break;

            case MATCH_ENTITY:
                Printf("match_entity: '%s'\n", ti->ti_Data);
                break;

            case QUERY_OWNER:
                Printf("query_owner: '%s'\n", ti->ti_Data);
                break;

            case MATCH_OWNER:
                Printf("match_owner: '%s'\n", ti->ti_Data);
                break;

            case QUERY_MACHDESC:
                Printf("query_machdesc: '%s'\n", ti->ti_Data);
                break;

            case MATCH_MACHDESC:
                Printf("match_machdesc: '%s'\n", ti->ti_Data);
                break;

            case QUERY_ATTNFLAGS:
                Printf("query_attnflags: $%08lx ==", ti->ti_Data);
                printAttnFlags(ti->ti_Data);
                break;

            case MATCH_ATTNFLAGS:
                Printf("match_attnflags: $%08lx ==", ti->ti_Data);
                printAttnFlags(ti->ti_Data);
                break;

            case QUERY_LIBVERSION:
                tmpVer = ((ti->ti_Data) ? (ti->ti_Data >> 16) : 0UL);
                tmpRev = ((ti->ti_Data) ? (ti->ti_Data & 0x0000FFFF) : 0UL);
                Printf("query_libversion: %lu.%lu\n", tmpVer, tmpRev);
                break;

            case MATCH_LIBVERSION:
                tmpVer = ((ti->ti_Data) ? (ti->ti_Data >> 16) : 0UL);
                tmpRev = ((ti->ti_Data) ? (ti->ti_Data & 0x0000FFFF) : 0UL);
                Printf("match_libversion: %lu.%lu\n", tmpVer, tmpRev);
                break;

            case QUERY_CHIPREVBITS:
                Printf("query_chiprevbits: $%08lx ==", ti->ti_Data);
                printChipFlags(ti->ti_Data);
                break;

            case MATCH_CHIPREVBITS:
                Printf("match_chiprevbits: $%08lx ==", ti->ti_Data);
                printChipFlags(ti->ti_Data);
                break;

            case QUERY_MAXFASTMEM:
                Printf("query_maxfastmem: %lu\n", ti->ti_Data);
                break;

            case MATCH_MAXFASTMEM:
                Printf("match_maxfastmem: %lu\n", ti->ti_Data);
                break;

            case QUERY_AVAILFASTMEM:
                Printf("query_availfastmem: %lu\n", ti->ti_Data);
                break;

            case MATCH_AVAILFASTMEM:
                Printf("match_availfastmem: %lu\n", ti->ti_Data);
                break;

            case QUERY_MAXCHIPMEM:
                Printf("query_maxchipmem: %lu\n", ti->ti_Data);
                break;

            case MATCH_MAXCHIPMEM:
                Printf("match_maxchipmem: %lu\n", ti->ti_Data);
                break;

            case QUERY_AVAILCHIPMEM:
                Printf("query_availchipmem: %lu\n", ti->ti_Data);
                break;

            case MATCH_AVAILCHIPMEM:
                Printf("match_availchipmem: %lu\n", ti->ti_Data);
                break;

            case QUERY_KICKVERSION:
                Printf("query_kickversion: %lu.%lu\n", (ti->ti_Data >> 16), (ti->ti_Data & 0x0000FFFF));
                break;

            case MATCH_KICKVERSION:
                Printf("match_kickversion: %lu.%lu\n", (ti->ti_Data >> 16), (ti->ti_Data & 0x0000FFFF));
                break;

            case QUERY_WBVERSION:
                Printf("query_wbversion: %lu.%lu\n", (ti->ti_Data >> 16), (ti->ti_Data & 0x0000FFFF));
                break;

            case MATCH_WBVERSION:
                Printf("match_wbversion: %lu.%lu\n", (ti->ti_Data >> 16), (ti->ti_Data & 0x0000FFFF));
                break;

            case QUERY_NIPCVERSION:
                Printf("query_nipcversion: %lu.%lu\n", (ti->ti_Data >> 16), (ti->ti_Data & 0x0000FFFF));
                break;

            case MATCH_NIPCVERSION:
                Printf("match_nipcversion: %lu.%lu\n", (ti->ti_Data >> 16), (ti->ti_Data & 0x0000FFFF));
                break;

            default:
                break;
        } /* end switch */

    /* END OF LONG BORING BUNCH OF PRINTF()s ................................... */

    } /* end for() */

    PutStr("\n");
    return;
}

/* printAttnFlags ===================================================================
 */
static VOID printAttnFlags(ULONG fl) {

    if (!fl)
        PutStr(" None!");

    if (fl & AFF_68010)
        PutStr(" 68010");
    if (fl & AFF_68020)
        PutStr(" 68020");
    if (fl & AFF_68030)
        PutStr(" 68030");
    if (fl & AFF_68040)
        PutStr(" 68040");
    if (fl & AFF_68881)
        PutStr(" 68881");
    if (fl & AFF_68882)
        PutStr(" 68882");
    if (fl & AFF_FPU40)
        PutStr(" FPU40");
    if (fl & AFF_PRIVATE)
        PutStr(" Private");
    PutStr("\n");
}

/* printChipFlags =====================================================================
 */
static VOID printChipFlags(ULONG fl) {

    /* describe chip set */
    switch (fl & ~((ULONG)(GFXF_AA_MLISA))) {
        case (ULONG)SETCHIPREV_A:
            PutStr(" (Orig)");
            break;
        case (ULONG)SETCHIPREV_ECS:
            PutStr(" (ECS)");
            break;
        case (ULONG)SETCHIPREV_AA:
            PutStr(" (AGA)");
            break;
        default:
            break;
    }

    /* describe individual chips */
    if (fl & (ULONG)(GFXF_HR_AGNUS)) {
        PutStr(" HR_Agnus");
    }
    if (fl & (ULONG)(GFXF_HR_DENISE)) {
        PutStr(" HR_Denise");
    }
    if (fl & (ULONG)(GFXF_AA_ALICE)) {
        PutStr(" AA_Alice");
    }
    if (fl & (ULONG)(GFXF_AA_LISA)) {
        PutStr(" AA_Lisa");
    }
    if (fl & (ULONG)(GFXF_AA_MLISA)) {
        PutStr(" AA_MLisa");
    }

    PutStr("\n");
}

