
/* Code generated by Toolmaker V1.1.19 */

/* includes */

#include <exec/types.h>
#include <exec/memory.h>
#include <intuition/intuition.h>
#include <intuition/gadgetclass.h>
#include <libraries/gadtools.h>
#include <stdlib.h>
#include <graphics/view.h>

#include <clib/exec_protos.h>
#include <clib/intuition_protos.h>
#include <clib/gadtools_protos.h>

/* Pragma includes for register parameters */

#include <pragmas/exec_pragmas.h>
#include <pragmas/intuition_pragmas.h>
#include <pragmas/gadtools_pragmas.h>

#include "locator_tm.h"
#include "locator_text.h"

/* Data for DISABLEd window pointer */

UWORD chip WaitPointer[] =
{
    0x0000, 0x0000,
    0x0400, 0x07C0,
    0x0000, 0x07C0,
    0x0100, 0x0380,
    0x0000, 0x07E0,
    0x07C0, 0x1FF8,
    0x1FF0, 0x3FEC,
    0x3FF8, 0x7FDE,
    0x3FF8, 0x7FBE,
    0x7FFC, 0xFF7F,
    0x7EFC, 0xFFFF,
    0x7FFC, 0xFFFF,
    0x3FF8, 0x7FFE,
    0x3FF8, 0x7FFE,
    0x1FF0, 0x3FFC,
    0x07C0, 0x1FF8,
    0x0000, 0x07E0,
    0x0000, 0x0000,
};

/* TTextAttr structures */

struct TTextAttr topaz8 =
{
    "topaz.font",       /* tta_Name */
    8,              /* tta_YSize */
    FS_NORMAL,          /* tta_Style */
    0x1,            /* tta_Flags */
    NULL            /* *tta_Tags */
};

extern ULONG query_MaxTime;
extern struct MinList ResultList;
/* Functions */

/* ----------------------------------------------- */
/* TM_Request - display a message in a requester  */
/* ----------------------------------------------- */

LONG TM_Request(struct Window * window, char *title, char *textformat, char *gadgetformat)
{
    struct EasyStruct es =
    {sizeof(struct EasyStruct), 0, NULL, NULL, NULL};

    es.es_Title = title;
    es.es_TextFormat = textformat;
    es.es_GadgetFormat = gadgetformat;

    return (EasyRequestArgs(window, &es, NULL, NULL));
}

/* -------------------- */
/* TM_Open - open all  */
/* -------------------- */

LONG TM_Open(struct TMData ** TMData)
{
    struct TMData *tmdata;
    LONG error;

    if (tmdata = AllocMem(sizeof(struct TMData), MEMF_CLEAR))
    {
    tmdata->Size = sizeof(struct TMData);

    if (tmdata->WindowMsgPort = CreateMsgPort())
    {
        if (tmdata->Screen = LockPubScreen(NULL))
        {
        if (tmdata->VisualInfo = GetVisualInfo(tmdata->Screen, TAG_DONE))
        {
            *TMData = tmdata;
            return (NULL);
        }
        else
            error = TMERROR_VISUALINFO;
        UnlockPubScreen(NULL, tmdata->Screen);
        }
        else
        error = TMERROR_SCREEN;
        DeleteMsgPort(tmdata->WindowMsgPort);
    }
    else
        error = TMERROR_MSGPORT;
    FreeMem(tmdata, sizeof(struct TMData));
    }
    else
    error = TMERROR_MEMORY;

    return (error);
}

/* --------------------------------------------------- */
/* TM_EventLoop - call signal function when signaled  */
/* --------------------------------------------------- */

VOID TM_EventLoop(struct TMData * TMData)
{
    BOOL done = FALSE, result;
    ULONG windowsignal, signals;

    windowsignal = 1L << TMData->WindowMsgPort->mp_SigBit;

    while (!done)
    {
    signals = Wait(windowsignal | TMData->UserSignal);

    if (signals & windowsignal)
    {
        if (result = TM_WindowSignal(TMData))
        done = result;
    }
    if (signals & TMData->UserSignal)
    {
        if (result = UserSignal(TMData, signals))
        done = result;
    }
    }
}

/* --------------------------------------------------- */
/* TM_WindowSignal - call appropriate IDCMP function  */
/* --------------------------------------------------- */

BOOL TM_WindowSignal(struct TMData * TMData)
{
    BOOL done = FALSE;
    BOOL result;
    struct IntuiMessage *imessage;

    while (imessage = GT_GetIMsg(TMData->WindowMsgPort))
    {
    if (imessage->IDCMPWindow == TMData->TMWindowInfo[0].Window)
    {
        if (result = TM_Window0IDCMP(TMData, imessage))
        done = result;
    }

    GT_ReplyIMsg(imessage);
    }

    return (done);
}

/* --------------------------------------------------- */
/* TM_Window#IDCMP - call appropriate IDCMP function  */
/* --------------------------------------------------- */

BOOL TM_Window0IDCMP(struct TMData * TMData, struct IntuiMessage * imessage)
{
    BOOL done = FALSE;
    BOOL result;

    switch (imessage->Class)
    {
    case IDCMP_REFRESHWINDOW:   /* Always refresh */
        GT_BeginRefresh(TMData->TMWindowInfo[0].Window);
        GT_EndRefresh(TMData->TMWindowInfo[0].Window, TRUE);
        break;

    case IDCMP_GADGETDOWN:
        if (result = Window0GADGETDOWN(TMData, imessage))
        done = result;
        break;

    case IDCMP_GADGETUP:
        if (result = Window0GADGETUP(TMData, imessage))
        done = result;
        break;

    case IDCMP_CLOSEWINDOW:
        if (result = Window0CLOSEWINDOW(TMData, imessage))
        done = result;
        break;

    }

    return (done);
}

/* --------------------------------------- */
/* TM_Window# - DISPLAY or REMOVE window  */
/* --------------------------------------- */

BOOL TM_Window0(struct TMData * TMData, UBYTE command)
{
    static char *gadget5labels1[] =
    {TEXT_W0G5L1S1, TEXT_W0G5L1S2, TEXT_W0G5L1S3, TEXT_W0G5L1S4, NULL}; /* NHClass_Hosts */
    struct NewGadget ng;

    switch (command)
    {
    case DISPLAY:
        if (TMData->TMWindowInfo[0].Window)
        {
        WindowToFront(TMData->TMWindowInfo[0].Window);
        ActivateWindow(TMData->TMWindowInfo[0].Window);
        }
        else
        {
        TMData->TMWindowInfo[0].FirstGadget = &TMData->Window0Gadget[0];
        TMData->Window0Gadget[1] = CreateContext(&TMData->Window0Gadget[0]);

        ng.ng_VisualInfo = TMData->VisualInfo;

        ng.ng_LeftEdge = 16;
        ng.ng_TopEdge = 4 + TMData->Screen->BarHeight;
        ng.ng_Width = 260;
        ng.ng_Height = 12;
        ng.ng_Flags = PLACETEXT_IN | NG_HIGHLABEL;
        ng.ng_TextAttr = (struct TextAttr *) & topaz8;
        ng.ng_GadgetText = TEXT_W0G2;   /* Query Setup */
        ng.ng_GadgetID = ID_LC_Text0;
        TMData->Window0Gadget[2] = CreateGadget(TEXT_KIND, TMData->Window0Gadget[1], &ng,
                            TAG_DONE);

        ng.ng_LeftEdge = 164;
        ng.ng_TopEdge = 98 + TMData->Screen->BarHeight;
        ng.ng_Width = 112;
        ng.ng_Height = 14;
        ng.ng_Flags = PLACETEXT_IN;
        ng.ng_GadgetText = TEXT_W0G3;   /* Send Query */
        ng.ng_GadgetID = ID_LC_Send;
        TMData->Window0Gadget[3] = CreateGadget(BUTTON_KIND, TMData->Window0Gadget[2], &ng,
                            TAG_DONE);

        ng.ng_LeftEdge = 114;
        ng.ng_Width = 46;
        ng.ng_Flags = PLACETEXT_LEFT;
        ng.ng_GadgetText = TEXT_W0G4;   /* Timeout */
        ng.ng_GadgetID = ID_LC_Timeout;
        TMData->Window0Gadget[4] = CreateGadget(INTEGER_KIND, TMData->Window0Gadget[3], &ng,
                            GTIN_Number, query_MaxTime,
                            TAG_DONE);

        ng.ng_TopEdge = 18 + TMData->Screen->BarHeight;
        ng.ng_Width = 162;
        ng.ng_GadgetText = TEXT_W0G5;   /* Query Class */
        ng.ng_GadgetID = ID_LC_Class;
        TMData->Window0Gadget[5] = CreateGadget(CYCLE_KIND, TMData->Window0Gadget[4], &ng,
                        GTCY_Labels, gadget5labels1,
                            TAG_DONE);

        ng.ng_TopEdge = 82 + TMData->Screen->BarHeight;
        ng.ng_GadgetText = TEXT_W0G6;   /* Entity Name */
        ng.ng_GadgetID = ID_LC_Entity;
        TMData->Window0Gadget[6] = CreateGadget(STRING_KIND, TMData->Window0Gadget[5], &ng,
                            GTST_MaxChars, 64,
                            TAG_DONE);

        ng.ng_TopEdge = 66 + TMData->Screen->BarHeight;
        ng.ng_GadgetText = TEXT_W0G7;   /* Service Name */
        ng.ng_GadgetID = ID_LC_Service;
        TMData->Window0Gadget[7] = CreateGadget(STRING_KIND, TMData->Window0Gadget[6], &ng,
                            GTST_MaxChars, 64,
                            TAG_DONE);

        ng.ng_TopEdge = 50 + TMData->Screen->BarHeight;
        ng.ng_GadgetText = TEXT_W0G8;   /* Amiga Name */
        ng.ng_GadgetID = ID_LC_Host;
        TMData->Window0Gadget[8] = CreateGadget(STRING_KIND, TMData->Window0Gadget[7], &ng,
                            GTST_MaxChars, 64,
                            TAG_DONE);

        ng.ng_TopEdge = 34 + TMData->Screen->BarHeight;
        ng.ng_GadgetText = TEXT_W0G9;   /* Realm Name */
        ng.ng_GadgetID = ID_LC_Realm;
        TMData->Window0Gadget[9] = CreateGadget(STRING_KIND, TMData->Window0Gadget[8], &ng,
                            GTST_MaxChars, 64,
                            TAG_DONE);

        ng.ng_LeftEdge = 280;
        ng.ng_TopEdge = 18 + TMData->Screen->BarHeight;
        ng.ng_Width = 206;
        ng.ng_Height = 94;
        ng.ng_Flags = PLACETEXT_ABOVE | NG_HIGHLABEL;
        ng.ng_GadgetText = TEXT_W0G10;  /* Query Result */
        ng.ng_GadgetID = ID_LC_Result;
        TMData->Window0Gadget[10] = CreateGadget(LISTVIEW_KIND, TMData->Window0Gadget[9], &ng,
                             GTLV_ReadOnly, TRUE,
                             GTLV_Labels, (ULONG)&ResultList,
                               GTLV_ScrollWidth, 18,
                             TAG_DONE);

        if (!TMData->Window0Gadget[10])
            goto cleanexit;

        if (!(TMData->TMWindowInfo[0].Window = OpenWindowTags(NULL,
                           WA_PubScreen, TMData->Screen,
                             WA_Title, TEXT_W0TITLE,    /* NIPC Locator Utility */
                                 WA_IDCMP, NULL,
                       WA_Gadgets, TMData->Window0Gadget[0],
                              WA_WBenchWindow, TRUE,
                               WA_DragBar, TRUE,
                               WA_DepthGadget, TRUE,
                               WA_CloseGadget, TRUE,
                                   WA_Left, 268,
                                WA_Top, 194,
                             WA_InnerWidth, 540,
                            WA_InnerHeight, 120,
                                WA_MinWidth, 50,
                               WA_MinHeight, 30,
                                WA_MaxWidth, -1,
                               WA_MaxHeight, -1,
                              WA_Activate, TRUE,
                             WA_SimpleRefresh, TRUE,
                                 TAG_DONE)))
            goto cleanexit;

        TMData->TMWindowInfo[0].Window->UserPort = TMData->WindowMsgPort;
        ModifyIDCMP(TMData->TMWindowInfo[0].Window, IDCMP_REFRESHWINDOW | TEXTIDCMP | BUTTONIDCMP | INTEGERIDCMP | CYCLEIDCMP | STRINGIDCMP | LISTVIEWIDCMP | IDCMP_GADGETDOWN | IDCMP_GADGETUP | IDCMP_CLOSEWINDOW);
        GT_RefreshWindow(TMData->TMWindowInfo[0].Window, NULL);
        TMData->TMWindowInfo[0].Flags |= TMWF_OPEN;
        }
        break;

    case REMOVE:
        TM_RemoveWindow(&TMData->TMWindowInfo[0]);
        break;

    case DISABLE:
        if (TMData->TMWindowInfo[0].DisableCount == 0)
        {
        InitRequester(&TMData->TMWindowInfo[0].Requester);
        if (Request(&TMData->TMWindowInfo[0].Requester, TMData->TMWindowInfo[0].Window))
        {
            TMData->TMWindowInfo[0].Flags |= TMWF_DISABLED;
            SetPointer(TMData->TMWindowInfo[0].Window, WaitPointer, 16, 16, -6, 0);
        }
        }

        TMData->TMWindowInfo[0].DisableCount++;
        break;

    case ENABLE:
        TMData->TMWindowInfo[0].DisableCount--;

        if (TMData->TMWindowInfo[0].DisableCount == 0 && TMData->TMWindowInfo[0].Flags & TMWF_DISABLED)
        {
        EndRequest(&TMData->TMWindowInfo[0].Requester, TMData->TMWindowInfo[0].Window);
        TMData->TMWindowInfo[0].Flags &= ~TMWF_DISABLED;
        ClearPointer(TMData->TMWindowInfo[0].Window);
        }
        break;
    }

    return (TRUE);

  cleanexit:            /* Error trap */
    TM_RemoveWindow(&TMData->TMWindowInfo[0]);
    return (FALSE);
}

/* -------------------------------------------------------------- */
/* TM_RemoveWindow - Don't call directly! Use TM_Window(REMOVE)  */
/* -------------------------------------------------------------- */

VOID TM_RemoveWindow(struct TMWindowInfo * TMWindowInfo)
{
    struct IntuiMessage *imessage;
    struct Node *succ;

    if (TMWindowInfo->Window)
    {
    if (TMWindowInfo->Menu)
    {
        ClearMenuStrip(TMWindowInfo->Window);
        FreeMenus(TMWindowInfo->Menu);
        TMWindowInfo->Menu = NULL;
    }

    if (TMWindowInfo->Window->UserPort)
    {
        Forbid();
        imessage = (struct IntuiMessage *) TMWindowInfo->Window->UserPort->mp_MsgList.lh_Head;
        while (succ = imessage->ExecMessage.mn_Node.ln_Succ)
        {
        if (imessage->IDCMPWindow == TMWindowInfo->Window)
        {
            Remove((struct Node *) imessage);
            GT_ReplyIMsg(imessage);
        }
        imessage = (struct IntuiMessage *) succ;
        }
        TMWindowInfo->Window->UserPort = NULL;
        ModifyIDCMP(TMWindowInfo->Window, 0L);
        Permit();
    }

    CloseWindow(TMWindowInfo->Window);
    TMWindowInfo->Window = NULL;
    TMWindowInfo->Flags = NULL;
    }
    if (TMWindowInfo->FirstGadget)
    {
    FreeGadgets(*TMWindowInfo->FirstGadget);
    TMWindowInfo->FirstGadget = NULL;
    }
}

/* ---------------------- */
/* TM_Close - close all  */
/* ---------------------- */

VOID TM_Close(struct TMData * TMData)
{
    if (TMData)
    {
    if (TMData->VisualInfo)
        FreeVisualInfo(TMData->VisualInfo);
    if (TMData->Screen)
        UnlockPubScreen(NULL, TMData->Screen);
    if (TMData->WindowMsgPort)
        DeleteMsgPort(TMData->WindowMsgPort);
    FreeMem(TMData, TMData->Size);
    }
}
