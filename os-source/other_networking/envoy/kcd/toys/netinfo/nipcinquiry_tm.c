
/* Code generated by Toolmaker V1.1.19 */

/* includes */
 
#include <exec/types.h>
#include <exec/memory.h>
#include <intuition/intuition.h>
#include <intuition/gadgetclass.h>
#include <libraries/gadtools.h>
#include <stdlib.h>
#include <graphics/view.h>

#include <clib/exec_protos.h>
#include <clib/intuition_protos.h>
#include <clib/gadtools_protos.h>

/* Pragma includes for register parameters */
 
#include <pragmas/exec.h>
#include <pragmas/intuition.h>
#include <pragmas/gadtools.h>

#include "NIPCInquiry_tm.h"
#include "NIPCInquiry_text.h"

/* Data for DISABLEd window pointer */
 
UWORD chip WaitPointer[] =
  {
  0x0000, 0x0000,
  0x0400, 0x07C0,
  0x0000, 0x07C0,
  0x0100, 0x0380,
  0x0000, 0x07E0,
  0x07C0, 0x1FF8,
  0x1FF0, 0x3FEC,
  0x3FF8, 0x7FDE,
  0x3FF8, 0x7FBE,
  0x7FFC, 0xFF7F,
  0x7EFC, 0xFFFF,
  0x7FFC, 0xFFFF,
  0x3FF8, 0x7FFE,
  0x3FF8, 0x7FFE,
  0x1FF0, 0x3FFC,
  0x07C0, 0x1FF8,
  0x0000, 0x07E0,
  0x0000, 0x0000,
  };

/* TTextAttr structures */
 
struct TTextAttr topaz8 =
  {
  "topaz.font",	/* tta_Name */
  8,	/* tta_YSize */
  FS_NORMAL,	/* tta_Style */
  0x1,	/* tta_Flags */
  NULL	/* *tta_Tags */
  };

/* Functions */
 
/* ----------------------------------------------- */
/*  TM_Request - display a message in a requester  */
/* ----------------------------------------------- */
 
LONG TM_Request(struct Window *window, char *title, char *textformat, char *gadgetformat)
  {
  struct EasyStruct es = {sizeof(struct EasyStruct), 0, NULL, NULL, NULL};

  es.es_Title = title;
  es.es_TextFormat = textformat;
  es.es_GadgetFormat = gadgetformat;

  return(EasyRequestArgs(window, &es, NULL, NULL));
  }

/* -------------------- */
/*  TM_Open - open all  */
/* -------------------- */
 
LONG TM_Open(struct TMData **TMData)
  {
  struct TMData *tmdata;
  LONG error;

  if(tmdata = AllocMem(sizeof(struct TMData), MEMF_CLEAR))
    {
    tmdata->Size = sizeof(struct TMData);

    if(tmdata->WindowMsgPort = CreateMsgPort())
      {
      if(tmdata->Screen = LockPubScreen(NULL))
        {
        if(tmdata->VisualInfo = GetVisualInfo(tmdata->Screen, TAG_DONE))
          {
          *TMData = tmdata;
          return(NULL);
          }
        else
          error = TMERROR_VISUALINFO;
        UnlockPubScreen(NULL, tmdata->Screen);
        }
      else
        error = TMERROR_SCREEN;
      DeleteMsgPort(tmdata->WindowMsgPort);
      }
    else
      error = TMERROR_MSGPORT;
    FreeMem(tmdata, sizeof(struct TMData));
    }
  else
    error = TMERROR_MEMORY;

  return(error);
  }

/* --------------------------------------------------- */
/*  TM_EventLoop - call signal function when signaled  */
/* --------------------------------------------------- */
 
VOID TM_EventLoop(struct TMData *TMData)
  {
  BOOL done=FALSE, result;
  ULONG windowsignal, signals;

  windowsignal = 1L << TMData->WindowMsgPort->mp_SigBit;

  while(!done)
    {
    signals = Wait(windowsignal | TMData->UserSignal);

    if(signals & windowsignal)
      {
      if(result = TM_WindowSignal(TMData)) done = result;
      }
    if(signals & TMData->UserSignal)
      {
      if(result = UserSignal(TMData, signals)) done = result;
      }
    }
  }

/* --------------------------------------------------- */
/*  TM_WindowSignal - call appropriate IDCMP function  */
/* --------------------------------------------------- */
 
BOOL TM_WindowSignal(struct TMData *TMData)
  {
  BOOL done=FALSE;
  BOOL result;
  struct IntuiMessage *imessage;

  while(imessage = GT_GetIMsg(TMData->WindowMsgPort))
    {
    if(imessage->IDCMPWindow == TMData->TMWindowInfo[0].Window)
      {
      if(result = TM_Window0IDCMP(TMData, imessage)) done = result;
      }

    GT_ReplyIMsg(imessage);
    }

  return(done);
  }

/* --------------------------------------------------- */
/*  TM_Window#IDCMP - call appropriate IDCMP function  */
/* --------------------------------------------------- */
 
BOOL TM_Window0IDCMP(struct TMData *TMData, struct IntuiMessage *imessage)
  {
  BOOL done=FALSE;
  BOOL result;

  switch(imessage->Class)
    {
    case IDCMP_REFRESHWINDOW:	/* Always refresh */
      GT_BeginRefresh(TMData->TMWindowInfo[0].Window);
      GT_EndRefresh(TMData->TMWindowInfo[0].Window, TRUE);
      break;

    case IDCMP_GADGETDOWN:
      if(result = Window0GADGETDOWN(TMData, imessage)) done = result;
      break;

    case IDCMP_GADGETUP:
      if(result = Window0GADGETUP(TMData, imessage)) done = result;
      break;

    case IDCMP_CLOSEWINDOW:
      if(result = Window0CLOSEWINDOW(TMData, imessage)) done = result;
      break;

    }

  return(done);
  }

/* --------------------------------------- */
/*  TM_Window# - DISPLAY or REMOVE window  */
/* --------------------------------------- */
 
BOOL TM_Window0(struct TMData *TMData, UBYTE command)
  {
  static char *gadget2labels1[] = {TEXT_W0G2L1S1,TEXT_W0G2L1S2,NULL};	/* Query */
  static char *gadget3labels1[] = {TEXT_W0G3L1S1,TEXT_W0G3L1S2,NULL};	/* Query */
  static char *gadget4labels1[] = {TEXT_W0G4L1S1,TEXT_W0G4L1S2,NULL};	/* Query */
  static char *gadget5labels1[] = {TEXT_W0G5L1S1,TEXT_W0G5L1S2,NULL};	/* Query */
  static char *gadget18labels1[] = {TEXT_W0G18L1S1,TEXT_W0G18L1S2,NULL};	/* Query */
  struct NewGadget ng;

  switch(command)
    {
    case DISPLAY:
      if(TMData->TMWindowInfo[0].Window)
        {
        WindowToFront(TMData->TMWindowInfo[0].Window);
        ActivateWindow(TMData->TMWindowInfo[0].Window);
        }
      else
        {
        TMData->TMWindowInfo[0].FirstGadget = &TMData->Window0Gadget[0];
        TMData->Window0Gadget[1] = CreateContext(&TMData->Window0Gadget[0]);

        ng.ng_VisualInfo = TMData->VisualInfo;

        ng.ng_LeftEdge = 12;
        ng.ng_TopEdge = 6+TMData->Screen->BarHeight;
        ng.ng_Width = 74;
        ng.ng_Height = 14;
        ng.ng_Flags = PLACETEXT_LEFT;
        ng.ng_TextAttr = (struct TextAttr *) &topaz8;
        ng.ng_GadgetText = TEXT_W0G2;	 
        ng.ng_GadgetID = ID_REALM_TYPE;
        TMData->Window0Gadget[2] = CreateGadget(CYCLE_KIND, TMData->Window0Gadget[1], &ng,
		GTCY_Labels, gadget2labels1,
		TAG_DONE);

        ng.ng_TopEdge = 22+TMData->Screen->BarHeight;
        ng.ng_GadgetText = TEXT_W0G3;	 
        ng.ng_GadgetID = ID_HOST_TYPE;
        TMData->Window0Gadget[3] = CreateGadget(CYCLE_KIND, TMData->Window0Gadget[2], &ng,
		GTCY_Labels, gadget3labels1,
		TAG_DONE);

        ng.ng_TopEdge = 38+TMData->Screen->BarHeight;
        ng.ng_GadgetText = TEXT_W0G4;	 
        ng.ng_GadgetID = ID_ENTITY_TYPE;
        TMData->Window0Gadget[4] = CreateGadget(CYCLE_KIND, TMData->Window0Gadget[3], &ng,
		GTCY_Labels, gadget4labels1,
		TAG_DONE);

        ng.ng_TopEdge = 54+TMData->Screen->BarHeight;
        ng.ng_GadgetText = TEXT_W0G5;	 
        ng.ng_GadgetID = ID_SVC_TYPE;
        TMData->Window0Gadget[5] = CreateGadget(CYCLE_KIND, TMData->Window0Gadget[4], &ng,
		GTCY_Labels, gadget5labels1,
		TAG_DONE);

        ng.ng_TopEdge = 74+TMData->Screen->BarHeight;
        ng.ng_Width = 578;
        ng.ng_Height = 100;
        ng.ng_Flags = PLACETEXT_ABOVE;
        ng.ng_GadgetText = TEXT_W0G6;	 
        ng.ng_GadgetID = ID_RESULT_DISP;
        TMData->Window0Gadget[6] = CreateGadget(LISTVIEW_KIND, TMData->Window0Gadget[5], &ng,
		GTLV_ReadOnly, TRUE,
		GTLV_ScrollWidth, 16,
		TAG_DONE);

        ng.ng_LeftEdge = 88;
        ng.ng_TopEdge = 6+TMData->Screen->BarHeight;
        ng.ng_Width = 130;
        ng.ng_Height = 14;
        ng.ng_Flags = PLACETEXT_RIGHT;
        ng.ng_GadgetText = TEXT_W0G7;	/* Realm */
        ng.ng_GadgetID = ID_REALM_NAME;
        TMData->Window0Gadget[7] = CreateGadget(STRING_KIND, TMData->Window0Gadget[6], &ng,
		TAG_DONE);

        ng.ng_TopEdge = 22+TMData->Screen->BarHeight;
        ng.ng_GadgetText = TEXT_W0G8;	/* Host */
        ng.ng_GadgetID = ID_HOST_NAME;
        TMData->Window0Gadget[8] = CreateGadget(STRING_KIND, TMData->Window0Gadget[7], &ng,
		TAG_DONE);

        ng.ng_TopEdge = 38+TMData->Screen->BarHeight;
        ng.ng_GadgetText = TEXT_W0G9;	/* Entity */
        ng.ng_GadgetID = ID_ENTITY_NAME;
        TMData->Window0Gadget[9] = CreateGadget(STRING_KIND, TMData->Window0Gadget[8], &ng,
		TAG_DONE);

        ng.ng_TopEdge = 54+TMData->Screen->BarHeight;
        ng.ng_GadgetText = TEXT_W0G10;	/* Service */
        ng.ng_GadgetID = ID_SVC_NAME;
        TMData->Window0Gadget[10] = CreateGadget(STRING_KIND, TMData->Window0Gadget[9], &ng,
		TAG_DONE);

        ng.ng_LeftEdge = 294;
        ng.ng_TopEdge = 23+TMData->Screen->BarHeight;
        ng.ng_Width = 26;
        ng.ng_Height = 11;
        ng.ng_GadgetText = TEXT_W0G11;	/* System Info */
        ng.ng_GadgetID = ID_SYS_INFO;
        TMData->Window0Gadget[11] = CreateGadget(CHECKBOX_KIND, TMData->Window0Gadget[10], &ng,
		TAG_DONE);

        ng.ng_TopEdge = 39+TMData->Screen->BarHeight;
        ng.ng_GadgetText = TEXT_W0G12;	/* Owner */
        ng.ng_GadgetID = ID_OWNER_NAME;
        TMData->Window0Gadget[12] = CreateGadget(CHECKBOX_KIND, TMData->Window0Gadget[11], &ng,
		TAG_DONE);

        ng.ng_TopEdge = 55+TMData->Screen->BarHeight;
        ng.ng_GadgetText = TEXT_W0G13;	/* Description */
        ng.ng_GadgetID = ID_MACH_DESC;
        TMData->Window0Gadget[13] = CreateGadget(CHECKBOX_KIND, TMData->Window0Gadget[12], &ng,
		TAG_DONE);

        ng.ng_LeftEdge = 370;
        ng.ng_TopEdge = 6+TMData->Screen->BarHeight;
        ng.ng_Width = 130;
        ng.ng_Height = 14;
        ng.ng_GadgetText = TEXT_W0G14;	/* IP Address */
        ng.ng_GadgetID = ID_IP_STR;
        TMData->Window0Gadget[14] = CreateGadget(STRING_KIND, TMData->Window0Gadget[13], &ng,
		TAG_DONE);

        ng.ng_LeftEdge = 424;
        ng.ng_TopEdge = 22+TMData->Screen->BarHeight;
        ng.ng_Width = 60;
        ng.ng_GadgetText = TEXT_W0G15;	/* Max Responses */
        ng.ng_GadgetID = ID_MAX_RESP;
        TMData->Window0Gadget[15] = CreateGadget(INTEGER_KIND, TMData->Window0Gadget[14], &ng,
		TAG_DONE);

        ng.ng_TopEdge = 38+TMData->Screen->BarHeight;
        ng.ng_GadgetText = TEXT_W0G16;	/* Timeout */
        ng.ng_GadgetID = ID_MAX_TIME;
        TMData->Window0Gadget[16] = CreateGadget(INTEGER_KIND, TMData->Window0Gadget[15], &ng,
		TAG_DONE);

        ng.ng_TopEdge = 54+TMData->Screen->BarHeight;
        ng.ng_Width = 166;
        ng.ng_Flags = PLACETEXT_IN;
        ng.ng_GadgetText = TEXT_W0G17;	/* Send Inquiry */
        ng.ng_GadgetID = ID_DO_INQUIRY;
        TMData->Window0Gadget[17] = CreateGadget(BUTTON_KIND, TMData->Window0Gadget[16], &ng,
		TAG_DONE);

        ng.ng_LeftEdge = 294;
        ng.ng_TopEdge = 6+TMData->Screen->BarHeight;
        ng.ng_Width = 74;
        ng.ng_Flags = PLACETEXT_LEFT;
        ng.ng_GadgetText = TEXT_W0G18;	 
        ng.ng_GadgetID = ID_IP_TYPE;
        TMData->Window0Gadget[18] = CreateGadget(CYCLE_KIND, TMData->Window0Gadget[17], &ng,
		GTCY_Labels, gadget18labels1,
		TAG_DONE);

        if(!TMData->Window0Gadget[18]) goto cleanexit;

        if(!(TMData->TMWindowInfo[0].Window = OpenWindowTags(NULL,
		WA_PubScreen, TMData->Screen,
		WA_Title, TEXT_W0TITLE,	/* NIPC Network Information */
		WA_IDCMP, NULL,
		WA_Gadgets, TMData->Window0Gadget[0],
		WA_WBenchWindow, TRUE,
		WA_DragBar, TRUE,
		WA_SizeGadget, TRUE,
		WA_DepthGadget, TRUE,
		WA_CloseGadget, TRUE,
		WA_Left, 206,
		WA_Top, 325,
		WA_InnerWidth, 596,
		WA_InnerHeight, 180,
		WA_MinWidth, 50,
		WA_MinHeight, 30,
		WA_MaxWidth, -1,
		WA_MaxHeight, -1,
		WA_Activate, TRUE,
		WA_SimpleRefresh, TRUE,
		TAG_DONE))) goto cleanexit;

        TMData->TMWindowInfo[0].Window->UserPort = TMData->WindowMsgPort;
        ModifyIDCMP(TMData->TMWindowInfo[0].Window, IDCMP_REFRESHWINDOW | CYCLEIDCMP | LISTVIEWIDCMP | STRINGIDCMP | CHECKBOXIDCMP | INTEGERIDCMP | BUTTONIDCMP | IDCMP_GADGETDOWN | IDCMP_GADGETUP | IDCMP_CLOSEWINDOW);
        GT_RefreshWindow(TMData->TMWindowInfo[0].Window, NULL);
        TMData->TMWindowInfo[0].Flags |= TMWF_OPEN;
        }
      break;

    case REMOVE:
      TM_RemoveWindow(&TMData->TMWindowInfo[0]);
      break;

    case DISABLE:
      if(TMData->TMWindowInfo[0].DisableCount==0)
        {
        InitRequester(&TMData->TMWindowInfo[0].Requester);
        if(Request(&TMData->TMWindowInfo[0].Requester, TMData->TMWindowInfo[0].Window))
          {
          TMData->TMWindowInfo[0].Flags |= TMWF_DISABLED;
          SetPointer(TMData->TMWindowInfo[0].Window, WaitPointer, 16, 16, -6, 0);
          }
        }

      TMData->TMWindowInfo[0].DisableCount++;
      break;

    case ENABLE:
      TMData->TMWindowInfo[0].DisableCount--;

      if(TMData->TMWindowInfo[0].DisableCount==0 && TMData->TMWindowInfo[0].Flags&TMWF_DISABLED)
        {
        EndRequest(&TMData->TMWindowInfo[0].Requester, TMData->TMWindowInfo[0].Window);
        TMData->TMWindowInfo[0].Flags &= ~TMWF_DISABLED;
        ClearPointer(TMData->TMWindowInfo[0].Window);
        }
      break;
    }

  return(TRUE);

  cleanexit:	/* Error trap */
  TM_RemoveWindow(&TMData->TMWindowInfo[0]);
  return(FALSE);
  }

/* -------------------------------------------------------------- */
/*  TM_RemoveWindow - Don't call directly! Use TM_Window(REMOVE)  */
/* -------------------------------------------------------------- */
 
VOID TM_RemoveWindow(struct TMWindowInfo *TMWindowInfo)
  {
  struct IntuiMessage *imessage;
  struct Node *succ;

  if(TMWindowInfo->Window)
    {
    if(TMWindowInfo->Menu)
      {
      ClearMenuStrip(TMWindowInfo->Window);
      FreeMenus(TMWindowInfo->Menu);
      TMWindowInfo->Menu = NULL;
      }

    if(TMWindowInfo->Window->UserPort)
      {
      Forbid();
      imessage = (struct IntuiMessage *) TMWindowInfo->Window->UserPort->mp_MsgList.lh_Head;
      while(succ = imessage->ExecMessage.mn_Node.ln_Succ)
        {
        if(imessage->IDCMPWindow == TMWindowInfo->Window)
          {
          Remove((struct Node *) imessage);
          GT_ReplyIMsg(imessage);
          }
        imessage = (struct IntuiMessage *) succ;
        }
      TMWindowInfo->Window->UserPort = NULL;
      ModifyIDCMP(TMWindowInfo->Window, 0L);
      Permit();
      }

    CloseWindow(TMWindowInfo->Window);
    TMWindowInfo->Window = NULL;
    TMWindowInfo->Flags = NULL;
    }
  if(TMWindowInfo->FirstGadget)
    {
    FreeGadgets(*TMWindowInfo->FirstGadget);
    TMWindowInfo->FirstGadget = NULL;
    }
  }

/* ---------------------- */
/*  TM_Close - close all  */
/* ---------------------- */
 
VOID TM_Close(struct TMData *TMData)
  {
  if(TMData)
    {
    if(TMData->VisualInfo) FreeVisualInfo(TMData->VisualInfo);
    if(TMData->Screen) UnlockPubScreen(NULL, TMData->Screen);
    if(TMData->WindowMsgPort) DeleteMsgPort(TMData->WindowMsgPort);
    FreeMem(TMData, TMData->Size);
    }
  }

