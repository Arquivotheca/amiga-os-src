
/* Code generated by Toolmaker V1.1.19 */

#include <exec/types.h>
#include <exec/memory.h>
#include <intuition/intuition.h>
#include <intuition/gadgetclass.h>
#include <libraries/gadtools.h>
#include <stdlib.h>
#include <graphics/view.h>

#include <clib/exec_protos.h>
#include <clib/intuition_protos.h>
#include <clib/gadtools_protos.h>

#include "play_tm.h"
#include "play_text.h"

UWORD chip WaitPointer[] =
  {
  0x0000, 0x0000,
  0x0400, 0x07C0,
  0x0000, 0x07C0,
  0x0100, 0x0380,
  0x0000, 0x07E0,
  0x07C0, 0x1FF8,
  0x1FF0, 0x3FEC,
  0x3FF8, 0x7FDE,
  0x3FF8, 0x7FBE,
  0x7FFC, 0xFF7F,
  0x7EFC, 0xFFFF,
  0x7FFC, 0xFFFF,
  0x3FF8, 0x7FFE,
  0x3FF8, 0x7FFE,
  0x1FF0, 0x3FFC,
  0x07C0, 0x1FF8,
  0x0000, 0x07E0,
  0x0000, 0x0000,
  };

struct TTextAttr topaz8 =
  {
  "topaz.font",
  8,
  FS_NORMAL,
  0x1,
  NULL
  };

LONG TM_Request(struct Window *window, char *title, char *textformat, char *gadgetformat)
  {
  struct EasyStruct es = {sizeof(struct EasyStruct), 0, NULL, NULL, NULL};

  es.es_Title = title;
  es.es_TextFormat = textformat;
  es.es_GadgetFormat = gadgetformat;

  return(EasyRequestArgs(window, &es, NULL, NULL));
  }

LONG TM_Open(struct TMData **TMData)
  {
  struct TMData *tmdata;
  LONG error;

  if(tmdata = AllocMem(sizeof(struct TMData), MEMF_CLEAR))
    {
    tmdata->Size = sizeof(struct TMData);

    if(tmdata->WindowMsgPort = CreateMsgPort())
      {
      if(tmdata->Screen = LockPubScreen(NULL))
        {
        if(tmdata->VisualInfo = GetVisualInfo(tmdata->Screen, TAG_DONE))
          {
          *TMData = tmdata;
          return(NULL);
          }
        else
          error = TMERROR_VISUALINFO;
        UnlockPubScreen(NULL, tmdata->Screen);
        }
      else
        error = TMERROR_SCREEN;
      DeleteMsgPort(tmdata->WindowMsgPort);
      }
    else
      error = TMERROR_MSGPORT;
    FreeMem(tmdata, sizeof(struct TMData));
    }
  else
    error = TMERROR_MEMORY;

  return(error);
  }

VOID TM_EventLoop(struct TMData *TMData)
  {
  BOOL done=FALSE, result;
  ULONG windowsignal, signals;

  windowsignal = 1L << TMData->WindowMsgPort->mp_SigBit;

  while(!done)
    {
    signals = Wait(windowsignal);

    if(signals & windowsignal)
      {
      if(result = TM_WindowSignal(TMData)) done = result;
      }
    }
  }

BOOL TM_WindowSignal(struct TMData *TMData)
  {
  BOOL done=FALSE;
  BOOL result;
  struct IntuiMessage *imessage;

  while(imessage = GT_GetIMsg(TMData->WindowMsgPort))
    {
    if(imessage->IDCMPWindow == TMData->TMWindowInfo[0].Window)
      {
      if(result = TM_Window0IDCMP(TMData, imessage)) done = result;
      }

    GT_ReplyIMsg(imessage);
    }

  return(done);
  }

BOOL TM_Window0IDCMP(struct TMData *TMData, struct IntuiMessage *imessage)
  {
  BOOL done=FALSE;
  BOOL result;

  switch(imessage->Class)
    {
    case IDCMP_REFRESHWINDOW:
      GT_BeginRefresh(TMData->TMWindowInfo[0].Window);
      GT_EndRefresh(TMData->TMWindowInfo[0].Window, TRUE);
      break;

    case IDCMP_GADGETDOWN:
      if(result = Window0GADGETDOWN(TMData, imessage)) done = result;
      break;

    case IDCMP_GADGETUP:
      if(result = Window0GADGETUP(TMData, imessage)) done = result;
      break;

    case IDCMP_CLOSEWINDOW:
      if(result = Window0CLOSEWINDOW(TMData, imessage)) done = result;
      break;

    }

  return(done);
  }

BOOL TM_Window0(struct TMData *TMData, UBYTE command)
  {
  struct NewGadget ng;

  switch(command)
    {
    case DISPLAY:
      if(TMData->TMWindowInfo[0].Window)
        {
        WindowToFront(TMData->TMWindowInfo[0].Window);
        ActivateWindow(TMData->TMWindowInfo[0].Window);
        }
      else
        {
        TMData->TMWindowInfo[0].FirstGadget = &TMData->Window0Gadget[0];
        TMData->Window0Gadget[1] = CreateContext(&TMData->Window0Gadget[0]);

        ng.ng_VisualInfo = TMData->VisualInfo;

        ng.ng_LeftEdge = 460;
        ng.ng_TopEdge = 168+TMData->Screen->BarHeight;
        ng.ng_Width = 87;
        ng.ng_Height = 15;
        ng.ng_Flags = PLACETEXT_IN;
        ng.ng_TextAttr = (struct TextAttr *) &topaz8;
        ng.ng_GadgetText = TEXT_W0G2;
        ng.ng_GadgetID = ID_label2;
        TMData->Window0Gadget[2] = CreateGadget(BUTTON_KIND, TMData->Window0Gadget[1], &ng,
		TAG_DONE);

        ng.ng_LeftEdge = 16;
        ng.ng_Width = 88;
        ng.ng_GadgetText = TEXT_W0G3;
        ng.ng_GadgetID = ID_label3;
        TMData->Window0Gadget[3] = CreateGadget(BUTTON_KIND, TMData->Window0Gadget[2], &ng,
		TAG_DONE);

        ng.ng_LeftEdge = 432;
        ng.ng_TopEdge = 144+TMData->Screen->BarHeight;
        ng.ng_Width = 115;
        ng.ng_Height = 16;
        ng.ng_GadgetText = TEXT_W0G4;
        ng.ng_GadgetID = ID_label4;
        TMData->Window0Gadget[4] = CreateGadget(BUTTON_KIND, TMData->Window0Gadget[3], &ng,
		TAG_DONE);

        ng.ng_LeftEdge = 308;
        ng.ng_GadgetText = TEXT_W0G5;
        ng.ng_GadgetID = ID_label5;
        TMData->Window0Gadget[5] = CreateGadget(BUTTON_KIND, TMData->Window0Gadget[4], &ng,
		TAG_DONE);

        ng.ng_LeftEdge = 152;
        ng.ng_Width = 128;
        ng.ng_GadgetText = TEXT_W0G6;
        ng.ng_GadgetID = ID_label6;
        TMData->Window0Gadget[6] = CreateGadget(BUTTON_KIND, TMData->Window0Gadget[5], &ng,
		TAG_DONE);

        ng.ng_LeftEdge = 16;
        ng.ng_GadgetText = TEXT_W0G7;
        ng.ng_GadgetID = ID_label7;
        TMData->Window0Gadget[7] = CreateGadget(BUTTON_KIND, TMData->Window0Gadget[6], &ng,
		TAG_DONE);

        ng.ng_LeftEdge = 308;
        ng.ng_TopEdge = 72+TMData->Screen->BarHeight;
        ng.ng_Width = 238;
        ng.ng_Height = 74;
        ng.ng_Flags = PLACETEXT_ABOVE;
        ng.ng_GadgetText = TEXT_W0G8;
        ng.ng_GadgetID = ID_label8;
        TMData->Window0Gadget[8] = CreateGadget(LISTVIEW_KIND, TMData->Window0Gadget[7], &ng,
		GTLV_ShowSelected, 0,
		TAG_DONE);

        ng.ng_LeftEdge = 520;
        ng.ng_TopEdge = 36+TMData->Screen->BarHeight;
        ng.ng_Width = 26;
        ng.ng_Height = 11;
        ng.ng_Flags = PLACETEXT_LEFT;
        ng.ng_GadgetText = TEXT_W0G9;
        ng.ng_GadgetID = ID_label9;
        TMData->Window0Gadget[9] = CreateGadget(CHECKBOX_KIND, TMData->Window0Gadget[8], &ng,
		TAG_DONE);

        ng.ng_TopEdge = 16+TMData->Screen->BarHeight;
        ng.ng_GadgetText = TEXT_W0G10;
        ng.ng_GadgetID = ID_label10;
        TMData->Window0Gadget[10] = CreateGadget(CHECKBOX_KIND, TMData->Window0Gadget[9], &ng,
		TAG_DONE);

        ng.ng_LeftEdge = 16;
        ng.ng_Width = 264;
        ng.ng_Height = 128;
        ng.ng_Flags = PLACETEXT_ABOVE;
        ng.ng_GadgetText = TEXT_W0G11;
        ng.ng_GadgetID = ID_label11;
        TMData->Window0Gadget[11] = CreateGadget(LISTVIEW_KIND, TMData->Window0Gadget[10], &ng,
		GTLV_ShowSelected, TRUE,
		TAG_DONE);

        if(!TMData->Window0Gadget[11]) goto cleanexit;

        if(!(TMData->TMWindowInfo[0].Window = OpenWindowTags(NULL,
		WA_PubScreen, TMData->Screen,
		WA_Title, TEXT_W0TITLE,
		WA_IDCMP, NULL,
		WA_Gadgets, TMData->Window0Gadget[0],
		WA_WBenchWindow, TRUE,
		WA_DragBar, TRUE,
		WA_DepthGadget, TRUE,
		WA_CloseGadget, TRUE,
		WA_Left, 180,
		WA_Top, 14,
		WA_Width, 565,
		WA_Height, 211,
		WA_InnerWidth, 557,
		WA_InnerHeight, 188,
		WA_Activate, TRUE,
		WA_SmartRefresh, TRUE,
		TAG_DONE))) goto cleanexit;

        TMData->TMWindowInfo[0].Window->UserPort = TMData->WindowMsgPort;
        ModifyIDCMP(TMData->TMWindowInfo[0].Window, IDCMP_REFRESHWINDOW | BUTTONIDCMP | LISTVIEWIDCMP | CHECKBOXIDCMP | IDCMP_GADGETDOWN | IDCMP_GADGETUP | IDCMP_CLOSEWINDOW);
        GT_RefreshWindow(TMData->TMWindowInfo[0].Window, NULL);
        TMData->TMWindowInfo[0].Flags |= TMWF_OPEN;
        }
      break;

    case REMOVE:
      TM_RemoveWindow(&TMData->TMWindowInfo[0]);
      break;

    case DISABLE:
      if(TMData->TMWindowInfo[0].DisableCount==0)
        {
        InitRequester(&TMData->TMWindowInfo[0].Requester);
        if(Request(&TMData->TMWindowInfo[0].Requester, TMData->TMWindowInfo[0].Window))
          {
          TMData->TMWindowInfo[0].Flags |= TMWF_DISABLED;
          SetPointer(TMData->TMWindowInfo[0].Window, WaitPointer, 16, 16, -6, 0);
          }
        }

      TMData->TMWindowInfo[0].DisableCount++;
      break;

    case ENABLE:
      TMData->TMWindowInfo[0].DisableCount--;

      if(TMData->TMWindowInfo[0].DisableCount==0 && TMData->TMWindowInfo[0].Flags&TMWF_DISABLED)
        {
        EndRequest(&TMData->TMWindowInfo[0].Requester, TMData->TMWindowInfo[0].Window);
        TMData->TMWindowInfo[0].Flags &= ~TMWF_DISABLED;
        ClearPointer(TMData->TMWindowInfo[0].Window);
        }
      break;
    }

  return(TRUE);

  cleanexit:
  TM_RemoveWindow(&TMData->TMWindowInfo[0]);
  return(FALSE);
  }

VOID TM_RemoveWindow(struct TMWindowInfo *TMWindowInfo)
  {
  struct IntuiMessage *imessage;
  struct Node *succ;

  if(TMWindowInfo->Window)
    {
    if(TMWindowInfo->Menu)
      {
      ClearMenuStrip(TMWindowInfo->Window);
      FreeMenus(TMWindowInfo->Menu);
      TMWindowInfo->Menu = NULL;
      }

    if(TMWindowInfo->Window->UserPort)
      {
      Forbid();
      imessage = (struct IntuiMessage *) TMWindowInfo->Window->UserPort->mp_MsgList.lh_Head;
      while(succ = imessage->ExecMessage.mn_Node.ln_Succ)
        {
        if(imessage->IDCMPWindow == TMWindowInfo->Window)
          {
          Remove((struct Node *) imessage);
          GT_ReplyIMsg(imessage);
          }
        imessage = (struct IntuiMessage *) succ;
        }
      TMWindowInfo->Window->UserPort = NULL;
      ModifyIDCMP(TMWindowInfo->Window, 0L);
      Permit();
      }

    CloseWindow(TMWindowInfo->Window);
    TMWindowInfo->Window = NULL;
    TMWindowInfo->Flags = NULL;
    }
  if(TMWindowInfo->FirstGadget)
    {
    FreeGadgets(*TMWindowInfo->FirstGadget);
    TMWindowInfo->FirstGadget = NULL;
    }
  }

VOID TM_Close(struct TMData *TMData)
  {
  if(TMData)
    {
    if(TMData->VisualInfo) FreeVisualInfo(TMData->VisualInfo);
    if(TMData->Screen) UnlockPubScreen(NULL, TMData->Screen);
    if(TMData->WindowMsgPort) DeleteMsgPort(TMData->WindowMsgPort);
    FreeMem(TMData, TMData->Size);
    }
  }

