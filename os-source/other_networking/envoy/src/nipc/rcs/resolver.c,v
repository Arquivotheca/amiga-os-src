head     1.47;
branch   ;
access   ;
symbols  ;
locks    ; strict;
comment  @ * @;


1.47
date     93.10.06.19.23.09;  author kcd;  state Exp;
branches ;
next     1.46;

1.46
date     93.04.01.16.26.31;  author kcd;  state Exp;
branches ;
next     1.45;

1.45
date     93.03.03.11.54.33;  author kcd;  state Exp;
branches ;
next     1.44;

1.44
date     93.02.16.14.34.39;  author kcd;  state Exp;
branches ;
next     1.43;

1.43
date     93.01.15.18.11.47;  author kcd;  state Exp;
branches ;
next     1.42;

1.42
date     92.12.17.16.39.11;  author kcd;  state Exp;
branches ;
next     1.41;

1.41
date     92.12.16.14.44.25;  author kcd;  state Exp;
branches ;
next     1.40;

1.40
date     92.12.02.11.02.00;  author gregm;  state Exp;
branches ;
next     1.39;

1.39
date     92.11.19.14.19.29;  author kcd;  state Exp;
branches ;
next     1.38;

1.38
date     92.11.02.14.08.28;  author kcd;  state Exp;
branches ;
next     1.37;

1.37
date     92.09.18.14.56.26;  author kcd;  state Exp;
branches ;
next     1.36;

1.36
date     92.08.29.12.32.02;  author gregm;  state Exp;
branches ;
next     1.35;

1.35
date     92.08.21.14.25.37;  author kcd;  state Exp;
branches ;
next     1.34;

1.34
date     92.08.19.16.12.31;  author kcd;  state Exp;
branches ;
next     1.33;

1.33
date     92.08.18.15.46.04;  author kcd;  state Exp;
branches ;
next     1.32;

1.32
date     92.08.11.11.15.06;  author kcd;  state Exp;
branches ;
next     1.31;

1.31
date     92.08.03.09.48.56;  author kcd;  state Exp;
branches ;
next     1.30;

1.30
date     92.07.30.16.13.52;  author kcd;  state Exp;
branches ;
next     1.29;

1.29
date     92.07.09.19.37.52;  author gregm;  state Exp;
branches ;
next     1.28;

1.28
date     92.07.09.18.11.18;  author kcd;  state Exp;
branches ;
next     1.27;

1.27
date     92.06.29.12.28.00;  author kcd;  state Exp;
branches ;
next     1.26;

1.26
date     92.06.27.19.10.33;  author kcd;  state Exp;
branches ;
next     1.25;

1.25
date     92.06.25.16.43.38;  author kcd;  state Exp;
branches ;
next     1.24;

1.24
date     92.06.17.13.55.36;  author kcd;  state Exp;
branches ;
next     1.23;

1.23
date     92.06.08.09.55.30;  author kcd;  state Exp;
branches ;
next     1.22;

1.22
date     92.06.04.21.00.13;  author kcd;  state Exp;
branches ;
next     1.21;

1.21
date     92.06.04.19.48.45;  author kcd;  state Exp;
branches ;
next     1.20;

1.20
date     92.05.28.17.17.24;  author kcd;  state Exp;
branches ;
next     1.19;

1.19
date     92.05.08.14.32.19;  author kcd;  state Exp;
branches ;
next     1.18;

1.18
date     92.05.08.14.24.30;  author kcd;  state Exp;
branches ;
next     1.17;

1.17
date     92.05.05.17.34.03;  author kcd;  state Exp;
branches ;
next     1.16;

1.16
date     92.05.04.11.01.15;  author kcd;  state Exp;
branches ;
next     1.15;

1.15
date     92.04.27.11.17.25;  author kcd;  state Exp;
branches ;
next     1.14;

1.14
date     92.04.21.15.54.42;  author kcd;  state Exp;
branches ;
next     1.13;

1.13
date     92.04.14.11.25.11;  author kcd;  state Exp;
branches ;
next     1.12;

1.12
date     92.04.12.16.30.29;  author kcd;  state Exp;
branches ;
next     1.11;

1.11
date     92.04.10.00.40.16;  author kcd;  state Exp;
branches ;
next     1.10;

1.10
date     92.04.07.16.35.13;  author kcd;  state Exp;
branches ;
next     1.9;

1.9
date     92.04.05.18.17.36;  author kcd;  state Exp;
branches ;
next     1.8;

1.8
date     92.03.27.14.14.12;  author kcd;  state Exp;
branches ;
next     1.7;

1.7
date     92.03.23.10.24.24;  author gregm;  state Exp;
branches ;
next     1.6;

1.6
date     92.03.10.15.14.50;  author kcd;  state Exp;
branches ;
next     1.5;

1.5
date     92.03.06.21.09.11;  author kcd;  state Exp;
branches ;
next     1.4;

1.4
date     92.03.06.19.08.30;  author kcd;  state Exp;
branches ;
next     1.3;

1.3
date     92.03.04.16.58.08;  author gregm;  state Exp;
branches ;
next     1.2;

1.2
date     92.03.03.14.51.36;  author kcd;  state Exp;
branches ;
next     1.1;

1.1
date     92.02.29.20.34.32;  author kcd;  state Exp;
branches ;
next     ;


desc
@Simple NIPC host name resolver module.
@


1.47
log
@Fixed long standing bug in NIPCInquiry.  QUERY_ENTITY was not working
correctly.  
@
text
@/**************************************************************************
**
** resolver.c   - NIPC Simple Host Name Resolver functions
**
** Copyright 1992, Commodore-Amiga, Inc.
**
** $Id: resolver.c,v 1.46 93/04/01 16:26:31 kcd Exp Locker: kcd $
**
***************************************************************************

/*------------------------------------------------------------------------*/

#include "nipcinternal.h"
#include "externs.h"
#include <exec/execbase.h>
#include <graphics/gfxbase.h>
#include <utility/hooks.h>
#include <string.h>
#include <clib/exec_protos.h>
#include <clib/utility_protos.h>
#include <clib/iffparse_protos.h>
#include <clib/timer_protos.h>
#include "nipcinternal_protos.h"

#include <pragmas/exec_pragmas.h>
#include <pragmas/utility_pragmas.h>
#include <pragmas/iffparse_pragmas.h>
#include <pragmas/timer_pragmas.h>

/*------------------------------------------------------------------------*/

/* Structures used by the resolver */

struct ServicesLib
{
    struct Library           SVCS_Lib;
    APTR                     SVCS_NIPCBase;
    APTR                     SVCS_UtilityBase;
    struct ExecBase         *SVCS_SysBase;
    BPTR                     SVCS_SegList;

    /* Services Library and Services Manager Common */
    struct SignalSemaphore   SVCS_ServicesLock;
    struct MinList           SVCS_Services;
    struct SignalSemaphore   SVCS_OpenLock;
};

struct Service
{
    struct Node     svc_Node;                   /* Chain of services */
    UBYTE           svc_PathName[256];          /* Who to run to start a server */
    UBYTE           svc_SvcName[64];            /* Name of this service */
    ULONG           svc_Flags;                  /* Various Flags */
    UWORD           svc_UID;                    /* User allowed to use this service */
    UWORD           svc_GID;                    /* Group allowed to use this service */
};

struct TimedResponse
{
    struct timerequest  tr_TimerIO;
    ULONG               tr_Length;
    ULONG               tr_Destination;
    struct InquiryHeader *tr_Buffer;
};

#define SVCB_ENABLE	0
#define SVCB_EXPUNGE    1

#define SVCF_ENABLE	(1 << SVCB_ENABLE)
#define SVCF_EXPUNGE    (1 << SVCB_EXPUNGE)

extern void dbprint(STRPTR message);

/*------------------------------------------------------------------------*/

BOOL InitResolver()
{
    register struct NBase *nb = gb;
    struct NIPCRealmPrefs *nzp;
    struct NIPCHostPrefs *nhp;
    struct NIPCRoute *route;
    struct CollectionItem *ci;
    struct Realm *realm;
    struct EClockVal ev;

    nb->ResID = 1;
    InitSemaphore(&nb->ResponseCacheLock);
    InitSemaphore(&nb->RequestLock);
    InitSemaphore(&nb->RealmListLock);

    NewList((struct List *)&gb->ResponseCache);
    NewList((struct List *)&gb->RequestList);
    NewList((struct List *)&gb->RealmList);

    nb->NameRequestPort = OpenUDPPort(NIP_UDP_PORT,&ResolverInput);
    nb->ResolverPort = CreateMsgPort();
    nb->NameResponsePort = CreateMsgPort();
    nb->resolversigmask = (1 << gb->ResolverPort->mp_SigBit) | (1 << gb->NameResponsePort->mp_SigBit);
    nb->RIPTimer = 65535;
    nb->DNSHook = NULL;

    ReadEClock(&ev);
    nb->TimerSeed = ev.ev_lo;
    nb->IsRealmServer = 1;

    if(ci = FindCollection(nb->iff,ID_PREF,ID_HOST))
    {
        nhp = (struct NIPCHostPrefs *)ci->ci_Data;
        strcpy(nb->LocalHostName,nhp->nhp_HostName);
        strcpy(nb->RealmName,nhp->nhp_RealmName);
        nb->RealmServer = nhp->nhp_RealmServAddr;
        if(ci->ci_Size > 132)
        {
            strcpy(nb->OwnerName,nhp->nhp_OwnerName);
            if(!(nhp->nhp_HostFlags & NHPFLAGF_REALMS))
            {
            	nb->RealmServer = 0L;
            	nb->RealmName[0] = '\0';
            }
            if(!(nhp->nhp_HostFlags & NHPFLAGF_REALMSERVER))
            {
            	nb->IsRealmServer = 0;
            }
        }
    }

    if(nb->IsRealmServer)
    {
        ci = FindCollection(nb->iff,ID_PREF,ID_NLRM);
        while(ci)
        {
            if(realm = AllocMem(sizeof(struct Realm),MEMF_PUBLIC|MEMF_CLEAR))
            {
                nzp = (struct NIPCRealmPrefs *)ci->ci_Data;
                route = Route(nzp->nzp_RealmAddr,TRUE);
                if(route)
                {
                    realm->realm_SubnetMask = route->nr_Mask;
                    realm->realm_SrcIP = route->nr_Device->sanadev_IPAddress;
                }
                else
                {
                    realm->realm_SubnetMask = NetMask(nzp->nzp_RealmAddr);
                    realm->realm_SrcIP = 0xffffffff;
                }

                realm->realm_NetworkIP = nzp->nzp_RealmAddr;
                realm->realm_Broadcast = nzp->nzp_RealmAddr | ~realm->realm_SubnetMask;
                strcpy(realm->realm_Name,nzp->nzp_RealmName);
                realm->realm_Flags = REALM_AUTHORITY;
                AddTail((struct List *)&nb->RealmList,(struct Node *)realm);
            }
            ci = ci->ci_Next;
        }
        ci = FindCollection(nb->iff,ID_PREF,ID_NRRM);
        while(ci)
        {
            if(realm = AllocMem(sizeof(struct Realm),MEMF_PUBLIC|MEMF_CLEAR))
            {
                nzp = (struct NIPCRealmPrefs *)ci->ci_Data;
                realm->realm_Server = nzp->nzp_RealmAddr;
                strcpy(realm->realm_Name,nzp->nzp_RealmName);
                AddTail((struct List *)&nb->RealmList,(struct Node *)realm);
            }
            ci = ci->ci_Next;
        }
    }
    return(TRUE);
}

/*------------------------------------------------------------------------*/

VOID DeinitResolver()
{
    register struct NBase *nb = gb;
    struct Node *node;
    struct InquiryInfo *ii, *ii_tmp;
    struct InquiryHeader *ih;

    ii = (struct InquiryInfo *)nb->RequestList.mlh_Head;
    while(ii->ii_Msg.mn_Node.ln_Succ)
    {
        ii_tmp = (struct InquiryInfo *) ii->ii_Msg.mn_Node.ln_Succ;
        ih = ii->ii_IHeader;
        FreeMem(ih,ih->ih_Length);
        FreeMem(ii, sizeof(struct InquiryInfo));
        ii = ii_tmp;
    }

    if(gb->NameRequestPort)
        CloseUDPPort(nb->NameRequestPort);

    if(gb->ResolverPort)
        DeleteMsgPort(nb->ResolverPort);

    while(node = RemHead((struct List *)&nb->RealmList))
        FreeMem(node,sizeof(struct Realm));

    return;
}

/*------------------------------------------------------------------------*/
typedef ULONG (*HOOK_FUNC)();

ULONG ResolveName(hostname)
UBYTE *hostname;
{
    register struct NBase *nb = gb;
    struct Hook rn_hook;
    struct TagItem RNTags[4]={MATCH_REALM,0,
                              MATCH_HOSTNAME,0,
                              QUERY_IPADDR,0,
                              TAG_DONE,0};
    STRPTR realm_ptr,host_ptr,search_ptr;
    UBYTE nbuff[130];
    ULONG ipnum;

    if(!hostname)
        return 0L;

    if((*hostname == 0) || (strlen(hostname) >128))
        return 0L;

    stccpy(nbuff,hostname,128);

    search_ptr = nbuff;
    host_ptr = realm_ptr = NULL;

    while(*search_ptr)
    {
        switch(*search_ptr)
        {
            case ':'    : *search_ptr = 0;
                          host_ptr = search_ptr + 1;
                          realm_ptr = nbuff;
                          break;

            case 0      : break;

            default     : search_ptr++;
        }
    }
    if(!host_ptr)
        host_ptr = nbuff;

    else if(*host_ptr == 0)
        return 0;

    if(realm_ptr)
        if(*realm_ptr == 0)
            realm_ptr = NULL;

    if(!Stricmp(host_ptr,(STRPTR)&nb->LocalHostName))
    {
        if(realm_ptr)
        {
            if(!Stricmp(realm_ptr,(STRPTR)&nb->RealmName))
                return(0xffffffff);
        }
        else
            return(0xffffffff);
    }

    ipnum = 0;

    rn_hook.h_Entry = (HOOK_FUNC) RNHookFunc;
    rn_hook.h_SubEntry = (HOOK_FUNC) UtilityBase;
    rn_hook.h_Data = &ipnum;

    RNTags[0].ti_Data = (ULONG) realm_ptr;
    RNTags[1].ti_Data = (ULONG) host_ptr;
    if(!realm_ptr)
    {
        if(gb->RealmServer)
            RNTags[0].ti_Data = (ULONG) &gb->RealmName[0];
        else
            RNTags[0].ti_Tag = TAG_IGNORE;
    }

    SetSignal(0L,SIGF_NET);
    if(NIPCInquiryA(&rn_hook,5,1,RNTags))
        Wait(SIGF_NET);

    return ipnum;
}

#undef SysBase
#undef UtilityBase
#define SysBase (*(struct Library **)4L)

ULONG __asm RNHookFunc(register __a0 struct Hook *hook,
                      register __a2 struct Task *task,
                      register __a1 struct TagItem *tagList)
{
    struct TagItem *tag;
    struct Library *UtilityBase = (struct Library *)hook->h_SubEntry;

    if(tagList)
    {
        if(tag = FindTagItem(QUERY_IPADDR, tagList))
        {
            *(ULONG *)hook->h_Data = tag->ti_Data;
            Signal(task,SIGF_NET);
            return(FALSE);
        }
    }
    else
    {
        Signal(task,SIGF_NET);
        return(FALSE);
    }
    return(TRUE);
}

#undef SysBase
#undef UtilityBase

#define SysBase        (NIPCBASE->nb_SysBase)
#define UtilityBase    (NIPCBASE->nb_UtilityBase)

/****************************************************************************/

BOOL __asm NIPCInquiryA(register __a0 struct Hook *hook,
                     register __d0 ULONG maxTime,
                     register __d1 ULONG maxResponses,
                     register __a1 struct TagItem *tagList)

{
    register struct NBase *nb;
    struct InquiryInfo *ii;
    struct InquiryHeader *ih;
    struct TagItem *tag,*current;

    ULONG querylength,numtags,ptype;
    UBYTE *tagoffset,*dataoffset;

    BOOL addMRTag = FALSE;

    nb = gb;
    if(!(hook && tagList && maxTime ))
        return FALSE;

    if((FindTagItem(QUERY_REALMS,tagList) && !(gb->RealmServer)))
        return FALSE;

    if((FindTagItem(MATCH_REALM,tagList) && !(gb->RealmServer)))
        return FALSE;

    /* Now, let's figure out how much data we'll need. */

    querylength = sizeof(struct InquiryHeader) + 8;
    current = tagList;
    numtags = 1;

    if(gb->RealmServer)
    {
        addMRTag = TRUE;
        ptype = PTYPE_TRANSIT;
    }
    else
        ptype = PTYPE_QUERY;

    while(tag = NextTagItem(&current))
    {
        querylength+=8;
        numtags++;
        switch(tag->ti_Tag)
        {
            case QUERY_REALMS:          ptype = PTYPE_REALMREQ;
                                        addMRTag = FALSE;
                                        break;

            case MATCH_REALM:           addMRTag = FALSE;
            case MATCH_HOSTNAME:
            case MATCH_OWNER:
            case MATCH_ENTITY:
            case MATCH_SERVICE:
            case QUERY_LIBVERSION:
                                        querylength+=strlen((STRPTR)tag->ti_Data)+1;
                                        break;

            case MATCH_LIBVERSION:      querylength+=strlen((STRPTR)((ULONG)tag->ti_Data+4))+5;
                                        break;

        }
    }
    if(addMRTag)
    {
        querylength += (9 + strlen((STRPTR)&nb->RealmName));
        numtags++;
    }
    if(ii = (struct InquiryInfo *) AllocMem(sizeof(struct InquiryInfo),MEMF_CLEAR|MEMF_PUBLIC))
    {
        Forbid();
        ii->ii_ID = gb->ResID++;
        Permit();

        ii->ii_QueryLength = querylength;

        if(ih = (struct InquiryHeader *)AllocMem(ii->ii_QueryLength,MEMF_CLEAR|MEMF_PUBLIC))
        {

            struct TagItem *dtag;

            ii->ii_IHeader = ih;
            ii->ii_Task = FindTask(0L);
            ii->ii_Hook = hook;
            ii->ii_TTL = maxTime + 1;
            ii->ii_MaxResponses = maxResponses;
            ih->ih_PType = ptype;
            ih->ih_Length = querylength;
            ih->ih_HeaderLength = sizeof(struct InquiryHeader);
            ih->ih_ID    = ii->ii_ID;

            tagoffset = (UBYTE *)((ULONG)ih + (ULONG)sizeof(struct InquiryHeader));
            dataoffset = (UBYTE *)((ULONG)tagoffset + (ULONG)(numtags <<3));
            current = tagList;

            while(tag = NextTagItem(&current))
            {
                dtag = (struct TagItem *)tagoffset;
                tagoffset += 8;

                switch(tag->ti_Tag)
                {
                    case MATCH_HOSTNAME:
                    case MATCH_REALM:
                    case MATCH_OWNER:
                    case MATCH_ENTITY:
                    case MATCH_SERVICE:
                    case QUERY_LIBVERSION:	dtag->ti_Tag = tag->ti_Tag;
                                                dtag->ti_Data = (LONG)(dataoffset - (UBYTE *)ih);
                                                strcpy((STRPTR)dataoffset,(STRPTR)tag->ti_Data);
                                                dataoffset += (strlen((STRPTR)tag->ti_Data) + 1);
                                                break;

                    case MATCH_LIBVERSION:      dtag->ti_Tag = tag->ti_Tag;
                                                dtag->ti_Data = (LONG)(dataoffset - (UBYTE *)ih);
                                                *((ULONG *)dataoffset) = *(ULONG *)tag->ti_Data;
                                                strcpy((STRPTR)(dataoffset + 4),(STRPTR)(tag->ti_Data + 4));
                                                dataoffset += (strlen((STRPTR)tag->ti_Data+4) + 5);
                                                break;

                    default:                    dtag->ti_Tag = tag->ti_Tag;
                                                break;
                }
            }
            if(addMRTag)
            {
                dtag = (struct TagItem *)tagoffset;
                dtag->ti_Tag = MATCH_REALM;
                dtag->ti_Data = (LONG)(dataoffset - (UBYTE *)ih);
                strcpy((STRPTR)dataoffset,(STRPTR)&gb->RealmName);
            }

            PutMsg(nb->ResolverPort,(struct Message *)ii);
            return TRUE;
        }
        else
        {
            FreeMem(ii,sizeof(struct InquiryInfo));
            return FALSE;
        }
    }
    else
    {
        return FALSE;
    }
}

/*------------------------------------------------------------------------*/

void QueueNameResponse(struct InquiryHeader *buff, ULONG length, ULONG dest)
{
    struct TimedResponse *tr;

    if(tr = AllocMem(sizeof(struct TimedResponse),MEMF_CLEAR))
    {
        tr->tr_TimerIO.tr_node.io_Device = (struct Device *)gb->TimerDevice;
        tr->tr_TimerIO.tr_node.io_Unit = (struct Unit *)gb->TimerUnit;
        tr->tr_TimerIO.tr_node.io_Message.mn_ReplyPort = gb->NameResponsePort;
        tr->tr_TimerIO.tr_node.io_Command = TR_ADDREQUEST;
        gb->TimerSeed = makefastrand(gb->TimerSeed);
        tr->tr_TimerIO.tr_time.tv_secs=0;
        tr->tr_TimerIO.tr_time.tv_micro = 7 * gb->TimerSeed;
        tr->tr_Length = length;
        tr->tr_Destination = dest;
        tr->tr_Buffer = buff;
        SendIO((struct IORequest *)tr);
    }
}

/*------------------------------------------------------------------------*/

void DoResolver()
{
    register struct NBase *nb = gb;
    struct InquiryInfo *ii;
    struct TimedResponse *tr;
    ULONG destIP;

    while(ii = (struct InquiryInfo *) GetMsg(nb->ResolverPort))
    {
        AddTail((struct List *)&nb->RequestList,(struct Node *)ii);
        if((ii->ii_IHeader->ih_PType == PTYPE_TRANSIT) || (ii->ii_IHeader->ih_PType == PTYPE_REALMREQ))
        {
            destIP = gb->RealmServer;
        }
        else
        {
            ii->ii_IHeader->ih_SourceAddr = ((struct sanadev *) gb->DeviceList.lh_Head->ln_Succ)->sanadev_IPAddress;
            destIP = 0xffffffff;
        }
        UDP_Output((UBYTE *)ii->ii_IHeader,ii->ii_QueryLength,0,destIP,NIP_UDP_PORT,NIP_UDP_PORT);
    };

    while(tr = (struct TimedResponse *) GetMsg(nb->NameResponsePort))
    {
        UDP_Output((UBYTE *)tr->tr_Buffer,tr->tr_Length,0,tr->tr_Destination,NIP_UDP_PORT,NIP_UDP_PORT);
        FreeMem(tr->tr_Buffer,tr->tr_Buffer->ih_Length);
        FreeMem(tr,sizeof(struct TimedResponse));
    };
}

/*------------------------------------------------------------------------*/

BOOL InvalidRequest(struct NameHeader *nh);
void SendResponse(struct NameHeader *nh_req, struct NameHeader *nh_resp, ULONG len, ULONG DestIP, ULONG SrcIP);

VOID ResolverInput(conn, buff,dev)
struct UDPConnection *conn;
struct Buffer *buff;
struct sanadev *dev;
{
    register struct NBase *nb = gb;
    struct BuffEntry *be;
    struct udphdr *udp;
    struct iphdr *ip;
    struct NIPCRoute *route;
    struct InquiryHeader *ih,*ih_new;
    struct InquiryInfo *ii;
    struct Service *svc;
    struct Realm *realm,*realm_ptr;
    struct ServicesLib *ServicesBase = NULL;
    struct Node *node;
    struct TagItem *tag;

    UBYTE *str;
    BOOL match;

    UtilityBase = (struct Library *)gb->nb_UtilityBase;

    be = (struct BuffEntry *) buff->buff_list.mlh_Head;
    ip = (struct iphdr *) ( (ULONG) be->be_data + (ULONG) be->be_offset);
    udp = (struct udphdr *) ( (ULONG) ip + (ULONG) sizeof(struct iphdr));

    ih = (struct InquiryHeader *) ((ULONG) udp + (ULONG) sizeof(struct udphdr));

    if(ih->ih_PType == PTYPE_TRANSIT)
    {
        if(!ih->ih_SourceAddr && (ip->iph_SrcAddr != 0x7f000001))
            ih->ih_SourceAddr = ip->iph_SrcAddr;

        ObtainSemaphore(&nb->RealmListLock);

        realm = (struct Realm *) gb->RealmList.mlh_Head;
        if(tag = FindTagItem(MATCH_REALM,(struct TagItem *)((ULONG)ih+(ULONG)ih->ih_HeaderLength)))
        {
            str = (STRPTR) tag->ti_Data + (LONG)ih;
            while(realm->realm_Node.mln_Succ)
            {
                if(!Stricmp(str,realm->realm_Name))
                {
                    if(realm->realm_Flags & REALM_AUTHORITY)
                    {
                        ih->ih_PType = PTYPE_QUERY;
                        if(ih->ih_SourceAddr)
                            UDP_Output((UBYTE *)ih,ih->ih_Length,0,realm->realm_Broadcast,NIP_UDP_PORT,NIP_UDP_PORT);
                        else
                        {
                            ih->ih_SourceAddr = realm->realm_SrcIP;
                            UDP_Output((UBYTE *)ih,ih->ih_Length,0,realm->realm_Broadcast,NIP_UDP_PORT,NIP_UDP_PORT);
                            ih->ih_SourceAddr = 0;
                        }
                    }
                    else
                    {
                        ih->ih_PType = PTYPE_TRANSIT;
                        UDP_Output((UBYTE *)ih,ih->ih_Length,0,realm->realm_Server,NIP_UDP_PORT,NIP_UDP_PORT);
                        break;
                    }
                }
                realm = (struct Realm *) realm->realm_Node.mln_Succ;
            }
        }
        ReleaseSemaphore(&nb->RealmListLock);
    }
    else if((ih->ih_PType == PTYPE_QUERY) || (ih->ih_PType == PTYPE_REALMREQ))
    {
        struct TagItem *current;
        ULONG responselength,responsetags;
        STRPTR tmpstr;
        BOOL respond = TRUE;

        if ((ih->ih_PType == PTYPE_REALMREQ) && (!ih->ih_SourceAddr))
            ih->ih_SourceAddr = ip->iph_SrcAddr;

        current = (struct TagItem *)((ULONG)ih + ih->ih_HeaderLength);

        responselength = sizeof(struct InquiryHeader);  /* Don't forget the terminating TAG_DONE TagItem */
        responsetags = 1;

        while(tag = NextTagItem(&current))
        {
            responsetags++;
            switch(tag->ti_Tag)
            {
                case MATCH_HOSTNAME:    tmpstr = (STRPTR)((ULONG)ih + (ULONG)tag->ti_Data);
                                        if(Stricmp(tmpstr,(STRPTR)&nb->LocalHostName))
                                        {
                                            respond = FALSE;
                                        }
                                        responselength += strlen(tmpstr) + 1;
                                        break;

                case QUERY_HOSTNAME:    responselength += strlen((STRPTR)&nb->LocalHostName) + 1;
                                        if(gb->RealmServer)
                                            responselength += strlen((STRPTR)&gb->RealmName) + 1;
                                        break;

                case MATCH_OWNER:	tmpstr = (STRPTR)((ULONG)ih + (ULONG)tag->ti_Data);
                                        if(Stricmp(tmpstr,(STRPTR)&nb->OwnerName))
                                        {
                                            respond = FALSE;
                                        }
                                        responselength += strlen(tmpstr) + 1;
                                        break;

                case QUERY_OWNER:    	responselength += strlen((STRPTR)&nb->OwnerName) + 1;
                                        break;

                case MATCH_REALM:       tmpstr = (STRPTR)((ULONG)ih + (ULONG)tag->ti_Data);
                                        if(Stricmp(tmpstr,(STRPTR)&nb->RealmName))
                                        {
                                            respond = FALSE;
                                        }
                                        responselength += strlen(tmpstr) + 1;
                                        break;

                case QUERY_REALMS:      realm_ptr = (struct Realm *)gb->RealmList.mlh_Head;
                                        while(realm_ptr->realm_Node.mln_Succ)
                                        {
                                            responselength += strlen((STRPTR)&realm_ptr->realm_Name) + 1;
                                            responsetags++;
                                            realm_ptr = (struct Realm *)realm_ptr->realm_Node.mln_Succ;
                                        }
                                        responsetags--;
                                        break;

                case MATCH_IPADDR:
                                        if(!IsLocalDevice(tag->ti_Data))
                                        {
                                            respond = FALSE;
                                        }
                                        break;

                case MATCH_ATTNFLAGS:   if(!(tag->ti_Data & ((struct ExecBase *)SysBase)->AttnFlags))
                                        {
                                            respond = FALSE;
                                        }
                                        break;

                case MATCH_CHIPREVBITS:
                                        {
                                            struct GfxBase *GfxBase;
                                            if(GfxBase = (struct GfxBase *)OpenLibrary("graphics.library",37L))
                                            {
                                                if(!(tag->ti_Data & GfxBase->ChipRevBits0))
                                                {
                                                    respond = FALSE;
                                                }
                                                CloseLibrary((struct Library *)GfxBase);
                                            }
                                            else
                                                respond = FALSE;
                                        }
                                        break;

                case MATCH_MAXFASTMEM:
                case MATCH_MAXCHIPMEM:
                case MATCH_AVAILFASTMEM:
                case MATCH_AVAILCHIPMEM:
                                        {
                                            ULONG memflags;

                                            switch(tag->ti_Tag)
                                            {
                                                case MATCH_MAXFASTMEM:  memflags = MEMF_FAST|MEMF_TOTAL;
                                                                        break;
                                                case MATCH_MAXCHIPMEM:  memflags = MEMF_CHIP|MEMF_TOTAL;
                                                                        break;
                                                case MATCH_AVAILFASTMEM: memflags = MEMF_FAST;
                                                                         break;
                                                case MATCH_AVAILCHIPMEM: memflags = MEMF_CHIP;
                                                                         break;
                                            }
                                            if(!(AvailMem(memflags) >= tag->ti_Data))
                                            {
                                                respond = FALSE;
                                            }
                                        }
                                        break;

                case MATCH_KICKVERSION:
                                        {
                                            ULONG version;
                                            version = (SysBase->lib_Version << 16) | ((struct ExecBase *)SysBase)->SoftVer;
                                            if(version < tag->ti_Data)
                                            {
                                                respond = FALSE;
                                            }
                                        }
                                        break;

                case MATCH_WBVERSION:
                                        {
                                            ULONG version;
                                            struct Library *VBase;
                                            if(VBase = OpenLibrary("version.library",0))
                                            {
                                                version = (VBase->lib_Version << 16) | VBase->lib_Revision;
                                                if(version < tag->ti_Data)
                                                {
                                                    respond = FALSE;
                                                }
                                                CloseLibrary(VBase);
                                            }
                                            else
                                                respond = FALSE;
                                        }
                                        break;

                case MATCH_LIBVERSION:
                                        {
                                            ULONG match_version;
                                            ULONG lib_version;
                                            STRPTR lib_name;
                                            struct Library *LibBase;

					    match_version = *(ULONG *)((ULONG)ih + (ULONG)tag->ti_Data);
					    lib_name = (STRPTR)((ULONG)ih + (ULONG)tag->ti_Data + 4);

                                            if(LibBase = OpenLibrary(lib_name,0))
                                            {
                                                lib_version = (LibBase->lib_Version << 16) | LibBase->lib_Revision;
                                                if(lib_version < match_version)
                                                {
                                                    respond = FALSE;
                                                }
                                                else
                                                {
                                                    responsetags++;
                                                    responselength += strlen(lib_name) + 5;
                                                }
                                                CloseLibrary(LibBase);
                                            }
                                            else
                                                respond = FALSE;
                                        }
                                        break;

		case QUERY_LIBVERSION:	tmpstr = (STRPTR)((ULONG)ih + (ULONG)tag->ti_Data);
		                        responselength += strlen(tmpstr) + 5;
					responsetags++;
					break;

		case MATCH_NIPCVERSION:
					{
					    ULONG version;
					    version = (gb->LibNode.lib_Version << 16) | (gb->LibNode.lib_Revision);
					    if(version < tag->ti_Data)
					    {
					    	respond = FALSE;
					    }
					}
					break;

                case QUERY_ATTNFLAGS:
                case QUERY_CHIPREVBITS:
                case QUERY_MAXFASTMEM:
                case QUERY_AVAILFASTMEM:
                case QUERY_MAXCHIPMEM:
                case QUERY_AVAILCHIPMEM:
                case QUERY_KICKVERSION:
                case QUERY_WBVERSION:
                case QUERY_NIPCVERSION:
                                        break;

                case QUERY_IPADDR:
                                        if(!(route = Route(ih->ih_SourceAddr, TRUE)))
                                        {
                                            respond = FALSE;
                                        }
                                        break;

                case MATCH_SERVICE:     match = FALSE;
                                        Forbid();
                                        if(nb->nb_ServicesBase)
                                            ServicesBase = (struct ServicesLib *)OpenLibrary("services.library",0L);
                                        Permit();
                                        if(ServicesBase)
                                        {
                                            ObtainSemaphore(&ServicesBase->SVCS_ServicesLock);
                                            svc = (struct Service *)ServicesBase->SVCS_Services.mlh_Head;
                                            tmpstr = (STRPTR)((ULONG)ih + (ULONG)tag->ti_Data);
                                            while(svc->svc_Node.ln_Succ)
                                            {
                                                if(!Stricmp((STRPTR)&svc->svc_SvcName,tmpstr))
                                                {
                                                    if((!(svc->svc_Flags & SVCF_EXPUNGE)) && (svc->svc_Flags & SVCF_ENABLE))
                                                    {
                                                        responselength += strlen(tmpstr) + 1;
                                                        responsetags++;
                                                        match = TRUE;
                                                        break;
                                                    }
                                                }
                                                svc = (struct Service *)svc->svc_Node.ln_Succ;
                                            }
                                            ReleaseSemaphore(&ServicesBase->SVCS_ServicesLock);
                                            CloseLibrary((struct Library *)ServicesBase);
                                        }
                                        if(!match)
                                        {
                                            respond = FALSE;
                                        }
                                        responsetags--;
                                        break;

                case QUERY_SERVICE:
                                        Forbid();
                                        if(nb->nb_ServicesBase)
                                            ServicesBase = (struct ServicesLib *)OpenLibrary("services.library",0L);
                                        Permit();
                                        if(ServicesBase)
                                        {
                                            ObtainSemaphore(&ServicesBase->SVCS_ServicesLock);
                                            svc = (struct Service *)ServicesBase->SVCS_Services.mlh_Head;
                                            while(svc->svc_Node.ln_Succ)
                                            {
                                                if((!(svc->svc_Flags & SVCF_EXPUNGE)) && (svc->svc_Flags & SVCF_ENABLE))
                                                {
                                                    responselength += strlen((STRPTR)&svc->svc_SvcName) + 1 + 8;
                                                    responsetags++;
                                                }
                                                svc = (struct Service *)svc->svc_Node.ln_Succ;
                                            }
                                            ReleaseSemaphore(&ServicesBase->SVCS_ServicesLock);
                                            CloseLibrary((struct Library *)ServicesBase);
                                        }
                                        responsetags--;
                                        break;

                case MATCH_ENTITY:      tmpstr = (STRPTR)((ULONG)ih + (ULONG)tag->ti_Data);
                                        ObtainSemaphore(&nb->ANMPELSemaphore);
                                        if(FindNameI((struct List *)&nb->ANMPEntityList,tmpstr))
                                        {
                                            responselength += strlen(tmpstr) + 1;
                                        }
                                        else
                                            respond = FALSE;
                                        ReleaseSemaphore(&nb->ANMPELSemaphore);
                                        break;

                case QUERY_ENTITY:      ObtainSemaphore(&nb->ANMPELSemaphore);
                                        node = (struct Node *)gb->ANMPEntityList.mlh_Head;
                                        while(node->ln_Succ)
                                        {
                                            if(((struct Entity *)node)->entity_Flags & ENTF_PUBLIC)
                                            {
                                                responselength += strlen(node->ln_Name) + 1 + 8;
                                                responsetags++;
                                            }
                                            node = node->ln_Succ;
                                        }
                                        ReleaseSemaphore(&nb->ANMPELSemaphore);
                                        break;

            }
            if(!respond)
                break;
        }
        responselength += (responsetags << 3);
EndParse:
        if(respond)
        {
            if(ih_new = AllocMem(responselength,MEMF_CLEAR|MEMF_PUBLIC))
            {
                struct TagItem *dtag;
                UBYTE *newdataoffset;
                UBYTE *newtagoffset;

                ih_new->ih_Length = responselength;
                ih_new->ih_HeaderLength = sizeof(struct InquiryHeader);
                ih_new->ih_PType  = PTYPE_RESPONSE;
                ih_new->ih_ID     = ih->ih_ID;

                newtagoffset = (UBYTE *) (ULONG)ih_new + (ULONG)sizeof(struct InquiryHeader);
                newdataoffset = newtagoffset + (responsetags * 8);

                current = (struct TagItem *)((ULONG)ih + ih->ih_HeaderLength);

                while(tag = NextTagItem(&current))
                {
                    dtag = (struct TagItem *)newtagoffset;
                    dtag->ti_Tag = tag->ti_Tag;

                    switch(tag->ti_Tag)
                    {
                        case MATCH_HOSTNAME:
                        case MATCH_REALM:
                        case MATCH_ENTITY:
                        case MATCH_SERVICE:
                        case MATCH_OWNER:
                        case MATCH_MACHDESC:    dtag->ti_Data = (LONG)((ULONG)newdataoffset - (ULONG)ih_new);
                                                strcpy((STRPTR)newdataoffset,(STRPTR)ih+tag->ti_Data);
                                                newdataoffset += strlen((STRPTR)newdataoffset) + 1;
                                                break;

			case MATCH_LIBVERSION:	dtag->ti_Data = (LONG)((ULONG)newdataoffset - (ULONG)ih_new);
						*((ULONG *)newdataoffset) = *((ULONG *)((LONG)ih+tag->ti_Data));
						strcpy((STRPTR)((ULONG)newdataoffset+4),(STRPTR)ih+tag->ti_Data);
						newdataoffset += strlen((STRPTR)newdataoffset+4) +5;
						break;

                        case QUERY_HOSTNAME:    dtag->ti_Data = (LONG)((ULONG)newdataoffset - (ULONG)ih_new);
                                                if(gb->RealmServer)
                                                {
                                                    strcpy((STRPTR)newdataoffset,(STRPTR)&nb->RealmName);
                                                    newdataoffset += strlen((STRPTR)newdataoffset);
                                                    *newdataoffset=':';
                                                    newdataoffset++;
                                                }
                                                strcpy((STRPTR)newdataoffset,(STRPTR)&nb->LocalHostName);
                                                newdataoffset += strlen((STRPTR)newdataoffset) + 1;
                                                break;

                        case QUERY_OWNER:	dtag->ti_Data = (LONG)((ULONG)newdataoffset - (ULONG)ih_new);
                                                strcpy((STRPTR)newdataoffset,(STRPTR)&nb->OwnerName);
                                                newdataoffset += strlen((STRPTR)newdataoffset) + 1;
                                                break;

                        case MATCH_ATTNFLAGS:
                        case MATCH_CHIPREVBITS:
                        case MATCH_MAXFASTMEM:
                        case MATCH_AVAILFASTMEM:
                        case MATCH_MAXCHIPMEM:
                        case MATCH_AVAILCHIPMEM:
                        case MATCH_KICKVERSION:
                        case MATCH_WBVERSION:
                        case MATCH_NIPCVERSION:
                        case MATCH_IPADDR:      dtag->ti_Data = tag->ti_Data;
                                                break;

                        case QUERY_IPADDR:      route = Route(ih->ih_SourceAddr, TRUE);
                                                dtag->ti_Data = route->nr_Device->sanadev_IPAddress;
                                                break;

                        case QUERY_ENTITY:      ObtainSemaphore(&nb->ANMPELSemaphore);
                                                node = (struct Node *)gb->ANMPEntityList.mlh_Head;
                                                while(node->ln_Succ)
                                                {
                                                    if(((struct Entity *)node)->entity_Flags & ENTF_PUBLIC)
                                                    {
                                                        dtag->ti_Tag = QUERY_ENTITY;
                                                        dtag->ti_Data = (LONG)((ULONG)newdataoffset - (ULONG)ih_new);
                                                        strcpy((STRPTR)newdataoffset,(STRPTR)node->ln_Name);
                                                        newdataoffset += strlen((STRPTR)newdataoffset) +1;
                                                        newtagoffset +=8;
                                                        dtag = (struct TagItem *)newtagoffset;
                                                    }
                                                    node = node->ln_Succ;
                                                }
                                                ReleaseSemaphore(&nb->ANMPELSemaphore);
                                                newtagoffset -= 8;
                                                break;

                        case QUERY_SERVICE:     Forbid();
                                                if(nb->nb_ServicesBase)
                                                    ServicesBase = (struct ServicesLib *)OpenLibrary("services.library",0L);
                                                Permit();
                                                if(ServicesBase)
                                                {
                                                    ObtainSemaphore(&ServicesBase->SVCS_ServicesLock);
                                                    svc = (struct Service *)ServicesBase->SVCS_Services.mlh_Head;
                                                    while(svc->svc_Node.ln_Succ)
                                                    {
                                                        if((!(svc->svc_Flags & SVCF_EXPUNGE)) && (svc->svc_Flags & SVCF_ENABLE))
                                                        {
                                                            dtag->ti_Tag = QUERY_SERVICE;
                                                            dtag->ti_Data = (LONG)((ULONG)newdataoffset - (ULONG)ih_new);
                                                            strcpy((STRPTR)newdataoffset,(STRPTR)&svc->svc_SvcName);
                                                            newdataoffset +=strlen((STRPTR)&svc->svc_SvcName) + 1;
                                                            newtagoffset +=8;
                                                            dtag = (struct TagItem *)newtagoffset;
                                                        }
                                                        svc = (struct Service *)svc->svc_Node.ln_Succ;
                                                    }
                                                    ReleaseSemaphore(&ServicesBase->SVCS_ServicesLock);
                                                    CloseLibrary((struct Library *)ServicesBase);
                                                }
                                                newtagoffset -= 8;
                                                break;

                        case QUERY_REALMS:      node = (struct Node *)gb->RealmList.mlh_Head;
                                                while(node->ln_Succ)
                                                {
                                                    dtag->ti_Tag = QUERY_REALMS;
                                                    dtag->ti_Data = (LONG)((ULONG)newdataoffset - (ULONG)ih_new);
                                                    strcpy((STRPTR)newdataoffset,(STRPTR)((struct Realm *)node)->realm_Name);
                                                    newdataoffset += strlen((STRPTR)newdataoffset) +1;
                                                    newtagoffset +=8;
                                                    dtag = (struct TagItem *)newtagoffset;
                                                    node = node->ln_Succ;
                                                }
                                                newtagoffset -= 8;
                                                break;
                        case QUERY_MAXFASTMEM:
                        case QUERY_MAXCHIPMEM:
                        case QUERY_AVAILFASTMEM:
                        case QUERY_AVAILCHIPMEM:
                                                {
                                                    ULONG memflags;

                                                    switch(tag->ti_Tag)
                                                    {
                                                        case QUERY_MAXFASTMEM:  memflags = MEMF_FAST|MEMF_TOTAL;
                                                                                break;
                                                        case QUERY_MAXCHIPMEM:  memflags = MEMF_CHIP|MEMF_TOTAL;
                                                                                break;
                                                        case QUERY_AVAILFASTMEM: memflags = MEMF_FAST;
                                                                                 break;
                                                        case QUERY_AVAILCHIPMEM: memflags = MEMF_CHIP;
                                                                                 break;
                                                    }
                                                    dtag->ti_Data =  AvailMem(memflags);
                                                }
                                                break;

			case QUERY_ATTNFLAGS:
						dtag->ti_Data = ((struct ExecBase *)SysBase)->AttnFlags;
						break;

                        case QUERY_CHIPREVBITS:
                                                {
                                                    struct GfxBase *GfxBase;
                                                    if(GfxBase = (struct GfxBase *)OpenLibrary("graphics.library",37L))
                                                    {
                                                        dtag->ti_Data = GfxBase->ChipRevBits0;
                                                        CloseLibrary((struct Library *)GfxBase);
                                                    }
                                                }
                                                break;
                        case QUERY_KICKVERSION:
                                                dtag->ti_Data = (SysBase->lib_Version << 16) | ((struct ExecBase *)SysBase)->SoftVer;
                                                break;

                        case QUERY_NIPCVERSION:
                        			dtag->ti_Data = (gb->LibNode.lib_Version << 16) | (gb->LibNode.lib_Revision);
                        			break;

                        case QUERY_WBVERSION:
                                                {
                                                    struct Library *VBase;
                                                    if(VBase = OpenLibrary("version.library",0))
                                                    {
                                                        dtag->ti_Data = (VBase->lib_Version << 16) | VBase->lib_Revision;
                                                        CloseLibrary(VBase);
                                                    }
                                                }
                                                break;

                        case QUERY_LIBVERSION:
                                                {
                                                    ULONG lib_version;
                                                    STRPTR lib_name;
                                                    struct Library *LibBase;

                                                    lib_name = (STRPTR)((ULONG)ih + (ULONG)tag->ti_Data);
                                                    lib_version = 0;

                                                    if(LibBase = OpenLibrary(lib_name,0))
                                                    {
                                                        lib_version = (LibBase->lib_Version << 16) | LibBase->lib_Revision;
                                                        CloseLibrary(LibBase);
                                                    }
                                                    dtag->ti_Data = (LONG)((ULONG)newdataoffset - (ULONG)ih_new);
                                                    *((ULONG *)newdataoffset) = lib_version;
                                                    strcpy((STRPTR)((ULONG)newdataoffset+4),lib_name);
                                                    newdataoffset += strlen(lib_name) + 5;
                                                }
                                                break;

                    }
                    newtagoffset += 8;
                }
                dtag = (struct TagItem *)newtagoffset;
                dtag->ti_Tag = TAG_DONE;
                QueueNameResponse((APTR)ih_new, ih_new->ih_Length, ih->ih_SourceAddr);
//                UDP_Output((UBYTE *)ih_new,ih_new->ih_Length,0,ih->ih_SourceAddr,NIP_UDP_PORT,NIP_UDP_PORT);
//                FreeMem(ih_new,ih_new->ih_Length);
            }
        }
    }
    else if(ih->ih_PType == PTYPE_RESPONSE)
    {
        struct InquiryInfo *tmp_ii;
        ii = (struct InquiryInfo *) gb->RequestList.mlh_Head;
        while(ii->ii_Msg.mn_Node.ln_Succ)
        {
            tmp_ii = (struct InquiryInfo *)ii->ii_Msg.mn_Node.ln_Succ;

            if(ii->ii_ID == ih->ih_ID)
            {
                ULONG result;
                struct TagItem *ftag,*current;
                current = (struct TagItem *)((ULONG)ih + ih->ih_HeaderLength);
                while(ftag=NextTagItem(&current))
                {
                    switch(ftag->ti_Tag)
                    {
                        case TAG_DONE:
                        case MATCH_IPADDR:
                        case QUERY_IPADDR:
                        case MATCH_ATTNFLAGS:
                        case QUERY_ATTNFLAGS:
                        case MATCH_CHIPREVBITS:
                        case QUERY_CHIPREVBITS:
                        case MATCH_MAXFASTMEM:
                        case QUERY_MAXFASTMEM:
                        case MATCH_AVAILFASTMEM:
                        case QUERY_AVAILFASTMEM:
                        case MATCH_MAXCHIPMEM:
                        case QUERY_MAXCHIPMEM:
                        case MATCH_AVAILCHIPMEM:
                        case QUERY_AVAILCHIPMEM:
                        case MATCH_KICKVERSION:
                        case QUERY_KICKVERSION:
                        case MATCH_WBVERSION:
                        case QUERY_WBVERSION:
                        case MATCH_NIPCVERSION:
                        case QUERY_NIPCVERSION:
                                                break;

                        default:                ftag->ti_Data += (LONG)ih;
                                                break;
                    }
                }
                result = CallHookPkt(ii->ii_Hook,ii->ii_Task,(APTR)((ULONG)ih + ih->ih_HeaderLength));
                ii->ii_MaxResponses--;
                if(result && !ii->ii_MaxResponses)
                    CallHookPkt(ii->ii_Hook,ii->ii_Task,NULL);

                if(!result || !ii->ii_MaxResponses)
                {
                    Remove((struct Node *)ii);
                    FreeMem(ii->ii_IHeader,ii->ii_QueryLength);
                    FreeMem(ii,sizeof(struct InquiryInfo));
                    break;
                }
                break;
            }
            ii = tmp_ii;
        }
    }
    FreeBuffer(buff);
}
/*------------------------------------------------------------------------*/

void ResolverTimeout()
{
    struct InquiryInfo *ii;
    APTR next;

#ifdef RIP_YES
    struct RIPHeader *rip;

    if(gb->RIPTimer != -1)
    {
            /* HACK ALERT!!!!!! */
        if((!gb->RIPTimer) || (gb->RIPTimer >30))
        {
            gb->RIPTimer = 30;
            if(rip = (struct RIPHeader *) AllocMem(sizeof(struct RIPHeader),MEMF_CLEAR|MEMF_PUBLIC))
            {
                rip->rip_Command = 2;
                rip->rip_Version = 1;
                rip->rip_AddFam = 2;
                rip->rip_DestIP = 0x87070000;
                rip->rip_Metric = 1;
                UDP_Output((UBYTE *)rip,sizeof(struct RIPHeader),0,0xffffffff,520,520);
                FreeMem(rip,sizeof(struct RIPHeader));
            }
        }
        gb->RIPTimer--;
    }
#endif

    ii = (struct InquiryInfo *) gb->RequestList.mlh_Head;
    while(ii->ii_Msg.mn_Node.ln_Succ)
    {
        next = (struct InquiryInfo *) ii->ii_Msg.mn_Node.ln_Succ;
        ii->ii_TTL -= 1;
        if(!ii->ii_TTL)
        {
            CallHookPkt(ii->ii_Hook,ii->ii_Task,NULL);
            Remove((struct Node *)ii);
            FreeMem(ii->ii_IHeader,ii->ii_QueryLength);
            FreeMem(ii,sizeof(struct InquiryInfo));
        }
        else
        {
            ULONG destIP;

            if((ii->ii_IHeader->ih_PType == PTYPE_TRANSIT) || (ii->ii_IHeader->ih_PType == PTYPE_REALMREQ))
            {
                destIP = gb->RealmServer;
            }
            else
            {
                ii->ii_IHeader->ih_SourceAddr = ((struct sanadev *) gb->DeviceList.lh_Head->ln_Succ)->sanadev_IPAddress;
                destIP = 0xffffffff;
            }
            UDP_Output((UBYTE *)ii->ii_IHeader,ii->ii_QueryLength,0,destIP,NIP_UDP_PORT,NIP_UDP_PORT);
        }
        ii = next;
    }

}

/*------------------------------------------------------------------------*/
@


1.46
log
@Fixed QUERY_REALMS problems.  I wasn't setting ti_Tag correctly.
@
text
@d7 1
a7 1
** $Id: resolver.c,v 1.45 93/03/03 11:54:33 kcd Exp Locker: kcd $
d851 5
a855 2
                                                responselength += strlen((STRPTR)&svc->svc_SvcName) + 1 + 8;
                                                responsetags++;
d882 1
@


1.45
log
@Added support for checking nipc version and other library versions.
@
text
@d7 1
a7 1
** $Id: resolver.c,v 1.44 93/02/16 14:34:39 kcd Exp Locker: kcd $
d1014 1
@


1.44
log
@No longer will show services that aren't enabled.
@
text
@d7 1
a7 1
** $Id: resolver.c,v 1.43 93/01/15 18:11:47 kcd Exp Locker: kcd $
d378 1
d382 1
a382 1
            case QUERY_LIBVERSION:      querylength+=strlen((STRPTR)tag->ti_Data)+5;
d430 2
a431 1
                    case MATCH_SERVICE:         dtag->ti_Tag = tag->ti_Tag;
d439 3
a441 2
                                                strcpy((STRPTR)(dataoffset + 4),(STRPTR)tag->ti_Data);
                                                dataoffset += (strlen((STRPTR)tag->ti_Data) + 5);
d743 45
d796 1
d926 6
d957 1
a1013 1
                                                    dtag->ti_Tag = QUERY_REALMS;
d1063 4
d1078 21
d1146 2
@


1.43
log
@Fixed QUERY_ATTNFLAGS, and the QUERY_xxxxMEM tags.  Both were completely broken.
@
text
@d7 1
a7 1
** $Id: resolver.c,v 1.42 92/12/17 16:39:11 kcd Exp Locker: kcd $
d66 1
d68 2
d771 1
a771 1
                                                    if(!(svc->svc_Flags & SVCF_EXPUNGE))
d938 1
a938 1
                                                        if(!(svc->svc_Flags & SVCF_EXPUNGE))
@


1.42
log
@Added support for new fields in the IFF Host chunk.  Added support for
the MATCH/QUERY_OWNER Tags.
@
text
@d7 1
a7 1
** $Id: resolver.c,v 1.41 92/12/16 14:44:25 kcd Exp Locker: kcd $
d974 1
a974 1
                                                        case MATCH_MAXFASTMEM:  memflags = MEMF_FAST|MEMF_TOTAL;
d976 1
a976 1
                                                        case MATCH_MAXCHIPMEM:  memflags = MEMF_CHIP|MEMF_TOTAL;
d978 1
a978 1
                                                        case MATCH_AVAILFASTMEM: memflags = MEMF_FAST;
d980 1
a980 1
                                                        case MATCH_AVAILCHIPMEM: memflags = MEMF_CHIP;
d986 4
@


1.41
log
@Hopefully fixed the bug causing realm servers to not see anyone else.
This involved adding some code to check for a special case where the
originator address for a packet would get set to 127.0.0.1, which wouldn't
work right.
@
text
@d7 1
a7 1
** $Id: resolver.c,v 1.40 92/12/02 11:02:00 gregm Exp Locker: kcd $
d77 1
a77 1
    struct NIPCIFFHostPrefs *nhp;
d101 1
a102 38
    ci = FindCollection(nb->iff,ID_PREF,ID_NLRM);
    while(ci)
    {
        if(realm = AllocMem(sizeof(struct Realm),MEMF_PUBLIC|MEMF_CLEAR))
        {
            nzp = (struct NIPCRealmPrefs *)ci->ci_Data;
            route = Route(nzp->nzp_RealmAddr,TRUE);
            if(route)
            {
                realm->realm_SubnetMask = route->nr_Mask;
                realm->realm_SrcIP = route->nr_Device->sanadev_IPAddress;
            }
            else
            {
                realm->realm_SubnetMask = NetMask(nzp->nzp_RealmAddr);
                realm->realm_SrcIP = 0xffffffff;
            }

            realm->realm_NetworkIP = nzp->nzp_RealmAddr;
            realm->realm_Broadcast = nzp->nzp_RealmAddr | ~realm->realm_SubnetMask;
            strcpy(realm->realm_Name,nzp->nzp_RealmName);
            realm->realm_Flags = REALM_AUTHORITY;
            AddTail((struct List *)&nb->RealmList,(struct Node *)realm);
        }
        ci = ci->ci_Next;
    }
    ci = FindCollection(nb->iff,ID_PREF,ID_NRRM);
    while(ci)
    {
        if(realm = AllocMem(sizeof(struct Realm),MEMF_PUBLIC|MEMF_CLEAR))
        {
            nzp = (struct NIPCRealmPrefs *)ci->ci_Data;
            realm->realm_Server = nzp->nzp_RealmAddr;
            strcpy(realm->realm_Name,nzp->nzp_RealmName);
            AddTail((struct List *)&nb->RealmList,(struct Node *)realm);
        }
        ci = ci->ci_Next;
    }
d105 1
a105 1
        nhp = (struct NIPCIFFHostPrefs *)ci->ci_Data;
d109 55
d625 11
d883 5
@


1.40
log
@Moved the define for the assigned resolver port number to nipcinternal.h
@
text
@d7 1
a7 1
** $Id: resolver.c,v 1.39 92/11/19 14:19:29 kcd Exp Locker: gregm $
d110 1
d112 2
d115 1
d117 2
d525 2
a526 1
    BOOL match = TRUE;
d537 1
a537 1
        if(!ih->ih_SourceAddr)
d539 1
d553 8
a560 1
                        UDP_Output((UBYTE *)ih,ih->ih_Length,0,realm->realm_Broadcast,NIP_UDP_PORT,NIP_UDP_PORT);
a1054 1
    struct RIPHeader *rip;
d1056 1
d1058 2
d1080 1
@


1.39
log
@I *think* I fixed the problem with getting a list of realms.
@
text
@d7 1
a7 1
** $Id: resolver.c,v 1.38 92/11/02 14:08:28 kcd Exp Locker: kcd $
d60 3
a62 3
    struct timerequest	tr_TimerIO;
    ULONG		tr_Length;
    ULONG		tr_Destination;
a68 2
#define NIP_UDP_PORT    376

d330 2
a331 2
    	addMRTag = TRUE;
    	ptype = PTYPE_TRANSIT;
d334 1
a334 1
    	ptype = PTYPE_QUERY;
d343 1
a343 1
            				addMRTag = FALSE;
d346 1
a346 1
	    case MATCH_REALM:		addMRTag = FALSE;
d361 2
a362 2
    	querylength += (9 + strlen((STRPTR)&nb->RealmName));
    	numtags++;
d420 4
a423 4
            	dtag = (struct TagItem *)tagoffset;
            	dtag->ti_Tag = MATCH_REALM;
            	dtag->ti_Data = (LONG)(dataoffset - (UBYTE *)ih);
            	strcpy((STRPTR)dataoffset,(STRPTR)&gb->RealmName);
d449 11
a459 11
    	tr->tr_TimerIO.tr_node.io_Device = (struct Device *)gb->TimerDevice;
    	tr->tr_TimerIO.tr_node.io_Unit = (struct Unit *)gb->TimerUnit;
    	tr->tr_TimerIO.tr_node.io_Message.mn_ReplyPort = gb->NameResponsePort;
    	tr->tr_TimerIO.tr_node.io_Command = TR_ADDREQUEST;
    	gb->TimerSeed = makefastrand(gb->TimerSeed);
    	tr->tr_TimerIO.tr_time.tv_secs=0;
    	tr->tr_TimerIO.tr_time.tv_micro = 7 * gb->TimerSeed;
    	tr->tr_Length = length;
    	tr->tr_Destination = dest;
    	tr->tr_Buffer = buff;
    	SendIO((struct IORequest *)tr);
d489 3
a491 3
    	UDP_Output((UBYTE *)tr->tr_Buffer,tr->tr_Length,0,tr->tr_Destination,NIP_UDP_PORT,NIP_UDP_PORT);
    	FreeMem(tr->tr_Buffer,tr->tr_Buffer->ih_Length);
    	FreeMem(tr,sizeof(struct TimedResponse));
d588 2
a589 2
                			if(gb->RealmServer)
                			    responselength += strlen((STRPTR)&gb->RealmName) + 1;
d791 1
a791 1
            	break;
d968 1
a968 1
		QueueNameResponse((APTR)ih_new, ih_new->ih_Length, ih->ih_SourceAddr);
d1089 1
a1089 1
	}
@


1.38
log
@Added Delayed Query responses and added a resend mechanism to queries.
@
text
@d7 1
a7 1
** $Id: resolver.c,v 1.37 92/09/18 14:56:26 kcd Exp Locker: kcd $
d345 1
@


1.37
log
@I'm no longer using SIGF_SINGLE for name resolution. I am now using
SIGF_NET provided in exec/tasks.h.  
I also fixed the bug with doing queries in a realmed environment
with specifying a realm to match with.  That is now fixed.
@
text
@d7 1
a7 1
** $Id: resolver.c,v 1.36 92/08/29 12:32:02 gregm Exp Locker: kcd $
d22 1
d28 1
d58 8
d83 1
d96 2
a97 1
    nb->resolversigmask = (1 << gb->ResolverPort->mp_SigBit);
d101 3
d381 1
a381 1
            ii->ii_TTL = maxTime;
d444 22
d470 1
d487 7
d969 3
a971 3

                UDP_Output((UBYTE *)ih_new,ih_new->ih_Length,0,ih->ih_SourceAddr,NIP_UDP_PORT,NIP_UDP_PORT);
                FreeMem(ih_new,ih_new->ih_Length);
d1076 15
@


1.36
log
@Fixed the lack of an ih_SourceAddr in the case of a QUERY_REALMS.
@
text
@d7 1
a7 1
** $Id: resolver.c,v 1.35 92/08/21 14:25:37 kcd Exp Locker: gregm $
d240 1
d242 1
a242 1
        Wait(SIGF_SINGLE);
d263 1
a263 1
            Signal(task,SIGF_SINGLE);
d269 1
a269 1
        Signal(task,SIGF_SINGLE);
d297 2
d314 8
a321 1
    ptype = PTYPE_QUERY;
d331 2
a332 1
            case MATCH_REALM:           ptype = PTYPE_TRANSIT;
d345 5
a349 1

d404 8
d444 1
a444 1
            ii->ii_IHeader->ih_SourceAddr = ((struct sanadev *) gb->DeviceList.lh_Head)->sanadev_IPAddress;
d527 1
a527 1
        responselength = sizeof(struct InquiryHeader) + 8;  /* Don't forget the terminating TAG_DONE TagItem */
d532 1
a538 1
                                            goto EndParse;      /* Ack! */
d540 1
a540 2
                                        responselength += strlen(tmpstr) + 1 + 8;
                                        responsetags++;
d543 3
a545 2
                case QUERY_HOSTNAME:    responselength += strlen((STRPTR)&nb->LocalHostName) + 1 + 8;
                                        responsetags++;
a551 1
                                            goto EndParse;
d553 1
a553 2
                                        responselength += strlen(tmpstr) + 1 + 8;
                                        responsetags++;
d559 1
a559 1
                                            responselength += strlen((STRPTR)&realm_ptr->realm_Name) + 1 + 8;
d563 1
a569 1
                                            goto EndParse;
a570 2
                                        responselength += 8;
                                        responsetags++;
d573 1
a573 1
                case MATCH_ATTNFLAGS:   if(tag->ti_Data & ((struct ExecBase *)SysBase)->AttnFlags)
a574 5
                                            responselength += 8;
                                            responsetags++;
                                        }
                                        else
                                        {
a575 1
                                            goto EndParse;
a585 5
                                                    responselength += 8;
                                                    responsetags++;
                                                }
                                                else
                                                {
a592 2
                                        if(!respond)
                                            goto EndParse;
d613 1
a613 1
                                            if(AvailMem(memflags) >= tag->ti_Data)
a614 5
                                                responselength += 8;
                                                responsetags++;
                                            }
                                            else
                                            {
a615 1
                                                goto EndParse;
d624 1
a624 6
                                            if(version >= tag->ti_Data)
                                            {
                                                responselength += 8;
                                                responsetags++;
                                            }
                                            else
a626 1
                                                goto EndParse;
d638 1
a638 6
                                                if(version >= tag->ti_Data)
                                                {
                                                    responselength += 8;
                                                    responsetags++;
                                                }
                                                else
a646 2
                                        if(!respond)
                                            goto EndParse;
a656 2
                                        responselength += 8;
                                        responsetags++;
d660 1
a660 6
                                        if(route = Route(ih->ih_SourceAddr, TRUE))
                                        {
                                            responselength +=8;
                                            responsetags++;
                                        }
                                        else
a662 1
                                            goto EndParse;
d682 1
a682 1
                                                        responselength += strlen(tmpstr) + 1 + 8;
a695 1
                                            goto EndParse;
d697 1
d718 1
d725 1
a725 2
                                            responselength += strlen(tmpstr) + 1 + 8;
                                            responsetags++;
a729 2
                                        if(!respond)
                                            goto EndParse;
a738 1
                                                responsetags++;
d746 2
d749 1
a783 1
                                                newtagoffset += 8;
d787 7
a795 1
                                                newtagoffset += 8;
a806 1
                                                newtagoffset += 8;
a810 1
                                                newtagoffset += 8;
d829 1
d856 1
d870 1
a891 1
                                                newtagoffset += 8;
a899 1
                                                        newtagoffset += 8;
a905 1
                                                newtagoffset += 8;
a913 1
                                                        newtagoffset += 8;
d920 1
d973 5
a977 1
                if(!result)
a983 8
                ii->ii_MaxResponses--;
                if(!ii->ii_MaxResponses)
                {
                    CallHookPkt(ii->ii_Hook,ii->ii_Task,NULL);
                    Remove((struct Node *)ii);
                    FreeMem(ii->ii_IHeader,ii->ii_QueryLength);
                    FreeMem(ii,sizeof(struct InquiryInfo));
                }
d998 1
d1018 1
a1018 1

@


1.35
log
@Modified the way the inquiry function works to help eliminate the
routing problems here at C=.
@
text
@d7 1
a7 1
** $Id: resolver.c,v 1.34 92/08/19 16:12:31 kcd Exp Locker: kcd $
d59 1
a59 1
#define NIP_UDP_PORT	376
d319 2
a320 2
            case QUERY_REALMS:		ptype = PTYPE_REALMREQ;
            				break;
d463 2
a464 2
	if(!ih->ih_SourceAddr)
	    ih->ih_SourceAddr = ip->iph_SrcAddr;
d499 3
d554 107
a660 107
		case MATCH_ATTNFLAGS:   if(tag->ti_Data & ((struct ExecBase *)SysBase)->AttnFlags)
					{
					    responselength += 8;
					    responsetags++;
					}
					else
					{
					    respond = FALSE;
					    goto EndParse;
					}
					break;

		case MATCH_CHIPREVBITS:
					{
					    struct GfxBase *GfxBase;
					    if(GfxBase = (struct GfxBase *)OpenLibrary("graphics.library",37L))
					    {
					    	if(!(tag->ti_Data & GfxBase->ChipRevBits0))
					    	{
					    	    responselength += 8;
					    	    responsetags++;
					    	}
					    	else
					    	{
					    	    respond = FALSE;
					    	}
					    	CloseLibrary((struct Library *)GfxBase);
					    }
					    else
					    	respond = FALSE;
					}
					if(!respond)
					    goto EndParse;
					break;

		case MATCH_MAXFASTMEM:
		case MATCH_MAXCHIPMEM:
		case MATCH_AVAILFASTMEM:
		case MATCH_AVAILCHIPMEM:
					{
					    ULONG memflags;

					    switch(tag->ti_Tag)
					    {
					    	case MATCH_MAXFASTMEM:	memflags = MEMF_FAST|MEMF_TOTAL;
					    				break;
					    	case MATCH_MAXCHIPMEM:	memflags = MEMF_CHIP|MEMF_TOTAL;
					    				break;
					    	case MATCH_AVAILFASTMEM: memflags = MEMF_FAST;
					    				 break;
					    	case MATCH_AVAILCHIPMEM: memflags = MEMF_CHIP;
					    				 break;
					    }
					    if(AvailMem(memflags) >= tag->ti_Data)
					    {
					    	responselength += 8;
					    	responsetags++;
					    }
					    else
					    {
					    	respond = FALSE;
					    	goto EndParse;
					    }
					}
					break;

		case MATCH_KICKVERSION:
					{
					    ULONG version;
					    version = (SysBase->lib_Version << 16) | ((struct ExecBase *)SysBase)->SoftVer;
					    if(version >= tag->ti_Data)
					    {
					    	responselength += 8;
					    	responsetags++;
					    }
					    else
					    {
					    	respond = FALSE;
					    	goto EndParse;
					    }
					}
					break;

		case MATCH_WBVERSION:
					{
					    ULONG version;
					    struct Library *VBase;
					    if(VBase = OpenLibrary("version.library",0))
					    {
					    	version = (VBase->lib_Version << 16) | VBase->lib_Revision;
					    	if(version >= tag->ti_Data)
					    	{
					    	    responselength += 8;
					    	    responsetags++;
					    	}
					    	else
					    	{
					    	    respond = FALSE;
					    	}
					    	CloseLibrary(VBase);
					    }
					    else
					    	respond = FALSE;
					}
					if(!respond)
					    goto EndParse;
					break;
d670 3
a672 3
                			responselength += 8;
                			responsetags++;
                			break;
d688 1
a688 1
                			Forbid();
d703 2
a704 2
                                                    	responselength += strlen(tmpstr) + 1 + 8;
                                                    	responsetags++;
d793 1
a793 1
		    dtag->ti_Tag = tag->ti_Tag;
d814 8
a821 8
			case MATCH_ATTNFLAGS:
			case MATCH_CHIPREVBITS:
			case MATCH_MAXFASTMEM:
			case MATCH_AVAILFASTMEM:
			case MATCH_MAXCHIPMEM:
			case MATCH_AVAILCHIPMEM:
			case MATCH_KICKVERSION:
			case MATCH_WBVERSION:
d875 1
a875 1
			case QUERY_REALMS:      node = (struct Node *)gb->RealmList.mlh_Head;
d911 1
a911 1
                        			{
d919 2
a920 2
						}
						break;
d940 2
a941 2
		dtag = (struct TagItem *)newtagoffset;
		dtag->ti_Tag = TAG_DONE;
d958 1
a958 1
            	ULONG result;
d965 1
a965 1
                    	case TAG_DONE:
@


1.34
log
@Switched to stccpy from strncpy.
@
text
@d7 1
a7 1
** $Id: resolver.c,v 1.33 92/08/18 15:46:04 kcd Exp Locker: kcd $
a256 2
//  putreg(REG_A6,(LONG)hook->h_SubEntry);

d341 1
a341 1
        ii->ii_HeaderLength = querylength;
d343 1
a343 1
        if(ih = (struct InquiryHeader *)AllocMem(ii->ii_HeaderLength,MEMF_CLEAR|MEMF_PUBLIC))
d355 1
d420 2
d423 2
a424 1
        UDP_Output((UBYTE *)ii->ii_IHeader,ii->ii_HeaderLength,0,destIP,NIP_UDP_PORT,NIP_UDP_PORT);
d463 2
d468 1
a468 1
        if(tag = FindTagItem(MATCH_REALM,(struct TagItem *)((ULONG)ih+(ULONG)sizeof(struct InquiryHeader))))
d478 1
a478 1
                        UDP_Output((UBYTE *)ih,ih->ih_Length,ip->iph_SrcAddr,realm->realm_Broadcast,NIP_UDP_PORT,NIP_UDP_PORT);
d483 1
a483 1
                        UDP_Output((UBYTE *)ih,ih->ih_Length,ip->iph_SrcAddr,realm->realm_Server,NIP_UDP_PORT,NIP_UDP_PORT);
d499 1
a499 1
        current = (struct TagItem *)((ULONG)ih + (ULONG)sizeof(struct InquiryHeader));
d672 1
a672 1
                                        if(route = Route(ip->iph_SrcAddr, TRUE))
d778 1
d785 1
a785 1
                current = (struct TagItem *)((ULONG)ih + (ULONG)sizeof(struct InquiryHeader));
d823 1
a823 1
                        case QUERY_IPADDR:      route = Route(ip->iph_SrcAddr, TRUE);
d940 1
a940 1
                UDP_Output((UBYTE *)ih_new,ih_new->ih_Length,0,ip->iph_SrcAddr,NIP_UDP_PORT,NIP_UDP_PORT);
d957 1
a957 1
                current = (struct TagItem *)((ULONG)ih + (ULONG)sizeof(struct InquiryHeader));
d987 1
a987 1
                result = CallHookPkt(ii->ii_Hook,ii->ii_Task,(APTR)((ULONG)ih + (ULONG)sizeof(struct InquiryHeader)));
d991 1
a991 1
                    FreeMem(ii->ii_IHeader,ii->ii_HeaderLength);
d1000 1
a1000 1
                    FreeMem(ii->ii_IHeader,ii->ii_HeaderLength);
d1046 1
a1046 1
            FreeMem(ii->ii_IHeader,ii->ii_HeaderLength);
@


1.33
log
@Fixed some rather nasty bugs related to queries with MATCH_SERVICE in them.
Everything should be OK at this point.
@
text
@d7 1
a7 1
** $Id: resolver.c,v 1.32 92/08/11 11:15:06 kcd Exp Locker: kcd $
d184 1
a184 1
    strncpy(nbuff,hostname,128);
@


1.32
log
@Implemented most of the remaining query/match types.
@
text
@d7 1
a7 1
** $Id: resolver.c,v 1.31 92/08/03 09:48:56 kcd Exp Locker: kcd $
d680 2
a681 1
                case MATCH_SERVICE:     Forbid();
a686 1
                                            match = FALSE;
d689 1
d692 1
a692 1
                                                if(!Stricmp((STRPTR)&svc->svc_SvcName,(STRPTR)tag->ti_Data))
d696 2
d736 6
a741 1
                                        if(!FindNameI((struct List *)&nb->ANMPEntityList,tmpstr))
d856 1
a856 1
                                                            newdataoffset +=(1 + strlen((STRPTR)&svc->svc_SvcName));
@


1.31
log
@Switched over to our assigned UDP port number.
@
text
@d7 1
a7 1
** $Id: resolver.c,v 1.30 92/07/30 16:13:52 kcd Exp Locker: kcd $
d15 2
a16 1

d86 1
a86 1
    nb->RIPTimer = -1;
d123 1
a123 1
        nhp = (struct NIPCHostPrefs *)ci->ci_Data;
d241 1
a241 1
        Wait(SIGBREAKF_CTRL_F);
d250 3
a252 3
void __asm RNHookFunc(register __a0 struct Hook *hook,
                      register __a2 struct TagItem *tagList,
                      register __a1 struct Task *task)
d262 1
d264 3
d269 5
a273 1
        Signal(task,SIGBREAKF_CTRL_F);
d321 2
d416 1
a416 1
        if(ii->ii_IHeader->ih_PType == PTYPE_TRANSIT)
d448 1
d488 1
a488 1
    else if(ih->ih_PType == PTYPE_QUERY)
d547 120
d777 1
d786 1
a786 2
                        case MATCH_MACHDESC:    dtag->ti_Tag = tag->ti_Tag;
                                                dtag->ti_Data = (LONG)((ULONG)newdataoffset - (ULONG)ih_new);
d792 1
a792 2
                        case QUERY_HOSTNAME:    dtag->ti_Tag = QUERY_HOSTNAME;
                                                dtag->ti_Data = (LONG)((ULONG)newdataoffset - (ULONG)ih_new);
d798 9
a806 2
                        case MATCH_IPADDR:      dtag->ti_Tag = MATCH_IPADDR;
                                                dtag->ti_Data = tag->ti_Data;
d810 1
a810 2
                        case QUERY_IPADDR:      dtag->ti_Tag = QUERY_IPADDR;
                                                route = Route(ip->iph_SrcAddr, TRUE);
d859 63
d924 3
d942 1
d949 1
d952 16
d974 8
a981 1
                CallHookPkt(ii->ii_Hook,(APTR)((ULONG)ih + (ULONG)sizeof(struct InquiryHeader)),ii->ii_Task);
d985 1
a985 1
                    CallHookPkt(ii->ii_Hook,NULL,ii->ii_Task);
d1031 1
a1031 1
            CallHookPkt(ii->ii_Hook,NULL,ii->ii_Task);
@


1.30
log
@Fixed a bit of code that was choking with SAS/C 6.0.
@
text
@d7 1
a7 1
** $Id: resolver.c,v 1.29 92/07/09 19:37:52 gregm Exp $
d58 2
d82 1
a82 1
    nb->NameRequestPort = OpenUDPPort(1,&ResolverInput);
d411 1
a411 1
        UDP_Output((UBYTE *)ii->ii_IHeader,ii->ii_HeaderLength,0,destIP,0,1);
d462 1
a462 1
                        UDP_Output((UBYTE *)ih,ih->ih_Length,ip->iph_SrcAddr,realm->realm_Broadcast,0,1);
d467 1
a467 1
                        UDP_Output((UBYTE *)ih,ih->ih_Length,ip->iph_SrcAddr,realm->realm_Server,0,1);
d724 1
a724 1
                UDP_Output((UBYTE *)ih_new,ih_new->ih_Length,0,ip->iph_SrcAddr,0,1);
@


1.29
log
@undid kludge
@
text
@d7 1
a7 1
** $Id: resolver.c,v 1.28 92/07/09 18:11:18 kcd Exp Locker: gregm $
d224 1
a224 1
    rn_hook.h_SubEntry = (HOOK_FUNC) NIPCBASE;
d243 4
d252 3
a254 1
    putreg(REG_A6,(LONG)hook->h_SubEntry);
d264 6
@


1.28
log
@Temporary bug hunting change...
@
text
@d7 1
a7 1
** $Id: resolver.c,v 1.27 92/06/29 12:28:00 kcd Exp Locker: kcd $
d168 3
a170 3
    			      MATCH_HOSTNAME,0,
    			      QUERY_IPADDR,0,
    			      TAG_DONE,0};
d210 1
a210 1
/*    if(!Stricmp(host_ptr,(STRPTR)&nb->LocalHostName))
d212 7
a218 7
    	if(realm_ptr)
    	{
    	    if(!Stricmp(realm_ptr,(STRPTR)&nb->RealmName))
    	        return(0xffffffff);
    	}
    	else
    	    return(0xffffffff);
d220 1
a220 1
*/
d231 3
a233 3
    	if(gb->RealmServer)
    	    RNTags[0].ti_Data = (ULONG) &gb->RealmName[0];
    	else
d238 1
a238 1
	Wait(SIGBREAKF_CTRL_F);
d252 2
a253 2
   	if(tag = FindTagItem(QUERY_IPADDR, tagList))
	    *(ULONG *)hook->h_Data = tag->ti_Data;
d283 1
a283 1
    	return FALSE;
d294 14
a307 14
    	querylength+=8;
    	numtags++;
    	switch(tag->ti_Tag)
    	{
    	    case MATCH_REALM:		ptype = PTYPE_TRANSIT;
    	    case MATCH_HOSTNAME:
    	    case MATCH_OWNER:
    	    case MATCH_ENTITY:
    	    case MATCH_SERVICE:
    	    				querylength+=strlen((STRPTR)tag->ti_Data)+1;
    	    				break;

    	    case QUERY_LIBVERSION:	querylength+=strlen((STRPTR)tag->ti_Data)+5;
    	    				break;
d309 1
a309 1
    	}
d314 3
a316 3
    	Forbid();
    	ii->ii_ID = gb->ResID++;
    	Permit();
d318 3
a320 3
    	ii->ii_HeaderLength = querylength;

    	if(ih = (struct InquiryHeader *)AllocMem(ii->ii_HeaderLength,MEMF_CLEAR|MEMF_PUBLIC))
d323 1
a323 1
	    struct TagItem *dtag;
d327 6
a332 6
	    ii->ii_Hook = hook;
	    ii->ii_TTL = maxTime;
	    ii->ii_MaxResponses = maxResponses;
	    ih->ih_PType = ptype;
	    ih->ih_Length = querylength;
	    ih->ih_ID    = ii->ii_ID;
d336 1
a336 1
	    current = tagList;
d338 3
a340 3
	    while(tag = NextTagItem(&current))
	    {
	    	dtag = (struct TagItem *)tagoffset;
d343 17
a359 17
	    	switch(tag->ti_Tag)
	    	{
	    	    case MATCH_HOSTNAME:
	    	    case MATCH_REALM:
	    	    case MATCH_OWNER:
	    	    case MATCH_ENTITY:
	    	    case MATCH_SERVICE:		dtag->ti_Tag = tag->ti_Tag;
	    	    				dtag->ti_Data = (LONG)(dataoffset - (UBYTE *)ih);
	    	    				strcpy((STRPTR)dataoffset,(STRPTR)tag->ti_Data);
	    	    				dataoffset += (strlen((STRPTR)tag->ti_Data) + 1);
	    	    				break;

	    	    case MATCH_LIBVERSION:	dtag->ti_Tag = tag->ti_Tag;
	    	    				dtag->ti_Data = (LONG)(dataoffset - (UBYTE *)ih);
	    	    				strcpy((STRPTR)(dataoffset + 4),(STRPTR)tag->ti_Data);
	    	    				dataoffset += (strlen((STRPTR)tag->ti_Data) + 5);
	    	    				break;
d361 4
a364 4
	    	    default:			dtag->ti_Tag = tag->ti_Tag;
	    	    				break;
	    	}
	    }
d376 1
a376 1
    	return FALSE;
d464 3
a466 3
    	struct TagItem *current;
    	ULONG responselength,responsetags;
    	STRPTR tmpstr;
d469 18
a486 1
    	current = (struct TagItem *)((ULONG)ih + (ULONG)sizeof(struct InquiryHeader));
d488 3
a490 2
    	responselength = sizeof(struct InquiryHeader) + 8;  /* Don't forget the terminating TAG_DONE TagItem */
    	responsetags = 1;
d492 9
a500 27
    	while(tag = NextTagItem(&current))
    	{
    	    switch(tag->ti_Tag)
    	    {
    	    	case MATCH_HOSTNAME:	tmpstr = (STRPTR)((ULONG)ih + (ULONG)tag->ti_Data);
    	    				if(Stricmp(tmpstr,(STRPTR)&nb->LocalHostName))
    	    				{
    	    				    respond = FALSE;
    	    				    goto EndParse;	/* Ack! */
    	    				}
    	    				responselength += strlen(tmpstr) + 1 + 8;
    	    				responsetags++;
    	    				break;

    	    	case QUERY_HOSTNAME:	responselength += strlen((STRPTR)&nb->LocalHostName) + 1 + 8;
    	    				responsetags++;
    	    				break;

    	    	case MATCH_REALM:	tmpstr = (STRPTR)((ULONG)ih + (ULONG)tag->ti_Data);
    	    				if(Stricmp(tmpstr,(STRPTR)&nb->RealmName))
    	    				{
    	    				    respond = FALSE;
    	    				    goto EndParse;
    	    				}
    	    				responselength += strlen(tmpstr) + 1 + 8;
    	    				responsetags++;
    	    				break;
d502 1
a502 1
    	    	case QUERY_REALMS:	realm_ptr = (struct Realm *)gb->RealmList.mlh_Head;
d512 8
a519 8
                			if(!IsLocalDevice(tag->ti_Data))
                			{
                			    respond = FALSE;
                			    goto EndParse;
                			}
                			responselength += 8;
                			responsetags++;
                			break;
d522 1
a522 1
                			if(route = Route(ip->iph_SrcAddr, TRUE))
d529 4
a532 4
                                    	    respond = FALSE;
                                    	    goto EndParse;
                                    	}
                			break;
d534 1
a534 1
                case MATCH_SERVICE:	Forbid();
d585 2
a586 2
                case MATCH_ENTITY:	tmpstr = (STRPTR)((ULONG)ih + (ULONG)tag->ti_Data);
                			ObtainSemaphore(&nb->ANMPELSemaphore);
d594 1
a594 1
		case QUERY_ENTITY:	ObtainSemaphore(&nb->ANMPELSemaphore);
d609 1
a609 1
	}
d611 52
a662 52
	if(respond)
	{
	    if(ih_new = AllocMem(responselength,MEMF_CLEAR|MEMF_PUBLIC))
	    {
	    	struct TagItem *dtag;
	    	UBYTE *newdataoffset;
	    	UBYTE *newtagoffset;

		ih_new->ih_Length = responselength;
		ih_new->ih_PType  = PTYPE_RESPONSE;
		ih_new->ih_ID     = ih->ih_ID;

		newtagoffset = (UBYTE *) (ULONG)ih_new + (ULONG)sizeof(struct InquiryHeader);
		newdataoffset = newtagoffset + (responsetags * 8);

	    	current = (struct TagItem *)((ULONG)ih + (ULONG)sizeof(struct InquiryHeader));

	    	while(tag = NextTagItem(&current))
	    	{
	    	    dtag = (struct TagItem *)newtagoffset;

	    	    switch(tag->ti_Tag)
	    	    {
	    	    	case MATCH_HOSTNAME:
	    	    	case MATCH_REALM:
	    	    	case MATCH_ENTITY:
	    	    	case MATCH_SERVICE:
	    	    	case MATCH_OWNER:
	    	    	case MATCH_MACHDESC:	dtag->ti_Tag = tag->ti_Tag;
	    	    				dtag->ti_Data = (LONG)((ULONG)newdataoffset - (ULONG)ih_new);
	    	    				strcpy((STRPTR)newdataoffset,(STRPTR)ih+tag->ti_Data);
	    	    				newdataoffset += strlen((STRPTR)newdataoffset) + 1;
						newtagoffset += 8;
	    	    				break;

	    	    	case QUERY_HOSTNAME:	dtag->ti_Tag = QUERY_HOSTNAME;
	    	    				dtag->ti_Data = (LONG)((ULONG)newdataoffset - (ULONG)ih_new);
	    	    				strcpy((STRPTR)newdataoffset,(STRPTR)&nb->LocalHostName);
	    	    				newdataoffset += strlen((STRPTR)newdataoffset) + 1;
						newtagoffset += 8;
	    	    				break;

	    	    	case MATCH_IPADDR:	dtag->ti_Tag = MATCH_IPADDR;
	    	    				dtag->ti_Data = tag->ti_Data;
						newtagoffset += 8;
	    	    				break;

	    	    	case QUERY_IPADDR:	dtag->ti_Tag = QUERY_IPADDR;
	    	    				route = Route(ip->iph_SrcAddr, TRUE);
						dtag->ti_Data = route->nr_Device->sanadev_IPAddress;
						newtagoffset += 8;
						break;
d664 1
a664 1
			case QUERY_ENTITY:	ObtainSemaphore(&nb->ANMPELSemaphore);
d670 2
a671 2
                                                    	dtag->ti_Tag = QUERY_ENTITY;
                                                    	dtag->ti_Data = (LONG)((ULONG)newdataoffset - (ULONG)ih_new);
d680 1
a680 1
						break;
d682 1
a682 1
			case QUERY_SERVICE:	Forbid();
d708 6
a713 6
		    }
		}
		UDP_Output((UBYTE *)ih_new,ih_new->ih_Length,0,ip->iph_SrcAddr,0,1);
		FreeMem(ih_new,ih_new->ih_Length);
	    }
	}
d725 9
a733 9
            	struct TagItem *ftag,*current;
            	current = (struct TagItem *)((ULONG)ih + (ULONG)sizeof(struct InquiryHeader));
            	while(ftag=NextTagItem(&current))
            	{
            	    switch(ftag->ti_Tag)
            	    {
            	    	case MATCH_IPADDR:
            	    	case QUERY_IPADDR:
            	    				break;
d735 4
a738 4
            	    	default:		ftag->ti_Data += (LONG)ih;
            	    				break;
            	    }
            	}
d792 1
a792 1
   	    FreeMem(ii,sizeof(struct InquiryInfo));
@


1.27
log
@Changed name resolution to so that will always search your entire realm
for machine's that don't have a specific realm name.
@
text
@d7 1
a7 1
** $Id: resolver.c,v 1.26 92/06/27 19:10:33 kcd Exp Locker: kcd $
d210 1
a210 1
    if(!Stricmp(host_ptr,(STRPTR)&nb->LocalHostName))
d220 1
a220 1

@


1.26
log
@Added better checking for local hostname matching.
@
text
@d7 1
a7 1
** $Id: resolver.c,v 1.25 92/06/25 16:43:38 kcd Exp Locker: kcd $
d230 6
a235 1
        RNTags[0].ti_Tag = TAG_IGNORE;
@


1.25
log
@This is the new and improved name resolution stuff.
@
text
@d7 1
a7 1
** $Id: resolver.c,v 1.24 92/06/17 13:55:36 kcd Exp Locker: kcd $
a180 4
    if(!Stricmp(hostname,nb->LocalHostName))
    {
        return ((struct sanadev *)gb->DeviceList.lh_Head)->sanadev_IPAddress;
    }
d209 11
@


1.24
log
@Fixed a bug where a machine would respond to a name->network number query incorrectly.
@
text
@d7 1
a7 1
** $Id: resolver.c,v 1.23 92/06/08 09:55:30 kcd Exp Locker: kcd $
a30 13
struct NameHeader
{
    ULONG   nh_Reserved0;
    UWORD   nh_ID;
    UBYTE   nh_Type;
    UBYTE   nh_Class;
    UWORD   nh_Length;
    UBYTE   nh_Realms;
    UBYTE   nh_Hosts;
    UBYTE   nh_Services;
    UBYTE   nh_Entities;
};

a57 14
#define NHType_Query        1           /* A query about a single host. */
#define NHType_Response     2           /* A Realm-wide query. */
#define NHType_Transit      3           /* A query in transit to a realm server. */
#define NHType_Error        255

#define REALM_AUTHORITY 0x01

#define NHClass_Numbers     255         /* Realm:[Hostname]   -> Address(es) */

#define NHClass_Hosts       1           /* [Realm] & (Service|Entity) -> Hosts */
#define NHClass_Services    2           /* [Realm]:Hostname -> Services */
#define NHClass_Entities    3           /* [Realm]:Hostname -> Entities */
#define NHClass_Realms      4           /* If(RealmServer) -> Realms */

a59 23
struct NetResolveName
{
    struct Message          nrn_Msg;
    ULONG                   nrn_IP;
    UBYTE                   nrn_Name[256];
    UBYTE                   nrn_CName[256];
    struct NetResolveName  *nrn_Parent;
    ULONG                   nrn_Timer;
    UWORD                   nrn_ID;
    UWORD                   nrn_ParentID;
    UWORD                   nrn_State;
};

#define NetRes_NORMAL 1
#define NetRes_SERVER 2
#define NetRes_NESTED 4

#define NQ_Realm 1000
#define NQ_Host  1001
#define NQ_Service 1002
#define NQ_Entity 1003


a73 1
    InitSemaphore(&nb->DNSResolverLock);
a77 1
    NewList((struct List *)&gb->DNSNames);
d134 2
a135 2
    struct NameInfo *ni, *ni_tmp;
    struct NameHeader *nh;
d137 8
a144 15
    ni = (struct NameInfo *)nb->RequestList.mlh_Head;
    while(ni->ni_Msg.mn_Node.ln_Succ)
    {
        ni_tmp = (struct NameInfo *) ni->ni_Msg.mn_Node.ln_Succ;
        nh = ni->ni_Header;
        FreeMem(nh,nh->nh_Length);
        FreeMem(ni, sizeof(struct NameInfo));
        ni = ni_tmp;
    }

    if(gb->DNSHook)
    {
        CallHookPkt(nb->DNSHook,(void *)-1L,(void *)-1L);
        ObtainSemaphore(&nb->DNSResolverLock);
        ReleaseSemaphore(&nb->DNSResolverLock);
d167 4
a170 1
    struct TagItem RNTags[3]={NQ_Realm,0,NQ_Host,0,TAG_DONE,0};
d217 1
a217 1
    rn_hook.h_SubEntry = NULL;
d222 6
a227 1
    NetQueryA(&rn_hook,NHClass_Numbers,50,RNTags);
d232 2
a233 2
                      register __a2 struct NameHeader *nh,
                      register __a1 void *nada)
d235 10
a244 1
    *(ULONG *)hook->h_Data = nh->nh_Reserved0;
d249 3
a251 3
void __asm NetQueryA(register __a0 struct Hook *hook,
                     register __d0 ULONG queryClass,
                     register __d1 ULONG maxTime,
d253 1
d256 7
a262 7
    struct NameInfo *ni;
    struct NameHeader *nh;
    struct MsgPort *myport;
    struct TagItem *tag;
    STRPTR Names[4],sp;
    ULONG NTags[4]={NQ_Realm,NQ_Host,NQ_Service,NQ_Entity};
    UBYTE Lengths[4],i;
d264 93
a356 13
    if(!(hook && tagList && maxTime && queryClass))
    {
        return;
    }
    if((queryClass == NHClass_Realms) && !(gb->RealmServer))
    {
        return;
    }
    for(i=0;i<4;i++)
    {
        Names[i] = NULL;
        Lengths[i]=0;
        if(tag = FindTagItem(NTags[i],tagList))
d358 2
a359 9
            if(tag->ti_Data)
            {
                Names[i]=(STRPTR) tag->ti_Data;
                Lengths[i] = strlen(Names[i]);
                if(Lengths[i] > 64)
                    return;
                if(Lengths[i])
                    Lengths[i]++;
            }
d362 1
a362 2

    if((!Names[0]) && gb->RealmServer)
d364 1
a364 2
        Names[0] = (STRPTR) &gb->RealmName;
        Lengths[0] = strlen(Names[0]) + 1;
d366 1
a366 31
    else if((!Names[0][0]) && gb->RealmServer)
    {
        Names[0] = (STRPTR) &gb->RealmName;
        Lengths[0] = strlen(Names[0]) + 1;
    }
    if(myport = CreateMsgPort())
    {
        if(ni = (struct NameInfo *)AllocMem(sizeof(struct NameInfo),MEMF_CLEAR|MEMF_PUBLIC))
        {
            Forbid();
            ni->ni_ID = gb->ResID++;
            Permit();

            ni->ni_Msg.mn_ReplyPort = myport;

            ni->ni_HeaderLength = sizeof(struct NameHeader) + (Lengths[0] + Lengths[1] + Lengths[2] + Lengths[3]);
            if(nh = (struct NameHeader *)AllocMem(ni->ni_HeaderLength,MEMF_CLEAR|MEMF_PUBLIC))
            {
                ni->ni_Header = nh;
                ni->ni_TTL = maxTime >> 3; /* (HACK!) Supposed to be maxTime/10! */
                ni->ni_Hook = hook;
                nh->nh_ID = ni->ni_ID;
                nh->nh_Type = NHType_Query;
                nh->nh_Class = queryClass;
                nh->nh_Length = ni->ni_HeaderLength;
                nh->nh_Realms   = Lengths[0];
                nh->nh_Hosts    = Lengths[1];
                nh->nh_Services = Lengths[2];
                nh->nh_Entities  = Lengths[3];

                sp = (STRPTR) nh + sizeof(struct NameHeader);
a367 18
                for(i=0;i<4;i++)
                {
                    if(Lengths[i])
                    {
                        strcpy(sp,Names[i]);
                    }
                    sp = (STRPTR) sp + Lengths[i];
                }
                PutMsg(nb->ResolverPort,(struct Message *)ni);
                WaitPort(myport);
                GetMsg(myport);
                FreeMem(ni->ni_Header,ni->ni_HeaderLength);
            }
            FreeMem(ni,sizeof(struct NameInfo));
        }
        DeleteMsgPort(myport);
    }
}
d373 1
a373 1
    struct NameInfo *ni;
d376 1
a376 1
    while(ni = (struct NameInfo *) GetMsg(nb->ResolverPort))
d378 2
a379 2
        AddTail((struct List *)&nb->RequestList,(struct Node *)ni);
        if(ni->ni_Header->nh_Realms)
a381 1
            ni->ni_Header->nh_Type = NHType_Transit;
d385 1
a385 1
        UDP_Output((UBYTE *)ni->ni_Header,ni->ni_HeaderLength,0,destIP,0,1);
d404 2
a405 2
    struct NameHeader *nh,*nh_new;
    struct NameInfo *ni;
d410 1
d412 1
a412 2
    ULONG len;
    BOOL match = FALSE;
a414 1
//    dbprint("Received a name packet.");
d419 1
a419 1
    nh = (struct NameHeader *) ((ULONG) udp + (ULONG) sizeof(struct udphdr));
d421 1
a421 1
    if(nh->nh_Type == NHType_Transit)
d424 3
a426 6
        if(IsListEmpty((struct List *)&gb->RealmList))
        {
            nh->nh_Type = NHType_Error;
            UDP_Output((UBYTE *)nh,sizeof(struct NameHeader),0,ip->iph_SrcAddr,0,1);
        }
        else
d428 1
a428 2
            realm = (struct Realm *) gb->RealmList.mlh_Head;
            str = (STRPTR) nh + sizeof(struct NameHeader);
d435 2
a436 2
                        nh->nh_Type = NHType_Query;
                        UDP_Output((UBYTE *)nh,nh->nh_Length,ip->iph_SrcAddr,realm->realm_Broadcast,0,1);
d440 2
a441 2
                        nh->nh_Type = NHType_Transit;
                        UDP_Output((UBYTE *)nh,nh->nh_Length,ip->iph_SrcAddr,realm->realm_Server,0,1);
d450 1
a450 1
    else if(nh->nh_Type == NHType_Query)
d452 37
a488 34
        switch(nh->nh_Class)
        {
            case NHClass_Numbers:   if(nh->nh_Realms || gb->RealmServer)
                                    {
                                        str = (STRPTR) nh + sizeof(struct NameHeader);
                                        if(!gb->RealmServer)
                                            break;
                                        if(Stricmp(str,(STRPTR)&nb->RealmName))
                                            break;
                                    }
            			    str = (STRPTR) nh + sizeof(struct NameHeader) + nh->nh_Realms;
//            			    dbprint("Looking for host:");
//            			    dbprint(str);
                                    if(!Stricmp(nb->LocalHostName,str))
                                    {
//                                        dbprint("Match!");
                                        if(route = Route(ip->iph_SrcAddr, TRUE))
                                        {
//                                            dbprint("Sending response.");
                                            nh->nh_Reserved0 = route->nr_Device->sanadev_IPAddress;
                                            nh->nh_Type = NHType_Response;
                                            UDP_Output((UBYTE *)nh,nh->nh_Length,0,ip->iph_SrcAddr,0,1);
                                        }
                                    }
                                    break;

            case NHClass_Hosts:     if(nh->nh_Realms)
                                    {
                                        str = (STRPTR) nh + sizeof(struct NameHeader);
                                        if(!gb->RealmServer)
                                            break;
                                        if(Stricmp(str,(STRPTR)&nb->RealmName))
                                            break;
                                    }
d490 7
a496 1
                                    if(nh->nh_Hosts)
d499 24
a522 4
                                    if(nh->nh_Services)
                                    {
                                        str = (STRPTR) nh + sizeof(struct NameHeader) + nh->nh_Realms;
                                        Forbid();
d528 1
d533 1
a533 1
                                                if(!Stricmp((STRPTR)&svc->svc_SvcName,str))
d546 1
a546 21
                                    }
                                    else if(nh->nh_Entities)
                                    {
                                        match = FALSE;
                                        str = (STRPTR) nh + sizeof(struct NameHeader) + nh->nh_Realms;
                                        ObtainSemaphore(&nb->ANMPELSemaphore);
                                        if(FindName((struct List *)&nb->ANMPEntityList,str))
                                            match = TRUE;
                                        ReleaseSemaphore(&nb->ANMPELSemaphore);
                                    }
                                    else
                                        match = TRUE;

                                    if(match)
                                    {
                                      /*  if(nb->RealmServer)
                                            len = strlen(nb->RealmName) + 1;
                                        else */
                                            len = 0;
                                        len = len + strlen(nb->LocalHostName) + 1;
                                        if(nh_new = AllocMem((sizeof(struct NameHeader) + len),MEMF_CLEAR|MEMF_PUBLIC))
d548 3
a550 16
                                            str = (STRPTR) nh_new + sizeof(struct NameHeader);
                                         /*   if(nb->RealmServer)
                                            {
                                                strcpy(str,nb->RealmName);
                                                str+= strlen(nb->RealmName);
                                                *str=':';
                                                str++;
                                            } */
                                            strcpy(str,nb->LocalHostName);
                                            SendResponse(nh,nh_new,sizeof(struct NameHeader) + len,ip->iph_SrcAddr,dev->sanadev_IPAddress);
                                        }
                                    }
                                    break;

            case NHClass_Services:
                                    if(InvalidRequest(nh))
d553 6
a558 15
                                    Forbid();
                                    if(nb->nb_ServicesBase)
                                        ServicesBase = (struct ServicesLib *)OpenLibrary("services.library",0L);
                                    Permit();
                                    if(ServicesBase)
                                    {
                                        ObtainSemaphore(&ServicesBase->SVCS_ServicesLock);
                                        svc = (struct Service *)ServicesBase->SVCS_Services.mlh_Head;
                                        len = 0;
                                        while(svc->svc_Node.ln_Succ)
                                        {
                                            len = len + strlen((STRPTR)&svc->svc_SvcName) +1;
                                            svc = (struct Service *)svc->svc_Node.ln_Succ;
                                        }
                                        if(nh_new = AllocMem((sizeof(struct NameHeader) + len),MEMF_CLEAR|MEMF_PUBLIC))
d560 1
a560 1
                                            str = (STRPTR) nh_new + sizeof(struct NameHeader);
d564 2
a565 6
                                                if(!(svc->svc_Flags & SVCF_EXPUNGE))
                                                {
                                                    strcpy(str,(STRPTR)&svc->svc_SvcName);
                                                    str+=(1 + strlen((STRPTR)&svc->svc_SvcName));
                                                    nh_new->nh_Services++;
                                                }
d568 2
d571 9
a579 17
                                        ReleaseSemaphore(&ServicesBase->SVCS_ServicesLock);
                                        if(nh_new->nh_Services)
                                        {
                                            SendResponse(nh,nh_new,(ULONG)(str - (STRPTR)nh_new),ip->iph_SrcAddr,dev->sanadev_IPAddress);
                                        }
                                        CloseLibrary((struct Library *)ServicesBase);
                                    }
                                    else
                                    {
                                        if(nh_new = AllocMem((sizeof(struct NameHeader)),MEMF_CLEAR|MEMF_PUBLIC))
                                        {
                                            SendResponse(nh,nh_new,sizeof(struct NameHeader),ip->iph_SrcAddr,dev->sanadev_IPAddress);
                                        }
                                    }
                                    break;
            case NHClass_Entities:
                                    if(InvalidRequest(nh))
d582 1
a582 12
                                    ObtainSemaphore(&nb->ANMPELSemaphore);
                                    node = (struct Node *)gb->ANMPEntityList.mlh_Head;
                                    len = 0;
                                    while(node->ln_Succ)
                                    {
                                        if(((struct Entity *)node)->entity_Flags & ENTF_PUBLIC)
                                            len = len + strlen(node->ln_Name) + 1;
                                        node = node->ln_Succ;
                                    }
                                    if(nh_new = AllocMem((sizeof(struct NameHeader) + len),MEMF_CLEAR|MEMF_PUBLIC))
                                    {
                                        str = (STRPTR) nh_new + sizeof(struct NameHeader);
d588 2
a589 3
                                                strcpy(str,node->ln_Name);
                                                str+=(1 + strlen(node->ln_Name));
                                                nh_new->nh_Entities++;
d593 58
a650 7
                                    }
                                    ReleaseSemaphore(&nb->ANMPELSemaphore);
                                    if(nh_new)
                                    {
                                        SendResponse(nh,nh_new,(ULONG)(str - (STRPTR)nh_new),ip->iph_SrcAddr,dev->sanadev_IPAddress);
                                    }
                                    break;
d652 17
a668 12
            case NHClass_Realms:    if(!IsListEmpty((struct List *)&gb->RealmList))
                                    {
                                        realm_ptr = (struct Realm *)gb->RealmList.mlh_Head;
                                        len = 0;
                                        while(realm_ptr->realm_Node.mln_Succ)
                                        {
                                            len = len + strlen((STRPTR)&realm_ptr->realm_Name) + 1;
                                            realm_ptr = (struct Realm *)realm_ptr->realm_Node.mln_Succ;
                                        }
                                        if(nh_new = AllocMem((sizeof(struct NameHeader) + len),MEMF_CLEAR|MEMF_PUBLIC))
                                        {
                                            ObtainSemaphore(&nb->RealmListLock);
d670 25
a694 13
                                            realm_ptr = (struct Realm *)gb->RealmList.mlh_Head;
                                            str = (STRPTR) nh_new + sizeof(struct NameHeader);
                                            while(realm_ptr->realm_Node.mln_Succ)
                                            {
                                                strcpy(str,(STRPTR)&realm_ptr->realm_Name);
                                                str+=(1 + strlen(realm_ptr->realm_Name));
                                                nh_new->nh_Realms++;
                                                realm_ptr = (struct Realm *)realm_ptr->realm_Node.mln_Succ;
                                            }
                                            ReleaseSemaphore(&nb->RealmListLock);
                                            SendResponse(nh,nh_new,(ULONG)(str - (STRPTR)nh_new),ip->iph_SrcAddr,dev->sanadev_IPAddress);
                                        }
                                    }
d696 12
a707 6
        }
    }
    else if((nh->nh_Type == NHType_Response) || (nh->nh_Type == NHType_Error))
    {
        ni = (struct NameInfo *) gb->RequestList.mlh_Head;
        while(ni->ni_Msg.mn_Node.ln_Succ)
d709 3
a711 1
            if(ni->ni_ID == nh->nh_ID)
d713 17
a729 11
                if(nh->nh_Type == NHType_Response)
                {
                    CallHookPkt(ni->ni_Hook,nh,NULL);
                    if((nh->nh_Class == NHClass_Numbers) || (nh->nh_Class == NHClass_Entities) || (nh->nh_Class == NHClass_Services))
                    {
                        Remove((struct Node *)ni);
                        ReplyMsg((struct Message *)ni);
                    }
                    break;
                }
                else if(nh->nh_Type == NHType_Error)
d731 4
a734 3
                    Remove((struct Node *)ni);
                    ni->ni_Error = 1;
                    ReplyMsg((struct Message *)ni);
d736 1
d738 1
a738 1
            ni = (struct NameInfo *)ni->ni_Msg.mn_Node.ln_Succ;
a744 40
BOOL InvalidRequest(struct NameHeader *nh)
{
    register struct NBase *nb = gb;
    STRPTR str;

    if(nh->nh_Realms)
    {
        str = (STRPTR) nh + sizeof(struct NameHeader);
        if(!gb->RealmServer)
            return TRUE;
        if(Stricmp(str,(STRPTR)&nb->RealmName))
            return TRUE;
    }
    if(!nh->nh_Hosts)
    {
        return TRUE;
    }
    str = (STRPTR) nh + sizeof(struct NameHeader) + nh->nh_Realms;
    if(Stricmp(str,nb->LocalHostName))
    {
        return TRUE;
    }
    if(nh->nh_Services || nh->nh_Entities)
    {
        return TRUE;
    }
    return FALSE;
}

void SendResponse(struct NameHeader *nh_req, struct NameHeader *nh_resp, ULONG len, ULONG DestIP, ULONG SrcIP)
{
    nh_resp->nh_Reserved0 = SrcIP;
    nh_resp->nh_ID = nh_req->nh_ID;
    nh_resp->nh_Class = nh_req->nh_Class;
    nh_resp->nh_Type = NHType_Response;
    nh_resp->nh_Length = len;
    UDP_Output((UBYTE *)nh_resp,len,0,DestIP,0,1);
    FreeMem(nh_resp,len);
}

d747 1
a747 1
    struct NameInfo *ni;
d770 2
a771 2
    ni = (struct NameInfo *) gb->RequestList.mlh_Head;
    while(ni->ni_Msg.mn_Node.ln_Succ)
d773 8
a780 6
        next = (struct NameInfo *) ni->ni_Msg.mn_Node.ln_Succ;
        ni->ni_TTL -= 1;
        if(!ni->ni_TTL)
        {
            Remove((struct Node *)ni);
            ReplyMsg((struct Message *)ni);
d782 1
a782 1
        ni = next;
@


1.23
log
@Code cleanup and space saving.
@
text
@d7 1
a7 1
** $Id: resolver.c,v 1.22 92/06/04 21:00:13 kcd Exp Locker: kcd $
d85 2
d434 1
d478 11
a488 1
            case NHClass_Numbers:   str = (STRPTR) nh + sizeof(struct NameHeader) + nh->nh_Realms;
d491 1
d494 1
@


1.22
log
@Now ignores non-public entities.
@
text
@d7 1
a7 1
** $Id: resolver.c,v 1.21 92/06/04 19:48:45 kcd Exp Locker: kcd $
d184 2
d187 9
a195 2
/* ClearNames((struct NameInfo *)gb->ResponseCache.mlh_Head); */
    ClearNames((struct NameInfo *)gb->RequestList.mlh_Head);
a215 16
void ClearNames(ni)
struct NameInfo *ni;
{
    struct NameInfo *ni_tmp;
    struct NameHeader *nh;

    while(ni->ni_Msg.mn_Node.ln_Succ)
    {
        ni_tmp = (struct NameInfo *) ni->ni_Msg.mn_Node.ln_Succ;
        nh = ni->ni_Header;
        FreeMem(nh,nh->nh_Length);
        FreeMem(ni, sizeof(struct NameInfo));
        ni = ni_tmp;
    }
}

d217 1
d232 1
a232 4
    if(*hostname == 0)
        return 0L;

    if(strlen(hostname) > 128)
d270 1
a270 1
    rn_hook.h_Entry = RNHookFunc;
d353 1
a353 1
                ni->ni_TTL = maxTime;
d406 1
a406 2


d408 2
a410 3

/*------------------------------------------------------------------------*/

d540 1
a540 1
                                        if(nb->RealmServer)
d542 1
a542 1
                                        else
d548 1
a548 1
                                            if(nb->RealmServer)
d554 1
a554 1
                                            }
d556 1
a556 8

                                            nh_new->nh_Type = NHType_Response;
                                            nh_new->nh_Reserved0 = dev->sanadev_IPAddress;
                                            nh_new->nh_Class = NHClass_Hosts;
                                            nh_new->nh_ID = nh->nh_ID;
                                            nh_new->nh_Length = sizeof(struct NameHeader) + len;
                                            UDP_Output((UBYTE *)nh_new,nh_new->nh_Length,0,ip->iph_SrcAddr,0,1);
                                            FreeMem(nh_new,nh_new->nh_Length);
d562 1
a562 10
                                    if(nh->nh_Realms)
                                    {
                                        str = (STRPTR) nh + sizeof(struct NameHeader);
                                        if(!gb->RealmServer)
                                            break;
                                        if(Stricmp(str,(STRPTR)&nb->RealmName))
                                            break;
                                    }
                                    if(!nh->nh_Hosts)
                                    {
d564 1
a564 10
                                    }
                                    str = (STRPTR) nh + sizeof(struct NameHeader) + nh->nh_Realms;
                                    if(Stricmp(str,nb->LocalHostName))
                                    {
                                        break;
                                    }
                                    if(nh->nh_Services || nh->nh_Entities)
                                    {
                                        break;
                                    }
d597 1
a597 6
                                            nh_new->nh_ID = nh->nh_ID;
                                            nh_new->nh_Class = nh->nh_Class;
                                            nh_new->nh_Type = NHType_Response;
                                            nh_new->nh_Length = (UWORD)(str - (STRPTR)nh_new);
                                            UDP_Output((UBYTE *)nh_new,nh_new->nh_Length,0,ip->iph_SrcAddr,0,1);
                                            FreeMem(nh_new,nh_new->nh_Length);
d605 1
a605 6
                                            nh_new->nh_ID = nh->nh_ID;
                                            nh_new->nh_Class = nh->nh_Class;
                                            nh_new->nh_Type = NHType_Response;
                                            nh_new->nh_Length = sizeof(struct NameHeader);
                                            UDP_Output((UBYTE *)nh_new,nh_new->nh_Length,0,ip->iph_SrcAddr,0,1);
                                            FreeMem(nh_new,nh_new->nh_Length);
d610 1
a610 10
                                    if(nh->nh_Realms)
                                    {
                                        str = (STRPTR) nh + sizeof(struct NameHeader);
                                        if(!gb->RealmServer)
                                            break;
                                        if(Stricmp(str,(STRPTR)&nb->RealmName))
                                            break;
                                    }
                                    if(!nh->nh_Hosts)
                                    {
d612 1
a612 10
                                    }
                                    str = (STRPTR) nh + sizeof(struct NameHeader) + nh->nh_Realms;
                                    if(Stricmp(str,nb->LocalHostName))
                                    {
                                        break;
                                    }
                                    if(nh->nh_Services || nh->nh_Entities)
                                    {
                                        break;
                                    }
d640 1
a640 6
                                        nh_new->nh_ID = nh->nh_ID;
                                        nh_new->nh_Class = nh->nh_Class;
                                        nh_new->nh_Type = NHType_Response;
                                        nh_new->nh_Length = (UWORD)(str - (STRPTR)nh_new);
                                        UDP_Output((UBYTE *)nh_new,nh_new->nh_Length,0,ip->iph_SrcAddr,0,1);
                                        FreeMem(nh_new,nh_new->nh_Length);
d643 1
d667 1
a667 6
                                            nh_new->nh_ID = nh->nh_ID;
                                            nh_new->nh_Class = nh->nh_Class;
                                            nh_new->nh_Type = NHType_Response;
                                            nh_new->nh_Length = (UWORD)(str - (STRPTR)nh_new);
                                            UDP_Output((UBYTE *)nh_new,nh_new->nh_Length,0,ip->iph_SrcAddr,0,1);
                                            FreeMem(nh_new,nh_new->nh_Length);
a701 1

d704 1
a704 1
void ResolverTimeout()
d707 36
d744 2
d752 1
a752 1
        if(!gb->RIPTimer)
d754 1
a754 1
            gb->RIPTimer = 300;
a780 17

    ObtainSemaphore(&nb->ResponseCacheLock);

    ni = (struct NameInfo *) gb->ResponseCache.mlh_Head;
    while(ni->ni_Msg.mn_Node.ln_Succ)
    {
        next = (struct SimpleNameInfo *) ni->ni_Msg.mn_Node.ln_Succ;
        ni->ni_TTL -= 1;
        if(!ni->ni_TTL)
        {
            Remove((struct Node *)ni);
            FreeMem(ni->ni_Header,ni->ni_Header->nh_Length);
            FreeMem(ni,sizeof(struct NameInfo));
        }
        ni = next;
    }
    ReleaseSemaphore(&nb->ResponseCacheLock);
@


1.21
log
@Updated services.library library base structure.
@
text
@d7 1
a7 1
** $Id: resolver.c,v 1.20 92/05/28 17:17:24 kcd Exp Locker: kcd $
d682 2
a683 1
                                        len = len + strlen(node->ln_Name) + 1;
d692 6
a697 3
                                            strcpy(str,node->ln_Name);
                                            str+=(1 + strlen(node->ln_Name));
                                            nh_new->nh_Entities++;
@


1.20
log
@*** empty log message ***
@
text
@d7 1
a7 1
** $Id: resolver.c,v 1.19 92/05/08 14:32:19 kcd Exp Locker: kcd $
a46 1
    ULONG                    SVCS_Unique;
a47 1
    APTR                     SVCS_DosBase;
a54 2
    struct SignalSemaphore   SVCS_StartedLock;
    struct MinList           SVCS_Started;
a60 1
    struct MinList  svc_List;                   /* List of servers providing this service */
d63 2
a64 4
    ULONG           svc_Flags;                  /* Flags. See below */
    ULONG           svc_Stack;                  /* Stack required by server process */
    UBYTE           svc_Pri;                    /* Priority of server process */
    UBYTE           svc_Type;                   /* Server Type */
d403 1
a411 1
        AddTail((struct List *)&nb->RequestList,(struct Node *)ni);
@


1.19
log
@Oops! 1.18 was the wrong file!
@
text
@d7 1
a7 1
** $Id: resolver.c,v 1.17 92/05/05 17:34:03 kcd Exp Locker: kcd $
a254 1

d350 5
d438 1
d443 1
a443 1
    struct ServicesLib *ServicesBase;
a465 1
            nh->nh_Type = NHType_Query;
d474 1
d479 1
d496 6
a501 3
                                        nh->nh_Reserved0 = dev->sanadev_IPAddress;
                                        nh->nh_Type = NHType_Response;
                                        UDP_Output((UBYTE *)nh,nh->nh_Length,0,ip->iph_SrcAddr,0,1);
d634 1
a634 1
                                                    svc = (struct Service *)svc->svc_Node.ln_Succ;
d721 1
a721 1
                                            len = len + strlen((STRPTR)&realm_ptr->realm_Name);
@


1.18
log
@Fixed a bug in setting the broadcast addresses for Realms.
@
text
@d7 1
a7 1
** $Id: resolver.c,v 1.10 92/04/07 16:35:13 kcd Exp Locker: kcd $
d20 1
d25 1
d33 9
a41 9
	ULONG	nh_Reserved0;
	UWORD	nh_ID;
	UBYTE	nh_Type;
	UBYTE	nh_Class;
	UWORD	nh_Length;
	UBYTE	nh_RealmLength;
	UBYTE	nh_HostLength;
	UBYTE	nh_ServiceLength;
	UBYTE	nh_EntityLength;
a43 42
struct NameInfo
{
	struct Message			 ni_Msg;
	UWORD					 ni_ID;
	UWORD					 ni_TTL;
	UWORD					 ni_Error;
	UWORD					 ni_HeaderLength;
	struct Hook				*ni_Hook;
	struct NameHeader	*ni_Header;
};

struct NameCache
{
	struct MinNode  nc_Node;
	ULONG			nc_IPNum;
	UBYTE			nc_HostName[64];
};

struct Realm
{
	struct MinNode	realm_Node;
	ULONG			realm_Server;
	ULONG			realm_Flags;
	ULONG			realm_NetworkIP;
	ULONG			realm_SubnetMask;
	ULONG			realm_Broadcast;
	UBYTE			realm_Name[64];
};

struct RIPHeader
{
	UBYTE	rip_Command;
	UBYTE	rip_Version;
	UWORD	rip_Unused0;
	UWORD	rip_AddFam;
	UWORD	rip_Unused1;
	ULONG	rip_DestIP;
	ULONG	rip_Unused2;
	ULONG	rip_Unused3;
	ULONG	rip_Metric;
};

d47 1
a47 1
    ULONG		     SVCS_Unique;
d78 4
a81 4
#define NHType_Query		1			/* A query about a single host. */
#define NHType_Response		2			/* A Realm-wide query. */
#define NHType_Transit		3			/* A query in transit to a realm server. */
#define NHType_Error		255
d85 1
a85 1
#define NHClass_Numbers		255			/* Realm:[Hostname]   -> Address(es) */
d87 4
a90 4
#define NHClass_Hosts		1			/* [Realm] & (Service|Entity) -> Hosts */
#define NHClass_Services	2			/* [Realm]:Hostname -> Services */
#define NHClass_Entities	3			/* [Realm]:Hostname -> Entities */
#define NHClass_Realms		4			/* If(RealmServer) -> Realms */
d117 1
a117 1
void InitResolver()
d119 12
a130 5
    gb->ResID = 1;
    InitSemaphore(&gb->ResponseCacheLock);
    InitSemaphore(&gb->RequestLock);
    InitSemaphore(&gb->DNSNamesLock);
    InitSemaphore(&gb->RealmListLock);
d137 5
a141 4
    gb->NameRequestPort = OpenUDPPort(1,&ResolverInput);
    gb->ResolverPort = CreateMsgPort();
    gb->resolversigmask = (1 << gb->ResolverPort->mp_SigBit);
	gb->RIPTimer = 0;
d143 40
a182 4
/*    gb->DNSPort = DNSInit(0x87070A01); */

/*    if(gb->DNSPort)
        gb->resolversigmask |= (1<< gb->DNSPort->mp_SigBit); */
d189 2
a190 1
    struct NetResolveName *nrn,*n2;
d193 1
a193 1
	ClearNames((struct NameInfo *)gb->RequestList.mlh_Head);
d195 1
a195 2
    nrn = (struct NetResolveName *) gb->DNSNames.mlh_Head;
    while(nrn->nrn_Msg.mn_Node.ln_Succ)
d197 3
a199 3
        n2 = (struct NetResolveName *) nrn->nrn_Msg.mn_Node.ln_Succ;
        FreeMem(nrn, sizeof(struct NetResolveName));
        nrn = n2;
a201 3
    if(gb->DNSPort)
        DNSDeinit();

d203 1
a203 1
        CloseUDPPort(gb->NameRequestPort);
d206 1
a206 1
        DeleteMsgPort(gb->ResolverPort);
d208 3
d217 2
a218 2
	struct NameInfo *ni_tmp;
	struct NameHeader *nh;
d220 1
a220 1
	while(ni->ni_Msg.mn_Node.ln_Succ)
d235 1
a235 1
    struct NetResolveName *nrn;
d243 1
a243 1
    	return 0L;
d246 2
a247 1
    	return 0L;
d249 1
a249 1
    	return 0L;
d251 1
a251 1
    if (ipnum = lookuphost(hostname))
d253 16
a268 24
    	return ipnum;
    }

	strncpy(nbuff,hostname,128);

	search_ptr = nbuff;
	host_ptr = realm_ptr = NULL;

	while(*search_ptr)
	{
		switch(*search_ptr)
		{
			case ':'	: *search_ptr = 0;
						  host_ptr = search_ptr + 1;
						  realm_ptr = nbuff;
						  break;

			case 0		: break;

			default		: search_ptr++;
		}
	}
	if(!host_ptr)
		host_ptr = nbuff;
d270 8
d279 1
a279 1
		return 0;
d282 2
a283 4
		if(*realm_ptr == 0)
			realm_ptr = NULL;

	ipnum = 0;
d285 1
a285 22
    ObtainSemaphore(&gb->DNSNamesLock);

    nrn = (struct NetResolveName *) gb->DNSNames.mlh_Head;

    while(nrn->nrn_Msg.mn_Node.ln_Succ)
    {
        if(!Stricmp(nrn->nrn_CName,hostname))
        {
            ipnum = nrn->nrn_IP;
            break;
        }
        nrn = (struct NetResolveName *) nrn->nrn_Msg.mn_Node.ln_Succ;
    }
    ReleaseSemaphore(&gb->DNSNamesLock);

	if(ipnum)
		return ipnum;


	rn_hook.h_Entry = RNHookFunc;
	rn_hook.h_SubEntry = NULL;
	rn_hook.h_Data = &ipnum;
d287 3
a289 3
	RNTags[0].ti_Data = (ULONG) realm_ptr;
	RNTags[1].ti_Data = (ULONG) host_ptr;
	NetQueryA(&rn_hook,NHClass_Numbers,50,RNTags);
d291 3
d298 2
a299 2
					  register __a2 struct NameHeader *nh,
					  register __a1 void *nada)
d301 1
a301 1
	*(ULONG *)hook->h_Data = nh->nh_Reserved0;
d304 1
a304 1
/*------------------------------------------------------------------------*/
d307 3
a309 3
					 register __d0 ULONG queryClass,
					 register __d1 ULONG maxTime,
					 register __a1 struct TagItem *tagList)
d311 59
a369 55
	struct NameInfo *ni;
	struct NameHeader *nh;
	struct MsgPort *myport;
	struct TagItem *tag;
	STRPTR Names[4],sp;
	ULONG NTags[4]={NQ_Realm,NQ_Host,NQ_Service,NQ_Entity};
	UBYTE Lengths[4],i;

	if(!(hook && tagList && maxTime && queryClass))
		return;
 	if((queryClass == NHClass_Realms) && !(gb->RealmServer))
 		return;

	for(i=0;i<4;i++)
	{
		Names[i] = NULL;
		Lengths[i]=0;
		if(tag = FindTagItem(NTags[i],tagList))
		{
			if(tag->ti_Data)
			{
				Names[i]=(STRPTR) tag->ti_Data;
				Lengths[i] = strlen(Names[i]);
				if(Lengths[i] > 64)
					return;
				if(Lengths[i])
					Lengths[i]++;
			}
		}
	}

	if((!Names[0]) && gb->RealmServer)
	{
		Names[0] = (STRPTR) &gb->RealmName;
		Lengths[0] = strlen(Names[0]) + 1;
	}
	if(myport = CreateMsgPort())
	{
		if(ni =	(struct	NameInfo *)AllocMem(sizeof(struct NameInfo),MEMF_CLEAR|MEMF_PUBLIC))
		{
			Forbid();
			ni->ni_ID =	gb->ResID++;
			Permit();

        	ni->ni_Msg.mn_ReplyPort = myport;

			ni->ni_HeaderLength = sizeof(struct NameHeader) + (Lengths[0] + Lengths[1] + Lengths[2] + Lengths[3]);
			if(nh = (struct NameHeader *)AllocMem(ni->ni_HeaderLength,MEMF_CLEAR|MEMF_PUBLIC))
			{
				ni->ni_Header = nh;
				ni->ni_TTL = maxTime;
				ni->ni_Hook = hook;
				nh->nh_ID = ni->ni_ID;
				nh->nh_Type = NHType_Query;
				nh->nh_Class = queryClass;
d371 4
a374 4
				nh->nh_RealmLength   = Lengths[0];
				nh->nh_HostLength    = Lengths[1];
				nh->nh_ServiceLength = Lengths[2];
				nh->nh_EntityLength  = Lengths[3];
d376 19
a394 19
				sp = (STRPTR) nh + sizeof(struct NameHeader);

				for(i=0;i<4;i++)
				{
					if(Lengths[i])
					{
						strcpy(sp,Names[i]);
					}
					sp = (STRPTR) sp + Lengths[i];
				}
				PutMsg(gb->ResolverPort,(struct Message *)ni);
				WaitPort(myport);
				GetMsg(gb->ResolverPort);
				FreeMem(ni->ni_Header,ni->ni_HeaderLength);
			}
			FreeMem(ni,sizeof(struct NameInfo));
		}
		DeleteMsgPort(myport);
	}
d400 1
d404 1
a404 1
    while(ni = (struct NameInfo *) GetMsg(gb->ResolverPort))
d406 7
a412 7
    	if(ni->ni_Header->nh_RealmLength)
    	{
    		destIP = gb->RealmServer;
    		ni->ni_Header->nh_Type = NHType_Transit;
    	}
    	else
    		destIP = 0xffffffff;
d414 1
a414 1
        AddTail((struct List *)&gb->RequestList,(struct Node *)ni);
a415 1
    /* DoDNS(); */
d430 1
a441 1
    BOOL local = FALSE;
d443 1
a443 3
    struct NBase *gb2;
    gb2 = (struct NBase *) getreg(REG_A6);
	UtilityBase = (struct Library *)gb->nb_UtilityBase;
d451 317
a767 258
	if(nh->nh_Type == NHType_Transit)
	{
		ObtainSemaphore(&gb->RealmListLock);
		if(IsListEmpty((struct List *)&gb->RealmList))
		{
			nh->nh_Type = NHType_Error;
			UDP_Output((UBYTE *)nh,sizeof(struct NameHeader),0,ip->iph_SrcAddr,0,1);
		}
		else
		{
			realm = (struct Realm *) gb->RealmList.mlh_Head;
			str = (STRPTR) nh + sizeof(struct NameHeader);
			while(realm->realm_Node.mln_Succ)
			{
				if(!Stricmp(str,realm->realm_Name))
				{
					if(realm->realm_Flags & REALM_AUTHORITY)
					{
						UDP_Output((UBYTE *)nh,nh->nh_Length,ip->iph_SrcAddr,realm->realm_Broadcast,0,1);
					}
					else
					{
						UDP_Output((UBYTE *)nh,nh->nh_Length,ip->iph_SrcAddr,realm->realm_Server,0,1);
						break;
					}
				}
				realm = (struct Realm *) realm->realm_Node.mln_Succ;
			}
		}
		ReleaseSemaphore(&gb->RealmListLock);
	}
	else if(nh->nh_Type == NHType_Query)
	{
		switch(nh->nh_Class)
		{
			case NHClass_Numbers:	str = (STRPTR) nh + sizeof(struct NameHeader) + nh->nh_RealmLength;
									if(nh->nh_Reserved0 = lookuphost(str))
									{
										nh->nh_Type = NHType_Response;
										UDP_Output((UBYTE *)nh,nh->nh_Length,0,ip->iph_SrcAddr,0,1);
									}
									break;

			case NHClass_Hosts:		if(nh->nh_RealmLength)
									{
										str = (STRPTR) nh + sizeof(struct NameHeader);
										if(!gb->RealmServer)
											break;
										if(Stricmp(str,(STRPTR)&gb2->RealmName))
											break;
									}

									if(nh->nh_HostLength)
										break;

									if(nh->nh_ServiceLength)
									{
										str = (STRPTR) nh + sizeof(struct NameHeader) + nh->nh_RealmLength;
										Forbid();
										if(ServicesBase = (struct ServicesLib *)FindResident("services.library"))
										{
											ObtainSemaphore(&ServicesBase->SVCS_ServicesLock);
										}
										Permit();
										if(ServicesBase)
										{
											svc = (struct Service *)ServicesBase->SVCS_Services.mlh_Head;
											while(svc->svc_Node.ln_Succ);
											{
												if(!Stricmp((STRPTR)&svc->svc_SvcName,str))
												{
													match = TRUE;
													break;
												}
												svc = (struct Service *)svc->svc_Node.ln_Succ;
											}
											ReleaseSemaphore(&ServicesBase->SVCS_ServicesLock);
										}
									}
									else if(nh->nh_EntityLength)
									{
										match = FALSE;
										str = (STRPTR) nh + sizeof(struct NameHeader) + nh->nh_RealmLength;
										ObtainSemaphore(&gb->ANMPELSemaphore);
										if(FindName((struct List *)&gb->ANMPEntityList,str))
											match = TRUE;
										ReleaseSemaphore(&gb->ANMPELSemaphore);
									}
									else
										match = TRUE;

									if(match)
									{
										nh->nh_Type = NHType_Response;
										nh->nh_Reserved0 = dev->sanadev_IPAddress;
										UDP_Output((UBYTE *)nh,nh->nh_Length,0,ip->iph_SrcAddr,0,1);
									}
									break;

			case NHClass_Services:	if(nh->nh_RealmLength)
									{
										str = (STRPTR) nh + sizeof(struct NameHeader);
										if(!gb->RealmServer)
											break;
										if(Stricmp(str,(STRPTR)&gb2->RealmName))
											break;
									}
									if(!nh->nh_HostLength)
										break;

									if(nh->nh_ServiceLength || nh->nh_EntityLength)
										break;

									Forbid();
									if(ServicesBase = (struct ServicesLib *)FindResident("services.library"))
									{
										ObtainSemaphore(&ServicesBase->SVCS_ServicesLock);
									}
									Permit();
									if(ServicesBase)
									{
										svc = (struct Service *)ServicesBase->SVCS_Services.mlh_Head;
										len = 0;
										while(svc->svc_Node.ln_Succ);
										{
											len = len + strlen((STRPTR)&svc->svc_SvcName) +1;
											svc = (struct Service *)svc->svc_Node.ln_Succ;
										}
										if(nh_new = AllocMem((sizeof(struct NameHeader) + len),MEMF_CLEAR|MEMF_PUBLIC))
										{
											str = (STRPTR) nh_new + sizeof(struct NameHeader);
											svc = (struct Service *)ServicesBase->SVCS_Services.mlh_Head;
											while(svc->svc_Node.ln_Succ);
											{
												if(!(svc->svc_Flags & SVCF_EXPUNGE))
												{
													strcpy(str,(STRPTR)&svc->svc_SvcName);
													str+=(1 + strlen((STRPTR)&svc->svc_SvcName));
													nh_new->nh_ServiceLength++;
												}
													svc = (struct Service *)svc->svc_Node.ln_Succ;
											}
										}
										ReleaseSemaphore(&ServicesBase->SVCS_ServicesLock);
										if(nh_new->nh_ServiceLength)
										{
											nh_new->nh_ID = nh->nh_ID;
											nh_new->nh_Class = nh->nh_Class;
											nh_new->nh_Type = NHType_Response;
											nh_new->nh_Length = (UWORD)(str - (STRPTR)nh_new);
											UDP_Output((UBYTE *)nh_new,nh_new->nh_Length,0,ip->iph_SrcAddr,0,1);
										}
									}
			case NHClass_Entities:	if(nh->nh_RealmLength)
									{
										str = (STRPTR) nh + sizeof(struct NameHeader);
										if(!gb->RealmServer)
											break;
										if(Stricmp(str,(STRPTR)&gb2->RealmName))
											break;
									}
									if(!nh->nh_HostLength)
										break;

									if(nh->nh_ServiceLength || nh->nh_EntityLength)
										break;

									ObtainSemaphore(&gb->ANMPELSemaphore);
									node = (struct Node *)gb->ANMPEntityList.mlh_Head;
									len = 0;
									while(node->ln_Succ);
									{
										len = len + strlen(node->ln_Name) + 1;
										node = node->ln_Succ;
									}
									if(nh_new = AllocMem((sizeof(struct NameHeader) + len),MEMF_CLEAR|MEMF_PUBLIC))
									{
										str = (STRPTR) nh_new + sizeof(struct NameHeader);
										node = (struct Node *)gb->ANMPEntityList.mlh_Head;
										while(node->ln_Succ);
										{
											strcpy(str,node->ln_Name);
											str+=(1 + strlen(node->ln_Name));
											nh_new->nh_EntityLength++;
											node = node->ln_Succ;
										}
									}
									ReleaseSemaphore(&gb->ANMPELSemaphore);
									if(nh_new->nh_ServiceLength)
									{
										nh_new->nh_ID = nh->nh_ID;
										nh_new->nh_Class = nh->nh_Class;
										nh_new->nh_Type = NHType_Response;
										nh_new->nh_Length = (UWORD)(str - (STRPTR)nh_new);
										UDP_Output((UBYTE *)nh_new,nh_new->nh_Length,0,ip->iph_SrcAddr,0,1);
									}
									break;
			case NHClass_Realms:	if(!IsListEmpty((struct List *)&gb->RealmList))
									{
										realm_ptr = (struct Realm *)gb->RealmList.mlh_Head;
										len = 0;
										while(realm_ptr->realm_Node.mln_Succ)
										{
											len = len + strlen((STRPTR)&realm_ptr->realm_Name);
											realm_ptr = (struct Realm *)realm_ptr->realm_Node.mln_Succ;
										}
										if(nh_new = AllocMem((sizeof(struct NameHeader) + len),MEMF_CLEAR|MEMF_PUBLIC))
										{
											ObtainSemaphore(&gb->RealmListLock);

											realm_ptr = (struct Realm *)gb->RealmList.mlh_Head;
											str = (STRPTR) nh_new + sizeof(struct NameHeader);
											while(realm_ptr->realm_Node.mln_Succ)
											{
												strcpy(str,(STRPTR)&realm_ptr->realm_Name);
												str+=(1 + strlen(realm_ptr->realm_Name));
												nh_new->nh_RealmLength++;
												realm_ptr = (struct Realm *)realm_ptr->realm_Node.mln_Succ;
											}
											ReleaseSemaphore(&gb->RealmListLock);
											nh_new->nh_ID = nh->nh_ID;
											nh_new->nh_Class = nh->nh_Class;
											nh_new->nh_Type = NHType_Response;
											nh_new->nh_Length = (UWORD)(str - (STRPTR)nh_new);
											UDP_Output((UBYTE *)nh_new,nh_new->nh_Length,0,ip->iph_SrcAddr,0,1);
										}
									}

		}
	}
	else if((nh->nh_Type == NHType_Response) || (nh->nh_Type == NHType_Error))
	{
		ni = (struct NameInfo *) gb->RequestList.mlh_Head;
		while(ni->ni_Msg.mn_Node.ln_Succ)
		{
			if(ni->ni_ID == nh->nh_ID)
			{
				if(nh->nh_Type == NHType_Response)
				{
					CallHookPkt(ni->ni_Hook,nh,NULL);
					if(nh->nh_Class == NHClass_Numbers)
					{
						Remove((struct Node *)ni);
						ReplyMsg((struct Message *)ni);
					}
					break;
				}
				else if(nh->nh_Type == NHType_Error)
				{
					Remove((struct Node *)ni);
					ni->ni_Error = 1;
					ReplyMsg((struct Message *)ni);
				}
			}
			ni = (struct NameInfo *)ni->ni_Msg.mn_Node.ln_Succ;
		}
	}
	FreeBuffer(buff);
d774 2
a776 1
    struct NetResolveName *nrn;
d779 19
a797 17

	/* HACK ALERT!!!!!! */
	if(!gb->RIPTimer)
	{
		gb->RIPTimer = 300;
		if(rip = (struct RIPHeader *) AllocMem(sizeof(struct RIPHeader),MEMF_CLEAR|MEMF_PUBLIC))
		{
			rip->rip_Command = 2;
			rip->rip_Version = 1;
			rip->rip_AddFam = 2;
			rip->rip_DestIP = 0x87070000;
			rip->rip_Metric = 1;
			UDP_Output((UBYTE *)rip,sizeof(struct RIPHeader),0,0xffffffff,520,520);
			FreeMem(rip,sizeof(struct RIPHeader));
		}
	}
	gb->RIPTimer--;
d812 1
a812 1
    ObtainSemaphore(&gb->ResponseCacheLock);
d827 1
a827 3
    ReleaseSemaphore(&gb->ResponseCacheLock);

    ObtainSemaphore(&gb->DNSNamesLock);
a828 17
    if(gb->DNSPort)
    {
        nrn = (struct NetResolveName *) gb->DNSNames.mlh_Head;
        while(nrn->nrn_Msg.mn_Node.ln_Succ)
        {
            next = (struct NetResolveName *) nrn->nrn_Msg.mn_Node.ln_Succ;
            nrn->nrn_Timer -= 1;
            if(!nrn->nrn_Timer)
            {
                Remove((struct Node *)nrn);
                FreeMem(nrn,sizeof(struct NetResolveName));
            }
            nrn = next;
        }
        DNSTimer();
    }
    ReleaseSemaphore(&gb->DNSNamesLock);
@


1.17
log
@Init now returns a BOOL.
@
text
@d7 1
a7 1
** $Id: resolver.c,v 1.16 92/05/04 11:01:15 kcd Exp Locker: kcd $
a19 1
#include <clib/iffparse_protos.h>
a23 1
#include <pragmas/iffparse_pragmas.h>
d31 9
a39 9
    ULONG   nh_Reserved0;
    UWORD   nh_ID;
    UBYTE   nh_Type;
    UBYTE   nh_Class;
    UWORD   nh_Length;
    UBYTE   nh_Realms;
    UBYTE   nh_Hosts;
    UBYTE   nh_Services;
    UBYTE   nh_Entities;
d42 42
d87 1
a87 1
    ULONG                    SVCS_Unique;
d118 4
a121 4
#define NHType_Query        1           /* A query about a single host. */
#define NHType_Response     2           /* A Realm-wide query. */
#define NHType_Transit      3           /* A query in transit to a realm server. */
#define NHType_Error        255
d125 1
a125 1
#define NHClass_Numbers     255         /* Realm:[Hostname]   -> Address(es) */
d127 4
a130 4
#define NHClass_Hosts       1           /* [Realm] & (Service|Entity) -> Hosts */
#define NHClass_Services    2           /* [Realm]:Hostname -> Services */
#define NHClass_Entities    3           /* [Realm]:Hostname -> Entities */
#define NHClass_Realms      4           /* If(RealmServer) -> Realms */
d157 1
a157 1
BOOL InitResolver()
d159 5
a163 12
    register struct NBase *nb = gb;
    struct NIPCRealmPrefs *nzp;
    struct NIPCIFFHostPrefs *nhp;
    struct NIPCRoute *route;
    struct CollectionItem *ci;
    struct Realm *realm;

    nb->ResID = 1;
    InitSemaphore(&nb->ResponseCacheLock);
    InitSemaphore(&nb->RequestLock);
    InitSemaphore(&nb->DNSResolverLock);
    InitSemaphore(&nb->RealmListLock);
d170 4
a173 5
    nb->NameRequestPort = OpenUDPPort(1,&ResolverInput);
    nb->ResolverPort = CreateMsgPort();
    nb->resolversigmask = (1 << gb->ResolverPort->mp_SigBit);
    nb->RIPTimer = -1;
    nb->DNSHook = NULL;
d175 4
a178 39
    ci = FindCollection(nb->iff,ID_PREF,ID_NLRM);
    while(ci)
    {
        if(realm = AllocMem(sizeof(struct Realm),MEMF_PUBLIC|MEMF_CLEAR))
        {
            nzp = (struct NIPCRealmPrefs *)ci->ci_Data;
            route = Route(nzp->nzp_RealmAddr,TRUE);
            if(route->nr_Device->sanadev_SValid)
                realm->realm_SubnetMask = route->nr_Device->sanadev_SubnetMask;
            else
                realm->realm_SubnetMask = route->nr_Device->sanadev_IPMask;
            realm->realm_NetworkIP = nzp->nzp_RealmAddr;
            realm->realm_Broadcast = nzp->nzp_RealmAddr | ~realm->realm_SubnetMask;
            strcpy(realm->realm_Name,nzp->nzp_RealmName);
            realm->realm_Flags = REALM_AUTHORITY;
            AddTail((struct List *)&nb->RealmList,(struct Node *)realm);
        }
        ci = ci->ci_Next;
    }
    ci = FindCollection(nb->iff,ID_PREF,ID_NRRM);
    while(ci)
    {
        if(realm = AllocMem(sizeof(struct Realm),MEMF_PUBLIC|MEMF_CLEAR))
        {
            nzp = (struct NIPCRealmPrefs *)ci->ci_Data;
            realm->realm_Server = nzp->nzp_RealmAddr;
            strcpy(realm->realm_Name,nzp->nzp_RealmName);
            AddTail((struct List *)&nb->RealmList,(struct Node *)realm);
        }
        ci = ci->ci_Next;
    }
    if(ci = FindCollection(nb->iff,ID_PREF,ID_HOST))
    {
        nhp = (struct NIPCHostPrefs *)ci->ci_Data;
        strcpy(nb->LocalHostName,nhp->nhp_HostName);
        strcpy(nb->RealmName,nhp->nhp_RealmName);
        nb->RealmServer = nhp->nhp_RealmServAddr;
    }
    return(TRUE);
d185 1
a185 2
    register struct NBase *nb = gb;
    struct Node *node;
d188 1
a188 1
    ClearNames((struct NameInfo *)gb->RequestList.mlh_Head);
d190 2
a191 1
    if(gb->DNSHook)
d193 3
a195 3
        CallHookPkt(nb->DNSHook,(void *)-1L,(void *)-1L);
        ObtainSemaphore(&nb->DNSResolverLock);
        ReleaseSemaphore(&nb->DNSResolverLock);
d198 3
d202 1
a202 1
        CloseUDPPort(nb->NameRequestPort);
d205 1
a205 1
        DeleteMsgPort(nb->ResolverPort);
a206 3
    while(node = RemHead((struct List *)&nb->RealmList))
        FreeMem(node,sizeof(struct Realm));

d213 2
a214 2
    struct NameInfo *ni_tmp;
    struct NameHeader *nh;
d216 1
a216 1
    while(ni->ni_Msg.mn_Node.ln_Succ)
d231 1
a231 1
    register struct NBase *nb = gb;
d239 1
a239 1
        return 0L;
d242 1
a242 2
        return 0L;

d244 1
a244 1
        return 0L;
d246 1
a246 1
    if(!Stricmp(hostname,nb->LocalHostName))
d248 24
a271 16
        return ((struct sanadev *)gb->DeviceList.lh_Head)->sanadev_IPAddress;
    }

    strncpy(nbuff,hostname,128);

    search_ptr = nbuff;
    host_ptr = realm_ptr = NULL;

    while(*search_ptr)
    {
        switch(*search_ptr)
        {
            case ':'    : *search_ptr = 0;
                          host_ptr = search_ptr + 1;
                          realm_ptr = nbuff;
                          break;
a272 8
            case 0      : break;

            default     : search_ptr++;
        }
    }
    if(!host_ptr)
        host_ptr = nbuff;

d274 1
a274 1
        return 0;
d277 4
a280 2
        if(*realm_ptr == 0)
            realm_ptr = NULL;
d282 22
a303 1
    ipnum = 0;
d305 3
a307 3
    rn_hook.h_Entry = RNHookFunc;
    rn_hook.h_SubEntry = NULL;
    rn_hook.h_Data = &ipnum;
a308 3
    RNTags[0].ti_Data = (ULONG) realm_ptr;
    RNTags[1].ti_Data = (ULONG) host_ptr;
    NetQueryA(&rn_hook,NHClass_Numbers,50,RNTags);
d313 2
a314 2
                      register __a2 struct NameHeader *nh,
                      register __a1 void *nada)
d316 1
a316 1
    *(ULONG *)hook->h_Data = nh->nh_Reserved0;
d319 1
a319 1
/****************************************************************************/
d322 3
a324 3
                     register __d0 ULONG queryClass,
                     register __d1 ULONG maxTime,
                     register __a1 struct TagItem *tagList)
d326 55
a380 59
    register struct NBase *nb;
    struct NameInfo *ni;
    struct NameHeader *nh;
    struct MsgPort *myport;
    struct TagItem *tag;
    STRPTR Names[4],sp;
    ULONG NTags[4]={NQ_Realm,NQ_Host,NQ_Service,NQ_Entity};
    UBYTE Lengths[4],i;
    nb = gb;
    if(!(hook && tagList && maxTime && queryClass))
    {
        return;
    }
    if((queryClass == NHClass_Realms) && !(gb->RealmServer))
    {
        return;
    }
    for(i=0;i<4;i++)
    {
        Names[i] = NULL;
        Lengths[i]=0;
        if(tag = FindTagItem(NTags[i],tagList))
        {
            if(tag->ti_Data)
            {
                Names[i]=(STRPTR) tag->ti_Data;
                Lengths[i] = strlen(Names[i]);
                if(Lengths[i] > 64)
                    return;
                if(Lengths[i])
                    Lengths[i]++;
            }
        }
    }

    if((!Names[0]) && gb->RealmServer)
    {
        Names[0] = (STRPTR) &gb->RealmName;
        Lengths[0] = strlen(Names[0]) + 1;
    }
    if(myport = CreateMsgPort())
    {
        if(ni = (struct NameInfo *)AllocMem(sizeof(struct NameInfo),MEMF_CLEAR|MEMF_PUBLIC))
        {
            Forbid();
            ni->ni_ID = gb->ResID++;
            Permit();

            ni->ni_Msg.mn_ReplyPort = myport;

            ni->ni_HeaderLength = sizeof(struct NameHeader) + (Lengths[0] + Lengths[1] + Lengths[2] + Lengths[3]);
            if(nh = (struct NameHeader *)AllocMem(ni->ni_HeaderLength,MEMF_CLEAR|MEMF_PUBLIC))
            {
                ni->ni_Header = nh;
                ni->ni_TTL = maxTime;
                ni->ni_Hook = hook;
                nh->nh_ID = ni->ni_ID;
                nh->nh_Type = NHType_Query;
                nh->nh_Class = queryClass;
d382 4
a385 4
                nh->nh_Realms   = Lengths[0];
                nh->nh_Hosts    = Lengths[1];
                nh->nh_Services = Lengths[2];
                nh->nh_Entities  = Lengths[3];
d387 19
a405 19
                sp = (STRPTR) nh + sizeof(struct NameHeader);

                for(i=0;i<4;i++)
                {
                    if(Lengths[i])
                    {
                        strcpy(sp,Names[i]);
                    }
                    sp = (STRPTR) sp + Lengths[i];
                }
                PutMsg(nb->ResolverPort,(struct Message *)ni);
                WaitPort(myport);
                GetMsg(myport);
                FreeMem(ni->ni_Header,ni->ni_HeaderLength);
            }
            FreeMem(ni,sizeof(struct NameInfo));
        }
        DeleteMsgPort(myport);
    }
a410 1
    register struct NBase *nb = gb;
d414 1
a414 1
    while(ni = (struct NameInfo *) GetMsg(nb->ResolverPort))
d416 7
a422 7
        if(ni->ni_Header->nh_Realms)
        {
            destIP = gb->RealmServer;
            ni->ni_Header->nh_Type = NHType_Transit;
        }
        else
            destIP = 0xffffffff;
d424 1
a424 1
        AddTail((struct List *)&nb->RequestList,(struct Node *)ni);
d426 1
a440 1
    register struct NBase *nb = gb;
d452 1
d454 3
a456 1
    UtilityBase = (struct Library *)gb->nb_UtilityBase;
d464 258
a721 317
    if(nh->nh_Type == NHType_Transit)
    {
        ObtainSemaphore(&nb->RealmListLock);
        if(IsListEmpty((struct List *)&gb->RealmList))
        {
            nh->nh_Type = NHType_Error;
            UDP_Output((UBYTE *)nh,sizeof(struct NameHeader),0,ip->iph_SrcAddr,0,1);
        }
        else
        {
            nh->nh_Type = NHType_Query;
            realm = (struct Realm *) gb->RealmList.mlh_Head;
            str = (STRPTR) nh + sizeof(struct NameHeader);
            while(realm->realm_Node.mln_Succ)
            {
                if(!Stricmp(str,realm->realm_Name))
                {
                    if(realm->realm_Flags & REALM_AUTHORITY)
                    {
                        UDP_Output((UBYTE *)nh,nh->nh_Length,ip->iph_SrcAddr,realm->realm_Broadcast,0,1);
                    }
                    else
                    {
                        UDP_Output((UBYTE *)nh,nh->nh_Length,ip->iph_SrcAddr,realm->realm_Server,0,1);
                        break;
                    }
                }
                realm = (struct Realm *) realm->realm_Node.mln_Succ;
            }
        }
        ReleaseSemaphore(&nb->RealmListLock);
    }
    else if(nh->nh_Type == NHType_Query)
    {
        switch(nh->nh_Class)
        {
            case NHClass_Numbers:   str = (STRPTR) nh + sizeof(struct NameHeader) + nh->nh_Realms;
                                    if(!Stricmp(nb->LocalHostName,str))
                                    {
                                        nh->nh_Reserved0 = dev->sanadev_IPAddress;
                                        nh->nh_Type = NHType_Response;
                                        UDP_Output((UBYTE *)nh,nh->nh_Length,0,ip->iph_SrcAddr,0,1);
                                    }
                                    break;

            case NHClass_Hosts:     if(nh->nh_Realms)
                                    {
                                        str = (STRPTR) nh + sizeof(struct NameHeader);
                                        if(!gb->RealmServer)
                                            break;
                                        if(Stricmp(str,(STRPTR)&nb->RealmName))
                                            break;
                                    }

                                    if(nh->nh_Hosts)
                                        break;

                                    if(nh->nh_Services)
                                    {
                                        str = (STRPTR) nh + sizeof(struct NameHeader) + nh->nh_Realms;
                                        Forbid();
                                        if(nb->nb_ServicesBase)
                                            ServicesBase = (struct ServicesLib *)OpenLibrary("services.library",0L);
                                        Permit();
                                        if(ServicesBase)
                                        {
                                            ObtainSemaphore(&ServicesBase->SVCS_ServicesLock);
                                            svc = (struct Service *)ServicesBase->SVCS_Services.mlh_Head;
                                            while(svc->svc_Node.ln_Succ)
                                            {
                                                if(!Stricmp((STRPTR)&svc->svc_SvcName,str))
                                                {
                                                    if(!(svc->svc_Flags & SVCF_EXPUNGE))
                                                    {
                                                        match = TRUE;
                                                        break;
                                                    }
                                                }
                                                svc = (struct Service *)svc->svc_Node.ln_Succ;
                                            }
                                            ReleaseSemaphore(&ServicesBase->SVCS_ServicesLock);
                                            CloseLibrary((struct Library *)ServicesBase);
                                        }
                                    }
                                    else if(nh->nh_Entities)
                                    {
                                        match = FALSE;
                                        str = (STRPTR) nh + sizeof(struct NameHeader) + nh->nh_Realms;
                                        ObtainSemaphore(&nb->ANMPELSemaphore);
                                        if(FindName((struct List *)&nb->ANMPEntityList,str))
                                            match = TRUE;
                                        ReleaseSemaphore(&nb->ANMPELSemaphore);
                                    }
                                    else
                                        match = TRUE;

                                    if(match)
                                    {
                                        if(nb->RealmServer)
                                            len = strlen(nb->RealmName) + 1;
                                        else
                                            len = 0;
                                        len = len + strlen(nb->LocalHostName) + 1;
                                        if(nh_new = AllocMem((sizeof(struct NameHeader) + len),MEMF_CLEAR|MEMF_PUBLIC))
                                        {
                                            str = (STRPTR) nh_new + sizeof(struct NameHeader);
                                            if(nb->RealmServer)
                                            {
                                                strcpy(str,nb->RealmName);
                                                str+= strlen(nb->RealmName);
                                                *str=':';
                                                str++;
                                            }
                                            strcpy(str,nb->LocalHostName);

                                            nh_new->nh_Type = NHType_Response;
                                            nh_new->nh_Reserved0 = dev->sanadev_IPAddress;
                                            nh_new->nh_Class = NHClass_Hosts;
                                            nh_new->nh_ID = nh->nh_ID;
                                            nh_new->nh_Length = sizeof(struct NameHeader) + len;
                                            UDP_Output((UBYTE *)nh_new,nh_new->nh_Length,0,ip->iph_SrcAddr,0,1);
                                            FreeMem(nh_new,nh_new->nh_Length);
                                        }
                                    }
                                    break;

            case NHClass_Services:
                                    if(nh->nh_Realms)
                                    {
                                        str = (STRPTR) nh + sizeof(struct NameHeader);
                                        if(!gb->RealmServer)
                                            break;
                                        if(Stricmp(str,(STRPTR)&nb->RealmName))
                                            break;
                                    }
                                    if(!nh->nh_Hosts)
                                    {
                                        break;
                                    }
                                    str = (STRPTR) nh + sizeof(struct NameHeader) + nh->nh_Realms;
                                    if(Stricmp(str,nb->LocalHostName))
                                    {
                                        break;
                                    }
                                    if(nh->nh_Services || nh->nh_Entities)
                                    {
                                        break;
                                    }
                                    Forbid();
                                    if(nb->nb_ServicesBase)
                                        ServicesBase = (struct ServicesLib *)OpenLibrary("services.library",0L);
                                    Permit();
                                    if(ServicesBase)
                                    {
                                        ObtainSemaphore(&ServicesBase->SVCS_ServicesLock);
                                        svc = (struct Service *)ServicesBase->SVCS_Services.mlh_Head;
                                        len = 0;
                                        while(svc->svc_Node.ln_Succ)
                                        {
                                            len = len + strlen((STRPTR)&svc->svc_SvcName) +1;
                                            svc = (struct Service *)svc->svc_Node.ln_Succ;
                                        }
                                        if(nh_new = AllocMem((sizeof(struct NameHeader) + len),MEMF_CLEAR|MEMF_PUBLIC))
                                        {
                                            str = (STRPTR) nh_new + sizeof(struct NameHeader);
                                            svc = (struct Service *)ServicesBase->SVCS_Services.mlh_Head;
                                            while(svc->svc_Node.ln_Succ)
                                            {
                                                if(!(svc->svc_Flags & SVCF_EXPUNGE))
                                                {
                                                    strcpy(str,(STRPTR)&svc->svc_SvcName);
                                                    str+=(1 + strlen((STRPTR)&svc->svc_SvcName));
                                                    nh_new->nh_Services++;
                                                }
                                                    svc = (struct Service *)svc->svc_Node.ln_Succ;
                                            }
                                        }
                                        ReleaseSemaphore(&ServicesBase->SVCS_ServicesLock);
                                        if(nh_new->nh_Services)
                                        {
                                            nh_new->nh_ID = nh->nh_ID;
                                            nh_new->nh_Class = nh->nh_Class;
                                            nh_new->nh_Type = NHType_Response;
                                            nh_new->nh_Length = (UWORD)(str - (STRPTR)nh_new);
                                            UDP_Output((UBYTE *)nh_new,nh_new->nh_Length,0,ip->iph_SrcAddr,0,1);
                                            FreeMem(nh_new,nh_new->nh_Length);
                                        }
                                        CloseLibrary((struct Library *)ServicesBase);
                                    }
                                    else
                                    {
                                        if(nh_new = AllocMem((sizeof(struct NameHeader)),MEMF_CLEAR|MEMF_PUBLIC))
                                        {
                                            nh_new->nh_ID = nh->nh_ID;
                                            nh_new->nh_Class = nh->nh_Class;
                                            nh_new->nh_Type = NHType_Response;
                                            nh_new->nh_Length = sizeof(struct NameHeader);
                                            UDP_Output((UBYTE *)nh_new,nh_new->nh_Length,0,ip->iph_SrcAddr,0,1);
                                            FreeMem(nh_new,nh_new->nh_Length);
                                        }
                                    }
                                    break;
            case NHClass_Entities:
                                    if(nh->nh_Realms)
                                    {
                                        str = (STRPTR) nh + sizeof(struct NameHeader);
                                        if(!gb->RealmServer)
                                            break;
                                        if(Stricmp(str,(STRPTR)&nb->RealmName))
                                            break;
                                    }
                                    if(!nh->nh_Hosts)
                                    {
                                        break;
                                    }
                                    str = (STRPTR) nh + sizeof(struct NameHeader) + nh->nh_Realms;
                                    if(Stricmp(str,nb->LocalHostName))
                                    {
                                        break;
                                    }
                                    if(nh->nh_Services || nh->nh_Entities)
                                    {
                                        break;
                                    }
                                    ObtainSemaphore(&nb->ANMPELSemaphore);
                                    node = (struct Node *)gb->ANMPEntityList.mlh_Head;
                                    len = 0;
                                    while(node->ln_Succ)
                                    {
                                        len = len + strlen(node->ln_Name) + 1;
                                        node = node->ln_Succ;
                                    }
                                    if(nh_new = AllocMem((sizeof(struct NameHeader) + len),MEMF_CLEAR|MEMF_PUBLIC))
                                    {
                                        str = (STRPTR) nh_new + sizeof(struct NameHeader);
                                        node = (struct Node *)gb->ANMPEntityList.mlh_Head;
                                        while(node->ln_Succ)
                                        {
                                            strcpy(str,node->ln_Name);
                                            str+=(1 + strlen(node->ln_Name));
                                            nh_new->nh_Entities++;
                                            node = node->ln_Succ;
                                        }
                                    }
                                    ReleaseSemaphore(&nb->ANMPELSemaphore);
                                    if(nh_new)
                                    {
                                        nh_new->nh_ID = nh->nh_ID;
                                        nh_new->nh_Class = nh->nh_Class;
                                        nh_new->nh_Type = NHType_Response;
                                        nh_new->nh_Length = (UWORD)(str - (STRPTR)nh_new);
                                        UDP_Output((UBYTE *)nh_new,nh_new->nh_Length,0,ip->iph_SrcAddr,0,1);
                                        FreeMem(nh_new,nh_new->nh_Length);
                                    }
                                    break;
            case NHClass_Realms:    if(!IsListEmpty((struct List *)&gb->RealmList))
                                    {
                                        realm_ptr = (struct Realm *)gb->RealmList.mlh_Head;
                                        len = 0;
                                        while(realm_ptr->realm_Node.mln_Succ)
                                        {
                                            len = len + strlen((STRPTR)&realm_ptr->realm_Name);
                                            realm_ptr = (struct Realm *)realm_ptr->realm_Node.mln_Succ;
                                        }
                                        if(nh_new = AllocMem((sizeof(struct NameHeader) + len),MEMF_CLEAR|MEMF_PUBLIC))
                                        {
                                            ObtainSemaphore(&nb->RealmListLock);

                                            realm_ptr = (struct Realm *)gb->RealmList.mlh_Head;
                                            str = (STRPTR) nh_new + sizeof(struct NameHeader);
                                            while(realm_ptr->realm_Node.mln_Succ)
                                            {
                                                strcpy(str,(STRPTR)&realm_ptr->realm_Name);
                                                str+=(1 + strlen(realm_ptr->realm_Name));
                                                nh_new->nh_Realms++;
                                                realm_ptr = (struct Realm *)realm_ptr->realm_Node.mln_Succ;
                                            }
                                            ReleaseSemaphore(&nb->RealmListLock);
                                            nh_new->nh_ID = nh->nh_ID;
                                            nh_new->nh_Class = nh->nh_Class;
                                            nh_new->nh_Type = NHType_Response;
                                            nh_new->nh_Length = (UWORD)(str - (STRPTR)nh_new);
                                            UDP_Output((UBYTE *)nh_new,nh_new->nh_Length,0,ip->iph_SrcAddr,0,1);
                                            FreeMem(nh_new,nh_new->nh_Length);
                                        }
                                    }

        }
    }
    else if((nh->nh_Type == NHType_Response) || (nh->nh_Type == NHType_Error))
    {
        ni = (struct NameInfo *) gb->RequestList.mlh_Head;
        while(ni->ni_Msg.mn_Node.ln_Succ)
        {
            if(ni->ni_ID == nh->nh_ID)
            {
                if(nh->nh_Type == NHType_Response)
                {
                    CallHookPkt(ni->ni_Hook,nh,NULL);
                    if((nh->nh_Class == NHClass_Numbers) || (nh->nh_Class == NHClass_Entities) || (nh->nh_Class == NHClass_Services))
                    {
                        Remove((struct Node *)ni);
                        ReplyMsg((struct Message *)ni);
                    }
                    break;
                }
                else if(nh->nh_Type == NHType_Error)
                {
                    Remove((struct Node *)ni);
                    ni->ni_Error = 1;
                    ReplyMsg((struct Message *)ni);
                }
            }
            ni = (struct NameInfo *)ni->ni_Msg.mn_Node.ln_Succ;
        }
    }
    FreeBuffer(buff);
a727 2
    register struct NBase *nb = gb;

d729 1
d732 17
a748 19
    if(gb->RIPTimer != -1)
    {
            /* HACK ALERT!!!!!! */
        if(!gb->RIPTimer)
        {
            gb->RIPTimer = 300;
            if(rip = (struct RIPHeader *) AllocMem(sizeof(struct RIPHeader),MEMF_CLEAR|MEMF_PUBLIC))
            {
                rip->rip_Command = 2;
                rip->rip_Version = 1;
                rip->rip_AddFam = 2;
                rip->rip_DestIP = 0x87070000;
                rip->rip_Metric = 1;
                UDP_Output((UBYTE *)rip,sizeof(struct RIPHeader),0,0xffffffff,520,520);
                FreeMem(rip,sizeof(struct RIPHeader));
            }
        }
        gb->RIPTimer--;
    }
d763 1
a763 1
    ObtainSemaphore(&nb->ResponseCacheLock);
d778 3
a780 1
    ReleaseSemaphore(&nb->ResponseCacheLock);
d782 17
@


1.16
log
@Updated to use the new IFF configuration file.  Removed calls to
lookuphost().
@
text
@d7 1
a7 1
** $Id: resolver.c,v 1.15 92/04/27 11:17:25 kcd Exp Locker: kcd $
d117 1
a117 1
void InitResolver()
d181 1
@


1.15
log
@Added NetQueryA Autodoc.
@
text
@d7 1
a7 1
** $Id: resolver.c,v 1.14 92/04/21 15:54:42 kcd Exp Locker: kcd $
d20 1
d25 1
d120 6
d142 39
d188 2
d206 3
a252 4
    if (ipnum = lookuphost(hostname))
    {
        return ipnum;
    }
d302 1
a302 82
/****** nipc.library/NetQueryA ************************************************
*
*   NAME
*       NetQueryA -- Start a nipc network query
*
*   SYNOPSIS
*       NetQueryA(struct Hook *hook, ULONG queryClass, maxTime,
*                      A0                 D0                D1
*
*                 struct TagItem *tagList)
*                 A1
*
*       VOID NetQueryA(struct Hook *hook, ULONG queryClass, ULONG maxTime,
*                      struct TagItem *tagList)
*
*   FUNCTION
*       Starts a nipc network query.  This function can be used to gather
*       data about a single machines, or to gather data for a given network.
*       Only one class of query may be performed at a time.  The classes of
*       queries you can do are:
*
*       NHClass_Hosts    - Query the local network or a given realm for the
*                          names of all hosts matching the data given in the
*                          tagList.  See below.
*       NHClass_Services - Query a single machine for a list of all services
*                          running on that machine.
*       NHClass_Entities - Query a single machine for a list of all public
*                          entities in use on a machine.
*       NHClass_Realms   - If you are in an internetworked situations, this
*                          will return a list of all Realms defined on your
*                          network.
*
*       The Hook is called for each packet returned from the network.
*       Depending on the class of the query, you may get more than one
*       packet.  For the NHClass_Hosts query, you will get one packet for
*       each machine matching your request.  For the other three classes,
*       you will get one packet containing all of the data you are looking
*       for.
*
*       A pointer to the packet is passed in A2 (the "object").  This
*       is the format of the data:
*
*           struct NameHeader
*           {
*               ULONG   nh_Reserved0;   /* Reserved */
*               UWORD   nh_ID;          /* Unique ID of this query */
*               UBYTE   nh_Type;        /* Query type (private) */
*               UBYTE   nh_Class;       /* Query Class */
*               UWORD   nh_Length;      /* Response packet length */
*               UBYTE   nh_Realms;      /* Number of Realms in the answer */
*               UBYTE   nh_Hosts;       /* Number of hosts in the answer */
*               UBYTE   nh_Services;    /* Number of services in the answer */
*               UBYTE   nh_Entities;    /* Number of entities in the answer */
*           };
*
*       The actual answer data is found immediately following the NameHeader.
*       The format is a series of null-terminated strings, the number of which
*       is specified in the fields above.
*
*   INPUTS
*       hook       - Pointer to a Hook structure to be called for each response.
*       queryClass - The Class of the query, one of NHClass_Hosts,
*                    NHClass_Services, NHClass_Entities, NHClass_Realms.
*       maxTime    - The maximum number of seconds allowed for the query.
*       tagList    - Pointer to an array of TagItem structures. See below.
*
*   TAGS
*
*       The Tags defined for NetQueryA() are:
*
*       NQ_Realm (STRPTR) - Optional name of Realm to query.
*       NQ_Host (STRPTR) - Name of the host to query for a Services or Entities
*                          query.
*       NQ_Service (STRPTR) - Optional name of a Service that you want hosts
*                             to try to match.
*       NQ_Entity (STRPTR) - Option name of an Entity that you want hosts to
*                            to try to match.
*
*   RESULT
*       None.
*
*******************************************************************************
d459 1
d589 1
a589 1
                                    if(!lookuphost(str))
d665 1
a665 1
                                    if(!lookuphost(str))
@


1.14
log
@Fixed more name resolver bugs. RIP is now controllable by software.
@
text
@d7 1
a7 1
** $Id: resolver.c,v 1.13 92/04/14 11:25:11 kcd Exp Locker: kcd $
d254 82
a335 1
/*------------------------------------------------------------------------*/
@


1.13
log
@Fixed some NetQueryA bugs. Everything seems to be working OK at this point.
@
text
@d7 1
a7 1
** $Id: resolver.c,v 1.12 92/04/12 16:30:29 kcd Exp Locker: kcd $
d36 4
a39 4
    UBYTE   nh_RealmLength;
    UBYTE   nh_HostLength;
    UBYTE   nh_ServiceLength;
    UBYTE   nh_EntityLength;
a41 42
struct NameInfo
{
    struct Message           ni_Msg;
    UWORD                    ni_ID;
    UWORD                    ni_TTL;
    UWORD                    ni_Error;
    UWORD                    ni_HeaderLength;
    struct Hook             *ni_Hook;
    struct NameHeader   *ni_Header;
};

struct NameCache
{
    struct MinNode  nc_Node;
    ULONG           nc_IPNum;
    UBYTE           nc_HostName[64];
};

struct Realm
{
    struct MinNode  realm_Node;
    ULONG           realm_Server;
    ULONG           realm_Flags;
    ULONG           realm_NetworkIP;
    ULONG           realm_SubnetMask;
    ULONG           realm_Broadcast;
    UBYTE           realm_Name[64];
};

struct RIPHeader
{
    UBYTE   rip_Command;
    UBYTE   rip_Version;
    UWORD   rip_Unused0;
    UWORD   rip_AddFam;
    UWORD   rip_Unused1;
    ULONG   rip_DestIP;
    ULONG   rip_Unused2;
    ULONG   rip_Unused3;
    ULONG   rip_Metric;
};

d45 1
a45 1
    ULONG            SVCS_Unique;
d132 1
a132 1
    nb->RIPTimer = 0;
d181 1
d197 4
d321 4
a324 4
                nh->nh_RealmLength   = Lengths[0];
                nh->nh_HostLength    = Lengths[1];
                nh->nh_ServiceLength = Lengths[2];
                nh->nh_EntityLength  = Lengths[3];
d356 1
a356 1
        if(ni->ni_Header->nh_RealmLength)
d436 1
a436 1
            case NHClass_Numbers:   str = (STRPTR) nh + sizeof(struct NameHeader) + nh->nh_RealmLength;
d439 1
a439 1
                                    	nh->nh_Reserved0 = dev->sanadev_IPAddress;
d445 1
a445 1
            case NHClass_Hosts:     if(nh->nh_RealmLength)
d454 1
a454 1
                                    if(nh->nh_HostLength)
d457 1
a457 1
                                    if(nh->nh_ServiceLength)
d459 1
a459 1
                                        str = (STRPTR) nh + sizeof(struct NameHeader) + nh->nh_RealmLength;
d474 3
a476 3
                                                    	match = TRUE;
	                                                break;
	                                            }
d484 1
a484 1
                                    else if(nh->nh_EntityLength)
d487 1
a487 1
                                        str = (STRPTR) nh + sizeof(struct NameHeader) + nh->nh_RealmLength;
d498 16
a513 16
                                    	if(nb->RealmServer)
                                    	    len = strlen(nb->RealmName) + 1;
                                    	else
                                    	    len = 0;
                                    	len = len + strlen(nb->LocalHostName) + 1;
                                    	if(nh_new = AllocMem((sizeof(struct NameHeader) + len),MEMF_CLEAR|MEMF_PUBLIC))
                                    	{
                                    	    str = (STRPTR) nh_new + sizeof(struct NameHeader);
                                    	    if(nb->RealmServer)
                                    	    {
                                    	    	strcpy(str,nb->RealmName);
                                    	    	str+= strlen(nb->RealmName);
                                    	    	*str=':';
                                    	    	str++;
                                    	    }
                                    	    strcpy(str,nb->LocalHostName);
d515 1
a515 1
	                                    nh_new->nh_Type = NHType_Response;
d527 1
a527 1
            			    if(nh->nh_RealmLength)
d535 1
a535 1
                                    if(!nh->nh_HostLength)
d538 2
a539 2
				    }
                                    str = (STRPTR) nh + sizeof(struct NameHeader) + nh->nh_RealmLength;
d543 2
a544 2
				    }
                                    if(nh->nh_ServiceLength || nh->nh_EntityLength)
d547 1
a547 1
				    }
d550 1
a550 1
                                    	ServicesBase = (struct ServicesLib *)OpenLibrary("services.library",0L);
d554 1
a554 1
                                    	ObtainSemaphore(&ServicesBase->SVCS_ServicesLock);
d559 1
a559 1
                                	    len = len + strlen((STRPTR)&svc->svc_SvcName) +1;
d572 1
a572 1
                                                    nh_new->nh_ServiceLength++;
d578 1
a578 1
                                        if(nh_new->nh_ServiceLength)
d591 2
a592 2
                                    	if(nh_new = AllocMem((sizeof(struct NameHeader)),MEMF_CLEAR|MEMF_PUBLIC))
                                    	{
d603 1
a603 1
            			    if(nh->nh_RealmLength)
d611 1
a611 1
                                    if(!nh->nh_HostLength)
d614 2
a615 2
				    }
                                    str = (STRPTR) nh + sizeof(struct NameHeader) + nh->nh_RealmLength;
d618 3
a620 3
                                    	break;
				    }
                                    if(nh->nh_ServiceLength || nh->nh_EntityLength)
d623 1
a623 1
				    }
d640 1
a640 1
                                            nh_new->nh_EntityLength++;
d674 1
a674 1
                                                nh_new->nh_RealmLength++;
d726 1
a726 1
//    struct RIPHeader *rip;
d728 1
a728 3

    /* HACK ALERT!!!!!! */
/*  if(!gb->RIPTimer)
d730 14
a743 10
        gb->RIPTimer = 300;
        if(rip = (struct RIPHeader *) AllocMem(sizeof(struct RIPHeader),MEMF_CLEAR|MEMF_PUBLIC))
        {
            rip->rip_Command = 2;
            rip->rip_Version = 1;
            rip->rip_AddFam = 2;
            rip->rip_DestIP = 0x87070000;
            rip->rip_Metric = 1;
            UDP_Output((UBYTE *)rip,sizeof(struct RIPHeader),0,0xffffffff,520,520);
            FreeMem(rip,sizeof(struct RIPHeader));
d745 1
d747 1
a747 2
    gb->RIPTimer--;
*/
@


1.12
log
@Commented out RIP stuff.
@
text
@d7 1
a7 1
** $Id: resolver.c,v 1.11 92/04/10 00:40:16 kcd Exp $
d31 9
a39 9
	ULONG	nh_Reserved0;
	UWORD	nh_ID;
	UBYTE	nh_Type;
	UBYTE	nh_Class;
	UWORD	nh_Length;
	UBYTE	nh_RealmLength;
	UBYTE	nh_HostLength;
	UBYTE	nh_ServiceLength;
	UBYTE	nh_EntityLength;
d44 7
a50 7
	struct Message			 ni_Msg;
	UWORD					 ni_ID;
	UWORD					 ni_TTL;
	UWORD					 ni_Error;
	UWORD					 ni_HeaderLength;
	struct Hook				*ni_Hook;
	struct NameHeader	*ni_Header;
d55 3
a57 3
	struct MinNode  nc_Node;
	ULONG			nc_IPNum;
	UBYTE			nc_HostName[64];
d62 7
a68 7
	struct MinNode	realm_Node;
	ULONG			realm_Server;
	ULONG			realm_Flags;
	ULONG			realm_NetworkIP;
	ULONG			realm_SubnetMask;
	ULONG			realm_Broadcast;
	UBYTE			realm_Name[64];
d73 9
a81 9
	UBYTE	rip_Command;
	UBYTE	rip_Version;
	UWORD	rip_Unused0;
	UWORD	rip_AddFam;
	UWORD	rip_Unused1;
	ULONG	rip_DestIP;
	ULONG	rip_Unused2;
	ULONG	rip_Unused3;
	ULONG	rip_Metric;
d87 1
a87 1
    ULONG		     SVCS_Unique;
d118 4
a121 4
#define NHType_Query		1			/* A query about a single host. */
#define NHType_Response		2			/* A Realm-wide query. */
#define NHType_Transit		3			/* A query in transit to a realm server. */
#define NHType_Error		255
d125 1
a125 1
#define NHClass_Numbers		255			/* Realm:[Hostname]   -> Address(es) */
d127 4
a130 4
#define NHClass_Hosts		1			/* [Realm] & (Service|Entity) -> Hosts */
#define NHClass_Services	2			/* [Realm]:Hostname -> Services */
#define NHClass_Entities	3			/* [Realm]:Hostname -> Entities */
#define NHClass_Realms		4			/* If(RealmServer) -> Realms */
d159 1
a159 1
	register struct NBase *nb = gb;
d174 2
a175 2
	nb->RIPTimer = 0;
	nb->DNSHook = NULL;
d182 1
a182 1
	register struct NBase *nb = gb;
d184 1
a184 1
	ClearNames((struct NameInfo *)gb->RequestList.mlh_Head);
d189 2
a190 2
     	ObtainSemaphore(&nb->DNSResolverLock);
     	ReleaseSemaphore(&nb->DNSResolverLock);
d205 2
a206 2
	struct NameInfo *ni_tmp;
	struct NameHeader *nh;
d208 1
a208 1
	while(ni->ni_Msg.mn_Node.ln_Succ)
d230 1
a230 1
    	return 0L;
d233 1
a233 1
    	return 0L;
d236 1
a236 1
    	return 0L;
d240 1
a240 1
    	return ipnum;
d243 1
a243 1
	strncpy(nbuff,hostname,128);
d245 2
a246 19
	search_ptr = nbuff;
	host_ptr = realm_ptr = NULL;

	while(*search_ptr)
	{
		switch(*search_ptr)
		{
			case ':'	: *search_ptr = 0;
						  host_ptr = search_ptr + 1;
						  realm_ptr = nbuff;
						  break;

			case 0		: break;

			default		: search_ptr++;
		}
	}
	if(!host_ptr)
		host_ptr = nbuff;
d248 17
d266 1
a266 1
		return 0;
d269 2
a270 2
		if(*realm_ptr == 0)
			realm_ptr = NULL;
d272 1
a272 1
	ipnum = 0;
d274 3
a276 3
	rn_hook.h_Entry = RNHookFunc;
	rn_hook.h_SubEntry = NULL;
	rn_hook.h_Data = &ipnum;
d278 3
a280 3
	RNTags[0].ti_Data = (ULONG) realm_ptr;
	RNTags[1].ti_Data = (ULONG) host_ptr;
	NetQueryA(&rn_hook,NHClass_Numbers,50,RNTags);
d285 2
a286 2
					  register __a2 struct NameHeader *nh,
					  register __a1 void *nada)
d288 1
a288 1
	*(ULONG *)hook->h_Data = nh->nh_Reserved0;
d294 3
a296 3
					 register __d0 ULONG queryClass,
					 register __d1 ULONG maxTime,
					 register __a1 struct TagItem *tagList)
d298 8
a305 8
	register struct NBase *nb;
	struct NameInfo *ni;
	struct NameHeader *nh;
	struct MsgPort *myport;
	struct TagItem *tag;
	STRPTR Names[4],sp;
	ULONG NTags[4]={NQ_Realm,NQ_Host,NQ_Service,NQ_Entity};
	UBYTE Lengths[4],i;
d307 25
a331 4
	if(!(hook && tagList && maxTime && queryClass))
		return;
 	if((queryClass == NHClass_Realms) && !(gb->RealmServer))
 		return;
d333 24
a356 42
	for(i=0;i<4;i++)
	{
		Names[i] = NULL;
		Lengths[i]=0;
		if(tag = FindTagItem(NTags[i],tagList))
		{
			if(tag->ti_Data)
			{
				Names[i]=(STRPTR) tag->ti_Data;
				Lengths[i] = strlen(Names[i]);
				if(Lengths[i] > 64)
					return;
				if(Lengths[i])
					Lengths[i]++;
			}
		}
	}

	if((!Names[0]) && gb->RealmServer)
	{
		Names[0] = (STRPTR) &gb->RealmName;
		Lengths[0] = strlen(Names[0]) + 1;
	}
	if(myport = CreateMsgPort())
	{
		if(ni =	(struct	NameInfo *)AllocMem(sizeof(struct NameInfo),MEMF_CLEAR|MEMF_PUBLIC))
		{
			Forbid();
			ni->ni_ID =	gb->ResID++;
			Permit();

        	ni->ni_Msg.mn_ReplyPort = myport;

			ni->ni_HeaderLength = sizeof(struct NameHeader) + (Lengths[0] + Lengths[1] + Lengths[2] + Lengths[3]);
			if(nh = (struct NameHeader *)AllocMem(ni->ni_HeaderLength,MEMF_CLEAR|MEMF_PUBLIC))
			{
				ni->ni_Header = nh;
				ni->ni_TTL = maxTime;
				ni->ni_Hook = hook;
				nh->nh_ID = ni->ni_ID;
				nh->nh_Type = NHType_Query;
				nh->nh_Class = queryClass;
d358 4
a361 4
				nh->nh_RealmLength   = Lengths[0];
				nh->nh_HostLength    = Lengths[1];
				nh->nh_ServiceLength = Lengths[2];
				nh->nh_EntityLength  = Lengths[3];
d363 19
a381 19
				sp = (STRPTR) nh + sizeof(struct NameHeader);

				for(i=0;i<4;i++)
				{
					if(Lengths[i])
					{
						strcpy(sp,Names[i]);
					}
					sp = (STRPTR) sp + Lengths[i];
				}
				PutMsg(nb->ResolverPort,(struct Message *)ni);
				WaitPort(myport);
				GetMsg(nb->ResolverPort);
				FreeMem(ni->ni_Header,ni->ni_HeaderLength);
			}
			FreeMem(ni,sizeof(struct NameInfo));
		}
		DeleteMsgPort(myport);
	}
d387 1
a387 1
	register struct NBase *nb = gb;
d393 7
a399 7
    	if(ni->ni_Header->nh_RealmLength)
    	{
    		destIP = gb->RealmServer;
    		ni->ni_Header->nh_Type = NHType_Transit;
    	}
    	else
    		destIP = 0xffffffff;
d417 1
a417 1
	register struct NBase *nb = gb;
d430 1
a430 1
	UtilityBase = (struct Library *)gb->nb_UtilityBase;
d438 316
a753 258
	if(nh->nh_Type == NHType_Transit)
	{
		ObtainSemaphore(&nb->RealmListLock);
		if(IsListEmpty((struct List *)&gb->RealmList))
		{
			nh->nh_Type = NHType_Error;
			UDP_Output((UBYTE *)nh,sizeof(struct NameHeader),0,ip->iph_SrcAddr,0,1);
		}
		else
		{
			realm = (struct Realm *) gb->RealmList.mlh_Head;
			str = (STRPTR) nh + sizeof(struct NameHeader);
			while(realm->realm_Node.mln_Succ)
			{
				if(!Stricmp(str,realm->realm_Name))
				{
					if(realm->realm_Flags & REALM_AUTHORITY)
					{
						UDP_Output((UBYTE *)nh,nh->nh_Length,ip->iph_SrcAddr,realm->realm_Broadcast,0,1);
					}
					else
					{
						UDP_Output((UBYTE *)nh,nh->nh_Length,ip->iph_SrcAddr,realm->realm_Server,0,1);
						break;
					}
				}
				realm = (struct Realm *) realm->realm_Node.mln_Succ;
			}
		}
		ReleaseSemaphore(&nb->RealmListLock);
	}
	else if(nh->nh_Type == NHType_Query)
	{
		switch(nh->nh_Class)
		{
			case NHClass_Numbers:	str = (STRPTR) nh + sizeof(struct NameHeader) + nh->nh_RealmLength;
									if(nh->nh_Reserved0 = lookuphost(str))
									{
										nh->nh_Type = NHType_Response;
										UDP_Output((UBYTE *)nh,nh->nh_Length,0,ip->iph_SrcAddr,0,1);
									}
									break;

			case NHClass_Hosts:		if(nh->nh_RealmLength)
									{
										str = (STRPTR) nh + sizeof(struct NameHeader);
										if(!gb->RealmServer)
											break;
										if(Stricmp(str,(STRPTR)&nb->RealmName))
											break;
									}

									if(nh->nh_HostLength)
										break;

									if(nh->nh_ServiceLength)
									{
										str = (STRPTR) nh + sizeof(struct NameHeader) + nh->nh_RealmLength;
										Forbid();
										if(ServicesBase = (struct ServicesLib *)FindResident("services.library"))
										{
											ObtainSemaphore(&ServicesBase->SVCS_ServicesLock);
										}
										Permit();
										if(ServicesBase)
										{
											svc = (struct Service *)ServicesBase->SVCS_Services.mlh_Head;
											while(svc->svc_Node.ln_Succ)
											{
												if(!Stricmp((STRPTR)&svc->svc_SvcName,str))
												{
													match = TRUE;
													break;
												}
												svc = (struct Service *)svc->svc_Node.ln_Succ;
											}
											ReleaseSemaphore(&ServicesBase->SVCS_ServicesLock);
										}
									}
									else if(nh->nh_EntityLength)
									{
										match = FALSE;
										str = (STRPTR) nh + sizeof(struct NameHeader) + nh->nh_RealmLength;
										ObtainSemaphore(&nb->ANMPELSemaphore);
										if(FindName((struct List *)&nb->ANMPEntityList,str))
											match = TRUE;
										ReleaseSemaphore(&nb->ANMPELSemaphore);
									}
									else
										match = TRUE;

									if(match)
									{
										nh->nh_Type = NHType_Response;
										nh->nh_Reserved0 = dev->sanadev_IPAddress;
										UDP_Output((UBYTE *)nh,nh->nh_Length,0,ip->iph_SrcAddr,0,1);
									}
									break;

			case NHClass_Services:	if(nh->nh_RealmLength)
									{
										str = (STRPTR) nh + sizeof(struct NameHeader);
										if(!gb->RealmServer)
											break;
										if(Stricmp(str,(STRPTR)&nb->RealmName))
											break;
									}
									if(!nh->nh_HostLength)
										break;

									if(nh->nh_ServiceLength || nh->nh_EntityLength)
										break;

									Forbid();
									if(ServicesBase = (struct ServicesLib *)FindResident("services.library"))
									{
										ObtainSemaphore(&ServicesBase->SVCS_ServicesLock);
									}
									Permit();
									if(ServicesBase)
									{
										svc = (struct Service *)ServicesBase->SVCS_Services.mlh_Head;
										len = 0;
										while(svc->svc_Node.ln_Succ)
										{
											len = len + strlen((STRPTR)&svc->svc_SvcName) +1;
											svc = (struct Service *)svc->svc_Node.ln_Succ;
										}
										if(nh_new = AllocMem((sizeof(struct NameHeader) + len),MEMF_CLEAR|MEMF_PUBLIC))
										{
											str = (STRPTR) nh_new + sizeof(struct NameHeader);
											svc = (struct Service *)ServicesBase->SVCS_Services.mlh_Head;
											while(svc->svc_Node.ln_Succ)
											{
												if(!(svc->svc_Flags & SVCF_EXPUNGE))
												{
													strcpy(str,(STRPTR)&svc->svc_SvcName);
													str+=(1 + strlen((STRPTR)&svc->svc_SvcName));
													nh_new->nh_ServiceLength++;
												}
													svc = (struct Service *)svc->svc_Node.ln_Succ;
											}
										}
										ReleaseSemaphore(&ServicesBase->SVCS_ServicesLock);
										if(nh_new->nh_ServiceLength)
										{
											nh_new->nh_ID = nh->nh_ID;
											nh_new->nh_Class = nh->nh_Class;
											nh_new->nh_Type = NHType_Response;
											nh_new->nh_Length = (UWORD)(str - (STRPTR)nh_new);
											UDP_Output((UBYTE *)nh_new,nh_new->nh_Length,0,ip->iph_SrcAddr,0,1);
										}
									}
			case NHClass_Entities:	if(nh->nh_RealmLength)
									{
										str = (STRPTR) nh + sizeof(struct NameHeader);
										if(!gb->RealmServer)
											break;
										if(Stricmp(str,(STRPTR)&nb->RealmName))
											break;
									}
									if(!nh->nh_HostLength)
										break;

									if(nh->nh_ServiceLength || nh->nh_EntityLength)
										break;

									ObtainSemaphore(&nb->ANMPELSemaphore);
									node = (struct Node *)gb->ANMPEntityList.mlh_Head;
									len = 0;
									while(node->ln_Succ)
									{
										len = len + strlen(node->ln_Name) + 1;
										node = node->ln_Succ;
									}
									if(nh_new = AllocMem((sizeof(struct NameHeader) + len),MEMF_CLEAR|MEMF_PUBLIC))
									{
										str = (STRPTR) nh_new + sizeof(struct NameHeader);
										node = (struct Node *)gb->ANMPEntityList.mlh_Head;
										while(node->ln_Succ)
										{
											strcpy(str,node->ln_Name);
											str+=(1 + strlen(node->ln_Name));
											nh_new->nh_EntityLength++;
											node = node->ln_Succ;
										}
									}
									ReleaseSemaphore(&nb->ANMPELSemaphore);
									if(nh_new->nh_ServiceLength)
									{
										nh_new->nh_ID = nh->nh_ID;
										nh_new->nh_Class = nh->nh_Class;
										nh_new->nh_Type = NHType_Response;
										nh_new->nh_Length = (UWORD)(str - (STRPTR)nh_new);
										UDP_Output((UBYTE *)nh_new,nh_new->nh_Length,0,ip->iph_SrcAddr,0,1);
									}
									break;
			case NHClass_Realms:	if(!IsListEmpty((struct List *)&gb->RealmList))
									{
										realm_ptr = (struct Realm *)gb->RealmList.mlh_Head;
										len = 0;
										while(realm_ptr->realm_Node.mln_Succ)
										{
											len = len + strlen((STRPTR)&realm_ptr->realm_Name);
											realm_ptr = (struct Realm *)realm_ptr->realm_Node.mln_Succ;
										}
										if(nh_new = AllocMem((sizeof(struct NameHeader) + len),MEMF_CLEAR|MEMF_PUBLIC))
										{
											ObtainSemaphore(&nb->RealmListLock);

											realm_ptr = (struct Realm *)gb->RealmList.mlh_Head;
											str = (STRPTR) nh_new + sizeof(struct NameHeader);
											while(realm_ptr->realm_Node.mln_Succ)
											{
												strcpy(str,(STRPTR)&realm_ptr->realm_Name);
												str+=(1 + strlen(realm_ptr->realm_Name));
												nh_new->nh_RealmLength++;
												realm_ptr = (struct Realm *)realm_ptr->realm_Node.mln_Succ;
											}
											ReleaseSemaphore(&nb->RealmListLock);
											nh_new->nh_ID = nh->nh_ID;
											nh_new->nh_Class = nh->nh_Class;
											nh_new->nh_Type = NHType_Response;
											nh_new->nh_Length = (UWORD)(str - (STRPTR)nh_new);
											UDP_Output((UBYTE *)nh_new,nh_new->nh_Length,0,ip->iph_SrcAddr,0,1);
										}
									}

		}
	}
	else if((nh->nh_Type == NHType_Response) || (nh->nh_Type == NHType_Error))
	{
		ni = (struct NameInfo *) gb->RequestList.mlh_Head;
		while(ni->ni_Msg.mn_Node.ln_Succ)
		{
			if(ni->ni_ID == nh->nh_ID)
			{
				if(nh->nh_Type == NHType_Response)
				{
					CallHookPkt(ni->ni_Hook,nh,NULL);
					if(nh->nh_Class == NHClass_Numbers)
					{
						Remove((struct Node *)ni);
						ReplyMsg((struct Message *)ni);
					}
					break;
				}
				else if(nh->nh_Type == NHType_Error)
				{
					Remove((struct Node *)ni);
					ni->ni_Error = 1;
					ReplyMsg((struct Message *)ni);
				}
			}
			ni = (struct NameInfo *)ni->ni_Msg.mn_Node.ln_Succ;
		}
	}
	FreeBuffer(buff);
d760 1
a760 1
	register struct NBase *nb = gb;
d766 16
a781 16
	/* HACK ALERT!!!!!! */
/*	if(!gb->RIPTimer)
	{
		gb->RIPTimer = 300;
		if(rip = (struct RIPHeader *) AllocMem(sizeof(struct RIPHeader),MEMF_CLEAR|MEMF_PUBLIC))
		{
			rip->rip_Command = 2;
			rip->rip_Version = 1;
			rip->rip_AddFam = 2;
			rip->rip_DestIP = 0x87070000;
			rip->rip_Metric = 1;
			UDP_Output((UBYTE *)rip,sizeof(struct RIPHeader),0,0xffffffff,520,520);
			FreeMem(rip,sizeof(struct RIPHeader));
		}
	}
	gb->RIPTimer--;
@


1.11
log
@Removed Dependencies on old exec_pragmas.h file.
@
text
@d7 1
a7 1
** $Id: resolver.c,v 1.10 92/04/07 16:35:13 kcd Exp Locker: kcd $
a280 1

d702 1
a702 1
    struct RIPHeader *rip;
d706 1
a706 1
	if(!gb->RIPTimer)
d721 1
a721 1

@


1.10
log
@Check in to see if this fixes Gre's problems.
@
text
@d7 1
a7 1
** $Id: resolver.c,v 1.9 92/04/05 18:17:36 kcd Exp Locker: kcd $
d159 6
a164 5
    gb->ResID = 1;
    InitSemaphore(&gb->ResponseCacheLock);
    InitSemaphore(&gb->RequestLock);
    InitSemaphore(&gb->DNSNamesLock);
    InitSemaphore(&gb->RealmListLock);
d171 5
a175 9
    gb->NameRequestPort = OpenUDPPort(1,&ResolverInput);
    gb->ResolverPort = CreateMsgPort();
    gb->resolversigmask = (1 << gb->ResolverPort->mp_SigBit);
	gb->RIPTimer = 0;

/*    gb->DNSPort = DNSInit(0x87070A01); */

/*    if(gb->DNSPort)
        gb->resolversigmask |= (1<< gb->DNSPort->mp_SigBit); */
d182 1
a182 2
    struct NetResolveName *nrn,*n2;

d186 1
a186 2
    nrn = (struct NetResolveName *) gb->DNSNames.mlh_Head;
    while(nrn->nrn_Msg.mn_Node.ln_Succ)
d188 3
a190 3
        n2 = (struct NetResolveName *) nrn->nrn_Msg.mn_Node.ln_Succ;
        FreeMem(nrn, sizeof(struct NetResolveName));
        nrn = n2;
a192 3
    if(gb->DNSPort)
        DNSDeinit();

d194 1
a194 1
        CloseUDPPort(gb->NameRequestPort);
d197 1
a197 1
        DeleteMsgPort(gb->ResolverPort);
a222 1
    struct NetResolveName *nrn;
d234 1
a273 19
    ObtainSemaphore(&gb->DNSNamesLock);

    nrn = (struct NetResolveName *) gb->DNSNames.mlh_Head;

    while(nrn->nrn_Msg.mn_Node.ln_Succ)
    {
        if(!Stricmp(nrn->nrn_CName,hostname))
        {
            ipnum = nrn->nrn_IP;
            break;
        }
        nrn = (struct NetResolveName *) nrn->nrn_Msg.mn_Node.ln_Succ;
    }
    ReleaseSemaphore(&gb->DNSNamesLock);

	if(ipnum)
		return ipnum;


d299 1
d307 1
a307 1

d371 1
a371 1
				PutMsg(gb->ResolverPort,(struct Message *)ni);
d373 1
a373 1
				GetMsg(gb->ResolverPort);
d385 1
d389 1
a389 1
    while(ni = (struct NameInfo *) GetMsg(gb->ResolverPort))
d399 1
a399 1
        AddTail((struct List *)&gb->RequestList,(struct Node *)ni);
a400 1
    /* DoDNS(); */
d415 1
a426 1
    BOOL local = FALSE;
a427 2
    struct NBase *gb2;
    gb2 = (struct NBase *) getreg(REG_A6);
d438 1
a438 1
		ObtainSemaphore(&gb->RealmListLock);
d465 1
a465 1
		ReleaseSemaphore(&gb->RealmListLock);
d484 1
a484 1
										if(Stricmp(str,(STRPTR)&gb2->RealmName))
d503 1
a503 1
											while(svc->svc_Node.ln_Succ);
d519 2
a520 2
										ObtainSemaphore(&gb->ANMPELSemaphore);
										if(FindName((struct List *)&gb->ANMPEntityList,str))
d522 1
a522 1
										ReleaseSemaphore(&gb->ANMPELSemaphore);
d540 1
a540 1
										if(Stricmp(str,(STRPTR)&gb2->RealmName))
d559 1
a559 1
										while(svc->svc_Node.ln_Succ);
d568 1
a568 1
											while(svc->svc_Node.ln_Succ);
d594 1
a594 1
										if(Stricmp(str,(STRPTR)&gb2->RealmName))
d603 1
a603 1
									ObtainSemaphore(&gb->ANMPELSemaphore);
d606 1
a606 1
									while(node->ln_Succ);
d615 1
a615 1
										while(node->ln_Succ);
d623 1
a623 1
									ReleaseSemaphore(&gb->ANMPELSemaphore);
d644 1
a644 1
											ObtainSemaphore(&gb->RealmListLock);
d655 1
a655 1
											ReleaseSemaphore(&gb->RealmListLock);
d700 2
a702 1
    struct NetResolveName *nrn;
d736 1
a736 1
    ObtainSemaphore(&gb->ResponseCacheLock);
d751 1
a751 1
    ReleaseSemaphore(&gb->ResponseCacheLock);
a752 19
    ObtainSemaphore(&gb->DNSNamesLock);

    if(gb->DNSPort)
    {
        nrn = (struct NetResolveName *) gb->DNSNames.mlh_Head;
        while(nrn->nrn_Msg.mn_Node.ln_Succ)
        {
            next = (struct NetResolveName *) nrn->nrn_Msg.mn_Node.ln_Succ;
            nrn->nrn_Timer -= 1;
            if(!nrn->nrn_Timer)
            {
                Remove((struct Node *)nrn);
                FreeMem(nrn,sizeof(struct NetResolveName));
            }
            nrn = next;
        }
        DNSTimer();
    }
    ReleaseSemaphore(&gb->DNSNamesLock);
@


1.9
log
@Major changes. Implemented my new naming mechanisms. Still under
testing.
@
text
@d7 1
a7 1
** $Id: resolver.c,v 1.8 92/03/27 14:14:12 kcd Exp Locker: kcd $
d247 1
d249 1
d734 1
a734 1
/*	if(!gb->RIPTimer)
d749 1
a749 1
*/
@


1.8
log
@Fixed DNS Nameserver timeout. DNSTimer was never being called.
@
text
@d7 1
a7 1
** $Id: resolver.c,v 1.7 92/03/23 10:24:24 gregm Exp Locker: kcd $
d16 1
a17 1

d27 74
a100 1
/* Structures used by the "simple" name resolver */
d102 11
a112 13
/* We use an exec Node structure, so we can use toys like FindName(),
 * Enqueue(), etc.
 * The ln_Name field will point the the name of the machine, which will
 * normally follow the SimpleNameInfo struct.
 */

struct SimpleNameInfo
{
    struct Message  sni_Msg;
    ULONG           sni_IPNum;
    UWORD           sni_TTL;
    UBYTE           sni_Type;
    UBYTE           sni_ID;
d115 17
a144 6
struct NetCache
{
    ULONG   nc_IP;
    UBYTE   nc_CName[256];
};

d149 4
a152 2
#define SNI_REQ 1
#define SNI_DAT 2
a153 4
extern struct MsgPort * __asm DNSInit(register __d0 ULONG ServerIP);
extern void __asm DNSDeinit(void);
extern void __asm DNSTimer(void);
extern void __asm DoDNS(void);
a154 1

d160 1
a160 1
    InitSemaphore(&gb->HostNamesLock);
d163 1
d165 1
a165 1
    NewList((struct List *)&gb->SimpleNames);
d168 1
d170 1
a170 1
    gb->SimpleNamePort = OpenUDPPort(1,&ResolverInput);
d173 1
d175 1
a175 1
    gb->DNSPort = DNSInit(0x87070A01);
d177 2
a178 2
    if(gb->DNSPort)
        gb->resolversigmask |= (1<< gb->DNSPort->mp_SigBit);
a184 1
    struct SimpleNameInfo *sni,*n1;
d187 2
a188 15
    sni = (struct SimpleNameInfo *) gb->SimpleNames.mlh_Head;
    while(sni->sni_Msg.mn_Node.ln_Succ)
    {
        n1 = (struct SimpleNameInfo *) sni->sni_Msg.mn_Node.ln_Succ;
        FreeMem(sni, sizeof(struct SimpleNameInfo));
        sni = n1;
    }

    sni = (struct SimpleNameInfo *) gb->RequestList.mlh_Head;
    while(sni->sni_Msg.mn_Node.ln_Succ)
    {
        n1 = (struct SimpleNameInfo *) sni->sni_Msg.mn_Node.ln_Succ;
        FreeMem(sni, sizeof(struct SimpleNameInfo));
        sni = n1;
    }
d201 2
a202 2
    if(gb->SimpleNamePort)
        CloseUDPPort(gb->SimpleNamePort);
d210 16
a230 1
    struct SimpleNameInfo *sni;
d232 13
a244 2
    struct MsgPort *myport;
    ULONG namelen, ipnum, reqlen,nbufflen;
a245 1

d247 1
a247 1
        return ipnum;
d249 1
a249 2
    ObtainSemaphore(&gb->HostNamesLock);
    sni = (struct SimpleNameInfo *) gb->SimpleNames.mlh_Head;
d251 26
a276 1
    ipnum = 0;
d278 1
a278 11
    while(sni->sni_Msg.mn_Node.ln_Succ)
    {
        if(!Stricmp(sni->sni_Msg.mn_Node.ln_Name,hostname))
        {
            ipnum = sni->sni_IPNum;
            ReleaseSemaphore(&gb->HostNamesLock);
            return ipnum;
        }
        sni = (struct SimpleNameInfo *) sni->sni_Msg.mn_Node.ln_Succ;
    }
    ReleaseSemaphore(&gb->HostNamesLock);
d281 2
a282 1
    nrn = (struct NetResolveName *) gb->SimpleNames.mlh_Head;
d288 2
a289 3
            ipnum = sni->sni_IPNum;
            ReleaseSemaphore(&gb->DNSNamesLock);
            return ipnum;
d295 2
a296 1
    namelen = strlen(hostname)+2;
a297 1
    nbufflen = (namelen & 0xfffffffe);
d299 3
a301 26
    reqlen = sizeof(struct SimpleNameInfo) + nbufflen;
    if(sni = AllocMem(reqlen,MEMF_CLEAR|MEMF_PUBLIC))
    {
        if(myport=CreateMsgPort())
        {
            sni->sni_IPNum = 0;
            sni->sni_TTL = 10;                  /* 1 second timeout */
            sni->sni_ID  = gb->ResID++;
            sni->sni_Msg.mn_Length = reqlen;
            sni->sni_Msg.mn_Node.ln_Name = (UBYTE *) (ULONG) sni + (ULONG) sizeof(struct SimpleNameInfo);
            sni->sni_Msg.mn_ReplyPort = myport;
            CopyMem(hostname,(UBYTE *) (ULONG) sni + (ULONG) sizeof(struct SimpleNameInfo),nbufflen);
            PutMsg(gb->ResolverPort,(struct Message *)sni);
            WaitPort(myport);
            sni = (struct SimpleNameInfo *) GetMsg(myport);
            if(ipnum = sni->sni_IPNum)
            {
                ObtainSemaphore(&gb->HostNamesLock);
                sni->sni_TTL=600;
                AddHead((struct List *)&gb->SimpleNames,(struct Node *)sni);
                ReleaseSemaphore(&gb->HostNamesLock);
            }
            DeleteMsgPort(myport);
        }
        if(!ipnum) FreeMem(sni,reqlen);
    }
d303 3
a305 23
    if((!ipnum) && (gb->DNSPort))
    {
        if(nrn = AllocMem(sizeof(struct NetResolveName),MEMF_CLEAR|MEMF_PUBLIC))
        {
            if(myport = CreateMsgPort())
            {
                nrn->nrn_Msg.mn_ReplyPort = myport;
                strcpy(nrn->nrn_CName,hostname);
                PutMsg(gb->DNSPort,(struct Message *)nrn);
                WaitPort(myport);
                nrn = (struct NetResolveName *) GetMsg(myport);
                if(ipnum = nrn->nrn_IP)
                {
                    ObtainSemaphore(&gb->DNSNamesLock);
                    nrn->nrn_Timer=600;
                    AddHead((struct List *)&gb->DNSNames,(struct Node *)nrn);
                    ReleaseSemaphore(&gb->DNSNamesLock);
                }
                DeleteMsgPort(myport);
            }
            if(!ipnum) FreeMem(nrn,sizeof(struct NetResolveName));
        }
    }
d308 1
d310 5
d319 88
d409 2
a410 1
    struct SimpleNameInfo *sni;
d412 1
a412 1
    while(sni = (struct SimpleNameInfo *) GetMsg(gb->ResolverPort))
d414 9
a422 3
        sni->sni_Msg.mn_Node.ln_Type = SNI_REQ;
        UDP_Output((UBYTE *)sni,sni->sni_Msg.mn_Length,0xffffffff,0,1);
        AddTail((struct List *)&gb->RequestList,(struct Node *)sni);
d424 1
a424 2

    DoDNS();
d434 1
a434 1
VOID ResolverInput(conn, buff)
d437 1
d442 6
a447 3
    struct SimpleNameInfo *sni;
    struct SimpleNameInfo *temp;
    struct SimpleNameInfo *next;
d449 6
a454 1
    ULONG our_ip;
d460 1
a460 3
    sni = (struct SimpleNameInfo *) ((ULONG) udp + (ULONG) sizeof(struct udphdr));

    str = (UBYTE *) (ULONG) sni + (ULONG) sizeof(struct SimpleNameInfo);
d462 258
a719 36
    if(sni->sni_Msg.mn_Length >= sizeof(struct SimpleNameInfo))
    {
        if(sni->sni_Msg.mn_Node.ln_Type == SNI_REQ)
        {
            if(our_ip = lookuphost((UBYTE *) (ULONG) sni + (ULONG) sizeof(struct SimpleNameInfo)))
            {
                sni->sni_IPNum = our_ip;
                sni->sni_TTL = 50;
                sni->sni_Msg.mn_Node.ln_Type = SNI_DAT;
                UDP_Output((UBYTE *)sni,sni->sni_Msg.mn_Length,ip->iph_SrcAddr,0,1);
            }
        }
        else
        {
            if(sni->sni_Msg.mn_Node.ln_Type == SNI_DAT)
            {
                temp = (struct SimpleNameInfo *) gb->RequestList.mlh_Head;
                while(temp->sni_Msg.mn_Node.ln_Succ)
                {
                    next = (struct SimpleNameInfo *) temp->sni_Msg.mn_Node.ln_Succ;
                    if(temp->sni_ID == sni->sni_ID)
                    {
                        if(!Stricmp(str,temp->sni_Msg.mn_Node.ln_Name))
                        {
                            Remove((struct Node *)temp);
                            temp->sni_IPNum = sni->sni_IPNum;
                            temp->sni_TTL = sni->sni_TTL;
                            ReplyMsg((struct Message *)temp);
                        }
                    }
                    temp = next;
                }
            }
        }
    }
    FreeBuffer(buff);
d726 1
a726 1
    struct SimpleNameInfo *sni;
d728 1
d731 42
a772 25
    sni = (struct SimpleNameInfo *) gb->RequestList.mlh_Head;
    while(sni->sni_Msg.mn_Node.ln_Succ)
    {
        next = (struct SimpleNameInfo *) sni->sni_Msg.mn_Node.ln_Succ;
        sni->sni_TTL -= 1;
        if(!sni->sni_TTL)
        {
            Remove((struct Node *)sni);
            sni->sni_IPNum = 0;
            ReplyMsg((struct Message *)sni);
        }
        sni = next;
    }

    ObtainSemaphore(&gb->HostNamesLock);

    sni = (struct SimpleNameInfo *) gb->SimpleNames.mlh_Head;
    while(sni->sni_Msg.mn_Node.ln_Succ)
    {
        next = (struct SimpleNameInfo *) sni->sni_Msg.mn_Node.ln_Succ;
        sni->sni_TTL -= 1;
        if(!sni->sni_TTL)
        {
            Remove((struct Node *)sni);
            FreeMem(sni,sni->sni_Msg.mn_Length);
d774 1
a774 1
        sni = next;
d776 1
a776 1
    ReleaseSemaphore(&gb->HostNamesLock);
a793 1
        ReleaseSemaphore(&gb->DNSNamesLock);
d796 1
@


1.7
log
@The_voodoo_stuff_is_GONE!
@
text
@d7 1
a7 1
** $Id: resolver.c,v 1.6 92/03/10 15:14:50 kcd Exp $
d384 1
@


1.6
log
@Finished up Deinit code.  Added a lookup in the DNS name resolver cache
that I had forgotten before.
@
text
@d7 1
a7 1
** $Id: resolver.c,v 1.5 92/03/06 21:09:11 kcd Exp Locker: kcd $
d80 4
a83 4
    ResID = 1;
    InitSemaphore(&HostNamesLock);
    InitSemaphore(&RequestLock);
    InitSemaphore(&DNSNamesLock);
d85 7
a91 7
    NewList((struct List *)&SimpleNames);
    NewList((struct List *)&RequestList);
    NewList((struct List *)&DNSNames);

    SimpleNamePort = OpenUDPPort(1,&ResolverInput);
    ResolverPort = CreateMsgPort();
    resolversigmask = (1 << ResolverPort->mp_SigBit);
d93 1
a93 1
    DNSPort = DNSInit(0x87070A01);
d95 2
a96 2
    if(DNSPort)
        resolversigmask |= (1<< DNSPort->mp_SigBit);
d106 1
a106 1
    sni = (struct SimpleNameInfo *) SimpleNames.mlh_Head;
d114 1
a114 1
    sni = (struct SimpleNameInfo *) RequestList.mlh_Head;
d122 1
a122 1
    nrn = (struct NetResolveName *) DNSNames.mlh_Head;
d130 1
a130 1
    if(DNSPort)
d133 2
a134 2
    if(SimpleNamePort)
        CloseUDPPort(SimpleNamePort);
d136 2
a137 2
    if(ResolverPort)
        DeleteMsgPort(ResolverPort);
d156 2
a157 2
    ObtainSemaphore(&HostNamesLock);
    sni = (struct SimpleNameInfo *) SimpleNames.mlh_Head;
d166 1
a166 1
            ReleaseSemaphore(&HostNamesLock);
d171 1
a171 1
    ReleaseSemaphore(&HostNamesLock);
d173 2
a174 2
    ObtainSemaphore(&DNSNamesLock);
    nrn = (struct NetResolveName *) SimpleNames.mlh_Head;
d181 1
a181 1
            ReleaseSemaphore(&DNSNamesLock);
d186 1
a186 1
    ReleaseSemaphore(&DNSNamesLock);
d199 1
a199 1
            sni->sni_ID  = ResID++;
d204 1
a204 1
            PutMsg(ResolverPort,(struct Message *)sni);
d209 1
a209 1
                ObtainSemaphore(&HostNamesLock);
d211 2
a212 2
                AddHead((struct List *)&SimpleNames,(struct Node *)sni);
                ReleaseSemaphore(&HostNamesLock);
d219 1
a219 1
    if((!ipnum) && (DNSPort))
d227 1
a227 1
                PutMsg(DNSPort,(struct Message *)nrn);
d232 1
a232 1
                    ObtainSemaphore(&DNSNamesLock);
d234 2
a235 2
                    AddHead((struct List *)&DNSNames,(struct Node *)nrn);
                    ReleaseSemaphore(&DNSNamesLock);
d253 1
a253 1
    while(sni = (struct SimpleNameInfo *) GetMsg(ResolverPort))
d257 1
a257 1
        AddTail((struct List *)&RequestList,(struct Node *)sni);
d307 1
a307 1
                temp = (struct SimpleNameInfo *) RequestList.mlh_Head;
d337 1
a337 1
    sni = (struct SimpleNameInfo *) RequestList.mlh_Head;
d351 1
a351 1
    ObtainSemaphore(&HostNamesLock);
d353 1
a353 1
    sni = (struct SimpleNameInfo *) SimpleNames.mlh_Head;
d365 1
a365 1
    ReleaseSemaphore(&HostNamesLock);
d367 1
a367 1
    ObtainSemaphore(&DNSNamesLock);
d369 1
a369 1
    if(DNSPort)
d371 1
a371 1
        nrn = (struct NetResolveName *) DNSNames.mlh_Head;
d383 1
a383 1
        ReleaseSemaphore(&DNSNamesLock);
@


1.5
log
@Removed kprintf's
@
text
@d7 1
a7 1
** $Id: resolver.c,v 1.4 92/03/06 19:08:30 kcd Exp Locker: kcd $
a92 1
//    kprintf("Calling DNSInit.\n");
d94 1
a94 1
//    kprintf("DNSInit returned.\n");
a95 2
    {
//        kprintf("DNS Active.\n");
a96 1
    }
d103 36
a157 1
    ipnum = 0L;
d159 1
a159 1
//    kprintf("Looking for host: %s\n",hostname);
a166 1
//            kprintf("Hostname %s's Address is: %lx\n",ipnum);
d173 15
a187 1
//    kprintf("Host %s not in cache.\n");
a206 1
//            kprintf("Got a Simple response.\n");
a220 1
//        kprintf("Trying DNS.\n");
a229 1
//                kprintf("Got a DNS response.\n");
a242 2
//    kprintf("Final: %lx\n",ipnum);

a252 1
//    kprintf("DoResolver() called.\n");
a254 1
//        kprintf("Sending a request.\n");
a282 1
//    kprintf("ResolverInput() called.\n");
a294 1
//            kprintf("Got a name lookup request.\n");
a306 1
//                kprintf("Got a name lookup response.\n");
a359 1
//            kprintf("Timing out a cached simple name.\n");
a377 1
//                kprintf("Timing out a cached DNS name.\n");
a384 2


@


1.4
log
@Added DNS Support.
@
text
@d7 1
a7 1
** $Id: resolver.c,v 1.3 92/03/04 16:58:08 gregm Exp Locker: kcd $
d93 1
a93 1
    kprintf("Calling DNSInit.\n");
d95 1
a95 1
    kprintf("DNSInit returned.\n");
d98 1
a98 1
        kprintf("DNS Active.\n");
d136 1
a136 1
            kprintf("Hostname %s's Address is: %lx\n",ipnum);
d143 1
a143 1
    kprintf("Host %s not in cache.\n");
d163 1
a163 1
            kprintf("Got a Simple response.\n");
d178 1
a178 1
        kprintf("Trying DNS.\n");
d188 1
a188 1
                kprintf("Got a DNS response.\n");
d202 1
a202 1
    kprintf("Final: %lx\n",ipnum);
d214 1
a214 1
    kprintf("DoResolver() called.\n");
d217 1
a217 1
        kprintf("Sending a request.\n");
d246 1
a246 1
    kprintf("ResolverInput() called.\n");
d259 1
a259 1
            kprintf("Got a name lookup request.\n");
d272 1
a272 1
                kprintf("Got a name lookup response.\n");
d326 1
a326 1
            kprintf("Timing out a cached simple name.\n");
d345 1
a345 1
                kprintf("Timing out a cached DNS name.\n");
@


1.3
log
@Moved globals to globals.c; externs for these in externs.h.
@
text
@d7 1
a7 1
** $Id: resolver.c,v 1.2 92/03/03 14:51:36 kcd Exp Locker: gregm $
d44 23
d70 6
d83 1
d87 1
d92 9
d116 1
a145 1

d154 1
a154 1
            sni->sni_TTL = 50;                  /* 5 second timeout */
d163 1
a163 1
            kprintf("Got a response.\n");
d175 29
a203 1
//    kprintf("Final: %lx\n",ipnum);
d205 1
d222 2
d263 1
a263 1
                sni->sni_TTL = 3000;
a272 1
//                ObtainSemaphore(&RequestLock);
a288 1
//                ReleaseSemaphore(&RequestLock);
d299 3
a301 4
    struct SimpleNameInfo *sni, *next;

//    kprintf("RT:Enter\n");
//    ObtainSemaphore(&RequestLock);
a309 1
//            kprintf("Timing out a name lookup.\n");
a315 1
//    ReleaseSemaphore(&RequestLock);
d317 1
a317 1
//    ObtainSemaphore(&HostNamesLock);
d326 1
a326 1
//            kprintf("Timing out a cached name.\n");
d332 23
a354 2
//    ReleaseSemaphore(&HostNamesLock);
//    kprintf("RT:Exit\n");
@


1.2
log
@client <--> resolver communication mechanism changed a bit to make
DNS easier to add in the future.
@
text
@d7 1
a7 1
** $Id: resolver.c,v 1.1 92/02/29 20:34:32 kcd Exp Locker: kcd $
d14 2
a45 19

/*------------------------------------------------------------------------*/

/* Externals */

extern struct Library *UtilityBase;

/*------------------------------------------------------------------------*/

/* Globals */

struct SignalSemaphore HostNamesLock;
struct SignalSemaphore RequestLock;
struct MinList SimpleNames;
struct MinList RequestList;
struct UDPConnection *SimpleNamePort;
struct MsgPort *ResolverPort;
ULONG resolversigmask;
UBYTE ResID;
@


1.1
log
@Initial revision
@
text
@d7 1
a7 1
** $Id: monitor.c,v 1.2 92/02/27 21:05:05 kcd Exp $
d60 2
d76 2
d112 1
a112 1
//            kprintf("Hostname %s's Address is: %lx\n",ipnum);
d119 1
a119 1
//    kprintf("Host %s not in cache.\n");
a133 1
            sni->sni_Msg.mn_Node.ln_Type = SNI_REQ;
d137 1
a137 9

            ObtainSemaphore(&RequestLock);
            AddTail((struct List *)&RequestList,(struct Node *)sni);
            ReleaseSemaphore(&RequestLock);

//            kprintf("Sending request packet to IP_Out().\n");
            UDP_Output((UBYTE *)sni,reqlen,0xffffffff,0,1);
//            kprintf("Waiting for a response.\n");

d140 1
a140 1
//            kprintf("Got a response.\n");
d158 21
d192 1
d205 1
d218 2
a219 1
                ObtainSemaphore(&RequestLock);
d236 1
a236 1
                ReleaseSemaphore(&RequestLock);
d250 1
a250 1
    ObtainSemaphore(&RequestLock);
d266 1
a266 1
    ReleaseSemaphore(&RequestLock);
d268 1
a268 1
    ObtainSemaphore(&HostNamesLock);
d283 1
a283 1
    ReleaseSemaphore(&HostNamesLock);
a287 1

@
