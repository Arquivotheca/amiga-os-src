head     1.31;
branch   ;
access   ;
symbols  ;
locks    ; strict;
comment  @ * @;


1.31
date     94.02.07.19.52.53;  author kcd;  state Exp;
branches ;
next     1.30;

1.30
date     93.04.05.11.17.02;  author gregm;  state Exp;
branches ;
next     1.29;

1.29
date     93.03.02.19.44.40;  author kcd;  state Exp;
branches ;
next     1.28;

1.28
date     93.01.05.13.00.01;  author kcd;  state Exp;
branches ;
next     1.27;

1.27
date     92.11.19.14.15.32;  author kcd;  state Exp;
branches ;
next     1.26;

1.26
date     92.07.30.17.37.01;  author kcd;  state Exp;
branches ;
next     1.25;

1.25
date     92.07.30.15.58.56;  author kcd;  state Exp;
branches ;
next     1.24;

1.24
date     92.07.13.17.01.48;  author kcd;  state Exp;
branches ;
next     1.23;

1.23
date     92.06.18.14.32.23;  author kcd;  state Exp;
branches ;
next     1.22;

1.22
date     92.06.08.09.52.59;  author kcd;  state Exp;
branches ;
next     1.21;

1.21
date     92.05.21.14.03.05;  author gregm;  state Exp;
branches ;
next     1.20;

1.20
date     92.05.15.12.45.48;  author kcd;  state Exp;
branches ;
next     1.19;

1.19
date     92.05.05.17.26.57;  author kcd;  state Exp;
branches ;
next     1.18;

1.18
date     92.05.04.10.56.08;  author kcd;  state Exp;
branches ;
next     1.17;

1.17
date     92.04.21.15.58.33;  author kcd;  state Exp;
branches ;
next     1.16;

1.16
date     92.04.10.14.51.36;  author kcd;  state Exp;
branches ;
next     1.15;

1.15
date     92.04.10.00.39.09;  author kcd;  state Exp;
branches ;
next     1.14;

1.14
date     92.03.27.10.32.08;  author gregm;  state Exp;
branches ;
next     1.13;

1.13
date     92.03.23.10.20.32;  author gregm;  state Exp;
branches ;
next     1.12;

1.12
date     92.03.13.14.47.57;  author gregm;  state Exp;
branches ;
next     1.11;

1.11
date     92.03.13.14.24.04;  author gregm;  state Exp;
branches ;
next     1.10;

1.10
date     92.03.05.17.35.15;  author gregm;  state Exp;
branches ;
next     1.9;

1.9
date     92.03.04.16.56.49;  author gregm;  state Exp;
branches ;
next     1.8;

1.8
date     92.03.03.14.51.07;  author kcd;  state Exp;
branches ;
next     1.7;

1.7
date     92.02.29.20.33.05;  author kcd;  state Exp;
branches ;
next     1.6;

1.6
date     92.02.27.21.03.18;  author kcd;  state Exp;
branches ;
next     1.5;

1.5
date     92.02.24.10.47.34;  author kcd;  state Exp;
branches ;
next     1.4;

1.4
date     92.02.20.14.08.16;  author gregm;  state Exp;
branches ;
next     1.3;

1.3
date     92.02.18.12.51.13;  author kcd;  state Exp;
branches ;
next     1.2;

1.2
date     92.02.16.17.23.07;  author kcd;  state Exp;
branches ;
next     1.1;

1.1
date     92.02.13.10.00.31;  author gregm;  state Exp;
branches ;
next     ;


desc
@The center of the nipc.library; where the Wait() is.  :')
@


1.31
log
@Moved the RDP ACK timeout interval to 1 second.
@
text
@/**************************************************************************
**
** center_custom.c  - NIPC Library Process Startup Module
**
** Copyright 1992, Commodore-Amiga, Inc.
**
** $Id: center_custom.c,v 1.30 93/04/05 11:17:02 gregm Exp Locker: kcd $
**
***************************************************************************

/*------------------------------------------------------------------------*/

#include <exec/exec.h>
#include <exec/ports.h>
#include <dos/dos.h>
#include <dos/dostags.h>
#include <dos.h>

#include "nipcinternal.h"

#include <clib/exec_protos.h>
#include <clib/dos_protos.h>
#include "nipcinternal_protos.h"


#include <pragmas/exec_pragmas.h>
#include <pragmas/dos_pragmas.h>

#include "externs.h"

/*------------------------------------------------------------------------*/

/* Externals */

extern void EntryPoint(void);
extern void SetSysBase(void);

/*------------------------------------------------------------------------*/

struct MyLibrary
{
    struct Library ml_Lib;
    ULONG ml_SegList;
    ULONG ml_Flags;
    APTR ml_ExecBase;           /* pointer to exec base */
    LONG ml_Data;               /* Global data */
};


/*------------------------------------------------------------------------*/

void __asm InitLock(register __a6 struct Library * libbase)
{
    register struct NBase *nb = gb;

    InitSemaphore(&nb->openlock);
    gb->jumpstart = FALSE;
}

/*------------------------------------------------------------------------*/

void __asm StartLibrary(register __a6 struct Library * libbase)
{
    register struct NBase *nb = gb;

    ULONG cptags[9];
    struct MsgPort *port;
    struct TagItem *ctti;
    struct Process **tproc;

    ObtainSemaphore(&nb->openlock);

    if (!gb->jumpstart)
    {

        cptags[0] = NP_Entry;
        cptags[1] = (ULONG) & EntryPoint;
        cptags[2] = NP_Name;
        cptags[3] = (ULONG) "nipc_supervisor";
        cptags[4] = NP_FreeSeglist;
        cptags[5] = TRUE;
        cptags[6] = NP_Priority;
        cptags[7] = 10;
        cptags[8] = TAG_DONE;

        port = CreateMsgPort();

        gb->smsg.sm_Msg.mn_ReplyPort = port;
        gb->smsg.sm_Msg.mn_Length = sizeof(struct StartMessage);
        gb->smsg.sm_LibBase = libbase;

        nb->nb_DOSBase = (struct Library *) OpenLibrary("dos.library", 37);
        if (!DOSBase)
            return;

        ctti = (struct TagItem *) &cptags;
        tproc = (struct Process **)&(gb->nipcprocess);
//        gb->nipcprocess = (struct Process *) CreateNewProc(ctti);
        *tproc = (struct Process *) CreateNewProc(ctti);
        gb->nipcprocess->pr_WindowPtr = (APTR)-1;
        CloseLibrary((struct Library *) nb->nb_DOSBase);
        PutMsg(&(nb->nipcprocess->pr_MsgPort), (struct Message *) & nb->smsg);
        WaitPort(port);
        GetMsg(port);
        DeleteMsgPort(port);

    }

    ReleaseSemaphore(&nb->openlock);

}

/*------------------------------------------------------------------------*/

void KillOffNIPC(void)
{
    register struct NBase *nb = gb;
    struct Task *ns;
    ns = FindTask("nipc_supervisor");
    if (ns)
        Signal(ns,(1 << nb->shutdownbit));
}

/*------------------------------------------------------------------------*/

void __asm __stdargs LibraryProcess(void)
{
    register struct NBase *nb = gb;

    ULONG waitmask, wokemask, shutdownmask;
    ULONG libsize;
    BPTR  ourseglist;
    BPTR  procsegarray, procseglist;
    struct ipproto *ipp;
    BOOL split=FALSE;

    waitmask = 0L;
    NewList((struct List *) &gb->BufferCache);
    NewList((struct List *) &gb->BuffEntryCache);

    {
        struct Node *node;
        UWORD count;

        for(count=0; count<128; count++)
            if(node = AllocMem(sizeof(struct Buffer),MEMF_PUBLIC|MEMF_CLEAR))
                AddHead((struct List *) &nb->BufferCache,node);

        for(count=0; count<256; count++)
            if(node = AllocMem(sizeof(struct BuffEntry),MEMF_PUBLIC|MEMF_CLEAR))
                AddHead((struct List *) &nb->BuffEntryCache,node);

    }

    if(nb->nb_DOSBase = (struct Library *) OpenLibrary("dos.library", 37L))
    {
        if(nb->nb_UtilityBase = (struct Library *) OpenLibrary("utility.library",37L))
        {
            if (InitMemory())
            {
                if(OpenConfig())
                {
                    if(InitSana2())
                    {
                        if(InitRoute())
                        {
                            if(InitARP())
                            {
                                if(InitTimer())
                                {

                                    NewList((struct List *) &gb->ProtocolList);

                                    if(init_icmp())
                                    {
                                        if(rdp_init())
                                        {
                                            if(UDP_Init())
                                            {
                                                if(InitANMP())
                                                {
                                                    if(InitResolver())
                                                    {
                                                        nb->shutdownbit = AllocSignal(-1L);
                                                        if (gb->shutdownbit != -1)
                                                        {
                                                            shutdownmask = (1 << gb->shutdownbit);
                                                            CloseConfig();
                                                            gb->jumpstart = TRUE;
                                                            ReplyMsg((struct Message *) & nb->smsg);
                                                            waitmask |= (gb->s2sigmask | gb->timersigmask | gb->resolversigmask | shutdownmask);

                                                            while (TRUE)
                                                            {
                                                                wokemask = Wait(waitmask);

                                                                if (wokemask & shutdownmask)
                                                                {
                                                                    break;
                                                                }
                                                                if (wokemask & gb->s2sigmask)
                                                                {
                                                                    ONTIMER(31);
                                                                    PollPort();         /* stuff on the gb->replyport for the s2 devices */
                                                                    OFFTIMER(31);
                                                                }
                                                                if (wokemask & gb->resolversigmask)
                                                                {
                                                                    DoResolver();
                                                                }
                                                                if (wokemask & gb->timersigmask)
                                                                {
                                                                    ONTIMER(9);
                                                                    TimeOut();          /* reset the timer */
                                                                    HeartBeat();
                                                                    OFFTIMER(9);
                                                                }
                                                            }

                                                            ourseglist = (BPTR) ((struct NBase *)getreg(REG_A6))->nb_SegList;
                                                            procsegarray = ((struct Process *)FindTask(0L))->pr_SegList;
                                                            procseglist = (BPTR) ((ULONG *)BADDR(procsegarray))[3];

                                                            /* Follow our seglist to the end, and tack them onto it */
                                                            while (((ULONG *) BADDR(ourseglist))[0])
                                                                ourseglist = (BPTR) ((ULONG *)BADDR(ourseglist))[0];
                                                            ((ULONG *) BADDR(ourseglist))[0] = (ULONG) procseglist;

                                                            /* Insert us at the top of the list */
                                                            ((ULONG *)BADDR(procsegarray))[3] =
                                                                               (BPTR) ((struct NBase *)getreg(REG_A6))->nb_SegList;

                                                            split = TRUE;
                                                            FreeSignal(nb->shutdownbit);
                                                        }
                                                        DeinitResolver();
                                                    }
                                                    DeinitANMP();
                                                }
                                            }
                                        }
                                        /* deinit all protocols */
                                        ipp = (struct ipproto *) gb->ProtocolList.mlh_Head;
                                        while (ipp->ipproto_link.mln_Succ)
                                        {
                                            (*ipp->ipproto_Deinit) ();
                                            ipp = (struct ipproto *) ipp->ipproto_link.mln_Succ;
                                        }
                                    }
                                    DeinitTimer();
                                }
                                DeinitARP();
                            }
                            DeinitRoute();
                        }
                        DeinitSana2();
                    }
                    CloseConfig();
                }
                DeinitMemory();
            }
            CloseLibrary(nb->nb_UtilityBase);
        }
        CloseLibrary(nb->nb_DOSBase);
    }
    {
        struct Node *node;

        while(node=RemHead((struct List *)&nb->BufferCache))
            FreeMem(node,sizeof(struct Buffer));

        while(node=RemHead((struct List *)&nb->BuffEntryCache))
            FreeMem(node,sizeof(struct BuffEntry));
    }

    if(nb->smsg.sm_Msg.mn_Node.ln_Type != NT_REPLYMSG)
    {
        nb->nipcprocess = NULL;
        ReplyMsg((struct Message *)&nb->smsg);
    }

    if (split)
    {
        /* Free up the library base */
        libsize = ((struct NBase *)getreg(REG_A6))->LibNode.lib_NegSize +
                  ((struct NBase *)getreg(REG_A6))->LibNode.lib_PosSize;
        FreeMem( (void *) (getreg(REG_A6) - (((struct NBase *)getreg(REG_A6))->LibNode.lib_NegSize)),
                 (LONG) libsize);
    }

}

/*------------------------------------------------------------------------*/

/* The Grand place where all input arrives at */

void ProtocolInput(inpbuff, length, ptype, dev)
struct Buffer *inpbuff;
ULONG length;
UWORD ptype;
struct sanadev *dev;
{

    switch (ptype)
    {

        case (PACKET_IP):
            multiplex_in(inpbuff, dev);
            break;

        case (PACKET_ARP):
            ARPInput(inpbuff, length, dev);
            break;

        default:
            FreeBuffer(inpbuff);
    }

}

/*------------------------------------------------------------------------*/

void HeartBeat()
{

    /*
     * go through each of the protocols attached to IP, and enter their
     * timeout routines.  Everyone will get "buzzed" every time the
     * timer.device finishes a request - currently every 0.1 second.
     */
    struct ipproto *pr;

//      kprintf("TimeCount: %ld\n",(ULONG)gb->TimeCount);

    gb->TimeCount--;
    if(!gb->TimeCount)
    {
        gb->TimeCount = 10;
        pr = (struct ipproto *) gb->ProtocolList.mlh_Head;
        while (pr->ipproto_link.mln_Succ)
        {
            (*pr->ipproto_Timeout) ();
            pr = (struct ipproto *) pr->ipproto_link.mln_Succ;
        }
        ResolverTimeout();
        arp_timeout();
        FragmentTimeout();
        ANMPTimeout();
        DevReqTimeout();
	rdp_ack_timeout();
    }
}

@


1.30
log
@Added Init/Deinit for memory.
@
text
@d7 1
a7 1
** $Id: center_custom.c,v 1.29 93/03/02 19:44:40 kcd Exp Locker: gregm $
d350 1
a351 1
    rdp_ack_timeout();
@


1.29
log
@Now set's the nipc proceess's pr_WindowPtr to -1.
@
text
@d7 1
a7 1
** $Id: center_custom.c,v 1.28 93/01/05 13:00:01 kcd Exp Locker: kcd $
d145 3
a147 3
	for(count=0; count<128; count++)
	    if(node = AllocMem(sizeof(struct Buffer),MEMF_PUBLIC|MEMF_CLEAR))
	    	AddHead((struct List *) &nb->BufferCache,node);
d149 3
a151 3
	for(count=0; count<256; count++)
	    if(node = AllocMem(sizeof(struct BuffEntry),MEMF_PUBLIC|MEMF_CLEAR))
	    	AddHead((struct List *) &nb->BuffEntryCache,node);
d159 1
a159 1
            if(OpenConfig())
d161 1
a161 1
                if(InitSana2())
d163 1
a163 1
                    if(InitRoute())
d165 1
a165 1
                        if(InitARP())
d167 1
a167 2
//                        	kprintf("Before: %ld\n",(ULONG)gb->TimeCount);
                            if(InitTimer())
d169 2
a170 1
//                        	kprintf("After: %ld\n",(ULONG)gb->TimeCount);
d172 1
a172 1
                                NewList((struct List *) &gb->ProtocolList);
d174 1
a174 3
                                if(init_icmp())
                                {
                                    if(rdp_init())
d176 1
a176 1
                                        if(UDP_Init())
d178 1
a178 1
                                            if(InitANMP())
d180 1
a180 1
                                                if(InitResolver())
d182 1
a182 2
                                                    nb->shutdownbit = AllocSignal(-1L);
                                                    if (gb->shutdownbit != -1)
d184 2
a185 7
                                                        shutdownmask = (1 << gb->shutdownbit);
                                                        CloseConfig();
                                                        gb->jumpstart = TRUE;
                                                        ReplyMsg((struct Message *) & nb->smsg);
                                                        waitmask |= (gb->s2sigmask | gb->timersigmask | gb->resolversigmask | shutdownmask);

                                                        while (TRUE)
d187 5
a191 1
                                                            wokemask = Wait(waitmask);
d193 1
a193 1
                                                            if (wokemask & shutdownmask)
d195 23
a217 11
                                                                break;
                                                            }
                                                            if (wokemask & gb->s2sigmask)
                                                            {
                                                                ONTIMER(31);
                                                                PollPort();         /* stuff on the gb->replyport for the s2 devices */
                                                                OFFTIMER(31);
                                                            }
                                                            if (wokemask & gb->resolversigmask)
                                                            {
                                                                DoResolver();
a218 8
                                                            if (wokemask & gb->timersigmask)
                                                            {
                                                                ONTIMER(9);
                                                                TimeOut();          /* reset the timer */
                                                                HeartBeat();
                                                                OFFTIMER(9);
                                                            }
                                                        }
d220 3
a222 3
                                                        ourseglist = (BPTR) ((struct NBase *)getreg(REG_A6))->nb_SegList;
                                                        procsegarray = ((struct Process *)FindTask(0L))->pr_SegList;
                                                        procseglist = (BPTR) ((ULONG *)BADDR(procsegarray))[3];
d224 8
a231 8
                                                        /* Follow our seglist to the end, and tack them onto it */
                                                        while (((ULONG *) BADDR(ourseglist))[0])
                                                            ourseglist = (BPTR) ((ULONG *)BADDR(ourseglist))[0];
                                                        ((ULONG *) BADDR(ourseglist))[0] = (ULONG) procseglist;

                                                        /* Insert us at the top of the list */
                                                        ((ULONG *)BADDR(procsegarray))[3] =
                                                                           (BPTR) ((struct NBase *)getreg(REG_A6))->nb_SegList;
d233 4
a236 2
                                                        split = TRUE;
                                                        FreeSignal(nb->shutdownbit);
d238 1
a238 1
                                                    DeinitResolver();
a239 1
                                                DeinitANMP();
d242 7
a248 7
                                    }
                                    /* deinit all protocols */
                                    ipp = (struct ipproto *) gb->ProtocolList.mlh_Head;
                                    while (ipp->ipproto_link.mln_Succ)
                                    {
                                        (*ipp->ipproto_Deinit) ();
                                        ipp = (struct ipproto *) ipp->ipproto_link.mln_Succ;
d250 1
d252 1
a252 1
                                DeinitTimer();
d254 1
a254 1
                            DeinitARP();
d256 1
a256 1
                        DeinitRoute();
d258 1
a258 1
                    DeinitSana2();
d260 1
a260 1
                CloseConfig();
d333 1
a333 1
//	kprintf("TimeCount: %ld\n",(ULONG)gb->TimeCount);
d338 1
a338 1
    	gb->TimeCount = 10;
@


1.28
log
@Added code to set the task priority of nipc's process to 10.
@
text
@d7 1
a7 1
** $Id: center_custom.c,v 1.27 92/11/19 14:15:32 kcd Exp Locker: kcd $
d100 1
@


1.27
log
@Added some buffer/buffentry pre-allocation
@
text
@d7 1
a7 1
** $Id: center_custom.c,v 1.26 92/07/30 17:37:01 kcd Exp $
d66 1
a66 1
    ULONG cptags[7];
d82 3
a84 1
        cptags[6] = TAG_DONE;
@


1.26
log
@Fixed a timer problem.  The TimeCount variable was getting set each
time someone opened the library.  This could cause serious memory loss
problems.
@
text
@d7 1
a7 1
** $Id: center_custom.c,v 1.25 92/07/30 15:58:56 kcd Exp Locker: kcd $
d137 15
@


1.25
log
@Reworked the timeout code again.  We had to switch back to .1 second
timeouts for the new RDP piggybacked-ACK code.
@
text
@d7 1
a7 1
** $Id: center_custom.c,v 1.24 92/07/13 17:01:48 kcd Exp Locker: kcd $
a72 2
    gb->TimeCount = 0;

d149 1
d152 2
d155 1
d312 2
@


1.24
log
@Space savings.
@
text
@d7 1
a7 1
** $Id: center_custom.c,v 1.23 92/06/18 14:32:23 kcd Exp Locker: kcd $
d311 2
a312 2
    pr = (struct ipproto *) gb->ProtocolList.mlh_Head;
    while (pr->ipproto_link.mln_Succ)
d314 14
a327 9
        (*pr->ipproto_Timeout) ();
        pr = (struct ipproto *) pr->ipproto_link.mln_Succ;
    }

    ResolverTimeout();
    arp_timeout();
    FragmentTimeout();
    ANMPTimeout();
    DevReqTimeout();
@


1.23
log
@I now free up any cached Buffers or BuffEntries.
@
text
@d7 1
a7 1
** $Id: center_custom.c,v 1.22 92/06/08 09:52:59 kcd Exp Locker: kcd $
d223 2
a224 1
                                    if (!IsListEmpty((struct List *) & gb->ProtocolList))
d226 2
a227 6
                                        ipp = (struct ipproto *) gb->ProtocolList.mlh_Head;
                                        while (ipp->ipproto_link.mln_Succ)
                                        {
                                            (*ipp->ipproto_Deinit) ();
                                            ipp = (struct ipproto *) ipp->ipproto_link.mln_Succ;
                                        }
a309 2
    if (IsListEmpty((struct List *) & gb->ProtocolList))
        return;
a311 1

@


1.22
log
@Added Init code for memory caching.  Changed timeouts to 1 second.
@
text
@d7 1
a7 1
** $Id: center_custom.c,v 1.21 92/05/21 14:03:05 gregm Exp Locker: kcd $
d246 9
@


1.21
log
@Fixed a bug with the library base being freed, and then still being
accessed.
@
text
@d7 1
a7 1
** $Id: center_custom.c,v 1.20 92/05/15 12:45:48 kcd Exp Locker: gregm $
d129 1
a129 1
    ULONG waitmask, wokemask, shutdownmask=0;
d137 2
a138 1

a168 1
                                                        gb->MonitorInfo.nmi_Monitor = NULL;
a274 1
    register struct NBase *nb = gb;
a290 2
    if (gb->MonitorInfo.nmi_Monitor)
        Signal(nb->MonitorInfo.nmi_Monitor, (1 << nb->MonitorInfo.nmi_SigBitNum));
d314 2
d318 2
a319 8
    ResolverTimeout();
    gb->TimeCount++;
    if (gb->TimeCount >= 10)
    {
        ANMPTimeout();
        DevReqTimeout();
        gb->TimeCount = 0;
    }
@


1.20
log
@Added some timing code.
@
text
@d7 1
a7 1
** $Id: center_custom.c,v 1.19 92/05/05 17:26:57 kcd Exp Locker: kcd $
d134 1
d200 3
a202 3
                                                            ourseglist = (BPTR) ((struct NBase *)getreg(REG_A6))->nb_SegList;
                                                            procsegarray = ((struct Process *)FindTask(0L))->pr_SegList;
                                                            procseglist = (BPTR) ((ULONG *)BADDR(procsegarray))[3];
d205 3
a207 3
                                                            while (((ULONG *) BADDR(ourseglist))[0])
                                                                ourseglist = (BPTR) ((ULONG *)BADDR(ourseglist))[0];
                                                            ((ULONG *) BADDR(ourseglist))[0] = (ULONG) procseglist;
d210 2
a211 2
                                                            ((ULONG *)BADDR(procsegarray))[3] =
                                                                               (BPTR) ((struct NBase *)getreg(REG_A6))->nb_SegList;
d213 1
a213 6
                                                        /* Free up the library base */
                                                        libsize = ((struct NBase *)getreg(REG_A6))->LibNode.lib_NegSize +
                                                                  ((struct NBase *)getreg(REG_A6))->LibNode.lib_PosSize;
                                                        FreeMem( (void *) (getreg(REG_A6) - (((struct NBase *)getreg(REG_A6))->LibNode.lib_NegSize)),
                                                                 (LONG) libsize);

d247 1
d253 10
@


1.19
log
@Reworked library startup code to gracefully fail if something
doesn't init correctly.
@
text
@d7 1
a7 1
** $Id: center_custom.c,v 1.18 92/05/04 10:56:08 kcd Exp Locker: kcd $
a30 1

d175 1
d182 1
d184 1
d192 1
d195 1
a299 1

@


1.18
log
@Added code to support the new configuration code.
@
text
@d7 1
a7 1
** $Id: center_custom.c,v 1.17 92/04/21 15:58:33 kcd Exp $
a106 1
        gb->jumpstart = TRUE;
d138 1
a138 36
    nb->nb_DOSBase = (struct Library *) OpenLibrary("dos.library", 0L);
    if (!DOSBase)
        return;
    nb->nb_UtilityBase = (struct Library *) OpenLibrary("utility.library", 0L);
    if (!UtilityBase)
        return;

    OpenConfig();
    InitSana2();
    InitRoute();
    InitARP();
    InitTimer();
    NewList((struct List *) &gb->ProtocolList);
    init_icmp();
    rdp_init();
    UDP_Init();
    InitANMP();
    /*
     * Everything's initialized.  Set the signal bit for the caller and
     * return
     */

    InitResolver();
    CloseConfig();

    gb->MonitorInfo.nmi_Monitor = NULL;

    nb->shutdownbit = AllocSignal(-1L);
    if (gb->shutdownbit != -1)
        shutdownmask = (1 << gb->shutdownbit);

    ReplyMsg((struct Message *) & nb->smsg);

    waitmask |= (gb->s2sigmask | gb->timersigmask | gb->resolversigmask | shutdownmask);

    while (TRUE)
d140 1
a140 14
        wokemask = Wait(waitmask);
        if (wokemask & shutdownmask)
        {
            break;
        }
        if (wokemask & gb->s2sigmask)
        {
            PollPort();         /* stuff on the gb->replyport for the s2 devices */
        }
        if (wokemask & gb->resolversigmask)
        {
            DoResolver();
        }
        if (wokemask & gb->timersigmask)
d142 102
a243 2
            TimeOut();          /* reset the timer */
            HeartBeat();
d245 1
d247 1
a247 4
    DeinitANMP();

    /* deinit all protocols */
    if (!IsListEmpty((struct List *) & gb->ProtocolList))
d249 2
a250 6
        ipp = (struct ipproto *) gb->ProtocolList.mlh_Head;
        while (ipp->ipproto_link.mln_Succ)
        {
            (*ipp->ipproto_Deinit) ();
            ipp = (struct ipproto *) ipp->ipproto_link.mln_Succ;
        }
a251 30

    DeinitResolver();
    DeinitTimer();
    DeinitARP();
    DeinitRoute();
    DeinitSana2();

    ourseglist = (BPTR) ((struct NBase *)getreg(REG_A6))->nb_SegList;
    procsegarray = ((struct Process *)FindTask(0L))->pr_SegList;
    procseglist = (BPTR) ((ULONG *)BADDR(procsegarray))[3];

/* Follow our seglist to the end, and tack them onto it */
    while (((ULONG *) BADDR(ourseglist))[0])
        ourseglist = (BPTR) ((ULONG *)BADDR(ourseglist))[0];
    ((ULONG *) BADDR(ourseglist))[0] = (ULONG) procseglist;

/* Insert us at the top of the list */
    ((ULONG *)BADDR(procsegarray))[3] =
                       (BPTR) ((struct NBase *)getreg(REG_A6))->nb_SegList;

    CloseLibrary(nb->nb_UtilityBase);
    CloseLibrary(nb->nb_DOSBase);
    FreeSignal(nb->shutdownbit);

/* Free up the library base */
    libsize = ((struct NBase *)getreg(REG_A6))->LibNode.lib_NegSize +
              ((struct NBase *)getreg(REG_A6))->LibNode.lib_PosSize;
    FreeMem( (void *) (getreg(REG_A6) - (((struct NBase *)getreg(REG_A6))->LibNode.lib_NegSize)),
             (LONG) libsize);

d314 1
@


1.17
log
@Changes call to ip_in() to multiplex().
@
text
@d7 1
a7 1
** $Id: center_custom.c,v 1.16 92/04/10 14:51:36 kcd Exp Locker: kcd $
d55 1
a55 1
	register struct NBase *nb = gb;
d65 1
a65 1
	register struct NBase *nb = gb;
d118 1
a118 1
	register struct NBase *nb = gb;
d129 1
a129 1
	register struct NBase *nb = gb;
d146 1
d162 1
d249 1
a249 1
	register struct NBase *nb = gb;
@


1.16
log
@Minor cleanups.
@
text
@d7 1
a7 1
** $Id: center_custom.c,v 1.15 92/04/10 00:39:09 kcd Exp $
a146 1

a147 1

a148 1

a149 1

a151 1

a152 1

a153 1

a154 1

a161 1

d253 1
a253 1
            ip_in(inpbuff, length, dev);
@


1.15
log
@Removed Dependencies on old exec_pragmas.h file.
@
text
@d7 1
a7 1
** $Id: center_custom.c,v 1.14 92/03/27 10:32:08 gregm Exp Locker: kcd $
a141 1

d170 1
d189 1
d191 1
d193 1
d195 1
a201 1

a298 1

@


1.14
log
@*** empty log message ***
@
text
@d7 1
a7 1
** $Id: center_custom.c,v 1.13 92/03/23 10:20:32 gregm Exp $
d55 1
d57 1
a57 1
    InitSemaphore(&gb->openlock);
d65 2
d72 1
a72 1
    ObtainSemaphore(&gb->openlock);
d93 1
a93 1
        DOSBase = (struct Library *) OpenLibrary("dos.library", 37);
d101 2
a102 2
        CloseLibrary((struct Library *) DOSBase);
        PutMsg(&(gb->nipcprocess->pr_MsgPort), (struct Message *) & gb->smsg);
d110 1
a110 1
    ReleaseSemaphore(&gb->openlock);
d118 1
d122 1
a122 1
        Signal(ns,(1 << gb->shutdownbit));
d129 3
a131 1
    ULONG waitmask=0, wokemask=0, shutdownmask=0;
d139 1
a139 1
    DOSBase = (struct Library *) OpenLibrary("dos.library", 0L);
d143 1
a143 1
    UtilityBase = (struct Library *) OpenLibrary("utility.library", 0L);
d173 1
a173 1
    gb->shutdownbit = AllocSignal(-1L);
d177 1
a177 1
    ReplyMsg((struct Message *) & gb->smsg);
d231 3
a233 3
    CloseLibrary(UtilityBase);
    CloseLibrary(DOSBase);
    FreeSignal(gb->shutdownbit);
d253 1
d271 1
a271 1
        Signal(gb->MonitorInfo.nmi_Monitor, (1 << gb->MonitorInfo.nmi_SigBitNum));
@


1.13
log
@The_voodoo_stuff_is_gone!
@
text
@d7 1
a7 1
** $Id: center_custom.c,v 1.12 92/03/13 14:47:57 gregm Exp $
d67 1
a67 1
    ULONG *tproc;
d70 3
d95 1
a95 1
        tproc = (ULONG *)&(gb->nipcprocess);
d97 1
a97 1
        *tproc = (ULONG) CreateNewProc(ctti);
d125 1
a125 1
    ULONG waitmask, wokemask, shutdownmask;
d149 1
a149 1
    NewList((struct List *) & gb->ProtocolList);
d212 1
a212 1
    ourseglist = (BPTR) ((struct MyLibrary *)getreg(REG_A6))->ml_SegList;
d217 4
a220 3
//    while (((ULONG *) BADDR(ourseglist))[0])
//        ourseglist = (BPTR) ((ULONG *)BADDR(ourseglist))[0];
//    ((ULONG *) BADDR(ourseglist))[0] = (ULONG) procseglist;
d223 1
a223 1
                       (BPTR) ((struct MyLibrary *)getreg(REG_A6))->ml_SegList;
d230 3
a232 3
    libsize = ((struct MyLibrary *)getreg(REG_A6))->ml_Lib.lib_NegSize +
              ((struct MyLibrary *)getreg(REG_A6))->ml_Lib.lib_PosSize;
    FreeMem( (void *) (getreg(REG_A6) - (((struct MyLibrary *)getreg(REG_A6))->ml_Lib.lib_NegSize)),
d293 6
a298 1

@


1.12
log
@Heh.  Junodism.  I left kprintf's in the file.
:')
@
text
@d7 1
a7 1
** $Id: center_custom.c,v 1.11 92/03/13 14:24:04 gregm Exp $
a23 1
#include "externs.h"
d29 3
a50 8
struct StartMessage
{
    struct Message sm_Msg;
    struct Library *sm_LibBase;
};

struct StartMessage smsg;

d53 1
a53 1
void __saveds __asm InitLock(register __a6 struct Library * libbase)
d55 3
a57 2
    InitSemaphore(&openlock);
    jumpstart = FALSE;
d62 1
a62 1
void __saveds __asm StartLibrary(register __a6 struct Library * libbase)
d66 2
d69 2
a70 2
    ObtainSemaphore(&openlock);
    if (!jumpstart)
d83 3
a85 3
        smsg.sm_Msg.mn_ReplyPort = port;
        smsg.sm_Msg.mn_Length = sizeof(struct StartMessage);
        smsg.sm_LibBase = libbase;
d91 4
a94 1
        nipcprocess = (struct Process *) CreateNewProc((struct TagItem *) & cptags);
d96 1
a96 1
        PutMsg(&(nipcprocess->pr_MsgPort), (struct Message *) & smsg);
d101 1
a101 1
        jumpstart = TRUE;
d104 1
a104 1
    ReleaseSemaphore(&openlock);
d110 1
a110 1
void __saveds KillOffNIPC(void)
d115 1
a115 1
        Signal(ns,(1 << shutdownbit));
d120 1
a120 1
void __saveds __asm __stdargs LibraryProcess(void)
d146 1
a146 1
    NewList((struct List *) & ProtocolList);
d162 1
a162 1
    MonitorInfo.nmi_Monitor = NULL;
d164 3
a166 5
    shutdownbit = AllocSignal(-1L);
    if (shutdownbit != -1)
        shutdownmask = (1 << shutdownbit);
//    else
//        kprintf("What now?  We SHOULD fail.\n");
d168 1
a168 1
    ReplyMsg((struct Message *) & smsg);
d170 1
a170 1
    waitmask |= (s2sigmask | timersigmask | resolversigmask | shutdownmask);
d179 3
a181 3
        if (wokemask & s2sigmask)
            PollPort();         /* stuff on the replyport for the s2 devices */
        if (wokemask & resolversigmask)
d183 1
a183 1
        if (wokemask & timersigmask)
d193 1
a193 1
    if (!IsListEmpty((struct List *) & ProtocolList))
d195 1
a195 1
        ipp = (struct ipproto *) ProtocolList.mlh_Head;
d223 1
a223 1
    FreeSignal(shutdownbit);
d259 2
a260 2
    if (MonitorInfo.nmi_Monitor)
        Signal(MonitorInfo.nmi_Monitor, (1 << MonitorInfo.nmi_SigBitNum));
d275 1
a275 1
    if (IsListEmpty((struct List *) & ProtocolList))
d278 1
a278 1
    pr = (struct ipproto *) ProtocolList.mlh_Head;
@


1.11
log
@We can expunge!  Yay!
@
text
@d7 1
a7 1
** $Id: center_custom.c,v 1.10 92/03/05 17:35:15 gregm Exp Locker: gregm $
a71 2
    kprintf("StartLibrary -- A6 is %lx\n",getreg(REG_A6));

a129 4
    kprintf("A6 is %lx\n",getreg(REG_A6));

    kprintf("Library Process: Init.\n");

a137 2
    kprintf("Avail 1: %lx\n", AvailMem(0L));

a139 2
    kprintf("Avail 2: %lx\n", AvailMem(0L));

a143 2
    kprintf("Avail 3: %lx\n", AvailMem(0L));

a145 3
    kprintf("Avail 4: %lx\n", AvailMem(0L));


a148 3
    kprintf("Avail 5: %lx\n", AvailMem(0L));


a152 2
    kprintf("Avail 6: %lx\n", AvailMem(0L));

a159 1
    kprintf("Avail 6.1\n");
a161 1
    kprintf("Avail 6.2\n");
a163 2
    kprintf("StartLibrary -- A6 is %lx\n",getreg(REG_A6));

d167 2
a168 2
    else
        kprintf("What now?  We SHOULD fail.\n");
a178 1
            kprintf("Got a termination signal\n");
a191 1
    kprintf("Deiniting ANMP\n");
a199 1
            kprintf("Deiniting a protocol\n");
a204 1
    kprintf("Deiniting Resolver\n");
a205 1
    kprintf("Deiniting Timer\n");
a206 1
    kprintf("Deiniting ARP\n");
a207 1
    kprintf("Deiniting Route\n");
a208 1
    kprintf("Deiniting Sana II\n");
a209 1
    kprintf("Closing libraries\n");
a213 4
    kprintf("ourseglist = %lx %lx procsegarray=%lx %lx  procseglist=%lx %lx\n",
            ourseglist,BADDR(ourseglist),
            procsegarray,BADDR(procsegarray),
            procseglist,BADDR(procseglist) );
a214 6
    kprintf("our seglist:  -4=%lx 0=%lx 4=%lx\n",
            ((ULONG *)BADDR(ourseglist))[-1],
            ((ULONG *)BADDR(ourseglist))[0],
            ((ULONG *)BADDR(ourseglist))[1] );


a226 2
    kprintf("freeing the library base\n");

a231 2

    kprintf("Aiieeee!  I'm melting ... I'm melting ... \n");
@


1.10
log
@trivial.
@
text
@d7 1
a7 1
** $Id: center_custom.c,v 1.9 92/03/04 16:56:49 gregm Exp Locker: gregm $
d17 1
d39 10
d69 1
a69 1
    ULONG cptags[5];
d72 2
d82 3
a84 1
        cptags[4] = TAG_DONE;
d112 10
d124 4
a127 1
    ULONG waitmask, wokemask;
d130 1
d132 1
a132 1
    waitmask = 0L;
d134 1
a134 1
//    kprintf("Library Process: Init.\n");
d144 1
a144 1
//    kprintf("Avail 1: %lx\n", AvailMem(0L));
d148 1
a148 1
//    kprintf("Avail 2: %lx\n", AvailMem(0L));
d154 1
a154 1
//    kprintf("Avail 3: %lx\n", AvailMem(0L));
d158 1
a158 1
//    kprintf("Avail 4: %lx\n", AvailMem(0L));
d164 1
a164 1
//    kprintf("Avail 5: %lx\n", AvailMem(0L));
d171 1
a171 8
//    kprintf("Avail 6: %lx\n", AvailMem(0L));


    /*
     * if (TRUE) { struct Buffer *br; br = AllocBuffer(10); ( (struct
     * BuffEntry *) (br->buff_list.mlh_Head))->be_length = 10;
     * ip_out(br,0x87070715,84,0,FALSE,0); Delay(60); PollPort(); }
     */
d180 1
d183 1
d186 8
d196 1
a196 3
//    kprintf("Avail 7: %lx\n", AvailMem(0L));

    waitmask |= (s2sigmask | timersigmask | resolversigmask);
d198 1
a198 1
    while (1)
d201 5
a205 1
//        kprintf("Awake!\n");
d217 3
d226 1
d232 1
d234 1
a234 3
    DeinitANMP();
    UDP_Deinit();
    rdp_deinit();
d236 1
d238 1
d240 1
d242 1
d244 22
d267 4
d272 8
d340 1
@


1.9
log
@Moved globals to globals.c; externs for these in externs.h.
@
text
@d7 1
a7 1
** $Id: center_custom.c,v 1.8 92/03/03 14:51:07 kcd Exp Locker: gregm $
d77 1
a77 1
        DOSBase = (struct DOSBase *) OpenLibrary("dos.library", 37);
d107 1
a107 1
    DOSBase = (struct DOSBase *) OpenLibrary("dos.library", 0L);
@


1.8
log
@Added DoResolver() call to main loop.
@
text
@d7 1
a7 1
** $Id: center_custom.c,v 1.7 92/02/29 20:33:05 kcd Exp Locker: kcd $
d23 1
d25 1
a36 15

/* Globals */

struct Library *DOSBase;
struct Library *UtilityBase;
extern ULONG s2sigmask;         /* from s2io.c */
extern struct MinList DeviceList;
extern struct MinList ProtocolList;
extern ULONG timersigmask;
extern struct NIPCMonitorInfo MonitorInfo;
extern struct MsgPort *ResolverPort;
extern ULONG resolversigmask;
BOOL jumpstart;
struct SignalSemaphore openlock;
struct Process *nipcprocess;
@


1.7
log
@Added Resolver calls.
@
text
@d7 1
a7 1
** $Id: center_custom.c,v 1.6 92/02/27 21:03:18 kcd Exp Locker: kcd $
d45 2
d179 1
a179 1
    waitmask |= (s2sigmask | timersigmask);
d187 2
@


1.6
log
@New formatting.  Changed to work with registerized arguments. Now uses
new internal include files.
@
text
@d7 1
a7 1
** $Id$
d169 2
d203 1
d271 1
@


1.5
log
@Added code for monitor calls.
@
text
@d1 9
d11 1
a11 4
/*
 * $Header: APPN:src/nipc/RCS/center_custom.c,v 1.4 92/02/20 14:08:16 gregm Exp Locker: kcd $
 *
 */
d13 2
a14 7

#include <stdio.h>
#include "s2io.h"
#include "memory.h"
#include "ip.h"
#include "rdp.h"
#include "monitor.h"
d17 18
a34 4
#include <exec/exec.h>
#include <exec/ports.h>
#include <proto/dos.h>
#include <proto/exec.h>
d36 1
a36 2
extern void EntryPoint();
struct ExecBase *SysBase = NULL;
d38 3
a40 2
/* externals */
extern ULONG s2sigmask;    /* from s2io.c */
a41 2
struct Buffer *AllocBuffer();
struct BuffEntry *AllocBuffEntry();
a46 4
struct Library *UtilityBase;

void __saveds LibraryProcess();
void HeartBeat();
d57 3
a59 1
void __saveds __asm InitLock(register __a6 struct Library *libbase)
d61 2
a62 2
 InitSemaphore(&openlock);
 jumpstart=FALSE;
d65 3
a67 1
void __saveds __asm StartLibrary(register __a6 struct Library *libbase)
d69 32
a100 2
 ULONG cptags[5];
 struct MsgPort *port;
d102 1
a102 46
 /* Prepare yourself for the TRULY inane - the craziest way possible to get the device
  * pointer into A6 at the start of the new process.
  */

// kprintf("Avail: %lx\n",AvailMem(0L));

 ObtainSemaphore(&openlock);
 if(!jumpstart)
 {

    cptags[0] = NP_Entry;
    cptags[1] = (ULONG)&EntryPoint;
    cptags[2] = NP_Name;
    cptags[3] = (ULONG) "nipc_supervisor";
    cptags[4] = TAG_DONE;

    SysBase = (struct ExecBase *)(*((ULONG *)4));

    port = CreateMsgPort();

    smsg.sm_Msg.mn_ReplyPort = port;
    smsg.sm_Msg.mn_Length = sizeof(struct StartMessage);
    smsg.sm_LibBase = libbase;

    DOSBase = (struct DOSBase *) OpenLibrary("dos.library",37);
    if (!DOSBase) return;

    nipcprocess = (struct Process *) CreateNewProc((struct TagItem *)&cptags);
    CloseLibrary((struct Library *) DOSBase);
//    kprintf("Startup Message: %lx\n",&smsg);
//    kprintf("Library Base: %lx\n",libbase);
    PutMsg(&(nipcprocess->pr_MsgPort),(struct Message *)&smsg);

//    kprintf("StartLibrary: Sent startup message. Waiting for reply. \n");

    WaitPort(port);

//    kprintf("StartLibrary: Got startup message back...cleaning up and exiting. \n");

    GetMsg(port);
    DeleteMsgPort(port);

    // kprintf("Avail A: %lx\n",AvailMem(0L));

    jumpstart = TRUE;
 }
d104 1
a104 1
 ReleaseSemaphore(&openlock);
d106 1
a106 1
}
d108 1
a108 1
void __saveds LibraryProcess()
d110 98
a207 2
ULONG waitmask, wokemask;
struct ipproto *ipp;
d209 1
a209 95

 waitmask = 0L;

// kprintf("Library Process: Init.\n");

 DOSBase = (struct DOSBase *) OpenLibrary("dos.library",0L);
 if (!DOSBase) return;

 UtilityBase = (struct Library *) OpenLibrary("utility.library",0L);
 if (!UtilityBase) return;

// kprintf("Avail 1: %lx\n",AvailMem(0L));

 InitSana2();

// kprintf("Avail 2: %lx\n",AvailMem(0L));

 InitRoute();

 InitARP();

// kprintf("Avail 3: %lx\n",AvailMem(0L));

 InitTimer();

// kprintf("Avail 4: %lx\n",AvailMem(0L));


 NewList( (struct List *) &ProtocolList);
 init_icmp();

// kprintf("Avail 5: %lx\n",AvailMem(0L));


 rdp_init();

// kprintf("Avail 6: %lx\n",AvailMem(0L));


/* if (TRUE)
   {
   struct Buffer *br;
   br = AllocBuffer(10);
   ( (struct BuffEntry *) (br->buff_list.mlh_Head))->be_length = 10;
   ip_out(br,0x87070715,84,0,FALSE,0);
   Delay(60);
   PollPort();
   }
 */

 InitANMP();

/* Everything's initialized.  Set the signal bit for the caller and return */

// kprintf("Library Process: replying to startup message.\n");

 MonitorInfo.nmi_Monitor = NULL;

 ReplyMsg((struct Message *)&smsg);

// Signal(startertask,(1<<starterbit));

// kprintf("Avail 7: %lx\n",AvailMem(0L));

 waitmask |= (s2sigmask | timersigmask);

 while (1)
   {
//   kprintf("Library Process: Waiting.\n");
   wokemask = Wait(waitmask);
   if (wokemask & s2sigmask) PollPort();     /* stuff on the replyport for the s2 devices */
   if (wokemask & timersigmask)
      {
      TimeOut();  /* reset the timer */
      HeartBeat();
      }
   }

/* deinit all protocols */
 if (!IsListEmpty((struct List *) &ProtocolList))
   {
   ipp = (struct ipproto *) ProtocolList.mlh_Head;
   while (ipp->ipproto_link.mln_Succ)
      {
      (*ipp->ipproto_Deinit)();
      ipp = (struct ipproto *) ipp->ipproto_link.mln_Succ;
      }
   }

 DeinitANMP();
 rdp_deinit();
 DeinitTimer();
 DeinitARP();
 DeinitRoute();
 DeinitSana2();
a210 2
 CloseLibrary(UtilityBase);

d213 1
d216 2
a217 1
void ProtocolInput(inpbuff,length,ptype,dev)
d224 2
a225 2
 switch (ptype)
   {
d227 11
a237 11
   case (PACKET_IP):
      ip_in(inpbuff,length,dev);
      break;

   case (PACKET_ARP):
      ARPInput(inpbuff,length,dev);
      break;

   default:
      FreeBuffer(inpbuff);
   }
d239 2
a240 2
 if(MonitorInfo.nmi_Monitor)
     Signal(MonitorInfo.nmi_Monitor,(1 << MonitorInfo.nmi_SigBitNum));
d243 2
d248 17
a264 15
/* go through each of the protocols attached to IP, and enter their
 * timeout routines.  Everyone will get "buzzed" every time the timer.device
 * finishes a request - currently every 0.1 second.
 */
 struct ipproto *pr;

 if (IsListEmpty( (struct List *) &ProtocolList)) return;

 pr = (struct ipproto *) ProtocolList.mlh_Head;

 while (pr->ipproto_link.mln_Succ)
   {
   (*pr->ipproto_Timeout)();
   pr = (struct ipproto *) pr->ipproto_link.mln_Succ;
   }
d266 2
a267 2
 arp_timeout();
 FragmentTimeout();
a269 1

@


1.4
log
@tacked on the ip frag timeout routine in the heartbeat function
@
text
@d3 1
a3 1
 * $Header: APPN:src/nipc/RCS/center_custom.c,v 1.3 92/02/18 12:51:13 kcd Exp Locker: gregm $
d13 1
d31 1
d118 1
a118 1
 kprintf("Library Process: Init.\n");
d171 2
d239 2
@


1.3
log
@Modified library startup mechanism to use a startup message.
@
text
@d3 1
a3 1
 * $Header: APPN:src/libs/nipc.library/RCS/center_custom.c,v 1.2 92/02/16 17:23:07 kcd Exp Locker: kcd $
d257 1
a257 1

@


1.2
log
@Added Semaphore code to StartLibrary.
@
text
@d3 1
a3 1
 * $Header: APPN:src/libs/nipc.library/RCS/center_custom.c,v 1.1 92/02/13 10:00:31 gregm Exp Locker: kcd $
d16 1
d38 7
a44 2
struct Task *startertask;
ULONG starterbit;
d54 2
a55 1
 ULONG cptags[8];
a59 4
 char  address[9];
 char *wadd;
 ULONG tempbase;
 int x;
d71 1
a71 3
    cptags[4] = NP_Arguments;
    cptags[5] = (ULONG) &address;
    cptags[6] = TAG_DONE;
d73 1
a73 8
    wadd = address;
    tempbase = (ULONG) libbase;
    for (x = 0; x < 8; x++)
    {
    *wadd++ = ((tempbase & 0xF)+0x30);
    tempbase = tempbase >> 4;
    }
    address[8]=0;
d75 1
a75 1
    SysBase = (struct ExecBase *)(*((ULONG *)4));
d77 3
a79 2
    startertask = (struct Task *) FindTask(0L);
    starterbit = AllocSignal(-1L);
d86 12
a100 3

    Wait(1 << starterbit);
    FreeSignal(starterbit);
d113 1
d116 2
d166 6
a171 1
 Signal(startertask,(1<<starterbit));
d179 1
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
 * $Header$
d29 2
d40 5
a58 27
 cptags[0] = NP_Entry;
 cptags[1] = (ULONG)&EntryPoint;
 cptags[2] = NP_Name;
 cptags[3] = (ULONG) "nipc_supervisor";
 cptags[4] = NP_Arguments;
 cptags[5] = (ULONG) &address;
 cptags[6] = TAG_DONE;

 wadd = address;
 tempbase = (ULONG) libbase;
 for (x = 0; x < 8; x++)
   {
   *wadd++ = ((tempbase & 0xF)+0x30);
   tempbase = tempbase >> 4;
   }
 address[8]=0;

 SysBase = (struct ExecBase *)(*((ULONG *)4));

 startertask = (struct Task *) FindTask(0L);
 starterbit = AllocSignal(-1L);

 DOSBase = (struct DOSBase *) OpenLibrary("dos.library",37);
 if (!DOSBase) return;

 nipcprocess = (struct Process *) CreateNewProc((struct TagItem *)&cptags);
 CloseLibrary((struct Library *) DOSBase);
d60 3
a62 1
// kprintf("Avail A: %lx\n",AvailMem(0L));
d64 35
d100 1
a100 2
 Wait(1 << starterbit);
 FreeSignal(starterbit);
d123 1
d191 1
@
