head     1.46;
branch   ;
access   ;
symbols  ;
locks    ; strict;
comment  @ * @;


1.46
date     94.02.07.19.53.40;  author kcd;  state Exp;
branches ;
next     1.45;

1.45
date     93.10.20.23.16.47;  author kcd;  state Exp;
branches ;
next     1.44;

1.44
date     93.07.30.18.51.11;  author gregm;  state Exp;
branches ;
next     1.43;

1.43
date     93.03.02.16.18.35;  author gregm;  state Exp;
branches ;
next     1.42;

1.42
date     93.01.05.13.38.47;  author gregm;  state Exp;
branches ;
next     1.41;

1.41
date     93.01.05.12.31.30;  author gregm;  state Exp;
branches ;
next     1.40;

1.40
date     92.12.16.14.43.11;  author kcd;  state Exp;
branches ;
next     1.39;

1.39
date     92.11.02.13.57.14;  author kcd;  state Exp;
branches ;
next     1.38;

1.38
date     92.09.03.16.26.12;  author kcd;  state Exp;
branches ;
next     1.37;

1.37
date     92.08.19.16.11.46;  author kcd;  state Exp;
branches ;
next     1.36;

1.36
date     92.08.13.17.54.01;  author kcd;  state Exp;
branches ;
next     1.35;

1.35
date     92.07.31.16.14.52;  author kcd;  state Exp;
branches ;
next     1.34;

1.34
date     92.07.30.20.24.36;  author kcd;  state Exp;
branches ;
next     1.33;

1.33
date     92.07.30.16.55.45;  author gregm;  state Exp;
branches ;
next     1.32;

1.32
date     92.07.29.13.39.26;  author gregm;  state Exp;
branches ;
next     1.31;

1.31
date     92.07.13.16.48.01;  author gregm;  state Exp;
branches ;
next     1.30;

1.30
date     92.07.13.16.45.06;  author gregm;  state Exp;
branches ;
next     1.29;

1.29
date     92.06.27.17.22.59;  author kcd;  state Exp;
branches ;
next     1.28;

1.28
date     92.06.26.11.32.18;  author gregm;  state Exp;
branches ;
next     1.27;

1.27
date     92.06.21.14.08.27;  author gregm;  state Exp;
branches ;
next     1.26;

1.26
date     92.06.19.11.01.13;  author kcd;  state Exp;
branches ;
next     1.25;

1.25
date     92.06.18.12.16.48;  author gregm;  state Exp;
branches ;
next     1.24;

1.24
date     92.06.11.10.44.29;  author gregm;  state Exp;
branches ;
next     1.23;

1.23
date     92.06.08.10.07.26;  author kcd;  state Exp;
branches ;
next     1.22;

1.22
date     92.06.04.22.22.17;  author kcd;  state Exp;
branches ;
next     1.21;

1.21
date     92.05.22.15.35.59;  author gregm;  state Exp;
branches ;
next     ;


desc
@The nipc implementation of RDP.
@


1.46
log
@Fixed a nasty bug introduced when transactions gained the ability
to pass in Buffer structures.  The RDP timeout code was assuming that
if more than one BuffEntry existed in a Buffer, then the first BuffEntry
must be an IP header.  Now there's a kludge^H^H^H^H^H^Hfix to have it
make sure that it's something other than an RDP header before removing
the first entry.
@
text
@/**************************************************************************
**
** rdp.c        - RDP Protocol routines for nipc.library
**
** Copyright 1992, Commodore-Amiga, Inc.
**
** $Id: rdp.c,v 1.45 93/10/20 23:16:47 kcd Exp Locker: kcd $
**
***************************************************************************

/*------------------------------------------------------------------------*/

//#define NOBUFFSHARING           1

#define max(a,b) ((a > b) ? a : b)

#include "nipcinternal.h"


#include <clib/exec_protos.h>
#include <clib/dos_protos.h>

#include "nipcinternal_protos.h"

#include <pragmas/exec_pragmas.h>
#include <pragmas/dos_pragmas.h>
#include "externs.h"
#include <pragmas/timer_pragmas.h>
#include <clib/timer_protos.h>


#define MAXSEGS 1
#define MAX_ACK_DIFF 3		/* Max number of non-acked packets to allow before
				   forcing an ACK packet */
#define MAXSIZE 8192

#define MIN(x, y) ((x) < (y) ? (x):(y))

/* #define DEBUGMSGS */
#define RETRIES  8
#define TIMEOUT  2             /* Temporary until I can work in an adaptive (2*10) timeout */
#define CONNTIME 1             /* 10ths of a second between connection state
                                 * timeouts */
#define TOTALALLOWED 10         /* # of times we'll send connection
                                 * retranmissions before giving up */

/*------------------------------------------------------------------------*/
/*
 * RDP
 *
 * - Piggybacked/delayed ACKS would be nice to save on net bandwidth.  Do this
 * if we get approval for ANMP/RDP/IP/SANAII set
 *
 * - The multiple spawning mechanism for the well-known entity resolver should
 * also time out dead connections.
 *
 */

/* Watch out for sequence # wraparound!! */

/*------------------------------------------------------------------------*/

BOOL rdp_init()
{
    register struct NBase *nb = gb;
//    ULONG eclkdata[2];

//    ReadEClock( (struct EClockVal *) &eclkdata);

//    gb->RDPPorts = (UWORD) ((UWORD *)&eclkdata[1])[1];
    gb->RDPPorts = 1024L;

    InitSemaphore(&nb->RDPCLSemaphore);     /* Init the semaphore */
    NewList((struct List *) & gb->RDPConnectionList);       /* Init the list */

    gb->RDPProto.ipproto_ProtocolNumber = 26;       /* Set up the ipproto
                                                 * structure */
    gb->RDPProto.ipproto_Input = &rdp_input;
    gb->RDPProto.ipproto_Deinit = &rdp_deinit;
    gb->RDPProto.ipproto_Timeout = &rdp_timeout;
    AddHead((struct List *) & nb->ProtocolList, (struct Node *) & nb->RDPProto);        /* Announce us to IP */

    return(TRUE);

}

/*------------------------------------------------------------------------*/

void rdp_deinit()
{
        register struct NBase *nb = gb;

    Remove((struct Node *) & nb->RDPProto);
    ObtainSemaphore(&nb->RDPCLSemaphore);
    while (!(IsListEmpty( (struct List *) &nb->RDPConnectionList)))
    {
        struct RDPConnection *rc;
        rc = (struct RDPConnection *) gb->RDPConnectionList.mlh_Head;
        rc->conn_State = STATE_CLOSE;  /* keep it from trying to send RST's */
        CloseConnection(rc);
    }
    ReleaseSemaphore(&nb->RDPCLSemaphore);
}


/*------------------------------------------------------------------------*/

//
// From our table, given the speed of the device, make a guess as to the correct
// window size.  (We need a SANA-2 field for devices that can describe themselves
// in a level of "lossy-ness" sooooo badly!  ARCNet almost never loses a packet;
// AmokNet loses about 1/4th of them.
//
int RDPFindWindow(struct sanadev *sd)
{
    struct initdataform
    {
        LONG BPSRate;
        LONG WindowSize;
    };

    int x;
    struct initdataform initdata[]={9600,3,30000,3,60000,3,100000,4,500000,5,2000000,6,10000000,8,-1,16};

    x = 0;
    while (initdata[x].BPSRate > 0)
    {
        if (sd->sanadev_BPS <= initdata[x].BPSRate)
            return(initdata[x].WindowSize);
        x++;
    }
    return(32); // Max.  For VERY high speed thingys.

}

/*------------------------------------------------------------------------*/



void rdp_ack_timeout()
{
    register struct NBase *nb = gb;

    struct RDPConnection *conn;

    ObtainSemaphore(&nb->RDPCLSemaphore);
    conn = (struct RDPConnection *) gb->RDPConnectionList.mlh_Head;
    while (conn->conn_link.mln_Succ)
    {
        if (conn->conn_Flags & CONN_UNSENTACK)
        {
            Forbid();
            conn->conn_Flags &= ~CONN_UNSENTACK;
            Permit();
            SendFlags(conn,RDPF_ACK);
        }

        conn = (struct RDPConnection *) conn->conn_link.mln_Succ;
    }
    ReleaseSemaphore(&nb->RDPCLSemaphore);
}


/*------------------------------------------------------------------------*/

void rdp_timeout()
{
        register struct NBase *nb = gb;

    struct RDPConnection *conn;
    struct retransmit *rexmit;
    BOOL rig;


    /*
     * Run through all of the open connections, and decrement the counts for
     * timeouts
     */
    ObtainSemaphore(&nb->RDPCLSemaphore);
    conn = (struct RDPConnection *) gb->RDPConnectionList.mlh_Head;
    while (conn->conn_link.mln_Succ)
    {
        rig = FALSE;
        /* Do any connection timeouts here */
        if ((conn->conn_State != STATE_OPEN) && (conn->conn_State != STATE_CLOSE) &&
            (conn->conn_State != STATE_LISTEN))
        {
            conn->conn_LastConnTime--;      /* dec countdown */
            if (!conn->conn_LastConnTime)   /* when it reaches 0 */
            {
                conn->conn_ConnRetransmits++;
                if ((conn->conn_ConnRetransmits == TOTALALLOWED) || (conn->conn_State == STATE_TIMEOUT))
                {
                    SendFlags(conn, RDPF_RST);
                    conn->conn_State = STATE_CLOSE;
                    conn = (struct RDPConnection *) conn->conn_link.mln_Succ;
                    ObtainSemaphore(&nb->RDPCLSemaphore);
                    /* Don'tcha just LOVE C when the code gets like the next line? */
                    if ((*((struct RDPConnection *)conn->conn_link.mln_Pred)->conn_Status) ((struct RDPConnection *)conn->conn_link.mln_Pred))
                    /* In case I forget ... the above line is basically just (*conn->conn_Status)(conn); except dealing with the conn one back on the list from conn */
                    {
                        ReleaseSemaphore(&nb->RDPCLSemaphore);
                        continue;
                    }
                    ReleaseSemaphore(&nb->RDPCLSemaphore);
                }
                else
                    SendFlags(conn, conn->conn_LastFlags);
            }
        }
        if (conn->conn_link.mln_Succ)
        {
            /* Retransmission timeouts */
            ObtainSemaphore(&(conn->conn_WriteListSemaphore));
            rexmit = (struct retransmit *) conn->conn_DataListW.mlh_Head;
            while (rexmit->xmit_link.mln_Succ)
            {
                /* Decrement the countdown */
                rexmit->xmit_countdown--;
                /* If we reach zero,  consider retransmitting */
                if (!rexmit->xmit_countdown)
                {
                    /*
                     * decrement the retry count.  If 0, free this entry,
                     * and give up on it
                     */
                    rexmit->xmit_retrycount--;
                    if ((!rexmit->xmit_retrycount) || (rexmit->xmit_seqnum < conn->conn_SendOldest))
                    {
                        struct retransmit *temp;
                        BOOL closeit = FALSE;
                        temp = rexmit;
                        if (!rexmit->xmit_retrycount)
                        {
                          /*  struct rdphdr *rr; */
                          /*  struct BuffEntry *xbe; */
                            closeit = TRUE;
                          /*  rr = (struct rdphdr *) BuffPointer(temp->xmit_data,0L,&xbe); */
                        }
                        rexmit = (struct retransmit *) rexmit->xmit_link.mln_Pred;
                        Remove((struct Node *) temp);
                        temp->xmit_data->buff_refcnt--;
#if WHAT_THE_FUCK // ????
                        if (TRUE)
                        {
                            struct rdphdr *rr;
                            struct BuffEntry *xbe;
                            rr = (struct rdphdr *) BuffPointer(temp->xmit_data,sizeof(struct iphdr),&xbe);
                        }
#endif
                        FreeBuffer(temp->xmit_data);
                        FreeMem(temp, sizeof(struct retransmit));
                        /*
                         * This has gotten out of hand - force the
                         * connection closed
                         */
                        if (closeit)
                        {
                            SendFlags(conn, RDPF_RST);
                            conn->conn_State = STATE_CLOSE;
                            conn = (struct RDPConnection *) conn->conn_link.mln_Succ;
                            ObtainSemaphore(&nb->RDPCLSemaphore);                       /* Isn't this redundant?  Don't we already have it locked? */
                            rig = (*((struct RDPConnection *)conn->conn_link.mln_Pred)->conn_Status) ((struct RDPConnection *)conn->conn_link.mln_Pred);
                            ReleaseSemaphore(&nb->RDPCLSemaphore);                      /* See above */
                            if (!rig)
                                conn = (struct RDPConnection *) conn->conn_link.mln_Pred; /* If not deleted, step back ... jeeze, how fucking ugly.  I need to recode this whole damned thing. */
                            break;
                        }
                    }
                    else
                    {
                        if (conn->conn_State == STATE_OPEN)
                        {
                            /* We have to yank the IP header off the front of this thing, since one will have
                               already been tacked on by now. */

#ifndef NOBUFFSHARING
                            if(rexmit->xmit_data->buff_refcnt == 1) /* Make sure it's not in ARP's queue... */
                            {

                                struct BuffEntry *bufe;

				bufe = (struct BuffEntry *)rexmit->xmit_data->buff_list.mlh_Head;
				if(bufe->be_link.mln_Succ && (bufe->be_length != sizeof(struct rdphdr)))
                                {
                                    Remove((struct Node *)bufe);
                                    FreeBuffEntry(bufe);
                                }
                                ip_sendsrc(rexmit->xmit_data /* rcpy */, conn->conn_OurAddress, rexmit->xmit_ToAddress, 26);
                            }

#else
                            if (TRUE)
                            {
                                struct Buffer *cb;
                                cb = CloneBuffer(rexmit->xmit_data);
                                ip_sendsrc(cb, conn->conn_OurAddress, rexmit->xmit_ToAddress, 26);
                            }
#endif
                        }
                        rexmit->xmit_countdown = TIMEOUT + conn->conn_MTUDelay;
                    }
                }
                rexmit = (struct retransmit *) rexmit->xmit_link.mln_Succ;
            }
            if (!rig)   /* As long as the connection wasn't deleted, release the semaphore, and skip to the next connection */
            {
                ReleaseSemaphore(&(conn->conn_WriteListSemaphore));
                conn = (struct RDPConnection *) conn->conn_link.mln_Succ;
            }
        }
    }
    ReleaseSemaphore(&nb->RDPCLSemaphore);

    return;
}

/*------------------------------------------------------------------------*/

void rdp_input(buff, length, dev)
struct Buffer *buff;
ULONG length;
struct sanadev *dev;
{
    register struct NBase *nb = gb;

    struct BuffEntry *be;
    struct rdphdr *r;
    struct iphdr *ip;
    ULONG source_address, destination_address;
    struct RDPConnection *conn;
    UWORD oldchecksum;

    be = (struct BuffEntry *) buff->buff_list.mlh_Head;
    ip = (struct iphdr *) ((ULONG) be->be_data + (ULONG) be->be_offset);
    r = (struct rdphdr *) ((ULONG) ip + (ULONG) sizeof(struct iphdr));

    source_address = ip->iph_SrcAddr;
    destination_address = ip->iph_DestAddr;

    /* If this isn't a packet of the version we know about, forget it */
    if (r->rdp_Version != RDP_VERSION)
    {
        FreeBuffer(buff);
        return;
    }


    /* Check to see if the checksum is valid */
    /* FILL THIS CODE IN */
    oldchecksum = r->rdp_Checksum;
    r->rdp_Checksum = 0;
    if (oldchecksum != (UWORD) CalcChecksum((UBYTE *) r, (ip->iph_Length - sizeof(struct iphdr)), 0))
    {
        FreeBuffer(buff);       /* Bad checksum -- drop the packet */
        return;
    }

    /* Check to see if there's a connection in our list that this matches */
    ObtainSemaphore(&nb->RDPCLSemaphore);
    conn = (struct RDPConnection *) gb->RDPConnectionList.mlh_Head;
    while (conn->conn_link.mln_Succ)
    {
        struct RDPConnection *nxt;
        nxt = (struct RDPConnection *) conn->conn_link.mln_Succ;
        if ((conn->conn_OurPort == r->rdp_DestPort) &&
            (conn->conn_TheirPort == r->rdp_SrcPort) &&
            (conn->conn_TheirAddress == source_address))
        {
            ULONG size;
            if (StateMachine(conn, r->rdp_Flags, r, destination_address, source_address))
            {
                size = ip->iph_Length - sizeof(struct iphdr) - r->rdp_HeaderLength;
                if (r->rdp_Flags & RDPF_SYN)
                    size -= 6;
                if (size)
                    PacketInput(conn, buff);
                else
                    FreeBuffer(buff);
            }
            else
            {
                conn = (struct RDPConnection *) nxt->conn_link.mln_Pred;
//                continue;
                FreeBuffer(buff);
            }
            break;
        }
        conn = nxt;
    }
    if (!conn->conn_link.mln_Succ)      /* If no connection exists */
    {
        ReleaseSemaphore(&nb->RDPCLSemaphore);
        if (r->rdp_Flags & RDPF_SYN)    /* They're trying to create a
                                         * connection */
        {
            struct RDPConnection *rconn;
            /*
             * Check to see if there's someone on that port - who isn't
             * connected
             */
            ObtainSemaphore(&nb->RDPCLSemaphore);
            rconn = (struct RDPConnection *) gb->RDPConnectionList.mlh_Head;
            while (rconn->conn_link.mln_Succ)
            {
                struct RDPConnection *nxt;
                nxt = (struct RDPConnection *) rconn->conn_link.mln_Succ;
                if ((rconn->conn_State == STATE_LISTEN) &&
                    (rconn->conn_OurPort == r->rdp_DestPort))
                {
                    if (rconn->conn_Flags & CONN_MULTIPLE)
                    {
                        rconn = OpenPassive(rconn->conn_OurPort, rconn->conn_DataIn, rconn->conn_Status);
                        if (!rconn)
                        {
                            FreeBuffer(buff);
                            break;
                        }
                    }
                    rconn->conn_TheirAddress = source_address;  /* Keep track of who
                                                                 * this is! */
                    rconn->conn_TheirPort = r->rdp_SrcPort;     /* ditto */


                    if (!StateMachine(rconn, r->rdp_Flags, r, destination_address,source_address))
                    {
//                        rconn = nxt;
//                        continue;
                    }
                    FreeBuffer(buff);
                    break;
                }
                rconn = nxt;
            }
            ReleaseSemaphore(&nb->RDPCLSemaphore);
            if (!rconn->conn_link.mln_Succ)
            {
                struct RDPConnection tc;                       /* Reset them, so that they     */
                if (!(r->rdp_Flags & RDPF_RST))
                {
                    tc.conn_TheirPort = r->rdp_SrcPort;             /* stop trying immediately.     */
                    tc.conn_OurPort = r->rdp_DestPort;
                    tc.conn_TheirAddress = source_address;
                    tc.conn_OurAddress = destination_address;
                    tc.conn_SendNxt = r->rdp_AckNum+1;
                    SendFlags(&tc,RDPF_RST);
                }
                FreeBuffer(buff);
            }
        }
        else
        {
            struct RDPConnection tc;                       /* Reset them, so that they     */
            if (!(r->rdp_Flags & RDPF_RST))
            {
                tc.conn_TheirPort = r->rdp_SrcPort;             /* stop trying immediately.     */
                tc.conn_OurPort = r->rdp_DestPort;
                tc.conn_TheirAddress = source_address;
                tc.conn_OurAddress = destination_address;
                SendFlags(&tc,RDPF_RST);
            }
            FreeBuffer(buff);
        }
    }
    else
        ReleaseSemaphore(&nb->RDPCLSemaphore);

}

/*------------------------------------------------------------------------*/

/*
 * The RDP Connection state machine
 */

BOOL StateMachine(rc, flags, packet, ipdest,ipsrc)
struct RDPConnection *rc;       /* The connection in question */
UBYTE flags;                    /* The flag bits that describe the current
                                 * action */
struct rdphdr *packet;
ULONG ipdest, ipsrc;
{
    register struct NBase *nb = gb;

    UBYTE oldstate;



    if (flags & RDPF_SYN)
    {
        rc->conn_OurAddress = ipdest;
    }

    oldstate = rc->conn_State;  /* So we can see if the state changed */

    if (flags & RDPF_RST)
    {
        if (packet->rdp_SeqNum != (rc->conn_Current+1))
            return(TRUE);
        rc->conn_State = STATE_CLOSE;
    }

    switch (rc->conn_State)
    {
        case STATE_CLOSED:
            if (flags)
            {
                SendFlags(rc, RDPF_RST);        /* If we get ANYTHING while
                                                 * in this state, RESET
                                                 * ourselves! */
            }
            break;
        case STATE_LISTEN:
            if (flags & RDPF_SYN)
            {
                struct NIPCRoute *route;
                struct sanadev *sd;
                route = Route(ipsrc,TRUE);
                if (route)
                {
                    sd = route->nr_Device;  /* Find device it goes out on  ... */

                    rc->conn_RecvMax = RDPFindWindow(sd);

                    // stick with single-packet sizes for slow devices.
                    if (sd->sanadev_BPS < 1000000)
                       rc->conn_RecvMaxSize = ((sd->sanadev_MTU)-(sizeof(struct iphdr)+sizeof(struct rdphdr)));
                    else
                       rc->conn_RecvMaxSize = ((sd->sanadev_MTU)-(sizeof(struct iphdr)+sizeof(struct rdphdr)))*3;

                    rc->conn_InitialBPS = DivSASSucks(sd->sanadev_BPS,10);

                    if (sd->sanadev_BPS < 655360) /* If greater, time is trivial */
                        if (sd->sanadev_BPS > 65535) /* handle special cased, so we generate DIVS/DIVU not SAS divide code */
                        {                            /* If divisor > 16 bits, div by 16 first */
                            UWORD bps;
                            bps = (UWORD) ((ULONG) sd->sanadev_BPS >> 4);
                            if (bps)
                                rc->conn_TimeoutDelay = (UWORD) ( (ULONG)  40960 / bps ) < 1;
                        }
                        else
                            if (sd->sanadev_BPS)
                                rc->conn_TimeoutDelay = DivSASSucks(655360,sd->sanadev_BPS) < 1;
                    if (sd->sanadev_MTU < 65536)
                        rc->conn_MTUDelay = (rc->conn_TimeoutDelay >> 3); // div 3 because AMP dumps 8K chunks to RDP; time for 64K >> 3 = time for 8K
                }

                SendFlags(rc, RDPF_SYN | RDPF_ACK);
                rc->conn_State = STATE_RCVD;
                ReadEClock( (struct EClockVal *)&rc->conn_TimeStamp);

            }
            break;
        case STATE_SENT:
            if ((flags & (RDPF_SYN | RDPF_ACK)) == (RDPF_SYN | RDPF_ACK))
            {
                ULONG tmpts[2], freq;
                SendFlags(rc, RDPF_ACK);
                rc->conn_State = STATE_OPEN;
                freq = ReadEClock( (struct EClockVal *) &tmpts);
                if (tmpts[1] < rc->conn_TimeStamp[1])
                     tmpts[0]--;

                tmpts[1] = tmpts[1] - rc->conn_TimeStamp[1];
                tmpts[0] = tmpts[0] - rc->conn_TimeStamp[0];

                rc->conn_TimeStamp[0] = Div64by32(tmpts[0],tmpts[1],freq/1024);  /* Seconds*1024 */

            }
            else if (flags & RDPF_SYN)
            {
                SendFlags(rc, RDPF_SYN);
                rc->conn_State = STATE_RCVD;
                ReadEClock( (struct EClockVal *)&rc->conn_TimeStamp);

            }
            break;
        case STATE_RCVD:
            if (flags & RDPF_ACK)
            {
                ULONG tmpts[2], freq;
                rc->conn_State = STATE_OPEN;

                freq = ReadEClock( (struct EClockVal *) &tmpts);
                if (tmpts[1] < rc->conn_TimeStamp[1])
                    tmpts[0]--;

                tmpts[1] = tmpts[1] - rc->conn_TimeStamp[1];
                tmpts[0] = tmpts[0] - rc->conn_TimeStamp[0];

                rc->conn_TimeStamp[0] = Div64by32(tmpts[0],tmpts[1],freq/1024);  /* Seconds*1024 */
            }
            break;
        case STATE_OPEN:
            if (flags & RDPF_RST)
            {
                rc->conn_State = STATE_CLOSE;
            }
            break;

    }


    /* If they give us an ACK, log the ack # */
    if (flags & RDPF_ACK)
    {
        if ((packet->rdp_AckNum + 1) > rc->conn_SendOldest)
        {
            rc->conn_SendOldest = (packet->rdp_AckNum + 1);
            Forbid();
            if (rc->conn_Flags & CONN_WINDOWSIGNAL)
                Signal(rc->conn_WakeTask,(1 << rc->conn_WakeBit));
            Permit();
            /*
             * Now, filter out all retransmission saves that fall below
             * SendOldest
             */
            /* fill me in */
        }
    }

    /* If we have a SYN, get the SYN data too */

    if (flags & RDPF_SYN)
    {
        struct rdphdrSYN *rs;
        rs = (struct rdphdrSYN *) packet;
        rc->conn_SendMax = MIN(rs->rsyn_MaxOutstanding,rc->conn_RecvMax);
        rc->conn_SendMaxSize = MIN(rc->conn_RecvMaxSize,rs->rsyn_MaxSegment);
        rc->conn_InitRecv = packet->rdp_SeqNum + 1;
        rc->conn_SeqDelivered = packet->rdp_SeqNum;
        rc->conn_OurAddress = ipdest;
    }

    if (rc->conn_State != oldstate)     /* Let them know that this connection
                                         * status has changed */
        if (rc->conn_Status)
        {
            BOOL wasdead;
//            if (rc->conn_State == STATE_CLOSE)
//                wasdead = TRUE;
            ObtainSemaphore(&nb->RDPCLSemaphore);   /* This ought to be redundant - anyone who calls StateMachine() should already have the list locked */
            wasdead = (*rc->conn_Status)(rc);
            ReleaseSemaphore(&nb->RDPCLSemaphore);  /* Ditto */
//            if (wasdead)
//                return(FALSE);
            return((BOOL)!wasdead);
        }

    /* If we enter close-wait, perhaps a timer should start? */
    return(TRUE);

}

/*------------------------------------------------------------------------*/

/*
 * SendFlags(connection,flags); struct RDPConnection *connection; UBYTE
 * flags;
 *
 * This function is designed _entirely_ to provide for creating plain (dataless)
 * packets with certain flags set - like ACK, SYN, EAK, RST, NUL. It gains
 * all important knowledge of values for ACK fields and the like from the the
 * RDPConnection structure passed with the flag bitmap.
 */

void SendFlags(c, flags)
struct RDPConnection *c;
UBYTE flags;
{
    struct Buffer *fb;
    struct BuffEntry *fbe;
    struct rdphdr *r;
    ULONG headersize;

    headersize = sizeof(struct rdphdr);
    if (flags & RDPF_SYN)
        headersize += 6;
    if (flags & RDPF_EAK)
        headersize += 0;        /* This is dynamic FIXME later */
    fb = AllocBuffer(headersize);
    if (!fb)
        return;
    fbe = (struct BuffEntry *) fb->buff_list.mlh_Head;
    fbe->be_length = headersize;
    r = (struct rdphdr *) fbe->be_data;
    r->rdp_Flags = flags;
    r->rdp_Version = 2;
    r->rdp_HeaderLength = sizeof(struct rdphdr);
    r->rdp_SrcPort = c->conn_OurPort;
    r->rdp_DestPort = c->conn_TheirPort;
    Forbid();
    if (flags & RDPF_SYN)
    {
        c->conn_SendNxt = 1;
        r->rdp_SeqNum = 0;
    }
    else
        r->rdp_SeqNum = c->conn_SendNxt;
    if (flags & !(RDPF_SYN | RDPF_NUL))
        r->rdp_SeqNum--;
    Permit();
    r->rdp_AckNum = c->conn_Current;
    c->conn_LastAcked = c->conn_Current;
    if (flags & RDPF_SYN)
    {
        struct rdphdrSYN *rs;

        rs = (struct rdphdrSYN *) r;
        rs->rsyn_MaxOutstanding = c->conn_RecvMax;
        rs->rsyn_MaxSegment = c->conn_RecvMaxSize;  /* Figure this dynamically, based on the interface */
        rs->rsyn_Options = 0;
    }

    /*
     * if (flags & RDPF_EAK) { // build the eack list }
     *
     */
    r->rdp_Checksum = 0;
    r->rdp_Checksum = CalcChecksumBuffer(fb);

    c->conn_LastFlags = flags;
    c->conn_LastConnTime = CONNTIME;

    ip_sendsrc(fb, c->conn_OurAddress, c->conn_TheirAddress, 26);

}

/*------------------------------------------------------------------------*/

/*
 * PacketInput(connection,buffer) struct RDPConnection *connection; struct
 * Buffer *buffer;
 *
 * Queues up appropriate input on the appropriate connection lists
 */

void PacketInput(c, b)
struct RDPConnection *c;
struct Buffer *b;
{
        register struct NBase *nb = gb;

    UWORD pack;

    ObtainSemaphore(&(c->conn_ReadListSemaphore));
    AddTail((struct List *) & (c->conn_DataListR), (struct Node *) & (b->buff_link));
    c->conn_Current = FindSequential(c);

    Forbid();
    if((c->conn_Current - c->conn_LastAcked) >= max(1,(c->conn_RecvMax >> 1)))
        SendFlags(c, RDPF_ACK);
    else
        c->conn_Flags |= CONN_UNSENTACK;
    Permit();


    /*
     * Go through the list, and return all packets that are now between the
     * range of c->conn_SeqDelivered and c->conn_Current
     */

    for (pack = (c->conn_SeqDelivered + 1); pack <= c->conn_Current; pack++)
    {
        struct Buffer *bb;
        struct Buffer *tmpb;
        bb = (struct Buffer *) c->conn_DataListR.mlh_Head;
        while (bb->buff_link.mln_Succ)
        {
            struct rdphdr *rr;
            struct iphdr *ip;
            struct BuffEntry *bex;
            bex = (struct BuffEntry *) bb->buff_list.mlh_Head;
            ip = (struct iphdr *) ((ULONG) bex->be_data + (ULONG) bex->be_offset);
            rr = (struct rdphdr *) ((ULONG) ip + (ULONG) sizeof(struct iphdr));
            if (rr->rdp_SeqNum < pack)  /* Free any that're redundant */
            {
                tmpb = (struct Buffer *) bb->buff_link.mln_Pred;
                Remove((struct Node *) &(bb->buff_link));
                FreeBuffer(bb);
                bb = tmpb;
            }
            else
            {
                if (rr->rdp_SeqNum == pack) /* Return the proper packet
                                             * to the caller */
                {
                    tmpb = (struct Buffer *) bb->buff_link.mln_Pred;        /* Pull it safely from
                                                                             * the list */
                    Remove((struct Node *) & (bb->buff_link));
                    c->conn_SeqDelivered = pack;    /* Update the largest
                                                     * delivered # */
                    bex->be_offset = (sizeof(struct rdphdr) + sizeof(struct iphdr));
                    bex->be_length -= bex->be_offset;
                    if (c->conn_DataIn)
                    {
                        ObtainSemaphore(&nb->RDPCLSemaphore);
                        (*c->conn_DataIn) (c, bb);  /* Send it back to the
                                                     * opener */
                        ReleaseSemaphore(&nb->RDPCLSemaphore);
                        break; /* NEW */
                    }
                    bb = tmpb;
                }
            }
            bb = (struct Buffer *) bb->buff_link.mln_Succ;
        }
    }
    ReleaseSemaphore(&(c->conn_ReadListSemaphore));
}

/*------------------------------------------------------------------------*/

/*
 * UWORD FindSequential(connection)
 *
 * Finds the top sequence # of packets we have (in sequence) in the list
 *
 */

UWORD FindSequential(c)
struct RDPConnection *c;
{

    UWORD curseq;
    struct Buffer *b;

    curseq = c->conn_SeqDelivered + 1;

    /* Search the list for a packet with this sequence # */
    if (!c->conn_DataListR.mlh_Head->mln_Succ)
    {
        return (curseq);
    }

    while (TRUE)
    {
        b = (struct Buffer *) c->conn_DataListR.mlh_Head;
        while (b->buff_link.mln_Succ)
        {
            struct BuffEntry *be;
            struct iphdr *ip;
            struct rdphdr *r;
            be = (struct BuffEntry *) b->buff_list.mlh_Head;
            ip = (struct iphdr *) ((ULONG) be->be_data + (ULONG) be->be_offset);
            r = (struct rdphdr *) ((ULONG) ip + (ULONG) sizeof(struct iphdr));
            if (r->rdp_SeqNum == curseq)
            {
                curseq++;
                break;
            }
            b = (struct Buffer *) b->buff_link.mln_Succ;
        }
        if (!b->buff_link.mln_Succ)
            break;
    }
    curseq--;
    return (curseq);
}

/*------------------------------------------------------------------------*/

/*
 * connection = OpenActive(IP Address, port #, DataIn, Status, signal);
 *
 * Open an active RDP connection
 *
 */

struct RDPConnection *OpenActive(address, port, DataIn, Status)
ULONG address;
ULONG port;
RDP_DATA DataIn;
RDP_STATUS Status;
{
    register struct NBase *nb = gb;
    struct sanadev *sd;
    struct RDPConnection *c;
    struct NIPCRoute *route;

    c = (struct RDPConnection *) AllocMem(sizeof(struct RDPConnection), MEMF_CLEAR | MEMF_PUBLIC);
    if (!c)
        return ((struct RDPConnection *) 0L);

    c->conn_WakeBit = -1;
    c->conn_DataIn = DataIn;
    c->conn_Status = Status;
    /*
     * c->conn_WakeBit = signalbit; c->conn_WakeTask = FindTask(0L);
     */
    c->conn_State = STATE_SENT;

    c->conn_TheirAddress = address;
    c->conn_TheirPort = port;
    c->conn_LastConnTime = CONNTIME;
    route = Route(address, TRUE);

    if(!route)
    {
        FreeMem(c,sizeof(struct RDPConnection));
        return((struct RDPConnection *)NULL);
    }

    c->conn_OurAddress = route->nr_Device->sanadev_IPAddress;
    c->conn_RecvMax = RDPFindWindow(route->nr_Device);

    if (route->nr_Device->sanadev_BPS < 1000000)
        c->conn_RecvMaxSize = ((route->nr_Device->sanadev_MTU)-(sizeof(struct iphdr)+sizeof(struct rdphdr)));
    else
        c->conn_RecvMaxSize = ((route->nr_Device->sanadev_MTU)-(sizeof(struct iphdr)+sizeof(struct rdphdr)))*3;

    Forbid();
    c->conn_OurPort = gb->RDPPorts++;
    if (gb->RDPPorts == 0)
        gb->RDPPorts = 1024;
    Permit();

    InitSemaphore(&c->conn_ReadListSemaphore);
    InitSemaphore(&c->conn_WriteListSemaphore);
    InitSemaphore(&c->conn_InSema);
    NewList((struct List *) & c->conn_DataListR);
    NewList((struct List *) & c->conn_DataListW);
    NewList((struct List *) & c->conn_InList);  /* for amp */


    ObtainSemaphore(&nb->RDPCLSemaphore);
    AddTail((struct List *) & nb->RDPConnectionList, (struct Node *) & (c->conn_link));
    ReleaseSemaphore(&nb->RDPCLSemaphore);

    if (route)
    {
        sd = route->nr_Device;  /* Find device it goes out on  ... */

        c->conn_InitialBPS = DivSASSucks(sd->sanadev_BPS,10);

        if (sd->sanadev_BPS < 655360) /* If greater, time is trivial */
            if (sd->sanadev_BPS > 65535) /* handle special cased, so we generate DIVS/DIVU not SAS divide code */
            {                            /* If divisor > 16 bits, div by 16 first */
                UWORD bps;
                bps = (UWORD) ((ULONG) sd->sanadev_BPS >> 4);
                if (bps)
                    c->conn_TimeoutDelay = (UWORD) ( (ULONG)  40960 / bps ) < 1;
            }
            else
                if (sd->sanadev_BPS)
                    c->conn_TimeoutDelay = DivSASSucks(655360,sd->sanadev_BPS) < 1;
        if (sd->sanadev_MTU < 65536)
            c->conn_MTUDelay = (c->conn_TimeoutDelay >> 3); // div 3 because AMP dumps 8K chunks to RDP; time for 64K >> 3 = time for 8K
    }

    SendFlags(c, RDPF_SYN);
    ReadEClock( (struct EClockVal *)&c->conn_TimeStamp);


    return (c);
}


/*------------------------------------------------------------------------*/

/*
 * connection = OpenPassive(port);
 *
 * struct RDPConnection *OpenPassive(UWORD);
 *
 * port - either the port number you require, or -1 to allow one to be picked
 * for you.
 */

struct RDPConnection *OpenPassive(reqport, DataIn, Status)
ULONG reqport;
RDP_DATA DataIn;
RDP_STATUS Status;
{
        register struct NBase *nb = gb;
    struct RDPConnection *c;
    c = (struct RDPConnection *) AllocMem(sizeof(struct RDPConnection), MEMF_CLEAR | MEMF_PUBLIC);
    if (!c)
        return ((struct RDPConnection *) 0L);

    if (reqport == (ULONG) - 1)
    {
        Forbid();
        reqport = gb->RDPPorts++;
        if (gb->RDPPorts == 0)
            gb->RDPPorts = 1024;
        Permit();
    }

    c->conn_WakeBit = -1;
    c->conn_DataIn = DataIn;
    c->conn_Status = Status;
    c->conn_State = STATE_LISTEN;
    c->conn_RecvMax = MAXSEGS;
    c->conn_RecvMaxSize = MAXSIZE;
    c->conn_OurAddress = ((struct sanadev *) gb->DeviceList.lh_Head)->sanadev_IPAddress;   /* Our address is the
                                                                                         * 1st of the bunch */
    c->conn_OurPort = reqport;
    /*
     * c->conn_WakeBit = signalbit; c->conn_WakeTask = FindTask(0L);
     */
    c->conn_LastConnTime = CONNTIME;

    InitSemaphore(&c->conn_ReadListSemaphore);
    InitSemaphore(&c->conn_InSema);
    InitSemaphore(&(c->conn_WriteListSemaphore));
    NewList((struct List *) & c->conn_DataListR);
    NewList((struct List *) & c->conn_DataListW);
    NewList((struct List *) & c->conn_InList);  /* for amp */

    ObtainSemaphore(&nb->RDPCLSemaphore);
    AddTail((struct List *) & nb->RDPConnectionList, (struct Node *) & (c->conn_link));
    ReleaseSemaphore(&nb->RDPCLSemaphore);

    return (c);

}

/*------------------------------------------------------------------------*/

BOOL rdp_output_lame(conn, data, len)
struct RDPConnection *conn;
UBYTE *data;
ULONG len;
{
    struct Buffer *b;

    if(b = AllocBuffer(len))
    {
        CopyToBuffer(b,data,len);
        if(rdp_output(conn, b))
	{
	    return TRUE;
	}
	else
	{
	    FreeBuffer(b);
	    return FALSE;
	}
    }
    else
        return(FALSE);
}

BOOL rdp_output(conn, b)
struct RDPConnection *conn;
struct Buffer *b;              /* pointer to the data to packetize */
{

    register struct NBase *nb = gb;
    struct BuffEntry *be;
    struct rdphdr *r;
    UBYTE *data;
    UWORD thisseq;
    ULONG length;
    struct retransmit *rexmit;

    if (conn->conn_State != STATE_OPEN)
        return (FALSE);

    length = DataLength(b);

    be = AllocBuffEntry(sizeof(struct rdphdr));
    if(!be)
    {
        return(FALSE);
    }
    be->be_length = sizeof(struct rdphdr);

    r = (struct rdphdr *) be->be_data;
    AddHead((struct List *)&b->buff_list,(struct Node *)be);

    r->rdp_Flags = RDPF_ACK;
    r->rdp_Version = 2;
    r->rdp_HeaderLength = sizeof(struct rdphdr);
    r->rdp_SrcPort = conn->conn_OurPort;
    r->rdp_DestPort = conn->conn_TheirPort;

    Forbid();
    thisseq = r->rdp_SeqNum = conn->conn_SendNxt++;
    conn->conn_Flags &= ~CONN_UNSENTACK;
    Permit();


    r->rdp_AckNum = conn->conn_Current;
    conn->conn_LastAcked = conn->conn_Current;
    r->rdp_DataLength = length;
    r->rdp_Checksum = 0;
    r->rdp_Checksum = CalcChecksumBuffer(b);

    b->buff_refcnt++;   /* Make sure no one frees this buffer on us...*/

    rexmit = (struct retransmit *) AllocMem(sizeof(struct retransmit), MEMF_PUBLIC | MEMF_CLEAR);

    if (!rexmit)
    {
        b->buff_refcnt--;
        conn->conn_State = STATE_TIMEOUT; /* Close the connection; the connection timeout routine will do the dirty work. */
        return FALSE;
    }

#ifndef NOBUFFSHARING
    rexmit->xmit_data = b /* clone */ ;
#else
    rexmit->xmit_data = CloneBuffer(b);
#endif
    rexmit->xmit_countdown = TIMEOUT + conn->conn_MTUDelay;
    rexmit->xmit_retrycount = RETRIES;
    rexmit->xmit_ToAddress = conn->conn_TheirAddress;
    rexmit->xmit_seqnum = thisseq;

    ip_sendsrc(b, conn->conn_OurAddress, conn->conn_TheirAddress, 26);    /* Send the packet off to IP */

    ObtainSemaphore(&nb->RDPCLSemaphore);
    ObtainSemaphore(&conn->conn_WriteListSemaphore);
    AddTail((struct List *) & conn->conn_DataListW, (struct Node *) rexmit);
    ReleaseSemaphore(&conn->conn_WriteListSemaphore);
    ReleaseSemaphore(&nb->RDPCLSemaphore);

    return (TRUE);
}

/*------------------------------------------------------------------------*/

/*
 * CloseConnection(connection)
 *
 * Begins the process of closing a connection.
 *
 */

void CloseConnection(c)
struct RDPConnection *c;
{
    register struct NBase *nb = gb;
    struct Buffer *bt;

    ObtainSemaphore(&nb->RDPCLSemaphore);

    if (c->conn_State != STATE_CLOSE)
    {
        SendFlags(c, RDPF_RST);
        c->conn_State = STATE_CLOSE;
    }

    Remove((struct Node *) c);

    /* Free any queued reads */
    ObtainSemaphore(&(c->conn_ReadListSemaphore));
    while (bt = (struct Buffer *) RemHead((struct List *) & (c->conn_DataListR)))
    {
        FreeBuffer(bt);
    }
    ReleaseSemaphore(&(c->conn_ReadListSemaphore));

    ObtainSemaphore(&(c->conn_InSema));
    while (bt = (struct Buffer *) RemHead((struct List *) &(c->conn_InList)))
    {
        FreeBuffer(bt);
    }
    ReleaseSemaphore(&(c->conn_InSema));

    /* Free any retransmit queued writes */
    ObtainSemaphore(&(c->conn_WriteListSemaphore));
    while (!IsListEmpty((struct List *) & c->conn_DataListW))
    {
        struct retransmit *rt;
        struct Buffer *bt;
        rt = (struct retransmit *) RemHead((struct List *) & (c->conn_DataListW));
        bt = rt->xmit_data;
        bt->buff_refcnt--;
        FreeBuffer(bt);
        FreeMem(rt, sizeof(struct retransmit));
    }
    ReleaseSemaphore(&(c->conn_WriteListSemaphore));

    FreeMem(c, sizeof(struct RDPConnection));

    ReleaseSemaphore(&nb->RDPCLSemaphore);

}
/*------------------------------------------------------------------------*/


@


1.45
log
@Updated for improved buffer stuff.
@
text
@a1 1

d7 1
a7 1
** $Id: rdp.c,v 1.44 93/07/30 18:51:11 gregm Exp Locker: kcd $
d15 1
d33 2
a34 1
#define MAX_ACK_DIFF 3
d123 1
a123 1
    struct initdataform initdata[]={9600,1,30000,2,60000,3,100000,4,500000,8,2000000,12,10000000,16,-1,16};
a159 1

a241 1
#ifndef NOBUFFSHARING
d243 1
a243 1
#endif
d248 1
a248 1
                            rr = (struct rdphdr *) BuffPointer(temp->xmit_data,20L,&xbe);
d250 1
d280 1
d283 2
a284 1
                                if(CountEntries(rexmit->xmit_data) > 1)
d286 2
a287 3
                                    bufe = (struct BuffEntry *)RemHead((struct List *)&rexmit->xmit_data->buff_list);
                                    if(bufe)
                                        FreeBuffEntry(bufe);
a704 1

a748 1
//    kprintf("Current is now %ld; delivered %ld\n",c->conn_Current,c->conn_SeqDelivered);
d751 1
a751 1
//    if((c->conn_Current - c->conn_LastAcked) >= (c->conn_RecvMax >> 1))
d753 2
a754 2
//    else
//        c->conn_Flags |= CONN_UNSENTACK;
d1031 9
a1039 1
        return(rdp_output(conn, b));
a1065 1
        FreeBuffer(b);
a1090 1
#ifndef NOBUFFSHARING
a1091 3
#endif

    ip_sendsrc(b, conn->conn_OurAddress, conn->conn_TheirAddress, 26);    /* Send the packet off to IP */
a1096 1
#ifndef NOBUFFSHARING
a1097 1
#endif
d1112 2
a1170 1
#ifndef NOBUFFSHARING
a1171 1
#endif
@


1.44
log
@Added a bunch of code to help with lossy connections.
@
text
@d2 1
d8 1
a8 1
** $Id: rdp.c,v 1.43 93/03/02 16:18:35 gregm Exp $
d752 1
a752 1
    if((c->conn_Current - c->conn_LastAcked) >= MAX_ACK_DIFF)
d754 2
a755 2
    else
        c->conn_Flags |= CONN_UNSENTACK;
d1022 17
a1038 1
BOOL rdp_output(conn, dataptr, length)
d1040 1
a1040 2
UBYTE *dataptr;                 /* pointer to the data to packetize */
ULONG length;                  /* Length of the data */
a1043 1
    struct Buffer *b;
d1048 1
d1054 6
a1059 2
    b = AllocBuffer(length + (sizeof(struct rdphdr)));
    if (!b)
d1061 2
a1063 2
    be = (struct BuffEntry *) b->buff_list.mlh_Head;
    be->be_length = (length + (sizeof(struct rdphdr)));
d1065 1
a1065 1
    data = (UBYTE *) ((ULONG) r + (ULONG) sizeof(struct rdphdr));
a1066 1
    CopyMem(dataptr, data, length);
@


1.43
log
@The dynamic delay stuff now works for active and passive connections
@
text
@d7 1
a7 1
** $Id: rdp.c,v 1.42 93/01/05 13:38:47 gregm Exp Locker: gregm $
d31 1
a31 1
#define MAXSEGS 5
d35 1
d106 27
d134 4
d244 6
d443 1
d485 2
d496 2
d520 10
a529 1
                    rc->conn_RecvMaxSize = ((sd->sanadev_MTU)-(sizeof(struct iphdr)+sizeof(struct rdphdr)))*3;
d626 2
a627 2
        rc->conn_SendMax = rs->rsyn_MaxOutstanding;
        rc->conn_SendMaxSize = rs->rsyn_MaxSegment;
a690 1
    r->rdp_SeqNum = c->conn_SendNxt;
d692 6
a697 1
        c->conn_SendNxt++;
d748 1
d779 1
a779 1
                Remove((struct Node *) & (bb->buff_link));
a781 1

d880 1
d905 6
a910 2
    c->conn_RecvMax = MAXSEGS;
    c->conn_RecvMaxSize = ((route->nr_Device->sanadev_MTU)-(sizeof(struct iphdr)+sizeof(struct rdphdr)))*3;
d934 2
d958 1
a1079 1

@


1.42
log
@CloseConnection() has a loop where all pending retransmits are freed before the
rdpconnection structure is freed.  Since we're using multiple references to
any given buffer, before we free one, we have to decrement the reference count
this wasn't being done.
@
text
@d7 1
a7 1
** $Id: rdp.c,v 1.41 93/01/05 12:31:30 gregm Exp $
d159 1
a159 1
                if (conn->conn_ConnRetransmits == TOTALALLOWED)
d261 1
a261 1
                        rexmit->xmit_countdown = TIMEOUT;
d472 1
d475 19
a493 1
                    rc->conn_RecvMaxSize = ((route->nr_Device->sanadev_MTU)-(sizeof(struct iphdr)+sizeof(struct rdphdr)))*3;
d820 2
a821 1
        register struct NBase *nb = gb;
d868 20
d1015 1
d1025 1
a1025 1
    rexmit->xmit_countdown = TIMEOUT;
@


1.41
log
@Removed a redundant While(!islistempty()) in CloseConnection().
@
text
@d7 1
a7 1
** $Id: rdp.c,v 1.40 92/12/16 14:43:11 kcd Exp Locker: gregm $
d1046 3
@


1.40
log
@Fixed remaining compiler warnings.
@
text
@d7 1
a7 1
** $Id: rdp.c,v 1.39 92/11/02 13:57:14 kcd Exp Locker: kcd $
d241 1
a241 1
                            	struct BuffEntry *bufe;
d243 2
a244 2
				if(CountEntries(rexmit->xmit_data) > 1)
				{
d676 1
a676 1
	SendFlags(c, RDPF_ACK);
d678 1
a678 1
	c->conn_Flags |= CONN_UNSENTACK;
a1024 1
    while (!IsListEmpty((struct List *) & c->conn_DataListR))
@


1.39
log
@Removed TimerBase definition.
@
text
@d7 1
a7 1
** $Id: rdp.c,v 1.38 92/09/03 16:26:12 kcd Exp Locker: kcd $
d566 1
a566 1
            BOOL wasdead=FALSE;
d574 1
a574 1
            return(!wasdead);
d695 1
a695 1
            struct iphr *ip;
@


1.38
log
@Fixed the damn problem with retransmitting packets that would be
fragmented by IP.  Now, I no longer yank off the first buffentry
if the number of them is less than two.
@
text
@d7 1
a7 1
** $Id: rdp.c,v 1.37 92/08/19 16:11:46 kcd Exp Locker: kcd $
a42 2

#define TimerBase NIPCBASE->TimerBase;
@


1.37
log
@Removed the kprint's looking for buffer sharing problem.
@
text
@d7 1
a7 1
** $Id: rdp.c,v 1.36 92/08/13 17:54:01 kcd Exp Locker: kcd $
a243 2
//                            	if(CountEntries(rexmit->xmit_data) <= 1)
//                            	    kprintf("Shit! I just yanked the only BuffEntry! \g");
d245 6
a250 2
                                bufe = (struct BuffEntry *)RemHead((struct List *)&rexmit->xmit_data->buff_list);
                                FreeBuffEntry(bufe);
a849 1

@


1.36
log
@Added a debugging statement to catch a possible error condition.
@
text
@d7 1
a7 1
** $Id: rdp.c,v 1.35 92/07/31 16:14:52 kcd Exp Locker: kcd $
d244 2
a245 2
                            	if(CountEntries(rexmit->xmit_data) <= 1)
                            	    kprintf("Shit! I just yanked the only BuffEntry! \g");
@


1.35
log
@Added a #define for the delayed ACK thingy.
@
text
@d7 1
a7 1
** $Id: rdp.c,v 1.34 92/07/30 20:24:36 kcd Exp Locker: kcd $
d243 4
a246 1
                                struct BuffEntry *bufe;
@


1.34
log
@Added a bit of intelligence to the Piggybacked ACK stuff to make sure
the other side doesn't stop sending us data just because we haven't
ACK'd them in a while.
@
text
@d7 1
a7 1
** $Id: rdp.c,v 1.33 92/07/30 16:55:45 gregm Exp Locker: kcd $
d32 1
d672 1
a672 1
    if((c->conn_Current - c->conn_LastAcked) >=3)
@


1.33
log
@Addition of piggy-backed ACKs and probably a memory leak.
@
text
@d7 1
a7 1
** $Id: rdp.c,v 1.32 92/07/29 13:39:26 gregm Exp Locker: gregm $
d124 1
d623 1
a669 2
//    SendFlags(c, RDPF_ACK);

d671 4
a674 1
    c->conn_Flags |= CONN_UNSENTACK;
d954 1
@


1.32
log
@Clean up; comments removed, etc.
@
text
@d7 1
a7 1
** $Id: rdp.c,v 1.31 92/07/13 16:48:01 gregm Exp $
d103 28
d668 6
a673 1
    SendFlags(c, RDPF_ACK);
a748 1
//    if (IsListEmpty((struct List *) & (c->conn_DataListR)))
d946 1
d948 1
@


1.31
log
@Turned buffer sharing back on.
@
text
@d7 1
a7 1
** $Id: rdp.c,v 1.30 92/07/13 16:45:06 gregm Exp Locker: gregm $
a305 1
                {
a306 1
                }
d310 3
a312 2
                conn = nxt;
                continue;
d354 2
a355 2
                        rconn = nxt;
                        continue;
d409 1
a409 1
        register struct NBase *nb = gb;
d534 2
a535 2
            if (rc->conn_State == STATE_CLOSE)
                wasdead = TRUE;
d537 1
a537 1
            (*rc->conn_Status)(rc);
d539 3
a541 2
            if (wasdead)
                return(FALSE);
d647 1
a647 2
    if (c->conn_SeqDelivered <= c->conn_SeqDelivered)   /* What the FUCK is this
                                                         * ??? */
d649 23
a671 14
        for (pack = (c->conn_SeqDelivered + 1); pack <= c->conn_Current; pack++)
        {
            struct Buffer *bb;
            struct Buffer *tmpb;
            bb = (struct Buffer *) c->conn_DataListR.mlh_Head;
            while (bb->buff_link.mln_Succ)
            {
                struct rdphdr *rr;
                struct iphr *ip;
                struct BuffEntry *bex;
                bex = (struct BuffEntry *) bb->buff_list.mlh_Head;
                ip = (struct iphdr *) ((ULONG) bex->be_data + (ULONG) bex->be_offset);
                rr = (struct rdphdr *) ((ULONG) ip + (ULONG) sizeof(struct iphdr));
                if (rr->rdp_SeqNum < pack)  /* Free any that're redundant */
d673 2
a674 1
                    tmpb = (struct Buffer *) bb->buff_link.mln_Pred;
d676 5
a680 8
                    FreeBuffer(bb);
                    bb = tmpb;

                }
                else
                {
                    if (rr->rdp_SeqNum == pack) /* Return the proper packet
                                                 * to the caller */
d682 5
a686 16
                        tmpb = (struct Buffer *) bb->buff_link.mln_Pred;        /* Pull it safely from
                                                                                 * the list */
                        Remove((struct Node *) & (bb->buff_link));
                        c->conn_SeqDelivered = pack;    /* Update the largest
                                                         * delivered # */
                        bex->be_offset = (sizeof(struct rdphdr) + sizeof(struct iphdr));
                        bex->be_length -= bex->be_offset;
                        if (c->conn_DataIn)
                        {
                            ObtainSemaphore(&nb->RDPCLSemaphore);
                            (*c->conn_DataIn) (c, bb);  /* Send it back to the
                                                         * opener */
                            ReleaseSemaphore(&nb->RDPCLSemaphore);
                            break; /* NEW */
                        }
                        bb = tmpb;
d688 1
a689 1
                bb = (struct Buffer *) bb->buff_link.mln_Succ;
d691 1
a692 1
        ReleaseSemaphore(&(c->conn_ReadListSemaphore));
d694 1
d769 1
d848 1
@


1.30
log
@Fixed a bug with the retransmission/timeout routine.  It could step 
one entry beyond the end of the list, because of my goofy code.
@
text
@d7 1
a7 1
** $Id: rdp.c,v 1.29 92/06/27 17:22:59 kcd Exp $
d13 1
a13 1
#define NOBUFFSHARING           1
@


1.29
log
@Removed the annoying kprintf's.
@
text
@d7 1
a7 1
** $Id: rdp.c,v 1.28 92/06/26 11:32:18 gregm Exp Locker: kcd $
d13 1
d15 1
d144 1
d150 1
a150 5

        /* Retransmission timeouts */
        ObtainSemaphore(&(conn->conn_WriteListSemaphore));
        rexmit = (struct retransmit *) conn->conn_DataListW.mlh_Head;
        while (rexmit->xmit_link.mln_Succ)
d152 10
a161 27
            /* Decrement the countdown */
            rexmit->xmit_countdown--;
            /* If we reach zero,  consider retransmitting */
            if (!rexmit->xmit_countdown)
            {
                /*
                 * decrement the retry count.  If 0, free this entry,
                 * and give up on it
                 */
                rexmit->xmit_retrycount--;
                if ((!rexmit->xmit_retrycount) || (rexmit->xmit_seqnum < conn->conn_SendOldest))
                {
                    struct retransmit *temp;
                    BOOL closeit = FALSE;
                    temp = rexmit;
                    if (!rexmit->xmit_retrycount)
                    {
                      /*  struct rdphdr *rr; */
                      /*  struct BuffEntry *xbe; */
                        closeit = TRUE;
                      /*  rr = (struct rdphdr *) BuffPointer(temp->xmit_data,0L,&xbe); */
                    }
                    rexmit = (struct retransmit *) rexmit->xmit_link.mln_Pred;
                    Remove((struct Node *) temp);
                    temp->xmit_data->buff_refcnt--;
                    FreeBuffer(temp->xmit_data);
                    FreeMem(temp, sizeof(struct retransmit));
d163 2
a164 2
                     * This has gotten out of hand - force the
                     * connection closed
d166 2
a167 1
                    if (closeit)
d169 33
a201 9
                        SendFlags(conn, RDPF_RST);
                        conn->conn_State = STATE_CLOSE;
                        conn = (struct RDPConnection *) conn->conn_link.mln_Succ;
                        ObtainSemaphore(&nb->RDPCLSemaphore);                       /* Isn't this redundant?  Don't we already have it locked? */
                        rig = (*((struct RDPConnection *)conn->conn_link.mln_Pred)->conn_Status) ((struct RDPConnection *)conn->conn_link.mln_Pred);
                        ReleaseSemaphore(&nb->RDPCLSemaphore);                      /* See above */
                        if (!rig)
                            conn = (struct RDPConnection *) conn->conn_link.mln_Pred; /* If not deleted, step back ... jeeze, how fucking ugly.  I need to recode this whole damned thing. */
                        break;
d203 1
a203 4
                }
                else
                {
                    if (conn->conn_State == STATE_OPEN)
d205 4
a208 2
                        /* We have to yank the IP header off the front of this thing, since one will have
                           already been tacked on by now. */
d210 17
a226 6
                        if(rexmit->xmit_data->buff_refcnt == 1) /* Make sure it's not in ARP's queue... */
                        {
                            struct BuffEntry *bufe;
                            bufe = (struct BuffEntry *)RemHead((struct List *)&rexmit->xmit_data->buff_list);
                            FreeBuffEntry(bufe);
                            ip_sendsrc(rexmit->xmit_data /* rcpy */, conn->conn_OurAddress, rexmit->xmit_ToAddress, 26);
d228 1
a229 1
                    rexmit->xmit_countdown = TIMEOUT;
d231 6
a237 6
            rexmit = (struct retransmit *) rexmit->xmit_link.mln_Succ;
        }
        if (!rig)   /* As long as the connection wasn't deleted, release the semaphore, and skip to the next connection */
        {
            ReleaseSemaphore(&(conn->conn_WriteListSemaphore));
            conn = (struct RDPConnection *) conn->conn_link.mln_Succ;
d923 1
d925 1
d933 1
d935 1
d940 1
d942 3
@


1.28
log
@Made RDP send a RST packet whenever it receives a packet that it
can't identify (and that doesn't have a RST already in it).
This way, packets to non-existant ports force the sender to
close their connection immediately, rather than waiting for
the catch-all timeout.
@
text
@d7 1
a7 1
** $Id: rdp.c,v 1.27 92/06/21 14:08:27 gregm Exp Locker: gregm $
a257 10

#ifdef DEBUGMSGS
    kprintf("RDP Packet received:\n");
    kprintf("From address %lx\n", source_address);
    kprintf("Flags: %lx     Version: %lx   Header Length: %lx\n", r->rdp_Flags, r->rdp_Version, r->rdp_HeaderLength);
    kprintf("Source Port: %lx     Destination Port: %lx\n", r->rdp_SrcPort, r->rdp_DestPort);
    kprintf("Data Length: %lx\n", r->rdp_DataLength);
    kprintf("Sequence Number: %lx    Acknowledgement Number: %lx\n", r->rdp_SeqNum, r->rdp_AckNum);
    kprintf("Checksum: %lx\n", r->rdp_Checksum);
#endif
@


1.27
log
@fixed a typo
@
text
@d7 1
a7 1
** $Id: rdp.c,v 1.26 92/06/19 11:01:13 kcd Exp Locker: gregm $
d359 9
d373 9
@


1.26
log
@Hopefully fixed one of the last outstanding bugs in rdp. :)
@
text
@d7 1
a7 1
** $Id: rdp.c,v 1.25 92/06/18 12:16:48 gregm Exp Locker: kcd $
d201 2
a202 2
                    	/* We have to yank the IP header off the front of this thing, since one will have
                    	   already been tacked on by now. */
d204 7
a210 7
                    	if(rexmet->xmit_data->buff_refcnt == 1) /* Make sure it's not in ARP's queue... */
                    	{
                    	    struct BuffEntry *bufe;
                    	    bufe = (struct BuffEntry *)RemHead((struct List *)&rexmit->xmit_data->buff_list);
                    	    FreeBuffEntry(bufe);
	                    ip_sendsrc(rexmit->xmit_data /* rcpy */, conn->conn_OurAddress, rexmit->xmit_ToAddress, 26);
	                }
@


1.25
log
@REmade port #'s incrementing from 1K.  They were random for awhile.
@
text
@d7 1
a7 1
** $Id: rdp.c,v 1.24 92/06/11 10:44:29 gregm Exp Locker: gregm $
d200 3
a202 1
                        ip_sendsrc(rexmit->xmit_data /* rcpy */, conn->conn_OurAddress, rexmit->xmit_ToAddress, 26);
d204 8
@


1.24
log
@Timestamping for total round-trip delay
@
text
@d7 1
a7 1
** $Id: rdp.c,v 1.23 92/06/08 10:07:26 kcd Exp Locker: gregm $
d62 1
a62 1
    ULONG eclkdata[2];
d64 1
a64 1
    ReadEClock( (struct EClockVal *) &eclkdata);
d66 2
a67 1
    gb->RDPPorts = (UWORD) ((UWORD *)&eclkdata[1])[1];
@


1.23
log
@Adjustments for the reference count in Buffers.
@
text
@d7 1
a7 1
** $Id: rdp.c,v 1.22 92/06/04 22:22:17 kcd Exp Locker: kcd $
d379 1
d381 1
d409 2
d416 1
d419 9
d433 2
d439 2
d442 10
d562 1
d565 1
a565 1
        rs->rsyn_MaxSegment = c->conn_RecvMaxSize; /* Figure this dynamically, based on the interface */
d778 2
@


1.22
log
@Fixed Checksum calculation problem with freshly allocated
buffers.
@
text
@d7 1
a7 1
** $Id: rdp.c,v 1.21 92/05/22 15:35:59 gregm Exp Locker: kcd $
d35 2
a36 2
#define TIMEOUT  20            /* Temporary until I can work in an adaptive (2*10) timeout */
#define CONNTIME 10             /* 10ths of a second between connection state
d108 1
a108 1
    BOOL rig=FALSE;
d169 2
a170 2
                        struct rdphdr *rr;
                        struct BuffEntry *xbe;
d172 1
a172 1
                        rr = (struct rdphdr *) BuffPointer(temp->xmit_data,0L,&xbe);
d176 1
d198 2
a199 2
                    /* retransmit it */
                    struct Buffer *rcpy;
a200 4
                    if (rcpy = CloneBuffer(rexmit->xmit_data))
                        if (conn->conn_State == STATE_OPEN)
                            ip_sendsrc(rcpy, conn->conn_OurAddress, rexmit->xmit_ToAddress, 26);

a821 1
    struct Buffer *clone;
a854 2
    clone = CloneBuffer(b);     /* Make a copy of this buffer for
                                 * retransmissions */
d856 1
a856 5
    if (!clone)                 /* If we couldn't make a copy, just exit */
    {
        FreeBuffer(b);
        return FALSE;
    }
d864 1
a864 1
        FreeBuffer(clone);
d869 1
a869 1
    rexmit->xmit_data = clone;
@


1.21
log
@Lots of changes; window sizes are now calculated; semaphore problems removed, etc.
@
text
@d7 1
a7 1
** $Id: rdp.c,v 1.20 92/05/05 17:32:07 kcd Exp Locker: gregm $
d547 1
@
