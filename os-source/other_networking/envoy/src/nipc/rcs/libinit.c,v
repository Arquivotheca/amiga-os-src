head     1.5;
branch   ;
access   ;
symbols  ;
locks    kcd:1.5; strict;
comment  @ * @;


1.5
date     92.03.13.14.24.24;  author gregm;  state Exp;
branches ;
next     1.4;

1.4
date     92.02.27.20.52.44;  author kcd;  state Exp;
branches ;
next     1.3;

1.3
date     92.02.18.12.52.29;  author kcd;  state Exp;
branches ;
next     1.2;

1.2
date     92.02.16.17.24.10;  author kcd;  state Exp;
branches ;
next     1.1;

1.1
date     92.02.13.10.02.14;  author gregm;  state Exp;
branches ;
next     ;


desc
@Lattice Voodoo libraries stuff.
@


1.5
log
@We can expunge!  Yay!
@
text
@/**************************************************************************
**
** libinit.c    - Lattice "Magic" library init code
**
** Copyright 1992, Commodore-Amiga, Inc.
**
** $Id: libinit.c,v 1.4 92/02/27 20:52:44 kcd Exp Locker: gregm $
**
***************************************************************************

/*------------------------------------------------------------------------*/

#include "nipcinternal.h"
#include <exec/libraries.h>
#include <dos/dos.h>
#include <string.h>
#include "nipc.library_rev.h"

#include <clib/exec_protos.h>
#include "nipcinternal_protos.h"

#include <pragmas/exec_pragmas.h>

/*------------------------------------------------------------------------*/

struct MyLibrary
{
    struct Library ml_Lib;
    ULONG ml_SegList;
    ULONG ml_Flags;
    APTR ml_ExecBase;           /* pointer to exec base */
    LONG ml_Data;               /* Global data */
};

typedef LONG(*PFL) ();          /* pointer to function returning 32-bit int        */

/* library initialization table, used for AUTOINIT libraries                */
struct InitTable
{
    ULONG *it_DataSize;         /* library data space size         */
    PFL *it_FuncTable;          /* table of entry points           */
    APTR it_DataInit;           /* table of data initializers      */
    PFL it_InitFunc;            /* initialization function to run  */
};

extern PFL _LibFuncTab[];       /* my function table (Generated by Blink) */

extern char __far RESLEN;
extern long __far NEWDATAL;     /* Generated by BLINK */
#define DATAWORDS ((long)&NEWDATAL)


struct InitTable __far _LibInitTab =
{
    (long *) (&RESLEN + sizeof(struct MyLibrary)),
    _LibFuncTab,
    NULL,                       /* will initialize my own data */
    _LibInit,
};
extern long far _Libmergeddata; /* Need this to determine start of MERGED
                                 * DATA */


/* These two are defined by blink */
extern char __far _LibID[];
extern char __far _LibName[];

#define MYREVISION REVISION

/*------------------------------------------------------------------------*/

__saveds __asm __stdargs ULONG _LibInit(register __a0 APTR seglist, register __d0 struct MyLibrary * libbase)
{
    long *sdata, *reloc;
    char *ddata;
    long nrelocs;

    libbase->ml_SegList = (ULONG) seglist;

    /* init. library structure (since I don't do automatic data init.) */
    libbase->ml_Lib.lib_Node.ln_Type = NT_LIBRARY;
    libbase->ml_Lib.lib_Node.ln_Name = _LibName;
    libbase->ml_Lib.lib_Flags = LIBF_SUMUSED | LIBF_CHANGED;
    libbase->ml_Lib.lib_Version = 1;
    libbase->ml_Lib.lib_Revision = MYREVISION;
    libbase->ml_Lib.lib_IdString = (APTR) _LibID;

    ddata = (char *) &libbase->ml_Data + 4;     /* The +4 is a wasted long
                                                 * word, where _Libmergeddata
                                                 * is. */
    sdata = (long *) &_Libmergeddata;
    memcpy(ddata, (char *) sdata, DATAWORDS * 4);

    sdata = sdata + DATAWORDS;
    nrelocs = *sdata++;
    while (nrelocs > 0)
    {
        reloc = (long *) ((long) ddata + *sdata++);
        *reloc += (long) ddata;
        nrelocs--;
    }

    /* ----- Do library specific public initialization here ----- */
    InitLock((struct Library *) libbase);

    return ((ULONG) libbase);
}

/*------------------------------------------------------------------------*/

LONG __saveds __asm __stdargs _LibOpen(register __a6 struct MyLibrary * libbase)
{
    StartLibrary((struct Library *) libbase);

    /* mark us as having another customer */
    libbase->ml_Lib.lib_OpenCnt++;

    /* clear delayed expunges (standard procedure)                */
    libbase->ml_Lib.lib_Flags &= ~LIBF_DELEXP;

    return ((LONG) libbase);
}

/*------------------------------------------------------------------------*/

ULONG __saveds __asm __stdargs _LibClose(register __a6 struct MyLibrary * libbase)
{
    ULONG retval = 0;

    if ((--libbase->ml_Lib.lib_OpenCnt == 0) &&
        (libbase->ml_Lib.lib_Flags & LIBF_DELEXP))
    {
        /*
         * no more people have me open, and I have a delayed expunge pending
         */
        retval = _LibExpunge(libbase);  /* return segment list        */
    }

    return (retval);
}

/*------------------------------------------------------------------------*/

ULONG __saveds __asm __stdargs _LibExpunge(register __a6 struct MyLibrary * libbase)
{
    ULONG seglist = 0;
    LONG libsize;

    libbase->ml_Lib.lib_Flags |= LIBF_DELEXP;
    if (libbase->ml_Lib.lib_OpenCnt == 0)
    {

        /* really expunge: remove libbase and freemem        */

        seglist = 0L;

        Remove((struct Node *) libbase);
        KillOffNIPC();


//      libsize = libbase->ml_Lib.lib_NegSize + libbase->ml_Lib.lib_PosSize;
//      FreeMem((char *) libbase - libbase->ml_Lib.lib_NegSize, (LONG) libsize);
    }

    /* return NULL or real seglist                                */
    return ((ULONG) seglist);
}
/*------------------------------------------------------------------------*/
@


1.4
log
@New formatting.  Modified for use with registerized arguments.  Changed
for use with new include files.
@
text
@d7 1
a7 1
** $Id$
d152 1
d155 1
a155 1
        seglist = libbase->ml_SegList;
d158 2
d161 2
a162 2
        libsize = libbase->ml_Lib.lib_NegSize + libbase->ml_Lib.lib_PosSize;
        FreeMem((char *) libbase - libbase->ml_Lib.lib_NegSize, (LONG) libsize);
@


1.3
log
@Fixed bugs in InitLock().
@
text
@d1 9
d11 1
a11 4
/*
 * $Header: APPN:src/libs/nipc.library/RCS/libinit.c,v 1.2 92/02/16 17:24:10 kcd Exp Locker: kcd $
 *
 */
d13 5
d19 2
d22 1
a22 9
#include <exec/types.h>
#include <exec/nodes.h>
#include <exec/resident.h>
#include <exec/libraries.h>
#include <libraries/dos.h>
#include <proto/exec.h>
#include <proto/dos.h>
#include <string.h>
#include "nipc.library.h"
d24 1
a24 2
void __asm __saveds InitLock(register __a6 struct Library *libbase);
void __asm __saveds StartLibrary(register __a6 struct Library *libbase);
d26 8
a33 7
struct MyLibrary {
        struct       Library ml_Lib;
        ULONG        ml_SegList;
        ULONG        ml_Flags;
        APTR         ml_ExecBase;        /* pointer to exec base */
        LONG         ml_Data;                /* Global data */
        };
d35 1
a35 1
typedef LONG (*PFL)();   /* pointer to function returning 32-bit int        */
d38 6
a43 5
struct InitTable {
        ULONG        *it_DataSize;        /* library data space size         */
        PFL          *it_FuncTable;      /* table of entry points           */
        APTR         it_DataInit;        /* table of data initializers      */
        PFL          it_InitFunc;        /* initialization function to run  */
d46 1
a46 1
extern PFL _LibFuncTab[];      /* my function table (Generated by Blink) */
d49 1
a49 1
extern long __far NEWDATAL; /* Generated by BLINK */
a51 3
ULONG __saveds __asm _LibExpunge( register __a6 struct MyLibrary *libbase );
ULONG __saveds __asm _LibInit( register __a0 APTR seglist,
                                register __d0 struct MyLibrary *libbase );
d53 6
a58 5
struct InitTable __far _LibInitTab =  {
        (long *)(&RESLEN+sizeof(struct MyLibrary)),
        _LibFuncTab,
        NULL,                        /* will initialize my own data */
        _LibInit,
d60 2
a61 1
extern long far _Libmergeddata;    /* Need this to determine start of MERGED DATA */
d70 3
a72 3
__saveds __asm
ULONG _LibInit( register __a0 APTR seglist,
        register __d0 struct MyLibrary *libbase )
d74 28
a101 27
        long *sdata, *reloc;
        char *ddata;
        long nrelocs;

        libbase->ml_SegList = (ULONG) seglist;

        /* init. library structure (since I don't do automatic data init.) */
        libbase->ml_Lib.lib_Node.ln_Type = NT_LIBRARY;
        libbase->ml_Lib.lib_Node.ln_Name =  _LibName;
        libbase->ml_Lib.lib_Flags = LIBF_SUMUSED | LIBF_CHANGED;
        libbase->ml_Lib.lib_Version = 1;
        libbase->ml_Lib.lib_Revision = MYREVISION;
        libbase->ml_Lib.lib_IdString = (APTR) _LibID;

        ddata = (char *)&libbase->ml_Data+4;   /* The +4 is a wasted long word,
                                                                         where _Libmergeddata is. */
        sdata = (long *)&_Libmergeddata;
        memcpy(ddata, (char *)sdata, DATAWORDS*4);

        sdata = sdata + DATAWORDS;
        nrelocs = *sdata++;
        while (nrelocs > 0)
        {
                reloc = (long *)((long)ddata + *sdata++);
                *reloc += (long)ddata;
                nrelocs--;
        }
d103 2
a104 2
        /* ----- Do library specific public initialization here ----- */
        InitLock((struct Library *)libbase);
d106 1
a106 1
        return ( (ULONG) libbase );
d109 3
a111 2
LONG __saveds __asm
_LibOpen( register __a6 struct        MyLibrary *libbase )
d113 1
a113 1
        StartLibrary((struct Library *)libbase);
d115 2
a116 2
        /* mark us as having another customer */
        libbase->ml_Lib.lib_OpenCnt++;
d118 2
a119 2
        /* clear delayed expunges (standard procedure)                */
        libbase->ml_Lib.lib_Flags &= ~LIBF_DELEXP;
d121 1
a121 1
        return ( (LONG) libbase );
d124 3
a126 2
ULONG __saveds __asm
_LibClose( register __a6 struct MyLibrary *libbase )
d128 1
a128 1
        ULONG retval = 0;
d130 8
a137 8
        if (( --libbase->ml_Lib.lib_OpenCnt == 0 ) &&
                        ( libbase->ml_Lib.lib_Flags & LIBF_DELEXP ))
        {
                /* no more people have me open,
                 * and I have a delayed expunge pending
                 */
                retval = _LibExpunge( libbase ); /* return segment list        */
        }
d139 1
a139 1
        return (retval);
d142 3
a144 2
ULONG __saveds __asm
_LibExpunge( register __a6 struct MyLibrary *libbase )
d146 15
a160 15
        ULONG seglist = 0;
        LONG  libsize;

        libbase->ml_Lib.lib_Flags |= LIBF_DELEXP;
        if ( libbase->ml_Lib.lib_OpenCnt == 0 )
        {
                /* really expunge: remove libbase and freemem        */

                seglist = libbase->ml_SegList;

                Remove( (struct Node *) libbase);

                libsize = libbase->ml_Lib.lib_NegSize + libbase->ml_Lib.lib_PosSize;
                FreeMem( (char *) libbase - libbase->ml_Lib.lib_NegSize,(LONG) libsize );
        }
d162 2
a163 2
        /* return NULL or real seglist                                */
        return ( (ULONG) seglist );
d165 1
a165 1

@


1.2
log
@Moved StartLibrary to LibOpen to avoid ramlib deadlocks.
@
text
@d3 1
a3 1
 * $Header: APPN:src/libs/nipc.library/RCS/libinit.c,v 1.1 92/02/13 10:02:14 gregm Exp Locker: kcd $
d98 1
a98 1
        InitLock(libbase);
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
 * $Header$
d19 1
d98 1
a99 2
        StartLibrary((struct Library *)libbase);

d106 2
@
