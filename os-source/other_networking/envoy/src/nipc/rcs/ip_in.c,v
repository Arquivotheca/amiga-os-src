head     1.26;
branch   ;
access   ;
symbols  ;
locks    ; strict;
comment  @ * @;


1.26
date     93.08.10.16.15.36;  author kcd;  state Exp;
branches ;
next     1.25;

1.25
date     92.12.16.14.42.40;  author kcd;  state Exp;
branches ;
next     1.24;

1.24
date     92.08.19.16.10.15;  author kcd;  state Exp;
branches ;
next     1.23;

1.23
date     92.08.17.11.36.28;  author gregm;  state Exp;
branches ;
next     1.22;

1.22
date     92.08.13.18.07.39;  author kcd;  state Exp;
branches ;
next     1.21;

1.21
date     92.07.13.17.02.46;  author kcd;  state Exp;
branches ;
next     1.20;

1.20
date     92.06.12.11.14.34;  author gregm;  state Exp;
branches ;
next     1.19;

1.19
date     92.06.08.10.08.48;  author kcd;  state Exp;
branches ;
next     1.18;

1.18
date     92.05.22.15.34.30;  author gregm;  state Exp;
branches ;
next     1.17;

1.17
date     92.05.14.19.25.11;  author kcd;  state Exp;
branches ;
next     1.16;

1.16
date     92.05.05.17.35.07;  author kcd;  state Exp;
branches ;
next     1.15;

1.15
date     92.04.21.16.07.51;  author kcd;  state Exp;
branches ;
next     1.14;

1.14
date     92.04.12.16.00.21;  author kcd;  state Exp;
branches ;
next     1.13;

1.13
date     92.04.10.00.39.52;  author kcd;  state Exp;
branches ;
next     1.12;

1.12
date     92.04.05.18.11.02;  author gregm;  state Exp;
branches ;
next     1.11;

1.11
date     92.03.23.10.22.27;  author gregm;  state Exp;
branches ;
next     1.10;

1.10
date     92.03.04.16.59.47;  author gregm;  state Exp;
branches ;
next     1.9;

1.9
date     92.02.29.20.37.16;  author kcd;  state Exp;
branches ;
next     1.8;

1.8
date     92.02.27.20.56.19;  author kcd;  state Exp;
branches ;
next     1.7;

1.7
date     92.02.24.10.42.51;  author kcd;  state Exp;
branches ;
next     1.6;

1.6
date     92.02.20.20.14.12;  author gregm;  state Exp;
branches ;
next     1.5;

1.5
date     92.02.20.14.06.10;  author gregm;  state Exp;
branches ;
next     1.4;

1.4
date     92.02.20.11.49.58;  author gregm;  state Exp;
branches ;
next     1.3;

1.3
date     92.02.20.11.10.04;  author kcd;  state Exp;
branches ;
next     1.2;

1.2
date     92.02.17.09.54.01;  author kcd;  state Exp;
branches ;
next     1.1;

1.1
date     92.02.13.10.01.11;  author gregm;  state Exp;
branches ;
next     ;


desc
@The NIPC IP implementation's input routines.
@


1.26
log
@Commented out IP header checksum validation, as it's now done in ip_out.c
@
text
@/**************************************************************************
**
** ip_in.c      - Deal with incoming IP packets
**
** Copyright 1992, Commodore-Amiga, Inc.
**
** $Id: ip_in.c,v 1.25 92/12/16 14:42:40 kcd Exp Locker: kcd $
**
***************************************************************************

/*------------------------------------------------------------------------*/

#include "nipcinternal.h"
#include "externs.h"

#include <clib/exec_protos.h>
#include "nipcinternal_protos.h"

#include <pragmas/exec_pragmas.h>

#define FRAGTIMEOUT 3          /* 3 seconds timeout for fragments */

/*------------------------------------------------------------------------*/

void ip_in(ibuff, dev)
struct sanadev *dev;            /* ... and the device you rode in on! */
struct Buffer *ibuff;           /* The packet to sift */
{

    struct ipproto *protoptr;

    struct iphdr *ipkt;
    struct BuffEntry *be;
    ULONG packet_length,datalen;
    UWORD our_checksum;
    ONTIMER(2);
    if (ibuff->buff_list.mlh_Head->mln_Succ)
    {
        be = (struct BuffEntry *) ibuff->buff_list.mlh_Head;

        if (be->be_length >= sizeof(struct iphdr))
        {
            ipkt = (struct iphdr *) (be->be_data + be->be_offset);

            if (ipkt->iph_Version == 4)
            {
                packet_length = (ipkt->iph_IHL << 2);

                datalen = ipkt->iph_Length;

//                our_checksum = CalcChecksum((UBYTE *) ipkt, packet_length, 0L);
//                if (our_checksum == 0xFFFF)
//                {

                    /* checksum already verified in multiplex_in() */

                    /*
                     * Check for some level of fragmentation.  If none, completely skip the
                     * frag code.  If some, add it to the frag list, with the proper id
                     * (source+dest+protocol+identification).  Then, attempt to put all of
                     * the pieces together. Note that duplicate packets are held onto - and
                     * even if they're not used, eventually should time out.  However, we
                     * can't protect upper levels from duplicate packets.  If all of the
                     * pieces are duplicated (or even one packet, for one with no
                     * fragmentation), they WILL get passed on. This isn't IP's problem.
                     */

                    if ((ipkt->iph_FragmentOffset != 0) || (ipkt->iph_Flags & IPFLAG_MOREFRAGMENTS))
                    {

                        struct Buffer *os;
                        struct Buffer *assemble[150];
                        struct iphdr *iptr;
                        int acount;
                        BOOL completed = FALSE;
                        ibuff->buff_timeout = FRAGTIMEOUT;
                        AddTail((struct List *) & (dev->sanadev_Fragments), (struct Node *) & (ibuff->buff_link));

                        /*
                         * Parse the list.  Each time we find the beginning of a fragment,
                         * parse the list for the next entry, and so on.
                         */

                        os = (struct Buffer *) dev->sanadev_Fragments.mlh_Head;
                        while (os->buff_link.mln_Succ)
                        {
                            struct BuffEntry *hbe;
                            iptr = (struct iphdr *) BuffPointer(os, 0L, &hbe);
                            if (iptr->iph_FragmentOffset == 0)  /* Found the start of one */
                            {
                                struct Buffer *is;
                                struct iphdr *iniptr;
                                BOOL cantfindit;
                                UWORD nxtoffset;
                                nxtoffset = (iptr->iph_Length - (iptr->iph_IHL << 2));

                                cantfindit = FALSE;
                                acount = 0;

                                assemble[acount] = os;
                                acount++;

                                while (!cantfindit)
                                {
                                    completed = FALSE;
                                    /* Look for that specific piece */
                                    is = (struct Buffer *) dev->sanadev_Fragments.mlh_Head;
                                    while (is->buff_link.mln_Succ)
                                    {
                                        iniptr = (struct iphdr *) ((struct BuffEntry *) is->buff_list.mlh_Head)->be_data;
                                        if ((iniptr->iph_FragmentOffset << 3) == nxtoffset)
                                        {
                                            if ((iniptr->iph_Ident == iptr->iph_Ident) &&
                                             (iniptr->iph_Protocol == iptr->iph_Protocol) &&
                                                (iniptr->iph_SrcAddr == iptr->iph_SrcAddr) &&
                                                (iniptr->iph_DestAddr == iptr->iph_DestAddr))
                                            {
                                                /*
                                                 * found the next piece.  If all done, drop
                                                 * out.  else loop for the next piece
                                                 */
                                                nxtoffset += (iniptr->iph_Length - (iniptr->iph_IHL << 2));
                                                if (!(iniptr->iph_Flags & IPFLAG_MOREFRAGMENTS))
                                                    completed = TRUE;
                                                /* regardless, get it on the list */
                                                assemble[acount] = is;
                                                acount++;
                                                break;
                                            }
                                        }
                                        is = (struct Buffer *) is->buff_link.mln_Succ;
                                    }
                                    if (!is->buff_link.mln_Succ)
                                    {
                                        cantfindit = TRUE;      /* if at end of list */
                                    }
                                    if (completed)
                                        break;
                                }

                                if (completed)
                                {
                                    struct Buffer *headbuffer;
                                    struct iphdr *headip;
                                    struct Buffer *piece;
                                    struct iphdr *iptmp;
                                    int rc;
                                    struct BuffEntry *hbe;
                                    rc = 0;
                                    headbuffer = assemble[rc];
                                    rc++;
                                    headip = (struct iphdr *) BuffPointer(headbuffer, 0L, &hbe);
                                    Remove((struct Node *) headbuffer);
                                    while (rc != acount)
                                    {
                                        piece = assemble[rc];
                                        rc++;
                                        Remove((struct Node *) piece);
                                        iptmp = (struct iphdr *) BuffPointer(piece, 0L, &hbe);
                                        ((struct BuffEntry *) piece->buff_list.mlh_Head)->be_offset += (iptmp->iph_IHL << 2);
                                        ((struct BuffEntry *) piece->buff_list.mlh_Head)->be_length -= (iptmp->iph_IHL << 2);

                                        headip->iph_Length += DataLength(piece);
                                        MergeBuffer(headbuffer, piece);
                                        ibuff = headbuffer;
                                        ipkt = (struct iphdr *) BuffPointer(ibuff, 0L, &hbe);
                                    }           /* endwhile */
                                    break;
                                }               /* endif */
                            }                   /* endif */
                            os = (struct Buffer *) os->buff_link.mln_Succ;
                        }                       /* endwhile */
                        if (!completed)
                        {
                            OFFTIMER(2);
                            return;
                        }
                    }                           /* endif */

                    /* Cool.  Let's ship the packet along up to the next protocol */

                    /*
                     * Unfortunately, this list could be changing underneath us. It's
                     * probably wise to rid the code of the Forbid/Permit pairs and institure
                     * a signal semaphore for the list.
                     */

//                    if(!datalen)
//                    {
//                        kprintf("Alert! Alert! Recevied zero length packet from %lx!\n",ipkt->iph_SrcAddr);
//                    }

                    Forbid();

                    protoptr = (struct ipproto *) gb->ProtocolList.mlh_Head;
                    while (protoptr->ipproto_link.mln_Succ)
                    {

                        if (protoptr->ipproto_ProtocolNumber == ipkt->iph_Protocol)
                        {
                            Permit();

                            if (CountEntries(ibuff) > 1)
                            {
                                struct Buffer *i2buff;
                                i2buff = (struct Buffer *) CloneBuffer(ibuff);
                                FreeBuffer(ibuff);
                                ibuff = i2buff;
                            }
                            OFFTIMER(2);
                            if(ibuff)
                                (*protoptr->ipproto_Input) (ibuff, datalen, dev);
                            return;
                        }
                        protoptr = (struct ipproto *) protoptr->ipproto_link.mln_Succ;
                    }
                    Permit();                   /* Couldn't find a destination protocol */
//                }
            }
        }
    }
    FreeBuffer(ibuff);

    OFFTIMER(2);
}

/*------------------------------------------------------------------------*/

/* Routine to timeout IP fragments when we perceive them to be worthless */

void FragTimeoutDev(dev)
struct sanadev *dev;
{
    struct Buffer *tob;
    tob = (struct Buffer *) dev->sanadev_Fragments.mlh_Head;

    while (tob->buff_link.mln_Succ)
    {
        tob->buff_timeout--;
        if (!(tob->buff_timeout))
        {
            struct Buffer *rem;
            rem = tob;
            tob = (struct Buffer *) tob->buff_link.mln_Pred;
            Remove((struct Node *) rem);
            FreeBuffer(rem);
        }
        tob = (struct Buffer *) tob->buff_link.mln_Succ;
    }
}

/*------------------------------------------------------------------------*/

void FragmentTimeout()
{

    struct sanadev *sd;

    sd = (struct sanadev *) gb->DeviceList.lh_Head;
    while (sd->sanadev_Node.mln_Succ)
    {
        FragTimeoutDev(sd);
        sd = (struct sanadev *) sd->sanadev_Node.mln_Succ;
    }
}

/*------------------------------------------------------------------------*/
@


1.25
log
@Minor cleanup to fix remaining compiler warnings.
@
text
@d7 1
a7 1
** $Id: ip_in.c,v 1.24 92/08/19 16:10:15 kcd Exp Locker: kcd $
d51 3
a53 3
                our_checksum = CalcChecksum((UBYTE *) ipkt, packet_length, 0L);
                if (our_checksum == 0xFFFF)
                {
d55 1
a55 1
                    /* checksum is good! */
a182 7
                     * Well...not quite. :) See if the packet is for one of our sanadevs. If
                     * not, decrement the TTL value in the header and send the packet to
                     * ip_out, where it will be re-routed. Also, see if
                     */


                    /*
d218 1
a218 1
                }
@


1.24
log
@Removed the kprintf's.
@
text
@d7 1
a7 1
** $Id: ip_in.c,v 1.23 92/08/17 11:36:28 gregm Exp Locker: kcd $
a249 3
            struct BuffEntry *rbe;
            struct iphdr *ii;
            ii = (struct iphdr *) BuffPointer(tob,0L,&rbe);
@


1.23
log
@Fixed a typo.
@
text
@d7 1
a7 1
** $Id: ip_in.c,v 1.22 92/08/13 18:07:39 kcd Exp Locker: gregm $
d195 4
a198 4
                    if(!datalen)
                    {
                        kprintf("Alert! Alert! Recevied zero length packet from %lx!\n",ipkt->iph_SrcAddr);
                    }
@


1.22
log
@Added debugging statement to catch zero length packets.
@
text
@d7 1
a7 1
** $Id: ip_in.c,v 1.21 92/07/13 17:02:46 kcd Exp Locker: kcd $
d195 4
a198 4
		    if(!datalen)
		    {
		    	kprintf("Alert! Alert! Recevied zero length packet from %lx!\n",iph_SrcAddr);
		    }
@


1.21
log
@Space savings.
@
text
@d7 1
a7 1
** $Id: ip_in.c,v 1.20 92/06/12 11:14:34 gregm Exp Locker: kcd $
d194 5
@


1.20
log
@trivial
@
text
@d7 1
a7 1
** $Id: ip_in.c,v 1.19 92/06/08 10:08:48 kcd Exp Locker: gregm $
d236 4
a239 1
    if (!IsListEmpty((struct List *) & dev->sanadev_Fragments))
d241 2
a242 4
        struct Buffer *tob;
        tob = (struct Buffer *) dev->sanadev_Fragments.mlh_Head;

        while (tob->buff_link.mln_Succ)
d244 8
a251 13
            tob->buff_timeout--;
            if (!(tob->buff_timeout))
            {
                struct Buffer *rem;
                struct BuffEntry *rbe;
                struct iphdr *ii;
                ii = (struct iphdr *) BuffPointer(tob,0L,&rbe);
                rem = tob;
                tob = (struct Buffer *) tob->buff_link.mln_Pred;
                Remove((struct Node *) rem);
                FreeBuffer(rem);
            }
            tob = (struct Buffer *) tob->buff_link.mln_Succ;
d253 1
a253 1

d264 2
a265 1
    if (!IsListEmpty((struct List *) & gb->DeviceList))
d267 2
a268 6
        sd = (struct sanadev *) gb->DeviceList.lh_Head;
        while (sd->sanadev_Node.mln_Succ)
        {
            FragTimeoutDev(sd);
            sd = (struct sanadev *) sd->sanadev_Node.mln_Succ;
        }
@


1.19
log
@Code cleanups.
@
text
@d7 1
a7 1
** $Id: ip_in.c,v 1.18 92/05/22 15:34:30 gregm Exp Locker: kcd $
a249 1
                kprintf("Dropping seq %lx offset %lx\n",ii->iph_Ident,ii->iph_FragmentOffset);
@


1.18
log
@Added some kprintfs for when fragments are lost.
@
text
@d7 1
a7 1
** $Id: ip_in.c,v 1.17 92/05/14 19:25:11 kcd Exp Locker: gregm $
d21 1
a21 1
#define FRAGTIMEOUT 30          /* 3 seconds timeout for fragments */
d37 1
a37 1
    if (!ibuff->buff_list.mlh_Head->mln_Succ)
d39 9
a47 4
        FreeBuffer(ibuff);
        OFFTIMER(2);
        return;
    }
d49 1
a49 1
    be = (struct BuffEntry *) ibuff->buff_list.mlh_Head;
d51 3
a53 8
    if (be->be_length >= sizeof(struct iphdr))
        ipkt = (struct iphdr *) (be->be_data + be->be_offset);
    else
    {
        FreeBuffer(ibuff);
        OFFTIMER(2);
        return;
    }
d55 1
a55 6
    if (ipkt->iph_Version != 4)
    {
        FreeBuffer(ibuff);
        OFFTIMER(2);
        return;
    }
d57 10
a66 1
    packet_length = (ipkt->iph_IHL << 2);
d68 2
a69 1
    datalen = ipkt->iph_Length;
d71 12
a82 7
    our_checksum = CalcChecksum((UBYTE *) ipkt, packet_length, 0L);
    if (our_checksum != 0xFFFF)
    {
        FreeBuffer(ibuff);
        OFFTIMER(2);
        return;
    }
d84 12
a95 2
    gb->MonitorInfo.nmi_IPIn++;
    gb->MonitorInfo.nmi_IPBytesIn += (be->be_length - packet_length);
d97 2
a98 1
    /* checksum is good! */
d100 2
a101 10
    /*
     * Check for some level of fragmentation.  If none, completely skip the
     * frag code.  If some, add it to the frag list, with the proper id
     * (source+dest+protocol+identification).  Then, attempt to put all of
     * the pieces together. Note that duplicate packets are held onto - and
     * even if they're not used, eventually should time out.  However, we
     * can't protect upper levels from duplicate packets.  If all of the
     * pieces are duplicated (or even one packet, for one with no
     * fragmentation), they WILL get passed on. This isn't IP's problem.
     */
d103 76
a178 2
    if ((ipkt->iph_FragmentOffset != 0) || (ipkt->iph_Flags & IPFLAG_MOREFRAGMENTS))
    {
d180 1
a180 12
        struct Buffer *os;
        struct Buffer *assemble[150];
        struct iphdr *iptr;
        int acount;
        BOOL completed = FALSE;
        ibuff->buff_timeout = FRAGTIMEOUT;
        AddTail((struct List *) & (dev->sanadev_Fragments), (struct Node *) & (ibuff->buff_link));

        /*
         * Parse the list.  Each time we find the beginning of a fragment,
         * parse the list for the next entry, and so on.
         */
d182 12
a193 15
        os = (struct Buffer *) dev->sanadev_Fragments.mlh_Head;
        while (os->buff_link.mln_Succ)
        {
            struct BuffEntry *hbe;
            iptr = (struct iphdr *) BuffPointer(os, 0L, &hbe);
            if (iptr->iph_FragmentOffset == 0)  /* Found the start of one */
            {
                struct Buffer *is;
                struct iphdr *iniptr;
                BOOL cantfindit;
                UWORD nxtoffset;
                nxtoffset = (iptr->iph_Length - (iptr->iph_IHL << 2));

                cantfindit = FALSE;
                acount = 0;
d195 1
a195 2
                assemble[acount] = os;
                acount++;
d197 2
a198 6
                while (!cantfindit)
                {
                    completed = FALSE;
                    /* Look for that specific piece */
                    is = (struct Buffer *) dev->sanadev_Fragments.mlh_Head;
                    while (is->buff_link.mln_Succ)
d200 2
a201 2
                        iniptr = (struct iphdr *) ((struct BuffEntry *) is->buff_list.mlh_Head)->be_data;
                        if ((iniptr->iph_FragmentOffset << 3) == nxtoffset)
d203 3
a205 4
                            if ((iniptr->iph_Ident == iptr->iph_Ident) &&
                             (iniptr->iph_Protocol == iptr->iph_Protocol) &&
                                (iniptr->iph_SrcAddr == iptr->iph_SrcAddr) &&
                                (iniptr->iph_DestAddr == iptr->iph_DestAddr))
d207 4
a210 11
                                /*
                                 * found the next piece.  If all done, drop
                                 * out.  else loop for the next piece
                                 */
                                nxtoffset += (iniptr->iph_Length - (iniptr->iph_IHL << 2));
                                if (!(iniptr->iph_Flags & IPFLAG_MOREFRAGMENTS))
                                    completed = TRUE;
                                /* regardless, get it on the list */
                                assemble[acount] = is;
                                acount++;
                                break;
d212 4
d217 1
a217 5
                        is = (struct Buffer *) is->buff_link.mln_Succ;
                    }
                    if (!is->buff_link.mln_Succ)
                    {
                        cantfindit = TRUE;      /* if at end of list */
d219 1
a219 2
                    if (completed)
                        break;
a220 82

                if (completed)
                {
                    struct Buffer *headbuffer;
                    struct iphdr *headip;
                    struct Buffer *piece;
                    struct iphdr *iptmp;
                    int rc;
                    struct BuffEntry *hbe;
                    rc = 0;
                    headbuffer = assemble[rc];
                    rc++;
                    headip = (struct iphdr *) BuffPointer(headbuffer, 0L, &hbe);
                    Remove((struct Node *) headbuffer);
                    while (rc != acount)
                    {
                        piece = assemble[rc];
                        rc++;
                        Remove((struct Node *) piece);
                        iptmp = (struct iphdr *) BuffPointer(piece, 0L, &hbe);
                        ((struct BuffEntry *) piece->buff_list.mlh_Head)->be_offset += (iptmp->iph_IHL << 2);
                        ((struct BuffEntry *) piece->buff_list.mlh_Head)->be_length -= (iptmp->iph_IHL << 2);

                        headip->iph_Length += DataLength(piece);
                        MergeBuffer(headbuffer, piece);
                        ibuff = headbuffer;
                        ipkt = (struct iphdr *) BuffPointer(ibuff, 0L, &hbe);
                    }           /* endwhile */
                    break;
                }               /* endif */
            }                   /* endif */
            os = (struct Buffer *) os->buff_link.mln_Succ;
        }                       /* endwhile */
        if (!completed)
        {
            OFFTIMER(2);
            return;
        }
    }                           /* endif */

    /* Cool.  Let's ship the packet along up to the next protocol */

    /*
     * Well...not quite. :) See if the packet is for one of our sanadevs. If
     * not, decrement the TTL value in the header and send the packet to
     * ip_out, where it will be re-routed. Also, see if
     */


    /*
     * Unfortunately, this list could be changing underneath us. It's
     * probably wise to rid the code of the Forbid/Permit pairs and institure
     * a signal semaphore for the list.
     */

    Forbid();
//    if (IsListEmpty((struct List *) & gb->ProtocolList))    /* if no protocols exist */
    if (!gb->ProtocolList.mlh_Head->mln_Succ)
    {
        Permit();
        FreeBuffer(ibuff);
        OFFTIMER(2);
        return;
    }

    protoptr = (struct ipproto *) gb->ProtocolList.mlh_Head;
    while (protoptr->ipproto_link.mln_Succ)
    {

        if (protoptr->ipproto_ProtocolNumber == ipkt->iph_Protocol)
        {
            Permit();

            gb->MonitorInfo.nmi_IPKept++;
            gb->MonitorInfo.nmi_IPBytesKept += (ipkt->iph_Length - (ipkt->iph_IHL << 2));

            if (CountEntries(ibuff) > 1)
            {
                struct Buffer *i2buff;
                i2buff = (struct Buffer *) CloneBuffer(ibuff);
                FreeBuffer(ibuff);
                ibuff = i2buff;
a221 4
            OFFTIMER(2);
            if(ibuff)
                (*protoptr->ipproto_Input) (ibuff, datalen, dev);
            return;
a222 1
        protoptr = (struct ipproto *) protoptr->ipproto_link.mln_Succ;
a223 2
    Permit();                   /* Couldn't find a destination protocol */

a235 1
    register struct NBase *nb = gb;
a257 3

        if (gb->MonitorInfo.nmi_Monitor)
            Signal(nb->MonitorInfo.nmi_Monitor, (1 << nb->MonitorInfo.nmi_SigBitNum));
@


1.17
log
@Added some timing macros.
@
text
@d7 1
a7 1
** $Id: ip_in.c,v 1.16 92/05/05 17:35:07 kcd Exp Locker: kcd $
d278 4
@


1.16
log
@Fixed low-memory bug.
@
text
@d7 1
a7 1
** $Id: ip_in.c,v 1.15 92/04/21 16:07:51 kcd Exp Locker: kcd $
d29 1
d36 1
a36 1

d40 1
d51 1
d58 1
d70 1
d197 1
d223 1
d245 1
d256 1
a256 1

@


1.15
log
@Reworked low-level packet routing again. Now much cleaner than before.
@
text
@d7 1
a7 1
** $Id: ip_in.c,v 1.14 92/04/12 16:00:21 kcd Exp Locker: kcd $
d238 2
a239 1
            (*protoptr->ipproto_Input) (ibuff, datalen, dev);
d258 1
a258 1
	register struct NBase *nb = gb;
@


1.14
log
@Fixed Yet Another ip reassebly bug.  The loop could drop through
incorrectly if the packets came in out of order. (RS-485 helped us
find this one.)
@
text
@d7 1
a7 1
** $Id: ip_in.c,v 1.13 92/04/10 00:39:52 kcd Exp Locker: kcd $
d25 1
a25 1
void ip_in(ibuff, len, dev)
a27 1
ULONG len;
d33 1
a33 3
    struct sanadev *tdev;
    BOOL reroute, localcopy;
    ULONG packet_length;
a35 2

//    if (IsListEmpty((struct List *) & (ibuff->buff_list)))
a51 1

d58 1
d60 1
a60 1
    packet_length = (ipkt->iph_IHL << 2);
a68 2
    be->be_length = ipkt->iph_Length;

a71 35
    reroute = TRUE;

    tdev = (struct sanadev *) gb->DeviceList.lh_Head;

    while (tdev->sanadev_Node.mln_Succ)
    {
        if (ipkt->iph_DestAddr == tdev->sanadev_IPAddress)
        {
            reroute = FALSE;
            break;
        }
        tdev = (struct sanadev *) tdev->sanadev_Node.mln_Succ;
    }

    if (ipkt->iph_DestAddr == 0xffffffff)
        reroute = FALSE;

    /*
     * This packet isn't specifically for one of our interfaces.  We still
     * may need a copy of it if it is a broadcast message for a net we are
     * on.  All of the special cases will be handled by the gate_out()
     * routine in ip_out.c
     */

    localcopy = TRUE;

    if (reroute)
        localcopy = gate_out(ibuff, dev);

    if (!localcopy)
    {
        return;
    }


d87 1
a92 1

d227 4
d238 1
a238 4

            gb->MonitorInfo.nmi_IPKept++;
            gb->MonitorInfo.nmi_IPBytesKept += (ipkt->iph_Length - (ipkt->iph_IHL << 2));
            (*protoptr->ipproto_Input) (ibuff, len, dev);
a242 1

@


1.13
log
@Removed Dependencies on old exec_pragmas.h file.
@
text
@d7 1
a7 1
** $Id: ip_in.c,v 1.12 92/04/05 18:11:02 gregm Exp Locker: kcd $
d133 1
a133 1
        BOOL completed;
a236 1

@


1.12
log
@Upped the fragmentation limit.
@
text
@d7 1
a7 1
** $Id: ip_in.c,v 1.11 92/03/23 10:22:27 gregm Exp $
d300 1
d321 1
a321 1
            Signal(gb->MonitorInfo.nmi_Monitor, (1 << gb->MonitorInfo.nmi_SigBitNum));
@


1.11
log
@The_voodoo_stuff_is_GONE!
@
text
@d7 1
a7 1
** $Id: ip_in.c,v 1.10 92/03/04 16:59:47 gregm Exp $
d130 1
a130 1
        struct Buffer *assemble[20];
@


1.10
log
@Moved globals to globals.c; externs for these in externs.h.
@
text
@d7 1
a7 1
** $Id: ip_in.c,v 1.9 92/02/29 20:37:16 kcd Exp Locker: gregm $
d40 2
a41 1
    if (IsListEmpty((struct List *) & (ibuff->buff_list)))
d76 2
a77 2
    MonitorInfo.nmi_IPIn++;
    MonitorInfo.nmi_IPBytesIn += (be->be_length - packet_length);
d81 1
a81 1
    tdev = (struct sanadev *) DeviceList.lh_Head;
d255 2
a256 1
    if (IsListEmpty((struct List *) & ProtocolList))    /* if no protocols exist */
d263 1
a263 1
    protoptr = (struct ipproto *) ProtocolList.mlh_Head;
d278 2
a279 2
            MonitorInfo.nmi_IPKept++;
            MonitorInfo.nmi_IPBytesKept += (ipkt->iph_Length - (ipkt->iph_IHL << 2));
d319 2
a320 2
        if (MonitorInfo.nmi_Monitor)
            Signal(MonitorInfo.nmi_Monitor, (1 << MonitorInfo.nmi_SigBitNum));
d332 1
a332 1
    if (!IsListEmpty((struct List *) & DeviceList))
d334 1
a334 1
        sd = (struct sanadev *) DeviceList.lh_Head;
@


1.9
log
@Now recognizes hosts broadcasts (255.255.255.255) and doesn't try
calling the gate_out() function.
@
text
@d7 1
a7 1
** $Id: ip_in.c,v 1.8 92/02/27 20:56:19 kcd Exp $
d14 1
a24 16
/* Externals */

extern struct MinList DeviceList;
extern struct NIPCMonitorInfo MonitorInfo;
extern struct Library *DOSBase;

/*------------------------------------------------------------------------*/

/* Globals */

/* The protocol list that IP uses to find protocol input points */

struct MinList ProtocolList;

/*------------------------------------------------------------------------*/

d80 1
a80 1
    tdev = (struct sanadev *) DeviceList.mlh_Head;
d332 1
a332 1
        sd = (struct sanadev *) DeviceList.mlh_Head;
@


1.8
log
@New formatting.  Modified for use with registerized arguments.  Changed
for use with new include files.  Changed routing to not reassemble
packets if the destination is not our machine.
@
text
@d7 1
a7 1
** $Id$
d54 1
d107 3
d127 1
d146 1
a146 1
        int acount = 0;
a170 1
                iniptr = iptr;
a292 1

@


1.7
log
@Added code for monitor stats.
@
text
@d1 20
d22 1
a22 4
/*
 * $Header: APPN:src/nipc/RCS/ip_in.c,v 1.6 92/02/20 20:14:12 gregm Exp Locker: kcd $
 *
 */
d24 1
a24 11
#define FRAGTIMEOUT 30           /* 3 seconds timeout for fragments */

#include <exec/lists.h>
#include <exec/nodes.h>
#include "ip.h"
#include "memory.h"
#include "s2io.h"
#include <proto/exec.h>
#include <proto/dos.h>
#include "route.h"
#include "monitor.h"
d26 8
d35 1
a36 1
//struct MinList UnfragList;
d38 1
a38 2
extern struct MinList DeviceList;
extern struct NIPCMonitorInfo MonitorInfo;
d40 3
a42 3
void ip_in(ibuff,len,dev)
struct sanadev *dev;          /* ... and the device you rode in on! */
struct Buffer *ibuff;         /* The packet to sift */
d45 79
a123 1
struct ipproto *protoptr;
d125 146
a270 89
struct iphdr *ipkt;
struct BuffEntry *be;
struct sanadev *tdev;
BOOL reroute;
ULONG packet_length;
UWORD our_checksum;

 if (IsListEmpty((struct List *) &(ibuff->buff_list)))
   {
   FreeBuffer(ibuff);
   return;
   }

 be = (struct BuffEntry *) ibuff->buff_list.mlh_Head;

 if (be->be_length >= sizeof(struct iphdr))
   ipkt = (struct iphdr *) (be->be_data + be->be_offset);
 else
   {
   FreeBuffer(ibuff);
   return;
   }


 if (ipkt->iph_Version != 4)
   {
   FreeBuffer(ibuff);
   return;
   }


 packet_length = (ipkt->iph_IHL << 2);

 our_checksum = CalcChecksum(ipkt,packet_length,0L);
 if (our_checksum != 0xFFFF)
   {
   FreeBuffer(ibuff);
   return;
   }

 be->be_length = ipkt->iph_Length;

 MonitorInfo.nmi_IPIn++;
 MonitorInfo.nmi_IPBytesIn += (be->be_length - packet_length);

/* checksum is good! */

/* Check for some level of fragmentation.  If none, completely skip the
 * frag code.  If some, add it to the frag list, with the proper
 * id (source+dest+protocol+identification).  Then, attempt to put all of
 * the pieces together.
 * Note that duplicate packets are held onto - and even if they're not
 * used, eventually should time out.  However, we can't protect upper levels
 * from duplicate packets.  If all of the pieces are duplicated (or even
 * one packet, for one with no fragmentation), they WILL get passed on.
 * This isn't IP's problem.
 */

 if ((ipkt->iph_FragmentOffset != 0) || (ipkt->iph_Flags & IPFLAG_MOREFRAGMENTS))
   {
   struct Buffer *os;
   struct Buffer *assemble[20];
   struct iphdr *iptr;
   int acount=0;
   BOOL completed;

   ibuff->buff_timeout = FRAGTIMEOUT;
   AddTail((struct List *)&(dev->sanadev_Fragments),(struct Node *)&(ibuff->buff_link));

   /* Parse the list.  Each time we find the beginning of a fragment,
    * parse the list for the next entry, and so on.
    */

   os = (struct Buffer *) dev->sanadev_Fragments.mlh_Head;
   while (os->buff_link.mln_Succ)
      {
      struct BuffEntry *hbe;
      iptr = (struct iphdr *) BuffPointer(os,0L,&hbe);
      if (iptr->iph_FragmentOffset == 0)  /* Found the start of one */
         {
         struct Buffer *is;
         struct iphdr *iniptr;
         BOOL cantfindit;
         UWORD nxtoffset;
         nxtoffset = (iptr->iph_Length - (iptr->iph_IHL << 2));

         cantfindit = FALSE;
         iniptr = iptr;
         acount = 0;
d272 3
a274 2
         assemble[acount] = os;
         acount++;
d276 4
a279 1
         while (!cantfindit)
d281 4
a284 32
            completed = FALSE;
            /* Look for that specific piece */
            is = (struct Buffer *) dev->sanadev_Fragments.mlh_Head;
            while (is->buff_link.mln_Succ)
               {
               iniptr = (struct iphdr *) ( (struct BuffEntry *) is->buff_list.mlh_Head)->be_data;
               if ((iniptr->iph_FragmentOffset << 3) == nxtoffset)
                  {
                  if ( (iniptr->iph_Ident == iptr->iph_Ident) &&
                       (iniptr->iph_Protocol == iptr->iph_Protocol) &&
                       (iniptr->iph_SrcAddr == iptr->iph_SrcAddr) &&
                       (iniptr->iph_DestAddr == iptr->iph_DestAddr) )
                     {
                     /* found the next piece.  If all done, drop out.  else
                      * loop for the next piece
                      */
                     nxtoffset += (iniptr->iph_Length - (iniptr->iph_IHL << 2));
                     if (!(iniptr->iph_Flags & IPFLAG_MOREFRAGMENTS))
                        completed = TRUE;
                     /* regardless, get it on the list */
                     assemble[acount]=is;
                     acount++;
                     break;
                     }
                  }
               is = (struct Buffer *) is->buff_link.mln_Succ;
               }
            if (!is->buff_link.mln_Succ)
               {
               cantfindit = TRUE; /* if at end of list */
               }
            if (completed) break;
d287 2
a288 112
         if (completed)
            {
            struct Buffer *headbuffer;
            struct iphdr *headip;
            struct Buffer *piece;
            struct iphdr *iptmp;
            int rc;
            struct BuffEntry *hbe;
            rc = 0;
            headbuffer = assemble[rc];
            rc++;
            headip = (struct iphdr *) BuffPointer(headbuffer,0L,&hbe);
            Remove((struct Node *)headbuffer);
            while (rc != acount)
               {
               piece = assemble[rc];
               rc++;
               Remove((struct Node *)piece);
               iptmp = (struct iphdr *) BuffPointer(piece,0L,&hbe);
               ((struct BuffEntry *)piece->buff_list.mlh_Head)->be_offset += (iptmp->iph_IHL << 2);
               ((struct BuffEntry *)piece->buff_list.mlh_Head)->be_length -= (iptmp->iph_IHL << 2);

               headip->iph_Length += DataLength(piece);
               MergeBuffer(headbuffer,piece);
               ibuff = headbuffer;
               ipkt = (struct iphdr *) BuffPointer(ibuff,0L,&hbe);
               } /* endwhile */
            break;
            } /* endif */
         } /* endif */
      os = (struct Buffer *) os->buff_link.mln_Succ;
      } /* endwhile */
   if (!completed)
      {
      return;
      }
   } /* endif */


/* Cool.  Let's ship the packet along up to the next protocol */

/* Well...not quite. :) See if the packet is for one of our sanadevs. If not, decrement the
 * TTL value in the header and send the packet to ip_out, where it will be re-routed.
 * Also, see if
 */

 reroute = TRUE;

 tdev = (struct sanadev *) DeviceList.mlh_Head;

 while(tdev->sanadev_Node.mln_Succ)
 {
    if(ipkt->iph_DestAddr == tdev->sanadev_IPAddress)
    {
        reroute = FALSE;
        break;
    }
    tdev = (struct sanadev *) tdev->sanadev_Node.mln_Succ;
 }

/* This packet isn't specifically for one of our interfaces.  We still may need a copy of it if it
 * is a broadcast message for a net we are on.  All of the special cases will be handled by the
 * gate_out() routine in ip_out.c
 */

 if(reroute)
 {
//    kprintf("Rerouting Packet from: %lx\n",ipkt->iph_SrcAddr);
    gate_out(ibuff,dev);
    return;
 }
// else
//    kprintf("Got packet for this machine.\n");

/* Unfortunately, this list could be changing underneath us.
 * It's probably wise to rid the code of the Forbid/Permit
 * pairs and institure a signal semaphore for the list.
 */

 Forbid();
 if (IsListEmpty( (struct List *) &ProtocolList))     /* if no protocols exist */
   {
   Permit();
   FreeBuffer(ibuff);
   return;
   }

 protoptr = (struct ipproto *) ProtocolList.mlh_Head;
 while (protoptr->ipproto_link.mln_Succ)
   {

   if (protoptr->ipproto_ProtocolNumber == ipkt->iph_Protocol)
      {
      Permit();
      if (CountEntries(ibuff) > 1)
         {
         struct Buffer *i2buff;
         i2buff = (struct Buffer *) CloneBuffer(ibuff);
         FreeBuffer(ibuff);
         ibuff = i2buff;
         }

      MonitorInfo.nmi_IPKept++;
      MonitorInfo.nmi_IPBytesKept += (ipkt->iph_Length - (ipkt->iph_IHL << 2));

      (*protoptr->ipproto_Input)(ibuff,len,dev);
      return;
      }
   protoptr = (struct ipproto *) protoptr->ipproto_link.mln_Succ;
   }

 Permit();           /* Couldn't find a destination protocol */
d290 5
a294 1
 FreeBuffer(ibuff);
d296 1
d298 1
a298 1
}
d301 1
d303 1
d306 1
d310 4
a313 4
 if (!IsListEmpty( (struct List *) &dev->sanadev_Fragments ))
   {
   struct Buffer *tob;
   tob = (struct Buffer *) dev->sanadev_Fragments.mlh_Head;
d315 13
a327 14
   while (tob->buff_link.mln_Succ)
      {
      tob->buff_timeout --;
      if (!(tob->buff_timeout))
         {
         struct Buffer *rem;
         rem = tob;
         tob = (struct Buffer *) tob->buff_link.mln_Pred;
         kprintf("Timing out a fragment ... \n");
         Remove( (struct Node *) rem);
         FreeBuffer(rem);
         }
      tob = (struct Buffer *) tob->buff_link.mln_Succ;
      }
d329 2
a330 2
   if(MonitorInfo.nmi_Monitor)
      Signal(MonitorInfo.nmi_Monitor,(1 << MonitorInfo.nmi_SigBitNum));
d332 1
a332 1
   }
d335 2
d340 1
a340 1
 struct sanadev *sd;
d342 9
a350 9
 if (!IsListEmpty( (struct List *) &DeviceList))
   {
   sd = (struct sanadev *) DeviceList.mlh_Head;
   while (sd->sanadev_Node.mln_Succ)
      {
      FragTimeoutDev(sd);
      sd = (struct sanadev *) sd->sanadev_Node.mln_Succ;
      }
   }
d353 1
@


1.6
log
@Looked for a bug, and made some trivial changes
@
text
@d3 1
a3 1
 * $Header: APPN:src/nipc/RCS/ip_in.c,v 1.5 92/02/20 14:06:10 gregm Exp Locker: gregm $
d17 1
d24 1
d75 3
d263 4
d306 4
@


1.5
log
@Added in IP fragmentation timeouts.
@
text
@d3 1
a3 1
 * $Header: APPN:src/nipc/RCS/ip_in.c,v 1.4 92/02/20 11:49:58 gregm Exp $
d20 1
a20 1
struct MinList UnfragList;
d104 2
a105 2

      iptr = (struct iphdr *) ( (struct BuffEntry *) os->buff_list.mlh_Head)->be_data;
d111 3
a113 1
         UWORD nxtoffset = 0;
a122 1
            nxtoffset += (iniptr->iph_Length - (iniptr->iph_IHL << 2));
d139 1
d150 4
a153 1
            if (!is->buff_link.mln_Succ) cantfindit = TRUE; /* if at end of list */
d190 1
d192 1
d272 2
d275 2
a276 1
void FragmentTimeout()
d278 1
a278 2

 if (!IsListEmpty( (struct List *) &UnfragList ))
d281 1
a281 1
   tob = (struct Buffer *) UnfragList.mlh_Head;
d291 1
d300 15
@


1.4
log
@I -think- I fixed fragmentation input.  :')
@
text
@d3 1
a3 1
 * $Header: APPN:src/nipc/RCS/ip_in.c,v 1.3 92/02/20 11:10:04 kcd Exp Locker: gregm $
d7 1
d94 1
d263 27
@


1.3
log
@Routed moved to ip_out.c.  Fixed a bug related to minimum ethernet
packet size.  We now get the packet length from the IP header rather
than DataLength(buffer).
@
text
@d3 1
a3 1
 * $Header: APPN:src/libs/nipc.library/RCS/ip_in.c,v 1.2 92/02/17 09:54:01 kcd Exp $
a86 1

a92 1
   kprintf("Got an IP fragment.\n");
d157 1
d161 1
a161 1
            headip = (struct iphdr *) ( (struct BuffEntry *) headbuffer->buff_list.mlh_Head)->be_data;
d168 3
a170 4
               iptmp = (struct iphdr *) ( (struct BuffEntry *) piece->buff_list.mlh_Head)->be_data;

               ((struct BuffEntry *)piece->buff_list.mlh_Head)->be_offset += sizeof(struct iphdr);
               ((struct BuffEntry *)piece->buff_list.mlh_Head)->be_length -= sizeof(struct iphdr);
d174 6
a179 6
               }

//            os = (struct Buffer *) os->buff_link.mln_Pred;
//            FreeBuffer(headbuffer);
            }
         }
d181 4
a184 3
      }
   if(!completed) return;
   }
d242 7
@


1.2
log
@Added code to reroute packets back through ip_out.c
@
text
@d3 1
a3 1
 * $Header: APPN:src/libs/nipc.library/RCS/ip_in.c,v 1.1 92/02/13 10:01:11 gregm Exp Locker: kcd $
a33 2
ULONG packlen;
struct Buffer *newpacket;
d60 1
d70 2
d87 1
d94 1
a94 1

d171 3
d177 3
a179 2
            os = (struct Buffer *) os->buff_link.mln_Pred;
            FreeBuffer(headbuffer);
d184 1
a184 1
   return;
d192 1
a198 7
 packlen = (ULONG) ipkt->iph_Length;

// kprintf("Packet Source: %lx\n",ipkt->iph_SrcAddr);
// kprintf("Packet Dest:   %lx\n",ipkt->iph_DestAddr);
// kprintf("Packet Length: %ld\n",packlen - packet_length);
// kprintf("Buffer Length: %ld\n",DataLength(ibuff));

a200 2
//    kprintf("Checking against: %lx\n",tdev->sanadev_IPAddress);

a202 2
//        kprintf("Match found. No routing needed.\n");

d209 3
a211 6

/* If this packet isn't for us, we need to save off a few things from the ip header, and
 * then copy the data to a new buffer.  Then, send the new buffer off to ip_out. Unfortuneately,
 * I'm not sure if there is a better way to remove the ip header from the beginning.  The other
 * option is to give IP a flag that says, "there's already an attached ip header".  That's probably
 * the better thing to do, but that would break the ip fragmentation algorithm, etc, etc, etc.
d216 2
a217 8
//    kprintf("Rerouting packet!\n");

    newpacket = (struct Buffer *) AllocBuffer(packlen - packet_length);

    CopyBuffer(ibuff,be->be_offset+sizeof(struct iphdr),packlen - packet_length,newpacket);

    ip_out(newpacket,ipkt->iph_SrcAddr,ipkt->iph_DestAddr,ipkt->iph_Protocol,0,FALSE,0);
    FreeBuffer(ibuff);
d220 2
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
 * $Header$
d15 1
d21 2
d32 4
d183 50
@
