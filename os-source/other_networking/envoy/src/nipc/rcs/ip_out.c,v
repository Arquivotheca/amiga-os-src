head     1.41;
branch   ;
access   ;
symbols  ;
locks    ; strict;
comment  @ * @;


1.41
date     93.08.10.16.16.50;  author kcd;  state Exp;
branches ;
next     1.40;

1.40
date     93.07.30.18.45.48;  author gregm;  state Exp;
branches ;
next     1.39;

1.39
date     92.12.16.14.40.33;  author kcd;  state Exp;
branches ;
next     1.38;

1.38
date     92.12.01.14.36.03;  author kcd;  state Exp;
branches ;
next     1.37;

1.37
date     92.11.19.14.17.15;  author kcd;  state Exp;
branches ;
next     1.36;

1.36
date     92.09.24.16.58.31;  author kcd;  state Exp;
branches ;
next     1.35;

1.35
date     92.08.21.14.26.33;  author kcd;  state Exp;
branches ;
next     1.34;

1.34
date     92.08.19.16.09.40;  author kcd;  state Exp;
branches ;
next     1.33;

1.33
date     92.08.13.18.03.53;  author kcd;  state Exp;
branches ;
next     1.32;

1.32
date     92.06.12.10.59.41;  author kcd;  state Exp;
branches ;
next     1.31;

1.31
date     92.06.08.10.06.38;  author kcd;  state Exp;
branches ;
next     1.30;

1.30
date     92.05.28.17.18.24;  author kcd;  state Exp;
branches ;
next     1.29;

1.29
date     92.05.15.12.46.37;  author kcd;  state Exp;
branches ;
next     1.28;

1.28
date     92.05.12.17.03.37;  author gregm;  state Exp;
branches ;
next     1.27;

1.27
date     92.05.08.15.22.01;  author kcd;  state Exp;
branches ;
next     1.26;

1.26
date     92.05.08.14.33.14;  author kcd;  state Exp;
branches ;
next     1.25;

1.25
date     92.05.05.17.29.34;  author kcd;  state Exp;
branches ;
next     1.24;

1.24
date     92.05.04.10.57.07;  author kcd;  state Exp;
branches ;
next     1.23;

1.23
date     92.04.22.17.26.28;  author kcd;  state Exp;
branches ;
next     1.22;

1.22
date     92.04.22.16.01.21;  author gregm;  state Exp;
branches ;
next     1.21;

1.21
date     92.04.21.15.59.01;  author kcd;  state Exp;
branches ;
next     1.20;

1.20
date     92.04.12.15.59.11;  author kcd;  state Exp;
branches ;
next     1.19;

1.19
date     92.04.10.14.54.43;  author kcd;  state Exp;
branches ;
next     1.18;

1.18
date     92.04.10.00.41.08;  author kcd;  state Exp;
branches ;
next     1.17;

1.17
date     92.04.05.15.43.41;  author kcd;  state Exp;
branches ;
next     1.16;

1.16
date     92.04.05.15.37.38;  author kcd;  state Exp;
branches ;
next     1.15;

1.15
date     92.03.23.10.22.06;  author gregm;  state Exp;
branches ;
next     1.14;

1.14
date     92.03.05.17.24.39;  author gregm;  state Exp;
branches ;
next     1.13;

1.13
date     92.03.04.16.57.08;  author gregm;  state Exp;
branches ;
next     1.12;

1.12
date     92.02.29.20.30.42;  author kcd;  state Exp;
branches ;
next     1.11;

1.11
date     92.02.27.20.57.15;  author kcd;  state Exp;
branches ;
next     1.10;

1.10
date     92.02.24.10.49.24;  author kcd;  state Exp;
branches ;
next     1.9;

1.9
date     92.02.21.16.36.14;  author kcd;  state Exp;
branches ;
next     1.8;

1.8
date     92.02.21.13.26.09;  author kcd;  state Exp;
branches ;
next     1.7;

1.7
date     92.02.21.13.07.10;  author kcd;  state Exp;
branches ;
next     1.6;

1.6
date     92.02.20.20.32.01;  author kcd;  state Exp;
branches ;
next     1.5;

1.5
date     92.02.20.14.20.22;  author kcd;  state Exp;
branches ;
next     1.4;

1.4
date     92.02.20.14.05.22;  author gregm;  state Exp;
branches ;
next     1.3;

1.3
date     92.02.20.11.05.14;  author kcd;  state Exp;
branches ;
next     1.2;

1.2
date     92.02.17.09.54.28;  author kcd;  state Exp;
branches ;
next     1.1;

1.1
date     92.02.13.10.01.46;  author gregm;  state Exp;
branches ;
next     ;


desc
@The NIPC IP implementation's output routines.
@


1.41
log
@IP Header checkum validation now done in multiplex_in to avoid forwarding 
packets with trashed headers.
@
text
@/**************************************************************************
**
** ip_out.c     - IP Packet output and gateway functions
**
** Copyright 1992, Commodore-Amiga, Inc.
**
** $Id: ip_out.c,v 1.40 93/07/30 18:45:48 gregm Exp Locker: kcd $
**
***************************************************************************

/*------------------------------------------------------------------------*/
#include "nipcinternal.h"


#include <clib/exec_protos.h>
#include <clib/dos_protos.h>
#include "nipcinternal_protos.h"

#include <pragmas/exec_pragmas.h>
#include "externs.h"

/*------------------------------------------------------------------------*/

void ip_out(obuff, srcip, destip, protocol, iface, gateway, frags, morefrags, inident, ttl, dbc, fraglast)
struct Buffer *obuff;
UBYTE protocol;
struct sanadev *iface;
ULONG gateway;
ULONG srcip;
ULONG destip;
ULONG frags;
BOOL morefrags;
BOOL fraglast;
UWORD inident;
UBYTE ttl;
BOOL dbc;
{

    struct BuffEntry *be;
    struct iphdr *hdr;
    /* struct sanadev *dev; */
    ULONG len;

    ONTIMER(0);
    if(!ttl)
    {
        OFFTIMER(0);
        FreeBuffer(obuff);
        return;
    }

    len = DataLength(obuff);

    if ((len + sizeof(struct iphdr)) > iface->sanadev_MTU)
    {
        /*
         * Icky.  We have to fragment packets. Luckily, I can get away with
         * recursively calling ip_out. Fragmentation currently incurs data
         * copying.  This is unpleasant, but a necessity.  I may later change
         * the algorithm to be intelligent enough to avoid copying whenver
         * possible, and to build packets around already existant
         * BuffEntry's, whenever possible.
         */

        struct Buffer *fragbuff;
        ULONG x, y;

        y = ((iface->sanadev_MTU - sizeof(struct iphdr)) & 0xFFFFFFF8);
        for (x = 0; x < len; x += y)
        {
            if ((x + y) >= len)
                y = len - x;    /* for the last piece */
            if(fragbuff = (struct Buffer *) AllocBuffer(y))
            {
                CopyBuffer(obuff, x, y, fragbuff);
                ip_out(fragbuff, srcip, destip, protocol, iface, gateway, frags + (x / 8), ((x + y) < len), inident, ttl, dbc, fraglast);
                ONTIMER(2);
            }
        }
        FreeBuffer(obuff);
        OFFTIMER(2);
        return;
    }


    /*
     * First, allocate a BuffEntry with the necessary space in it to house
     * the IP header, and insert it at the Head of the Buffer.
     */

    if(be = AllocBuffEntry(sizeof(struct iphdr)))
    {
        AddHead((struct List *) & (obuff->buff_list), (struct Node *) be);
        hdr = (struct iphdr *) be->be_data;

        /* Now, start filling in the fields */
        hdr->iph_Version = 4;       /* IP revision #4 is the most recent */
        hdr->iph_IHL = 5;           /* I never send options, so the header is 20
                                     * bytes.  20/4 = 5 */
        be->be_length = 20;
        hdr->iph_TypeOfService = 0; /* Default service */
        hdr->iph_Length = DataLength(obuff);        /* Count up the size */

        /* Make sure that fragged packets all use the same identification # */
        Forbid();
        if ((frags == 0) && (!morefrags))
            hdr->iph_Ident = gb->IPIdentNumber++;
        else
            hdr->iph_Ident = inident;
        Permit();

        hdr->iph_Flags = 0;

        if (morefrags || fraglast)
            hdr->iph_Flags |= IPFLAG_MOREFRAGMENTS;
        hdr->iph_FragmentOffset = frags;

        hdr->iph_TimeToLive = ttl;
        hdr->iph_Protocol = protocol;
        hdr->iph_Checksum = 0;

        if (srcip)
            hdr->iph_SrcAddr = srcip;
        else
            hdr->iph_SrcAddr = iface->sanadev_IPAddress;

        hdr->iph_DestAddr = destip;

        /*
         * Calculate the checksum Note that the IP checksum covers ONLY the IP
         * header, and NOT the rest of the datagram!
         */

        hdr->iph_Checksum = (0xffffffff - CalcChecksum((UBYTE *) hdr, 20, 0));

        if (dbc)
        {
            PacketWrite(iface, 0L, obuff, 0L, PACKET_IP, TRUE, FALSE);
        }
        else
        {
            ONTIMER(7);
            PacketWrite(iface, gateway, obuff, destip, PACKET_IP, FALSE, FALSE);
            OFFTIMER(7);
        }
    }
    OFFTIMER(0);
}

/*------------------------------------------------------------------------*/
void ip_sendsrc(obuff, srcip, destip, protocol)
struct Buffer *obuff;
ULONG srcip;
ULONG destip;
UBYTE protocol;
{
    UWORD tmpid;
    Forbid();
    tmpid = gb->IPIdentNumber++;
    Permit();
    ONTIMER(11);
    multiplex(obuff, 0L, NULL, srcip, destip, protocol, 0, FALSE, tmpid, 30, FALSE);
    OFFTIMER(11);
}

void multiplex_in(ibuff, dev)
struct Buffer *ibuff;
struct sanadev *dev;
{
    struct BuffEntry *be;
    UWORD checksum;
    struct iphdr *ipkt;
    BOOL fraglast;
    ULONG headerlength;

    ONTIMER(10);

    be = (struct BuffEntry *) ibuff->buff_list.mlh_Head;
    ipkt = (struct iphdr *) (be->be_data + be->be_offset);
    fraglast = (ipkt->iph_Flags & IPFLAG_MOREFRAGMENTS);
    headerlength = ipkt->iph_IHL << 2;

    checksum = CalcChecksum((UBYTE *) ipkt, headerlength, 0L);
    if((ipkt->iph_Version == 4) && (checksum == 0xFFFF))
    {
        be->be_offset += headerlength;
        be->be_length = ipkt->iph_Length - headerlength;

        multiplex(ibuff, headerlength, dev, ipkt->iph_SrcAddr, ipkt->iph_DestAddr, ipkt->iph_Protocol,
                  ipkt->iph_FragmentOffset, fraglast, ipkt->iph_Ident, ipkt->iph_TimeToLive, fraglast);
    }
    else
    {
        FreeBuffer(ibuff);
    }
    OFFTIMER(10);
}

/*------------------------------------------------------------------------*/

void multiplex(ibuff, headerlength, dev, SrcIP, DestIP, protocol, frags, morefrags, ident, ttl, fraglast)
struct Buffer *ibuff;
struct sanadev *dev;
ULONG headerlength, SrcIP, DestIP, frags;
UBYTE protocol, ttl;
BOOL morefrags,fraglast;
UWORD ident;
{
    struct sanadev *iface;
    struct sanadev *propiface;
    struct NIPCRoute *route;
    struct Buffer *clonebuff;
    struct BuffEntry *be;
    BOOL LocalCopy, Sent, SendClone, ForwardPacket;

    ONTIMER(1);
    LocalCopy = Sent = ForwardPacket = SendClone = FALSE;

    if(IsLocalDevice(DestIP))
    {
        LocalCopy = TRUE;
    }
    else if((dev) && (IsLocalDevice(SrcIP)))
    {
        ;
    }
    else if(IsBroadcast(DestIP))
    {
        if(iface = LocalNet(DestIP))
        {
            if(iface->sanadev_SValid)
            {
                if(route = Route(SrcIP, FALSE))
                {
                    if ((DestIP & ~(iface->sanadev_SubnetMask)) == ~iface->sanadev_SubnetMask)  /* Host broadcast */
                    {
                        if((route->nr_Device == dev) || (!dev))
                        {
                            propiface = (struct sanadev *) gb->DeviceList.lh_Head->ln_Succ;

                            while (propiface->sanadev_Node.mln_Succ)
                            {
                                if (propiface != dev)       /* Don't bounce packets */
                                {
                                    if(clonebuff = (struct Buffer *) CloneBuffer(ibuff))
                                    {
                                        ip_out(clonebuff, SrcIP, DestIP, protocol, propiface,
                                               propiface->sanadev_IPAddress, frags, morefrags,
                                               ident, ttl - 1, TRUE, fraglast);
                                    }
                                }
                                propiface = (struct sanadev *) propiface->sanadev_Node.mln_Succ;
                            }
                        }
                    }
                    else if(!dev)
                        SendClone = TRUE;

                }
            }
            else
            {
                propiface = (struct sanadev *) gb->DeviceList.lh_Head->ln_Succ;

                while (propiface->sanadev_Node.mln_Succ)
                {
                    if(propiface != dev)
                    {
                        if((propiface->sanadev_IPNetwork | ~propiface->sanadev_IPMask) == DestIP)
                        {
                            if(clonebuff = (struct Buffer *) CloneBuffer(ibuff))
                            {
                                ip_out(clonebuff, SrcIP, DestIP, protocol, propiface,
                                       propiface->sanadev_IPAddress, frags, morefrags,
                                       ident, ttl - 1, TRUE, fraglast);
                            }
                        }
                    }
                    propiface = (struct sanadev *) propiface->sanadev_Node.mln_Succ;
                }
            }
            LocalCopy = TRUE;
        }
        else
        {
            if((DestIP == 0xffffffff) && (!dev))
            {
                propiface = (struct sanadev *) gb->DeviceList.lh_Head->ln_Succ;

                while (propiface->sanadev_Node.mln_Succ)
                {
                    if(clonebuff = (struct Buffer *) CloneBuffer(ibuff))
                    {
                        ip_out(clonebuff, SrcIP, DestIP, protocol, propiface,
                               propiface->sanadev_IPAddress, frags, morefrags,
                               ident, ttl - 1, TRUE, fraglast);
                    }
                    propiface = (struct sanadev *) propiface->sanadev_Node.mln_Succ;
                }
                LocalCopy = TRUE;
            }
            else if ((DestIP == 0xffffffff) && (dev))
            {
                LocalCopy = TRUE;
            }
            else if (route = Route(DestIP, FALSE))
            {
                ip_out(ibuff, SrcIP, DestIP, protocol, route->nr_Device, route->nr_Gateway,
                       frags, morefrags, ident, ttl - 1, FALSE, fraglast);
                Sent = TRUE;
                LocalCopy = FALSE;
            }
        }
    }
    else
    {
        ForwardPacket = TRUE;
    }
    if(ForwardPacket)
    {
        if(route = Route(DestIP, FALSE))
        {
            ip_out(ibuff, SrcIP, DestIP, protocol, route->nr_Device, route->nr_Gateway,
                   frags, morefrags, ident, ttl - 1, FALSE, fraglast);
            Sent = TRUE;
        }
    }
    if(SendClone)
    {
        if(clonebuff = (struct Buffer *) CloneBuffer(ibuff))
            ip_out(clonebuff, SrcIP, DestIP, protocol, iface, iface->sanadev_IPAddress,
                   frags, morefrags, ident, ttl - 1, TRUE, fraglast);
    }

#ifdef FOO

    if((dev) && (IsLocalDevice(SrcIP)))
    {
        ;
    }
    else if(IsLocalDevice(DestIP))
        LocalCopy = TRUE;
    else if (iface = LocalNet(DestIP))
    {
        if (iface->sanadev_SValid)
        {
            DestSubnet = DestIP & iface->sanadev_SubnetMask;
            SubMask = ~(iface->sanadev_IPMask | (~iface->sanadev_SubnetMask));
            if ((SubMask & DestIP) == SubMask)  /* Subnet Broadcast */
            {
                route = Route(SrcIP, FALSE);
                if (dev == route->nr_Device)
                {
                    if ((DestIP & ~(iface->sanadev_SubnetMask)) == ~iface->sanadev_SubnetMask)  /* Host broadcast */
                    {
                        propiface = (struct sanadev *) gb->DeviceList.lh_Head->ln_Succ;

                        while (propiface->sanadev_Node.mln_Succ)
                        {
                            if (propiface != dev)       /* Don't bounce packets */
                            {
                                if(clonebuff = (struct Buffer *) CloneBuffer(ibuff))
                                {
                                    ip_out(clonebuff, SrcIP, DestIP, protocol, propiface,
                                           propiface->sanadev_IPAddress, frags, morefrags,
                                           ident, ttl - 1, TRUE, fraglast);
                                }
                            }

                            propiface = (struct sanadev *) propiface->sanadev_Node.mln_Succ;
                        }
                        LocalCopy = TRUE;
                    }
                }
            }
            else /* Not a Subnet Broadcast */
            {
                if (!dev)
                {
                    if ((DestIP & ~(iface->sanadev_SubnetMask)) == ~iface->sanadev_SubnetMask)  /* Host broadcast */
                    {
                            if(clonebuff = (struct Buffer *) CloneBuffer(ibuff))
                                ip_out(clonebuff, SrcIP, DestIP, protocol, iface, iface->sanadev_IPAddress,
                                       frags, morefrags, ident, ttl - 1, TRUE, fraglast);
                            Sent = TRUE;
                            LocalCopy = TRUE;
                    }
                    else
                    if (route = Route(DestIP, FALSE))
                    {
                        ip_out(ibuff, SrcIP, DestIP, protocol, route->nr_Device, route->nr_Gateway,
                               frags, morefrags, ident, ttl - 1, FALSE, fraglast);
                        Sent = TRUE;
                        LocalCopy = FALSE;
                    }
                }
                else
                {
                    if (DestSubnet == dev->sanadev_IPSubnet)
                    {
                        if ((DestIP & ~(iface->sanadev_SubnetMask)) == ~iface->sanadev_SubnetMask)  /* Host broadcast */
                        {
                            LocalCopy = TRUE;
                        }
                    }
                    else
                    {
                        if (route = Route(DestIP, FALSE))
                        {
                            if(IsBroadcast(DestIP))
                            {
                                LocalCopy = TRUE;
                                if(clonebuff = (struct Buffer *) CloneBuffer(ibuff))
                                    ip_out(clonebuff, SrcIP, DestIP, protocol, route->nr_Device, route->nr_Gateway,
                                        frags, morefrags, ident, ttl - 1, TRUE, fraglast);
                            }
                            else
                            {
                                ip_out(ibuff, SrcIP, DestIP, protocol, route->nr_Device, route->nr_Gateway,
                                       frags, morefrags, ident, ttl - 1, FALSE, fraglast);
                                LocalCopy = FALSE;
                            }
                            Sent = TRUE;
                        }
                    }
                }
            }
        }
        else
        {
            if (IsBroadcast(DestIP))
            {
                propiface = (struct sanadev *) gb->DeviceList.lh_Head->ln_Succ;

                while (propiface->sanadev_Node.mln_Succ)
                {
                    if(propiface != dev)
                    {
                        if((propiface->sanadev_IPNetwork | ~propiface->sanadev_IPMask) == DestIP)
                        {
                            if(clonebuff = (struct Buffer *) CloneBuffer(ibuff))
                            {
                                ip_out(clonebuff, SrcIP, DestIP, protocol, propiface,
                                       propiface->sanadev_IPAddress, frags, morefrags,
                                       ident, ttl - 1, TRUE, fraglast);
                            }
                        }
                    }
                    propiface = (struct sanadev *) propiface->sanadev_Node.mln_Succ;
                }
                LocalCopy = TRUE;
            }
            else if (route = Route(DestIP, FALSE))
            {
                ip_out(ibuff, SrcIP, DestIP, protocol, route->nr_Device, route->nr_Gateway,
                      frags, morefrags, ident, ttl - 1, FALSE, fraglast);

                Sent = TRUE;
                LocalCopy = FALSE;
            }
        }
    }
    else
    {
        if((DestIP == 0xffffffff) && (!dev))
        {
            propiface = (struct sanadev *) gb->DeviceList.lh_Head->ln_Succ;

            while (propiface->sanadev_Node.mln_Succ)
            {
                if(clonebuff = (struct Buffer *) CloneBuffer(ibuff))
                {
                    ip_out(clonebuff, SrcIP, DestIP, protocol, propiface,
                           propiface->sanadev_IPAddress, frags, morefrags,
                           ident, ttl - 1, TRUE, fraglast);
                }
                propiface = (struct sanadev *) propiface->sanadev_Node.mln_Succ;
            }
            LocalCopy = TRUE;
        }
        else if ((DestIP == 0xffffffff) && (dev))
        {
            LocalCopy = TRUE;
        }
        else if (route = Route(DestIP, FALSE))
        {
            ip_out(ibuff, SrcIP, DestIP, protocol, route->nr_Device, route->nr_Gateway,
                   frags, morefrags, ident, ttl - 1, FALSE, fraglast);
            Sent = TRUE;
            LocalCopy = FALSE;
        }
    }
#endif

    if(LocalCopy)
    {
        if(!dev)
            dev = (struct sanadev *) gb->DeviceList.lh_Head;
        if(!headerlength)
        {
            ip_out(ibuff, dev->sanadev_IPAddress, dev->sanadev_IPAddress, protocol, dev,
                        dev->sanadev_IPAddress, frags, morefrags, ident, ttl - 1, FALSE, fraglast);
        }
        else
        {
            be = (struct BuffEntry *) ibuff->buff_list.mlh_Head;
            be->be_offset -= headerlength;
            be->be_length += headerlength;
            ip_in(ibuff, dev);
        }
    }
    if (!Sent && !LocalCopy)
    {
        if(headerlength)
        {
            be = (struct BuffEntry *) ibuff->buff_list.mlh_Head;
            be->be_offset -= headerlength;
            be->be_length += headerlength;
        }
        FreeBuffer(ibuff);
    }
    OFFTIMER(1);
}
/*------------------------------------------------------------------------*/
@


1.40
log
@Minor changes.
@
text
@d7 1
a7 1
** $Id: ip_out.c,v 1.39 92/12/16 14:40:33 kcd Exp Locker: gregm $
d171 1
a181 2
    be->be_offset += headerlength;
    be->be_length = ipkt->iph_Length - headerlength;
d183 5
a187 2
    multiplex(ibuff, headerlength, dev, ipkt->iph_SrcAddr, ipkt->iph_DestAddr, ipkt->iph_Protocol,
              ipkt->iph_FragmentOffset, fraglast, ipkt->iph_Ident, ipkt->iph_TimeToLive, fraglast);
d189 7
@


1.39
log
@Fixed some compiler warnings.  Added a missing case to the routing
card related to broadcasts.
@
text
@d7 1
a7 1
** $Id: ip_out.c,v 1.38 92/12/01 14:36:03 kcd Exp Locker: kcd $
d112 1
a112 1
	hdr->iph_Flags = 0;
d138 1
a138 1
            PacketWrite(iface, 0L, obuff, 0L, PACKET_IP, TRUE);
d143 1
a143 1
            PacketWrite(iface, gateway, obuff, destip, PACKET_IP, FALSE);
d216 1
a216 1
    	;
d220 4
a223 4
    	if(iface = LocalNet(DestIP))
    	{
    	    if(iface->sanadev_SValid)
    	    {
d248 1
a248 1
                    	SendClone = TRUE;
d260 2
a261 2
                    	if((propiface->sanadev_IPNetwork | ~propiface->sanadev_IPMask) == DestIP)
                    	{
d274 3
a276 3
	}
	else
	{
d308 1
a308 1
    	ForwardPacket = TRUE;
d330 1
a330 1
    	;
d430 2
a431 2
                    	if((propiface->sanadev_IPNetwork | ~propiface->sanadev_IPMask) == DestIP)
                    	{
d493 1
a493 1
            		dev->sanadev_IPAddress, frags, morefrags, ident, ttl - 1, FALSE, fraglast);
@


1.38
log
@Fixed a major bug in the routing code for non-subnet broadcasts.
@
text
@d7 1
a7 1
** $Id: ip_out.c,v 1.37 92/11/19 14:17:15 kcd Exp Locker: kcd $
a199 1
    struct NBase *nb = gb;
a204 3
    struct iphdr *ip;
    struct LocalIOReq *localreq;
    ULONG DestSubnet, SubMask;
d277 28
a304 2
	    ForwardPacket = TRUE;
	}
@


1.37
log
@New and improved routing code.
@
text
@d7 1
a7 1
** $Id: ip_out.c,v 1.36 92/09/24 16:58:31 kcd Exp $
d258 18
a275 1
            	SendClone = TRUE;
@


1.36
log
@Added support for the new sana2 pseudo-device.
@
text
@d7 1
a7 1
** $Id: ip_out.c,v 1.35 92/08/21 14:26:33 kcd Exp $
d209 1
a209 1
    BOOL LocalCopy, Sent;
d212 1
a212 1
    LocalCopy = Sent = FALSE;
d214 72
d287 2
d445 1
a455 39
#ifdef FOO
	{
            if(localreq = (struct LocalIOReq *) AllocMem(sizeof(struct LocalIOReq),MEMF_PUBLIC))
            {
                localreq->lreq_Buffer = ibuff;
                localreq->lreq_Device = dev;

                if(be = (struct BuffEntry *) AllocBuffEntry(sizeof(struct iphdr)))
                {
                    be->be_length = sizeof(struct iphdr);
                    AddHead((struct List *) &(ibuff->buff_list), (struct Node *)be);
                    ip = (struct iphdr *) be->be_data;
                    if(SrcIP)
                        ip->iph_SrcAddr = SrcIP;
                    else
                        ip->iph_SrcAddr = dev->sanadev_IPAddress;
                    ip->iph_DestAddr = dev->sanadev_IPAddress;
                    ip->iph_IHL = 5;
                    ip->iph_Length = DataLength(ibuff) + sizeof(struct iphdr);
                    ip->iph_Version = 4;
                    ip->iph_Ident = gb->IPIdentNumber++;
                    ip->iph_TimeToLive = 1;
                    ip->iph_Protocol = protocol;
                    ip->iph_TypeOfService = 0;
                    ip->iph_Flags = 0;
                    ip->iph_FragmentOffset = 0;
                    ip->iph_Checksum = 0;
                    ip->iph_Checksum = (0xffffffff - CalcChecksum((UBYTE *) ip, 20, 0));

                    PutMsg(nb->localport,(struct Message *)localreq);
                }
                else
                {
                    LocalCopy = FALSE;
                    FreeMem(localreq, sizeof(struct LocalIOReq));
                }
            }
        }
#endif
@


1.35
log
@Added a check that will help to eliminate packet loops very quickly.
@
text
@d7 1
a7 1
** $Id: ip_out.c,v 1.34 92/08/19 16:09:40 kcd Exp Locker: kcd $
a53 5
//    if(!len)
//    {
//    	kprintf("\gAlert! Alert! Sending zero length packet!\n");
//    }

d234 1
a234 1
                        propiface = (struct sanadev *) gb->DeviceList.lh_Head;
d311 1
a311 1
                propiface = (struct sanadev *) gb->DeviceList.lh_Head;
d345 1
a345 1
            propiface = (struct sanadev *) gb->DeviceList.lh_Head;
d378 5
d419 1
a427 2


@


1.34
log
@Removed the kprintf's.
@
text
@d7 1
a7 1
** $Id: ip_out.c,v 1.33 92/08/13 18:03:53 kcd Exp Locker: kcd $
d220 5
a224 1
    if (IsLocalDevice(DestIP))
@


1.33
log
@Fixed a possbile bug in the routing code. Also added a debuggins statement
to catch a possible problem we've been having.
@
text
@d7 1
a7 1
** $Id: ip_out.c,v 1.32 92/06/12 10:59:41 kcd Exp Locker: kcd $
d54 4
a57 4
    if(!len)
    {
    	kprintf("\gAlert! Alert! Sending zero length packet!\n");
    }
@


1.32
log
@Hopefully I fixed a mungwall hit with IP flags.
@
text
@d7 1
a7 1
** $Id: ip_out.c,v 1.31 92/06/08 10:06:38 kcd Exp Locker: kcd $
d54 5
d310 3
a312 3
            propiface = dev;
            if(!dev)
                dev = iface;
d314 1
a314 9
            if (DestIP == dev->sanadev_IPAddress)
            {
                if ((DestIP & ~dev->sanadev_IPMask) == ~dev->sanadev_IPMask)   /* Host broadcast w/o subnets */
                    LocalCopy = TRUE;
            }
            else
            {
                dev = propiface;
                if (IsBroadcast(DestIP))
d316 1
a316 3
                    propiface = (struct sanadev *) gb->DeviceList.lh_Head;

                    while (propiface->sanadev_Node.mln_Succ)
d318 3
a320 3
                        if((propiface->sanadev_IPNetwork | ~propiface->sanadev_IPMask) == DestIP)
                        {
                            if(propiface != dev)
d322 3
a324 6
                                if(clonebuff = (struct Buffer *) CloneBuffer(ibuff))
                                {
                                    ip_out(clonebuff, SrcIP, DestIP, protocol, propiface,
                                           propiface->sanadev_IPAddress, frags, morefrags,
                                           ident, ttl - 1, TRUE, fraglast);
                                }
a326 1
                        propiface = (struct sanadev *) propiface->sanadev_Node.mln_Succ;
d328 1
a328 1
                    LocalCopy = TRUE;
d330 6
a335 4
                else if (route = Route(DestIP, FALSE))
                {
                    ip_out(ibuff, SrcIP, DestIP, protocol, route->nr_Device, route->nr_Gateway,
                          frags, morefrags, ident, ttl - 1, FALSE, fraglast);
d337 2
a338 3
                    Sent = TRUE;
                    LocalCopy = FALSE;
                }
@


1.31
log
@Code cleanup and adjustments for the changes in the rest of the library.
@
text
@d7 1
a7 1
** $Id: ip_out.c,v 1.30 92/05/28 17:18:24 kcd Exp Locker: kcd $
d111 2
@


1.30
log
@*** empty log message ***
@
text
@d7 1
a7 1
** $Id: ip_out.c,v 1.29 92/05/15 12:46:37 kcd Exp Locker: kcd $
d136 1
a136 1
            PacketBroadcast(iface, obuff, PACKET_IP);
d141 1
a141 1
            PacketWrite(iface, gateway, obuff, destip, PACKET_IP);
d159 1
a159 1

d161 1
d170 5
a174 5
    ULONG SrcIP, DestIP;
    ULONG frags, headerlength;
    UWORD ttl, ident;
    BOOL morefrags, fraglast;
    UBYTE protocol;
d177 1
a177 7
    DestIP = ipkt->iph_DestAddr;
    protocol = ipkt->iph_Protocol;
    SrcIP = ipkt->iph_SrcAddr;
    ttl = ipkt->iph_TimeToLive;
    frags = ipkt->iph_FragmentOffset;
    ident = ipkt->iph_Ident;
    fraglast = morefrags = (ipkt->iph_Flags & IPFLAG_MOREFRAGMENTS);
d182 4
a185 1
    multiplex(ibuff, headerlength, dev, SrcIP, DestIP, protocol, frags, morefrags, ident, ttl, fraglast);
d206 2
a207 2
    ULONG DestSubnet, SubMask, packlen;
    BOOL LocalCopy, Sent,brc;
@


1.29
log
@Added some timing code
@
text
@d7 1
a7 1
** $Id: ip_out.c,v 1.28 92/05/12 17:03:37 gregm Exp Locker: kcd $
d45 7
d213 1
@


1.28
log
@Fixed an incorrect parameter call to multiplex().
@
text
@d7 1
a7 1
** $Id: ip_out.c,v 1.27 92/05/08 15:22:01 kcd Exp Locker: gregm $
d38 1
d44 1
d70 1
d74 1
a96 3
        gb->MonitorInfo.nmi_IPOut++;
        gb->MonitorInfo.nmi_IPBytesOut += hdr->iph_Length;

d133 1
d135 1
d138 1
d204 1
a204 1
    packlen = DataLength(ibuff);
a229 3
                                    gb->MonitorInfo.nmi_IPForwarded++;
                                    gb->MonitorInfo.nmi_IPBytesForwarded += packlen;

a256 3
                        gb->MonitorInfo.nmi_IPForwarded++;
                        gb->MonitorInfo.nmi_IPBytesForwarded += packlen;

a275 3
                            gb->MonitorInfo.nmi_IPForwarded++;
                            gb->MonitorInfo.nmi_IPBytesForwarded += packlen;

a320 3
                                    gb->MonitorInfo.nmi_IPForwarded++;
                                    gb->MonitorInfo.nmi_IPBytesForwarded += packlen;

a332 3
                    gb->MonitorInfo.nmi_IPForwarded++;
                    gb->MonitorInfo.nmi_IPBytesForwarded += packlen;

a351 3
                    gb->MonitorInfo.nmi_IPForwarded++;
                    gb->MonitorInfo.nmi_IPBytesForwarded += packlen;

a365 3
            gb->MonitorInfo.nmi_IPForwarded++;
            gb->MonitorInfo.nmi_IPBytesForwarded += packlen;

d435 1
@


1.27
log
@Umm...well...IP refragmentation was completely broken.  First attempt at
fixing it.
@
text
@d7 1
a7 1
** $Id: ip_out.c,v 1.26 92/05/08 14:33:14 kcd Exp Locker: kcd $
d97 1
d102 1
d144 6
a149 1
    multiplex(obuff, 0L, NULL, srcip, destip, protocol, 0, FALSE, 0, 30, FALSE);
@


1.26
log
@Fixed a few more routing bugs.
@
text
@d7 1
a7 1
** $Id: ip_out.c,v 1.25 92/05/05 17:29:34 kcd Exp Locker: kcd $
d57 1
a57 4
        ULONG x, y,inid;
        Forbid();
        inid = gb->IPIdentNumber++;
        Permit();
d67 1
a67 1
                ip_out(fragbuff, srcip, destip, protocol, iface, gateway, x / 8, ((x + y) < len), inid, ttl, dbc, fraglast);
@


1.25
log
@Fixed failed memory allocation problems.
@
text
@d7 1
a7 1
** $Id: ip_out.c,v 1.24 92/05/04 10:57:07 kcd Exp Locker: kcd $
d298 1
d309 27
a335 1
                if (route = Route(DestIP, FALSE))
@


1.24
log
@Fixed more routing code.  Subnet broadcasts and propagations
were partly broken, thereby affecting the name resolution code.
@
text
@d7 1
a7 1
** $Id: ip_out.c,v 1.23 92/04/22 17:26:28 kcd Exp Locker: kcd $
d67 5
a71 3
            fragbuff = (struct Buffer *) AllocBuffer(y);
            CopyBuffer(obuff, x, y, fragbuff);
            ip_out(fragbuff, srcip, destip, protocol, iface, gateway, x / 8, ((x + y) < len), inid, ttl, dbc, fraglast);
d83 4
a86 3
    be = AllocBuffEntry(sizeof(struct iphdr));
    AddHead((struct List *) & (obuff->buff_list), (struct Node *) be);
    hdr = (struct iphdr *) be->be_data;
d88 10
a97 10
    /* Now, start filling in the fields */
    hdr->iph_Version = 4;       /* IP revision #4 is the most recent */
    hdr->iph_IHL = 5;           /* I never send options, so the header is 20
                                 * bytes.  20/4 = 5 */
    be->be_length = 20;
    hdr->iph_TypeOfService = 0; /* Default service */
    hdr->iph_Length = DataLength(obuff);        /* Count up the size */

    gb->MonitorInfo.nmi_IPOut++;
    gb->MonitorInfo.nmi_IPBytesOut += hdr->iph_Length;
d99 5
a103 5
    /* Make sure that fragged packets all use the same identification # */
    if ((frags == 0) && (!morefrags))
        hdr->iph_Ident = gb->IPIdentNumber++;
    else
        hdr->iph_Ident = inident;
d105 7
a111 7
    if (morefrags || fraglast)
        hdr->iph_Flags |= IPFLAG_MOREFRAGMENTS;
    hdr->iph_FragmentOffset = frags;

    hdr->iph_TimeToLive = ttl;
    hdr->iph_Protocol = protocol;
    hdr->iph_Checksum = 0;
d113 4
a116 4
    if (srcip)
        hdr->iph_SrcAddr = srcip;
    else
        hdr->iph_SrcAddr = iface->sanadev_IPAddress;
d118 1
a118 1
    hdr->iph_DestAddr = destip;
d120 4
a123 4
    /*
     * Calculate the checksum Note that the IP checksum covers ONLY the IP
     * header, and NOT the rest of the datagram!
     */
d125 1
a125 1
    hdr->iph_Checksum = (0xffffffff - CalcChecksum((UBYTE *) hdr, 20, 0));
d127 8
a134 7
    if (dbc)
    {
        PacketBroadcast(iface, obuff, PACKET_IP);
    }
    else
    {
        PacketWrite(iface, gateway, obuff, destip, PACKET_IP);
d220 4
a223 4
                                clonebuff = (struct Buffer *) CloneBuffer(ibuff);

                                gb->MonitorInfo.nmi_IPForwarded++;
                                gb->MonitorInfo.nmi_IPBytesForwarded += packlen;
d225 4
a228 3
                                ip_out(clonebuff, SrcIP, DestIP, protocol, propiface,
                                       propiface->sanadev_IPAddress, frags, morefrags,
                                       ident, ttl - 1, TRUE, fraglast);
d243 3
a245 3
                            clonebuff = (struct Buffer *) CloneBuffer(ibuff);
                            ip_out(clonebuff, SrcIP, DestIP, protocol, iface, iface->sanadev_IPAddress,
                                   frags, morefrags, ident, ttl - 1, TRUE, fraglast);
d280 3
a282 3
                                clonebuff = (struct Buffer *) CloneBuffer(ibuff);
                                ip_out(clonebuff, SrcIP, DestIP, protocol, route->nr_Device, route->nr_Gateway,
                                    frags, morefrags, ident, ttl - 1, TRUE, fraglast);
d330 4
a333 1
                clonebuff = (struct Buffer *) CloneBuffer(ibuff);
d335 4
a338 7
                gb->MonitorInfo.nmi_IPForwarded++;
                gb->MonitorInfo.nmi_IPBytesForwarded += packlen;

                ip_out(clonebuff, SrcIP, DestIP, protocol, propiface,
                       propiface->sanadev_IPAddress, frags, morefrags,
                       ident, ttl - 1, TRUE, fraglast);

@


1.23
log
@Fixed stupid enforcer hit in the routing stuff. (*#&$!!!
@
text
@d7 1
a7 1
** $Id: ip_out.c,v 1.22 92/04/22 16:01:21 gregm Exp Locker: kcd $
d125 1
d127 1
d129 1
d131 1
a154 1

a156 1

d189 2
a190 2
    ULONG DestIPNet, DestSubnet, SubMask, packlen;
    BOOL LocalCopy, Sent;
a194 2
    DestIPNet = NetNum(DestIP);

d197 1
a197 1
    else if (iface = LocalNet(DestIPNet))
a202 1

d238 5
a242 4
                        ip_out(ibuff, SrcIP, DestIP, protocol, iface, iface->sanadev_IPAddress,
                               frags, morefrags, ident, ttl - 1, TRUE, fraglast);
                        Sent = TRUE;
                        LocalCopy = FALSE;
d247 2
a248 2
						gb->MonitorInfo.nmi_IPForwarded++;
						gb->MonitorInfo.nmi_IPBytesForwarded +=	packlen;
d250 4
a253 4
						ip_out(ibuff, SrcIP, DestIP, protocol, route->nr_Device, route->nr_Gateway,
							   frags, morefrags, ident,	ttl	- 1, FALSE,	fraglast);
						Sent = TRUE;
						LocalCopy =	FALSE;
d258 12
a269 12
					if (DestSubnet == dev->sanadev_IPSubnet)
					{
						if ((DestIP	& ~(iface->sanadev_SubnetMask))	== ~iface->sanadev_SubnetMask)	/* Host	broadcast */
						{
							LocalCopy =	TRUE;
						}
					}
					else
					{
						if (route =	Route(DestIP, FALSE))
						{
							gb->MonitorInfo.nmi_IPForwarded++;
d272 13
a284 2
                            ip_out(ibuff, SrcIP, DestIP, protocol, route->nr_Device, route->nr_Gateway,
                                   frags, morefrags, ident, ttl - 1, FALSE, fraglast);
a285 1
                            LocalCopy = FALSE;
a339 1
            kprintf("Received a brdcast packet.\n");
d370 4
a373 1
                    ip->iph_SrcAddr = dev->sanadev_IPAddress;
@


1.22
log
@<burp>

@
text
@d7 1
a7 1
** $Id: ip_out.c,v 1.21 92/04/21 15:59:01 kcd Exp $
d244 2
a245 4
                }
//                else
//                {
                    if (DestSubnet == dev->sanadev_IPSubnet)
d247 7
a253 4
                        if ((DestIP & ~(iface->sanadev_SubnetMask)) == ~iface->sanadev_SubnetMask)  /* Host broadcast */
                        {
                            LocalCopy = TRUE;
                        }
d255 15
a269 5
                    else
                    {
                        if (route = Route(DestIP, FALSE))
                        {
                            gb->MonitorInfo.nmi_IPForwarded++;
d278 1
a278 1
//                }
@


1.21
log
@Reworked low-level packet routing again. Now much cleaner than before.
@
text
@d7 1
a7 1
** $Id: ip_out.c,v 1.20 92/04/12 15:59:11 kcd Exp Locker: kcd $
d127 1
a127 1
	PacketWrite(iface, gateway, obuff, destip, PACKET_IP);
d196 1
a196 1
    	LocalCopy = TRUE;
d245 3
a247 3
                if (DestSubnet == dev->sanadev_IPSubnet)
                {
                    if ((DestIP & ~(iface->sanadev_SubnetMask)) == ~iface->sanadev_SubnetMask)  /* Host broadcast */
d249 4
a252 1
                        LocalCopy = TRUE;
d254 1
a254 4
                }
                else
                {
                    if (route = Route(DestIP, FALSE))
d256 4
a259 2
                        gb->MonitorInfo.nmi_IPForwarded++;
                        gb->MonitorInfo.nmi_IPBytesForwarded += packlen;
d261 5
a265 4
                        ip_out(ibuff, SrcIP, DestIP, protocol, route->nr_Device, route->nr_Gateway,
                               frags, morefrags, ident, ttl - 1, FALSE, fraglast);
                        Sent = TRUE;
                        LocalCopy = FALSE;
d267 1
a267 1
                }
d298 2
a299 2
    	if((DestIP == 0xffffffff) && (!dev))
    	{
d318 2
d321 1
d336 44
a379 44
    	if(!dev)
    	    dev = (struct sanadev *) gb->DeviceList.lh_Head;
    	if(!headerlength)
    	{
    	    if(localreq = (struct LocalIOReq *) AllocMem(sizeof(struct LocalIOReq),MEMF_PUBLIC))
    	    {
    	    	localreq->lreq_Buffer = ibuff;
    	    	localreq->lreq_Device = dev;

	        if(be = (struct BuffEntry *) AllocBuffEntry(sizeof(struct iphdr)))
    		{
    		    be->be_length = sizeof(struct iphdr);
		    AddHead((struct List *) &(ibuff->buff_list), (struct Node *)be);
		    ip = (struct iphdr *) be->be_data;
		    ip->iph_SrcAddr = dev->sanadev_IPAddress;
		    ip->iph_DestAddr = dev->sanadev_IPAddress;
		    ip->iph_IHL	= 5;
		    ip->iph_Length = DataLength(ibuff) + sizeof(struct iphdr);
		    ip->iph_Version = 4;
		    ip->iph_Ident = gb->IPIdentNumber++;
		    ip->iph_TimeToLive = 1;
		    ip->iph_Protocol = protocol;
		    ip->iph_TypeOfService = 0;
		    ip->iph_Flags = 0;
		    ip->iph_FragmentOffset = 0;
		    ip->iph_Checksum = 0;
		    ip->iph_Checksum = (0xffffffff - CalcChecksum((UBYTE *) ip,	20, 0));

		    PutMsg(nb->localport,(struct Message *)localreq);
		}
		else
		{
		    LocalCopy = FALSE;
		    FreeMem(localreq, sizeof(struct LocalIOReq));
		}
	    }
	}
	else
	{
       	    be = (struct BuffEntry *) ibuff->buff_list.mlh_Head;
    	    be->be_offset -= headerlength;
    	    be->be_length += headerlength;
    	    ip_in(ibuff, dev);
    	}
d385 7
a391 7
    	if(headerlength)
    	{
    	    be = (struct BuffEntry *) ibuff->buff_list.mlh_Head;
    	    be->be_offset -= headerlength;
    	    be->be_length += headerlength;
    	}
    	FreeBuffer(ibuff);
@


1.20
log
@Fixed bug in fragmentation code. Wasn't tracking ID numbers correctly.
@
text
@d7 1
a7 1
** $Id: ip_out.c,v 1.19 92/04/10 14:54:43 kcd Exp Locker: kcd $
d59 1
a61 2
        inid = gb->IPIdentNumber++;

d123 1
a124 1
    {
a125 1
    }
d127 1
a127 3
    {
        PacketWrite(iface, gateway, obuff, destip, PACKET_IP);
    }
a130 8
void ip_send(obuff, destip, protocol)
struct Buffer *obuff;
ULONG destip;
UBYTE protocol;
{
	ip_sendsrc(obuff,0,destip,protocol);
}

d137 1
a137 23
    struct NIPCRoute *route;
    struct sanadev *iface;
    struct Buffer *clone;
    if(destip == 0xffffffff)
    {
        iface = (struct sanadev *) gb->DeviceList.lh_Head;

        while(iface->sanadev_Node.mln_Succ)
        {
            clone = CloneBuffer(obuff);
            ip_out(clone, srcip, destip, protocol, iface, iface->sanadev_IPAddress, 0, FALSE, 0, 30, TRUE, FALSE);

            iface = (struct sanadev *) iface->sanadev_Node.mln_Succ;
        }
    }
    else
    {
    	route = Route(destip, TRUE);
    	if(destip)
	        ip_out(obuff, srcip, destip, protocol, route->nr_Device, route->nr_Gateway, 0, FALSE, 0, 30, FALSE, FALSE);
	    return;
	}
    FreeBuffer(obuff);
d140 1
a140 3
/*------------------------------------------------------------------------*/

BOOL gate_out(ibuff, dev)
d146 1
a146 6
    struct sanadev *iface;
    struct sanadev *propiface;
    struct NIPCRoute *route;
    struct Buffer *clonebuff;

    ULONG DestIP, DestIPNet, DestSubnet, SubMask, packlen, SrcIP;
d149 1
a149 1
    BOOL LocalCopy, morefrags, fraglast, Sent;
a151 2
    LocalCopy = Sent = FALSE;

d162 6
d169 1
a169 1
    DestIPNet = NetNum(DestIP);
d171 18
a188 1
    packlen = (ipkt->iph_Length - (ipkt->iph_IHL << 2));
d190 2
a191 1
    headerlength = ipkt->iph_IHL << 2;
d193 1
a193 2
    be->be_offset += headerlength;
    be->be_length -= headerlength;
d195 3
a197 1
    if (iface = LocalNet(DestIPNet))
a203 1

d233 1
a233 1
            else
d235 10
d269 3
d274 1
a274 2
                if ((DestIP & ~dev->sanadev_IPMask) == ~dev->sanadev_IPMask)    /* Host broadcast w/o
                                                                                 * subnets */
d295 22
a316 1
        if (route = Route(DestIP, FALSE))
d328 1
a328 1
    if (!Sent)
d330 44
a373 2
        be->be_offset -= headerlength;
        be->be_length += headerlength;
d375 2
d378 9
a386 3
        FreeBuffer(ibuff);

    return (LocalCopy);
a387 1

@


1.19
log
@Minor cleanups here & there.
@
text
@d7 1
a7 1
** $Id: ip_out.c,v 1.18 92/04/10 00:41:08 kcd Exp Locker: kcd $
d57 1
a57 1
        ULONG x, y;
d60 3
d70 1
a70 1
            ip_out(fragbuff, srcip, destip, protocol, iface, gateway, x / 8, ((x + y) < len), inident, ttl, dbc, fraglast);
@


1.18
log
@Removed Dependencies on old exec_pragmas.h file.
@
text
@d7 1
a7 1
** $Id: ip_out.c,v 1.17 92/04/05 15:43:41 kcd Exp Locker: kcd $
a122 1
//        kprintf("ip_out: Sending a directed broadcast to interface %lx.\n", iface);
a126 1
//        kprintf("ip_out: Sending a non-broadcast packet to interface %lx, gateway %lx.\n", iface, gateway);
a159 1
        FreeBuffer(obuff);
a160 2
    else if (route = Route(destip, TRUE))
        ip_out(obuff, srcip, destip, protocol, route->nr_Device, route->nr_Gateway, 0, FALSE, 0, 30, FALSE, FALSE);
d162 7
a168 1
        FreeBuffer(obuff);
@


1.17
log
@Arrggghhh...trivial change. Missing ';'.
@
text
@d7 1
a7 1
** $Id: ip_out.c,v 1.16 92/04/05 15:37:38 kcd Exp Locker: kcd $
a57 1
        UWORD inid;
a58 1
        inid = gb->IPIdentNumber++;
@


1.16
log
@Added ip_sendsrc() to allow the resolver to do high-level routing.
@
text
@d7 1
a7 1
** $Id: ip_out.c,v 1.15 92/03/23 10:22:06 gregm Exp Locker: kcd $
d141 1
a141 1
	ip_sendsrc(obuff,0,destip,protocol)
@


1.15
log
@The_voodoo_stuff_is_GONE!
@
text
@d7 1
a7 1
** $Id: ip_out.c,v 1.14 92/03/05 17:24:39 gregm Exp $
d136 7
d144 1
a144 1
void ip_send(obuff, destip, protocol)
d146 1
d160 1
a160 1
            ip_out(clone, 0, destip, protocol, iface, iface->sanadev_IPAddress, 0, FALSE, 0, 30, TRUE, FALSE);
d167 1
a167 1
        ip_out(obuff, 0, destip, protocol, route->nr_Device, route->nr_Gateway, 0, FALSE, 0, 30, FALSE, FALSE);
d220 1
a275 1

@


1.14
log
@trivial stylistic changes
@
text
@d7 1
a7 1
** $Id: ip_out.c,v 1.13 92/03/04 16:57:08 gregm Exp Locker: gregm $
d60 1
a60 1
        inid = IPIdentNumber++;
d93 2
a94 2
    MonitorInfo.nmi_IPOut++;
    MonitorInfo.nmi_IPBytesOut += hdr->iph_Length;
d98 1
a98 1
        hdr->iph_Ident = IPIdentNumber++;
d147 1
a147 1
        iface = (struct sanadev *) DeviceList.lh_Head;
d219 1
a219 1
                        propiface = (struct sanadev *) DeviceList.lh_Head;
d227 2
a228 2
                                MonitorInfo.nmi_IPForwarded++;
                                MonitorInfo.nmi_IPBytesForwarded += packlen;
d254 2
a255 2
                        MonitorInfo.nmi_IPForwarded++;
                        MonitorInfo.nmi_IPBytesForwarded += packlen;
d278 2
a279 2
                    MonitorInfo.nmi_IPForwarded++;
                    MonitorInfo.nmi_IPBytesForwarded += packlen;
d294 2
a295 2
            MonitorInfo.nmi_IPForwarded++;
            MonitorInfo.nmi_IPBytesForwarded += packlen;
@


1.13
log
@Moved globals to globals.c; externs for these in externs.h.
@
text
@d7 1
a7 1
** $Id: ip_out.c,v 1.12 92/02/29 20:30:42 kcd Exp Locker: gregm $
a13 1
#include "externs.h"
d20 1
@


1.12
log
@ip_send() now recognizes $FFFFFFFF broadcasts and sends the packet
to all network devices.
@
text
@d7 1
a7 1
** $Id: ip_out.c,v 1.11 92/02/27 20:57:15 kcd Exp $
d14 2
a23 14
/* Externals */

extern struct MinList DeviceList;
extern struct MinList ProtocolList;
extern struct NIPCMonitorInfo MonitorInfo;

/*------------------------------------------------------------------------*/

/* Globals */

UWORD IPIdentNumber;

/*------------------------------------------------------------------------*/

d147 1
a147 1
        iface = (struct sanadev *) DeviceList.mlh_Head;
d219 1
a219 1
                        propiface = (struct sanadev *) DeviceList.mlh_Head;
@


1.11
log
@New formatting.  Changes made to ip_out() to support setting the
morefragments bit in the ip header of the last packet sent.  Eliminated
code from gate_out that was duplicated in ip_in.c. Now uses new
inlude files.
@
text
@d7 1
a7 1
** $Id$
d155 10
d166 5
a170 1
    if (route = Route(destip, TRUE))
@


1.10
log
@Added support for monitor code.
@
text
@d1 26
a26 1

d28 1
a28 19
/*
 * $Header: APPN:src/nipc/RCS/ip_out.c,v 1.9 92/02/21 16:36:14 kcd Exp Locker: kcd $
 *
 */


#include "ip.h"
#include "memory.h"
#include "s2io.h"
#include "route.h"
#include "monitor.h"
#include <proto/exec.h>
#include <proto/dos.h>

/* protos */
 extern struct BuffEntry *AllocBuffEntry();
 extern struct MinList DeviceList;
 extern struct MinList ProtocolList;
 extern struct NIPCMonitorInfo MonitorInfo;
d30 1
a30 2
extern struct NIPCRoute *Route();
extern struct sanadev *LocalNet();
a31 1
/* globals */
d34 3
a36 1
void ip_out(obuff,srcip,destip,protocol,iface,gateway,frags,morefrags,inident,ttl,dbc)
d45 1
d50 63
a112 4
 struct BuffEntry *be;
 struct iphdr *hdr;
/* struct sanadev *dev; */
 ULONG len;
d114 31
a144 86
/* Until routing is added, always output to the 1st device */

 len = DataLength(obuff);

 if ((len+sizeof(struct iphdr)) > iface->sanadev_MTU)
   {
   /* Icky.  We have to fragment packets.
    * Luckily, I can get away with recursively calling ip_out.
    * Fragmentation currently incurs data copying.  This is unpleasant,
    * but a necessity.  I may later change the algorithm to be
    * intelligent enough to avoid copying whenver possible, and to
    * build packets around already existant BuffEntry's, whenever
    * possible.
    */

   struct Buffer *fragbuff;
   UWORD inid;
   ULONG x,y;
   Forbid();
   inid = IPIdentNumber++;
   Permit();
   y = ((iface->sanadev_MTU-sizeof(struct iphdr)) & 0xFFFFFFF8);
   for (x = 0; x < len; x+=y)
      {
      if ((x+y) >= len) y = len-x;        /* for the last piece */
      fragbuff = (struct Buffer *) AllocBuffer(y);
      CopyBuffer(obuff,x,y,fragbuff);
      ip_out(fragbuff,srcip,destip,protocol,iface,gateway,x/8,((x+y) < len),inid,ttl,dbc);
      }
   FreeBuffer(obuff);
   return;
   }


/* First, allocate a BuffEntry with the necessary space in it to house the
 * IP header, and insert it at the Head of the Buffer.
 */

 be = AllocBuffEntry(sizeof(struct iphdr));
 AddHead((struct List *)&(obuff->buff_list),(struct Node *)be);
 hdr = (struct iphdr *) be->be_data;

/* Now, start filling in the fields */
 hdr->iph_Version = 4;        /* IP revision #4 is the most recent */
 hdr->iph_IHL = 5;            /* I never send options, so the header is 20 bytes.  20/4 = 5 */
 be->be_length = 20;
 hdr->iph_TypeOfService = 0;  /* Default service */
 hdr->iph_Length = DataLength(obuff);  /* Count up the size */

 MonitorInfo.nmi_IPOut++;
 MonitorInfo.nmi_IPBytesOut += hdr->iph_Length;

/* Make sure that fragged packets all use the same identification # */
 if ((frags == 0) && (!morefrags)) hdr->iph_Ident = IPIdentNumber++;
 else hdr->iph_Ident = inident;

 if (morefrags) hdr->iph_Flags |= IPFLAG_MOREFRAGMENTS;
 hdr->iph_FragmentOffset = frags;

 hdr->iph_TimeToLive = ttl;
 hdr->iph_Protocol = protocol;
 hdr->iph_Checksum = 0;

 if(srcip)
    hdr->iph_SrcAddr = srcip;
 else
    hdr->iph_SrcAddr = iface->sanadev_IPAddress;

 hdr->iph_DestAddr = destip;

/* Calculate the checksum
 * Note that the IP checksum covers ONLY the IP header, and NOT
 * the rest of the datagram!
 */

 hdr->iph_Checksum = (0xffffffff-CalcChecksum(hdr,20,0));
 if(dbc)
 {
//    kprintf("ip_out: Sending a directed broadcast to interface %lx.\n",iface);
    PacketBroadcast(iface,obuff,PACKET_IP);
 }
 else
 {
//    kprintf("ip_out: Sending a non-broadcast packet to interface %lx, gateway %lx.\n",iface,gateway);
    PacketWrite(iface,gateway,obuff,destip,PACKET_IP);
 }
d147 1
d149 1
a149 1
void ip_send(obuff,destip,protocol)
d156 2
a157 5
    if( route = Route(destip,TRUE))
    {
        kprintf("ip_send(): Sending a packet to ip_out.\n");
        ip_out(obuff,0,destip,protocol,route->nr_Device,route->nr_Gateway,0,FALSE,0,30,FALSE);
    }
a158 2
    {
        kprintf("ip_send(): Dropping a packet from rdp.\n");
a159 1
    }
d162 1
d164 1
a164 1
void gate_out(ibuff,dev)
d175 4
a178 3
    ULONG DestIP, DestIPNet, DestSubnet,SubMask,packlen,SrcIP;
    UWORD ttl;
    BOOL LocalCopy;
a179 1
    struct ipproto *protoptr;
d181 1
a181 1
    LocalCopy = FALSE;
d190 3
d194 1
a194 1
    DestIPNet = netnum(DestIP);
d198 1
a198 2
    be->be_offset += sizeof(struct iphdr);
    be->be_length -= sizeof(struct iphdr);
d200 2
a201 1
//    nbuff = (struct Buffer *) CloneBuffer(ibuff);
d203 1
a203 8
//    be->be_offset -= sizeof(struct iphdr);
//    be->be_length += sizeof(struct iphdr);

//    CopyBuffer(ibuff,be->be_offset+sizeof(sizeof (struct iphdr)),nlen,nbuff);

//    kprintf("Gateway: Destination is %lx\n",DestIP);

    if(iface=LocalNet(DestIPNet))
d205 1
a205 3
//        kprintf("Gateway: Destination is on a local network.\n");

        if(iface->sanadev_SValid)
a206 2
//            kprintf("Gateway: Destination is subnetted.\n");

a207 3

//            kprintf("Gateway: Destination Subnet: %lx\n",DestSubnet);

d210 1
a210 3
//            kprintf("Gateway: SubMask = %lx\n",SubMask);

            if((SubMask & DestIP) == SubMask) /* Subnet Broadcast */
a211 2
//                kprintf("Gateway: Subnet Broadcast");

d213 1
a213 1
                if(dev == route->nr_Device)
d215 1
a215 3
//                    kprintf("Gateway: Packet came from closest gateway to source.\n");

                    if((DestIP & ~(iface->sanadev_SubnetMask)) == ~iface->sanadev_SubnetMask) /* Host broadcast */
a216 2
//                        kprintf("Gateway: Destination is a host broadcast.\n");

d219 1
a219 1
                        while(propiface->sanadev_Node.mln_Succ)
d221 1
a221 1
                            if(propiface != dev)  /* Don't bounce packets */
a224 2
//                                kprintf("Gateway: Sending a copy to interface %lx\n",propiface->sanadev_IPAddress);

d228 3
a230 2
                                ip_out(clonebuff,SrcIP,DestIP,protocol,propiface,
                                       propiface->sanadev_IPAddress,0,FALSE,0,ttl-1,TRUE);
d241 1
a241 3
//                kprintf("Gateway: Not a subnet broadcast.\n");

                if(DestSubnet == dev->sanadev_IPSubnet)
d243 1
a243 3
//                    kprintf("Gateway: Destination is our subnet.\n");

                    if((DestIP & ~(iface->sanadev_SubnetMask)) == ~iface->sanadev_SubnetMask) /* Host broadcast */
a244 1
//                        kprintf("Gateway: Destinaion is a host broadcast.\n");
d250 1
a250 2
//                    kprintf("Gateway: Destination is another subnet. Attempting to forward packet.\n");
                    if(route = Route(DestIP,FALSE))
d255 4
a258 4
                        ip_out(ibuff,SrcIP,DestIP,protocol,route->nr_Device,route->nr_Gateway,
                               0,FALSE,0,ttl-1,FALSE);
//                        FreeBuffer(ibuff);
                        return;
a264 1
//            kprintf("Gateway: Destination is not subnetted.");
d266 1
a266 1
            if(DestIP == dev->sanadev_IPAddress)
d268 2
a269 2
//                kprintf("Gateway: Packet for our interface.\n");
                if((DestIP & ~dev->sanadev_IPMask) == ~dev->sanadev_IPMask) /* Host broadcast w/o subnets */
d274 1
a274 3
//                kprintf("Gateway: Packet not for one of our interfaces.  Attempting to reroute packet.\n");

                if(route = Route(DestIP,FALSE))
d279 5
a283 4
                    ip_out(ibuff,SrcIP,DestIP,protocol,route->nr_Device,route->nr_Gateway,
                        0,FALSE,0,ttl-1,FALSE);
//                    FreeBuffer(ibuff);
                    return;
d290 1
a290 3
//        kprintf("Gateway: Destination not on a local net. Forwarding packet.\n");

        if(route = Route(DestIP,FALSE))
d295 4
a298 4
            ip_out(ibuff,SrcIP,DestIP,protocol,route->nr_Device,route->nr_Gateway,
                0,FALSE,0,ttl-1,FALSE);
//            FreeBuffer(ibuff);
            return;
d302 1
a302 6
//    FreeBuffer(nbuff);

    be->be_offset -= sizeof(struct iphdr);
    be->be_length += sizeof(struct iphdr);

    if(LocalCopy)
d304 2
a305 36
//        kprintf("Gateway: Keeping a local copy of packet.\n");

        Forbid();
        if (IsListEmpty( (struct List *) &ProtocolList))     /* if no protocols exist */
        {
            Permit();
            FreeBuffer(ibuff);
            return;
        }

        protoptr = (struct ipproto *) ProtocolList.mlh_Head;
        while (protoptr->ipproto_link.mln_Succ)
        {

            if (protoptr->ipproto_ProtocolNumber == ipkt->iph_Protocol)
            {
                Permit();
                if (CountEntries(ibuff) > 1)
                {
                    struct Buffer *i2buff;
                    i2buff = (struct Buffer *) CloneBuffer(ibuff);
                    FreeBuffer(ibuff);
                    ibuff = i2buff;
                }

                MonitorInfo.nmi_IPKept++;
                MonitorInfo.nmi_IPBytesKept += (ipkt->iph_Length - (ipkt->iph_IHL << 2));

                (*protoptr->ipproto_Input)(ibuff,DataLength(ibuff),dev);
                return;
            }
            protoptr = (struct ipproto *) protoptr->ipproto_link.mln_Succ;
        }

        Permit();           /* Couldn't find a destination protocol */

d307 2
d310 1
a310 1
    FreeBuffer(ibuff);
d313 1
a313 1

@


1.9
log
@Fixed bug in ip_send() preventing non-broadcast packets from leaving the system.
@
text
@d4 1
a4 1
 * $Header: APPN:src/nipc/RCS/ip_out.c,v 1.8 92/02/21 13:26:09 kcd Exp Locker: kcd $
d13 1
d21 1
d96 3
d167 1
a167 1
    ULONG DestIP, DestIPNet, DestSubnet,SubMask,nlen,SrcIP;
d185 1
a185 1
//    nlen = DataLength(ibuff) - sizeof(struct iphdr);
d238 3
d270 3
d297 3
d314 3
d355 3
@


1.8
log
@Fixed a tiny syntax error.  Routing times improved by about 1ms.
@
text
@d4 1
a4 1
 * $Header: APPN:src/nipc/RCS/ip_out.c,v 1.7 92/02/21 13:07:10 kcd Exp Locker: kcd $
a137 1
    if(isbrc(destip))
d139 2
d142 1
d144 2
d147 1
@


1.7
log
@Eliminated extra data copying in gate_out(). Should inprove routing speeds.
@
text
@d4 1
a4 1
 * $Header: APPN:src/nipc/RCS/ip_out.c,v 1.6 92/02/20 20:32:01 kcd Exp Locker: kcd $
a272 1
                {
@


1.6
log
@Finally fixed the last memory leak related to fragmentation.
@
text
@d4 1
a4 1
 * $Header: APPN:src/nipc/RCS/ip_out.c,v 1.5 92/02/20 14:20:22 kcd Exp Locker: kcd $
d155 1
a155 1
    struct Buffer *nbuff,*clonebuff;
d175 1
a175 1
    nlen = DataLength(ibuff) - sizeof(struct iphdr);
d180 1
a180 1
    nbuff = (struct Buffer *) CloneBuffer(ibuff);
d182 2
a183 2
    be->be_offset -= sizeof(struct iphdr);
    be->be_length += sizeof(struct iphdr);
d224 1
a224 1
                                clonebuff = (struct Buffer *) CloneBuffer(nbuff);
d257 1
a257 1
                        ip_out(nbuff,SrcIP,DestIP,protocol,route->nr_Device,route->nr_Gateway,
d259 1
a259 1
                        FreeBuffer(ibuff);
d273 1
d282 1
a282 1
                    ip_out(nbuff,SrcIP,DestIP,protocol,route->nr_Device,route->nr_Gateway,
d284 1
a284 1
                    FreeBuffer(ibuff);
d296 1
a296 1
            ip_out(nbuff,SrcIP,DestIP,protocol,route->nr_Device,route->nr_Gateway,
d298 1
a298 1
            FreeBuffer(ibuff);
d303 4
a306 1
    FreeBuffer(nbuff);
@


1.5
log
@Fixed *another* possible memory leak in gate_out().
@
text
@d4 1
a4 1
 * $Header: APPN:src/nipc/RCS/ip_out.c,v 1.4 92/02/20 14:05:22 gregm Exp Locker: kcd $
d74 1
@


1.4
log
@Added in a CloneBuffer() chunk of code to ensure 1-be per buffer for the upper
level protocols.
@
text
@d4 1
a4 1
 * $Header: APPN:src/nipc/RCS/ip_out.c,v 1.3 92/02/20 11:05:14 kcd Exp $
d282 1
@


1.3
log
@Totally new routing routines written.  Bad memory leak fixed.  ip_send()
routine added.  New ip_out parameters to go with the new routing method.
@
text
@d4 1
a4 1
 * $Header: APPN:src/libs/nipc.library/RCS/ip_out.c,v 1.2 92/02/17 09:54:28 kcd Exp Locker: kcd $
d321 8
@


1.2
log
@Added routing code.
@
text
@d1 1
a2 1

d4 1
a4 1
 * $Header: APPN:src/libs/nipc.library/RCS/ip_out.c,v 1.1 92/02/13 10:01:46 gregm Exp Locker: kcd $
d19 4
d27 1
a27 1
void ip_out(obuff,srcip,destip,protocol,frags,morefrags,inident)
d30 2
d37 2
a42 1
 struct NIPCRoute *route;
a45 6
 route = (struct NIPCRoute *) Route(destip, FALSE);
 if (!route)                       /* If packet can't be routed */
   {                             /* dump it */
   FreeBuffer(obuff);
   return;
   }
d49 1
a49 1
 if ((len+sizeof(struct iphdr)) > route->nr_Device->sanadev_MTU)
d66 1
a66 1
   y = ((route->nr_Device->sanadev_MTU-sizeof(struct iphdr)) & 0xFFFFFFF8);
d72 1
a72 1
      ip_out(fragbuff,srcip,destip,protocol,x/8,((x+y) < len),inid);
d100 1
a100 1
 hdr->iph_TimeToLive = 30;    /* 30 seconds or hops, either way */
d107 1
a107 1
    hdr->iph_SrcAddr = route->nr_Device->sanadev_IPAddress;
d117 27
a143 1
 PacketWrite(route,obuff,destip,PACKET_IP);
d145 187
d333 2
@


1.1
log
@Initial revision
@
text
@d4 1
a4 1
 * $Header$
d12 1
d23 1
a23 1
void ip_out(obuff,destip,protocol,frags,morefrags,inident)
d26 1
d34 2
a35 1
 struct sanadev *dev;
d39 2
a40 2
 dev = (struct sanadev *) Route(destip);
 if (!dev)                       /* If packet can't be routed */
d48 1
a48 1
 if ((len+sizeof(struct iphdr)) > dev->sanadev_MTU)
d65 1
a65 1
   y = ((dev->sanadev_MTU-sizeof(struct iphdr)) & 0xFFFFFFF8);
d71 1
a71 1
      ip_out(fragbuff,destip,protocol,x/8,((x+y) < len),inid);
d103 5
a107 1
 hdr->iph_SrcAddr = dev->sanadev_IPAddress;
d116 1
a116 1
 PacketWrite(dev,obuff,destip,PACKET_IP);
@
