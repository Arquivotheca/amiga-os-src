head     1.7;
branch   ;
access   ;
symbols  ;
locks    ; strict;
comment  @**@;


1.7
date     91.06.21.11.30.39;  author dlarson;  state Stab;
branches ;
next     1.6;

1.6
date     91.05.27.09.48.08;  author dlarson;  state Stab;
branches ;
next     1.5;

1.5
date     91.05.22.10.00.19;  author dlarson;  state Stab;
branches ;
next     1.4;

1.4
date     91.05.21.15.56.21;  author dlarson;  state Stab;
branches ;
next     1.3;

1.3
date     91.01.06.20.57.13;  author J_Toebes;  state Exp;
branches ;
next     1.2;

1.2
date     90.12.30.15.40.37;  author J_Toebes;  state Exp;
branches ;
next     1.1;

1.1
date     90.12.28.22.39.21;  author J_Toebes;  state Exp;
branches ;
next     ;


desc
@Initialization, ALlocation routines
@


1.7
log
@Fixed gapping memory leaks in SDN*Term() functions.
@
text
@/*
**      $Filename: SDNLocalUtil.c $
**      $Author: dlarson $
**      $Revision: 1.6 $
**      $Date: 91/05/27 09:48:08 $
**      $Log:	SDNLocalUtil.c,v $
**Revision 1.6  91/05/27  09:48:08  dlarson
**Tweaked autodocs, eliminated include of netcomm.h
**
 * Revision 1.5  91/05/22  10:00:19  dlarson
 * clean up stay comments, etc.
 *
 * Revision 1.4  91/05/21  15:56:21  dlarson
 * Updated autodocs, spaces->tabs, etc.
 *
 * Revision 1.3  91/01/06  20:57:13  J_Toebes
 * Correct strange bug where packets were being received by the local
 * sender.  This was due to overloading the Port field in the global structure.
 *
**/


#include "sdnlocal.h"

/****** NET-LOCAL.library/SDNSerInit **********************************
*
*   NAME
*	SDNSerInit -- Perform server specific initialization.
*
*   SYNOPSIS
*	rc = SDNSerInit(drglobal, mask, data)
*	D0		A0	  A1	A2
*
*	inet SDNSerInit(APTR *, ULONG *, char *);
*
*   FUNCTION
*	Perform server specific initialization.
*
*	The mask value is the communications mechanism for indicating which
*	bits are to be used by the server.  On input it is a mask of bits
*	available for use if the library is unable to allocate any bits.  On
*	output it is a mask of the bits that the library will set whenever it
*	needs to service a message.  Once the bit is set, the server should
*	call SDNAccept() until SDN_NONE is returned.
*
*	The data string is a simple null terminated C style string that is
*	for use by the library.  There is no format specified for the string,
*	so drivers may use this for whatever they want.  The server
*	code just reads the string from a configuration file and passes it
*	on to the library.  This pointer may be NULL if no initialization
*	string has been specified.  In the absence of any configuration
*	information, it is the responsibility of the library code to pick
*	an appropriate default or to safely fail the initialization.
*
*	The only difference between this routine and the SNDHanInit() is that
*	the server portion needs to set up to receive asynchronous new
*	connections.  It will only be doing calls to SDNAccept() and not any
*	to SDNReceive().
*
*   INPUTS
*	drglobal	- Server-specific global data pointer
*	mask		- On input, mask of signal bits already being used by
*			  all other drivers;  On output, mask of signal bits
*			  this driver will be using.
*	data		- Pointer to driver-specific initialization string.
*
*   RESULT
*	rc		- SDN_ERR, SDN_OK
*
*   NOTES
*	Driver is free to reuse signal bits or allocate new ones.
*
****************************************/
int LIBENT LOCALSDNSerInit (register __a0 LOCALGLOBAL *tgp,
			    register __a1 ULONG *maskp,
			    register __a2 char *data,
			    register __a6 struct DrLibrary *DriverBase)
{
LOCALGLOBAL tg;

	*tgp = NULL;

	if ((tg = LocalInit(maskp, data)) == NULL)
		return(SDN_ERR);

	tg->DriverBase = DriverBase;

	/* If the port already exists then we can not start the server.		 */
	if (tg->sendport != NULL)
	{
		FreeMem((void *)tg, sizeof(*tg));
		return(SDN_ERR);
	}

	tg->port = (struct MsgPort *)
		  AllocMem(sizeof(struct MsgPort), MEMF_CLEAR|MEMF_PUBLIC);
	if (tg->port == NULL)
	{
		FreeMem((void *)tg, sizeof(*tg));
		return(SDN_ERR);
	}
	tg->port->mp_Node.ln_Name = tg->portname;
	tg->port->mp_Node.ln_Pri = 0;
	tg->port->mp_Node.ln_Type = NT_MSGPORT;
	tg->port->mp_Flags = PA_SIGNAL;
	tg->port->mp_SigBit = tg->signalbit;
	tg->port->mp_SigTask = FindTask(0L);
	AddPort(tg->port);

	*tgp = tg;

	tg->state = CSTATE_CONNECT;
	return(SDN_OK);
}

/****** NET-LOCAL.library/SDNSerTerm **********************************
*
*   NAME
*	SDNSerTerm -- Terminate all resources associated with a server.
*
*   SYNOPSIS
*	SDNSerTerm(drglobal)
*		   A0
*
*	void SDNSerTerm(APTR);
*
*   FUNCTION
*	Terminate all resouces associated with a server.
*
*	This routine should terminate all pending operations and free up all
*	allocated objects in preparation for shutting down.  It must also free
*	the global structure allocated at SDNSerInit() time.
*
*   INPUTS
*	drglobal	- Driver-specific global data pointer.
*
*   RESULT
*	none.
*
*   NOTES
*	Driver must not free ANY signal bits, even if it allocated them.
*
*   BUGS
*
*   SEE ALSO
*	SDNSerInit()
****************************************/
void LIBENT LOCALSDNSerTerm (register __a0 LOCALGLOBAL tg,
				register __a6 struct DrLibrary *DriverBase)
{
	if (tg->port != NULL)
	{
		RemPort(tg->port);
		FreeMem(tg->port, sizeof(struct MsgPort));
	}
	SDNHanTerm((APTR)tg);
}

/****** NET-LOCAL.library/SDNHanInit **********************************
*
*   NAME
*	SDNHanInit --  Perform handler specific initialization.
*
*   SYNOPSIS
*	rc = SDNHanInit(drglobal, mask, data)
*	D0		A0	  A1	A2
*
*	int SDNHanInit(APTR *, ULONG *, char *);
*
*   FUNCTION
*	Perform handler specific initialization.
*
*	The mask value is the communications mechanism for indicating which
*	bits are to be used by the handler.  On input it is a mask of bits
*	available for use if the library is unable to allocate any bits.  On
*	output it is a mask of the bits that the library will set whenever it
*	needs to service a message.  Once the bit is set, the handler will
*	call SDNReceive() until SDN_NONE is returned.
*
*	The data string is a simple null terminated C style string that is
*	for use by the library.  There is no format specified in the string
*	and may contain whatever the library wants it to have.  The handler
*	code just reads the string from a configuration file and passes it
*	on to the library.  This pointer may be NULL if no initialization
*	string has been specified.  In the absence of any configuration
*	information, it is the responsibility of the library code to pick an
*	appropriate default or to safely fail the initialization.
*
*	The only difference between this routine and the SNDSerInit() is that
*	the handler portion does not need to set up to receive asynchronous
*	new connections.  It will only be doing calls to SDNReceive() and not
*	any to SDNAccept().
*
*   INPUTS
*	 drglobal	- Driver-specific global data pointer.
*	 mask		- On input, mask of signal bits already being used by
*			  all other drivers;  On output, mask of signal bits
*			  this driver will be using.
*	 data		- Pointer to driver-specific initialization string.
*
*   RESULT
*	 rc		- SDN_ERR, SDN_OK
*
*   NOTES
*	 Driver is free to reuse signal bits or allocate new ones.
*
*   BUGS
*
*   SEE ALSO
*	SDNSerInit(), SDNHandTerm()
*
****************************************/
int LIBENT LOCALSDNHanInit (register __a0 LOCALGLOBAL *tgp,
			    register __a1 ULONG *maskp,
			    register __a2 char *data,
			    register __a6 struct DrLibrary *DriverBase)
{
LOCALGLOBAL tg;

	*tgp = NULL;

	if ((tg = LocalInit(maskp, data)) == NULL)
		return(SDN_ERR);

	tg->DriverBase = DriverBase;

	tg->replyport = (struct MsgPort *)
		AllocMem(sizeof(struct MsgPort), MEMF_CLEAR|MEMF_PUBLIC);
	if (tg->replyport == NULL)
	{
		FreeMem((void *)tg, sizeof(*tg));
		return(SDN_ERR);
	}
	tg->replyport->mp_Node.ln_Type = NT_MSGPORT;
	tg->replyport->mp_Flags = PA_SIGNAL;
	tg->replyport->mp_SigBit = tg->signalbit; /* Note shared signal bit */
	tg->replyport->mp_SigTask = FindTask(0L);
	NewList(&(tg->replyport->mp_MsgList));

	*tgp = tg;

	return(SDN_OK);
}

/****i* NET-LOCAL.library/LocalInit **********************************
*
*   NAME
*	LocalInit -- Perform local initializaion.
*
*   SYNOPSIS
*	drglobal = LocalInit(drglobal, mask, data)
*
*	LOCALGLOBAL LocalInit(ULONG *, char *);
*
*   FUNCTION
*
*   INPUTS
*	 drglobal	- Driver-specific global data pointer.
*	 mask		- On input, mask of signal bits already
*			  being used by all other drivers;
*			  On output, mask of signal bits this.
*   RESULT													 driver will be using.
*	 data		-  Pointer to driver specific.
*														 Initialization string.
*   NOTES
*	 Driver is free to reuse signal bits or allocate new ones.
*
*   BUGS
*
*   SEE ALSO
*
****************************************/
LOCALGLOBAL LocalInit(maskp, data)
ULONG *maskp;
char *data;
{
LOCALGLOBAL tg;
int i;
struct LOCALRPacket *ip;
#undef SysBase
struct Library *SysBase = ABSEXECBASE;

	*maskp = 0;

	if(!(tg = (void *)AllocMem(sizeof(*tg), MEMF_CLEAR)))
	{
		return(NULL);
	}

	tg->tg_SysBase		 = SysBase;

	tg->signalbit = AllocSignal(-1);
	if (tg->signalbit == -1)
	{
		if (!*maskp)
		{
			return(NULL);
		}
		for (i = 0; i < 32; i++)
			if (*maskp & (1L << i)) break;
		tg->signalbit = i;
	}

	/* Allocate our pool of 10 RPackets */
	if ((tg->ppack = (struct LOCALRPacket *)
			 AllocMem(DEFPACKETS*sizeof(struct LOCALRPacket), MEMF_CLEAR)) == NULL)
	{
		FreeMem((void *)tg, sizeof(*tg));
		return(NULL) ;
	}

	for (ip = tg->ppack, i=0; i < DEFPACKETS; i++)
	{
		ip->next = ip+1;
		ip->class = PACKET_FREE;
		ip++;
	}
	ip--;
	ip->next = NULL;

	if (data)
	{
		while(*data == ' ') data++;
		i = 0;
		if(!tg->nodename[0])
		{
			while(*data > ' ')
			{
				if(i < MAXNAME)
					tg->nodename[i++] = *data;
				data++;
			}
			data++;
		}
		while(*data > ' ')
		{
			if (i < MAXNAME) tg->portname[i++] = *data;
			data++;
		}
		tg->portname[i] = 0; /* Null terminate the name */
		if (i == 0)
		{
			strcpy(tg->portname, "LOCAL_NET_PORT");
		}
	}

	tg->sendport = FindPort(tg->portname);
	*maskp = 1L << tg->signalbit;
	return(tg);
}

#define SysBase	 (tg->tg_SysBase)

/****** NET-LOCAL.library/SDNHanTerm **********************************
*
*   NAME
*	SDNHanTerm -- Terminate all resources associated with a handler.
*
*   SYNOPSIS
*	SDNHanTerm(drglobal)
*
*	void SDNHanTerm(APTR);
*
*   FUNCTION
*	Terminate all resources associated with a handler.
*
*	This routine should terminate all pendin operations and free up all
*	allocated objects in prepartion for shutting down.  It must also free
*	the global structure allocated at SDNHanInit() time.
*
*   INPUTS
*	 drglobal	- Driver-specific global data pointer.
*
*   RESULT
*	None.
*
*   NOTES
*	 Driver must not free ANY signal bits, even if it allocated them.
*
*   BUGS
*
*   SEE ALSO
*	SDNHanInit()
*
***************************************/

int LIBENT LOCALSDNHanTerm (register __a0 LOCALGLOBAL tg,
			    register __a6 struct DrLibrary *DriverBase)
{
	if(tg == NULL)
		return;
	if (tg->replyport != NULL)
		FreeMem(tg->replyport, sizeof(struct MsgPort));
	if(tg->ppack != NULL)
		FreeMem((void *)tg->ppack, DEFPACKETS*sizeof(struct LOCALRPacket));
	FreeMem((void *)tg, sizeof(*tg));
}


/****** NET-LOCAL.library/SDNAllocRPacket *******************************
*
*   NAME
*	SDNAllocRPacket -- Allocate an RPacket for general use.
*
*   SYNOPSIS
*	RP = SDNAllocRPacket(drglobal, con, len)
*	D0		     A0	       A1   D0
*
*	struct RPacket *SDNAllocRPacket(APTR, APTR, int);
*
*   FUNCTION
*	Allocate an RPacket for general use.
*
*   INPUTS
*	drglobal	- Driver-specific global data pointer.
*	con		- Connection to allocate packet for.
*	len		- Minimum number of bytes that must be in the DataP
*			  field.
*
*   RESULT
*	 RP		- created RPacket (or NULL for error).
*
*   NOTES
*	This routine is called only by the handler.
*
*	For ease of implementation, it is convenient to call this routine
*	internally with a NULL con pointer when generating packets.
*
*   BUGS
*
*   SEE ALSO
*	SDNFreeRPacket(), SDNDupRPacket(), SDNInitNode()
*
****************************************/
struct RPacket *
LIBENT LOCALSDNAllocRPacket (register __a0 LOCALGLOBAL tg,
			     register __a1 APTR con,
			     register __d0 int len,
			     register __a6 struct DrLibrary *DriverBase)
{
struct LOCALRPacket *ip;

	for (ip = tg->ppack; ip != NULL && ip->class != PACKET_FREE; ip = ip->next);
	if (ip != NULL)
	{
		ip->class = PACKET_PERM;
	}
	else
	{
		/* Have to allocate a temporary one from system storage */
		ip = (struct LOCALRPacket *)AllocMem(sizeof(*ip), 0L);
		if (ip == NULL) return(NULL);
		ip->next = tg->tpack;
		ip->class = PACKET_TEMP; /* mark it to be freed later	  */
		tg->tpack = ip;
		ip->rp.AllocP = NULL;
	}
	ip->rp.DataP = ip->rp.AllocP;
	if (ip->rp.DataP == NULL)
	{
		ip->rp.AllocP = ip->rp.DataP = AllocMem(NETBUFSIZE, 0);
		if (ip->rp.AllocP == NULL)
		{
			SDNFreeRPacket((APTR)tg, LRP2RP(ip));
			ip = NULL;
		}
	}
	return(LRP2RP(ip));
}

/****************************************
*
*   NAME
*	SDNDupRPacket --  Allocate a second RPacket on the same connection.
*
*   SYNOPSIS
*	NewRP = SDNDupRPacket(drglobal, RP)
*	D0		      A0	A1
*
*	struct RPacket *SDNDupRPacket(APTR, struct RPacket *);
*
*   FUNCTION
*	This function makes a copy of an RPacket so that it may be replied to
*	more than one time.  It is primarily intended for usage in situations
*	where asynchronous events need to be generated (i.e. file
*	notification).
*
*   INPUTS
*	drglobal	- Driver-specific global data pointer
*	RP		- RPacket to duplicate
*
*   RESULT
*	NewRP		- Duplicated RPacket (NULL if error)
*
*   NOTES
*
*   BUGS
*
*   SEE ALSO
*	SDNFreeRPacket()
*
****************************************/
struct RPacket *
LIBENT LOCALSDNDupRPacket (register __a0 LOCALGLOBAL tg,
			   register __a1 struct RPacket *rp,
			   register __a6 struct DrLibrary *DriverBase)
{
struct RPacket *newrp;

	newrp = SDNAllocRPacket((APTR)tg, NULL, NETBUFSIZE);
	if (newrp != NULL)
	{
		/* Actually, this is wrong, we need to copy less, but we aren't using it  */
		/* for now...																				 */
		memcpy(RP2LRP(newrp), rp, sizeof(struct LOCALRPacket));
	}

	return(newrp);
}

/****************************************
*
*   NAME
*	SDNFreeRPacket -- Free an RPacket.
*
*   SYNOPSIS
*	SDNFreeRPacket(drglobal, RP)
*
*	void SDNFreeRPacket(APTR, struct RPacket *);
*
*   FUNCTION
*	This function must be called before the driver is allowed to reuse an
*	RPacket structure which it previously issued via SDNAllocRPacket(),
*	SDNDupRPacket(), SDNReceive() or SDNAccept().
*
*	Both handler and server can call this function.
*
*   INPUTS
*	 drglobal	- Driver-specific global data pointer
*	 RP		- RPacket struct returned from
*
*   RESULT
*	None.
*
*   NOTES
*	FreeRPacket should be called ASAP on any packets returned from
*	SDNReceive() or SDNAccept() since the returned packets are really
*	driver-allocated input buffers;  holding on to them may result in
*	lots of memory being allocated to the driver for buffering.  The
*	server, in particular, must call FreeRPacket BEFORE calling Dispatch()
*	to process the packet.
*
*   BUGS
*
*   SEE ALSO
*	SDNDupRPacket(), SDNAllocRPacket(), SDNReceive(), SDNAccept()
*
****************************************/
void
LIBENT LOCALSDNFreeRPacket (register __a0 LOCALGLOBAL tg,
			  register __a1 struct RPacket *rp,
			  register __a6 struct DrLibrary *DriverBase)
{
struct LOCALRPacket *ipkt;
struct LOCALRPacket *ip;

	if (rp == NULL) return;
	ipkt = RP2LRP(rp);

	switch(ipkt->class)
	{
		case PACKET_TEMP:
			if (ipkt == tg->tpack)
			{
				tg->tpack = ipkt->next;
			}
			else
			{
				for(ip = tg->tpack; ip != NULL && ip->next != ipkt; ip = ip->next);
				if (ip == NULL)
				{
					return;
				}
				ip->next = ipkt->next;
			}
			if (ipkt->rp.AllocP != NULL)
				FreeMem((void *)ipkt->rp.AllocP, NETBUFSIZE);
			FreeMem((void *)ipkt, sizeof(*ipkt));
			break;

		case PACKET_PERM:
			if (ipkt->rp.AllocP != NULL)
				FreeMem((void *)ipkt->rp.AllocP, NETBUFSIZE);
			ipkt->class = PACKET_FREE;
			break;

		default:
			break;
	}
}

/****************************************
*
*   NAME
*	SDNGetConData -- Get data associated with a connection for a RPacket.
*
*   SYNOPSIS
*	data = SDNGetConData(drglobal, RP)
*	D0		     A0	       A1
*
*	void *SDNGetConData(APTR, struct RPacket *);
*
*   FUNCTION
*	Get data associated with a connection for a RPacket.
*
*	This function is the only way to obtain a connection specific pointer
*	for any given RPacket.  With this the server or hanler can store a
*	pointer to a global data item associated with an open connection.
*	When the connection closes, an ACTION_NETWORK_TERM packet ARG1
*	containing the data value set for the connection.
*
*   INPUTS
*	 drglobal	- Driver-specific global data pointer
*	 RP		- RPacket struct returned from
*			  SDNReceive() or SDNAccept()
*   RESULT
*	 data		- Data for given connection
*
*   NOTES
*
*   BUGS
*
*   SEE ALSO
*	SDNSetConData()
*
****************************************/
void *LIBENT LOCALSDNGetConData (register __a0 LOCALGLOBAL tg,
				  register __a1 struct RPacket *rp,
				  register __a6 struct DrLibrary *DriverBase)
{
	return(tg->data);
}

/****************************************
*
*   NAME
*	SDNSetConData -- Set data associated with a connection for a RPacket.
*
*   SYNOPSIS
*	SDNSetConData(drglobal, RP, data)
*
*	void SDNSetConData(APTR, struct RPacket *, void *);
*
*   FUNCTION
*	Set data associated with a connection for an RPacket.
*
*	This function sets the connection specific pointer for any given
*	RPacket.  With this the server or hanlder can store a pointer to a
*	global data item associated with an open connection.  When the
*	connection closes, an ACTION_NETWORK_END packet with ARG1 containing
*	the data value set for the connection.
*
*	Typically this pointer will point to a handler or server specific
*	data structure that indicates access or state information.
*
*   INPUTS
*	 drglobal  	- Driver-specific global data pointer
*	 RP		- RPacket struct returned from
*			  SDNReceive() or SDNAccept()
*	 data		- Data for given connection
*
*   RESULT
*	None.
*
*   NOTES
*	This is the only way for the server to track which connection a
*	particular packet is associated.
*
*   BUGS
*
*   SEE ALSO
*	SDNGetConData()
*
****************************************/
void LIBENT LOCALSDNSetConData  (register __a0 LOCALGLOBAL tg,
				  register __a1 struct RPacket *rp,
				  register __a2 void *data,
				  register __a6 struct DrLibrary *DriverBase)
{
	tg->data = data;
}

int LOCALprivate()
{
	return(0);
}

@


1.6
log
@Tweaked autodocs, eliminated include of netcomm.h
@
text
@d4 2
a5 2
**      $Revision: 1.5 $
**      $Date: 91/05/22 10:00:19 $
d7 3
d386 1
d390 7
a396 4
	if(tg != NULL)
	{
		FreeMem((void *)tg, sizeof(*tg));
	}
d592 2
@


1.5
log
@clean up stay comments, etc.
@
text
@d4 2
a5 2
**      $Revision: 1.4 $
**      $Date: 91/05/21 15:56:21 $
d7 3
d19 1
a19 1
#include "netcomm.h"
d37 1
a37 1
*	bits are to be used by the handle.  On input it is a mask of bits
d40 2
a41 2
*	needs to service a message.  Once the bit is set, the server will call
*	SDNAccept() until SDN_NONE is returned.
d44 2
a45 2
*	for use by the library.  There is no format specified in the string
*	and may contain whatever the library wants it to have.  The server
d52 1
a52 1
*	The only difference between this routine and the SNDHanInit is that
d55 1
a55 1
*	to SDNReceive.
d59 4
a62 6
*	mask		- On input, mask of signal bits already
*		  	  being used by all other drivers;
*		  	  On output, mask of signal bits this
*		  	  driver will be using.
*	data		- Pointer to driver specific
*		  	  Initialization string.
a68 3
*	Called by the server to initialize communications.  A signal bit should
*	be set when a new connection is detected or when a pending read or
*	write completes.
d168 1
a168 1
*	Perform handler Specific Initialization.
d171 1
a171 1
*	bits are to be used by the handle.  On input it is a mask of bits
d193 4
a196 6
*	 mask		- On input, mask of signal bits already.
*			  being used by all other drivers;
*			  On output, mask of signal bits this
*			  driver will be using.
*	 data		- Pointer to driver specific
*			  Initialization string.
a203 4
*	 Called by handler to initialize communication.  A signal bit should
*	 be set when a pending write completes and when a pending read
*	 completes.
*
d222 1
a222 1
	tg->DriverBase		 = DriverBase;
d225 1
a225 1
				  AllocMem(sizeof(struct MsgPort), MEMF_CLEAR|MEMF_PUBLIC);
d322 10
@


1.4
log
@Updated autodocs, spaces->tabs, etc.
@
text
@d3 3
a5 3
**      $Author: J_Toebes $
**      $Revision: 1.3 $
**      $Date: 91/01/06 20:57:13 $
d7 3
d85 1
a85 1
	tg->DriverBase		 = DriverBase;
d311 1
a311 1
						  AllocMem(DEFPACKETS*sizeof(struct LOCALRPacket), MEMF_CLEAR)) == NULL)
d425 1
a425 1
****************************************
d442 1
a442 1
		ip = (struct LOCALRPacket *)AllocMem(sizeof(*ip), 0);
@


1.3
log
@Correct strange bug where packets were being received by the local
sender.  This was due to overloading the Port field in the global structure.
@
text
@a0 9
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\
* |_o_o|\\ Copyright (c) 1990 The Software Distillery.                    *
* |. o.| ||          All Rights Reserved                                  *
* | .  | ||          Written by John Toebes and Doug Walker               *
* | o  | ||          The Software Distillery                              *
* |  . |//           207 Livingstone Drive                                *
* ======             Cary, NC 27513                                       *
*                    BBS:(919)-460-7430                                   *
\* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
d2 1
a2 1
**      $Filename: SDNLocalUtil.c $ 
d4 2
a5 2
**      $Revision: 1.10 $
**      $Date: 90/12/31 15:27:48 $
d7 4
d16 259
a274 175
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/*                                                                             */
/* ROUTINE: SDNSerInit                                                         */
/*                                                                             */
/* PURPOSE: Perform Server Specific Initialization                             */
/* SYNOPSIS:                                                                   */
/*   rc = SDNSerInit(drglobal, mask, data);                                    */
/*                                                                             */
/*     drglobal     APTR *      (out)    Server-specific global data pointer   */
/*                                                                             */
/*     mask         ULONG *     (in/out) On input, mask of signal bits already */
/*                                          being used by all other drivers;   */
/*                                       On output, mask of signal bits this   */
/*                                          driver will be using.              */
/*     data         char *      (in)     Pointer to driver specific            */
/*                                                Initialization string.       */
/*                                                                             */
/*     rc           int         (ret)    SDN_ERR, SDN_OK                       */
/*                                                                             */
/*   NOTES:                                                                    */
/*      Driver is free to reuse signal bits or allocate new ones.              */
/*      Called by the server to initialize communications.  A signal bit should*/
/*         be set when a new connection is detected or when a pending read or  */
/*         write completes.                                                    */
/*                                                                             */
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
int LIBENT LOCALSDNSerInit      (register __a0 LOCALGLOBAL *tgp,
                                register __a1 ULONG *maskp,
                                register __a2 char *data,
                                register __a6 struct DrLibrary *DriverBase
                               )
{
   LOCALGLOBAL tg;

   *tgp = NULL;

   if ((tg = LocalInit(maskp, data)) == NULL)
      return(SDN_ERR);

   tg->DriverBase       = DriverBase;

   /* If the port already exists then we can not start the server.       */
   if (tg->sendport != NULL)
   {
      FreeMem((void *)tg, sizeof(*tg));
      return(SDN_ERR);
   }
   
   tg->port = (struct MsgPort *)
              AllocMem(sizeof(struct MsgPort), MEMF_CLEAR|MEMF_PUBLIC);
   if (tg->port == NULL)
   {
      FreeMem((void *)tg, sizeof(*tg));
      return(SDN_ERR);
   }
   tg->port->mp_Node.ln_Name = tg->portname;
   tg->port->mp_Node.ln_Pri = 0;
   tg->port->mp_Node.ln_Type = NT_MSGPORT;
   tg->port->mp_Flags = PA_SIGNAL;
   tg->port->mp_SigBit = tg->signalbit;
   tg->port->mp_SigTask = FindTask(0L);
   AddPort(tg->port);

   *tgp = tg;

   tg->state = CSTATE_CONNECT;
   return(SDN_OK);
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/*                                                                             */
/* ROUTINE: SDNSerTerm                                                         */
/*                                                                             */
/* PURPOSE: Perform Server Specific Termination                                */
/* SYNOPSIS:                                                                   */
/*   rc = SDNSerTerm(drglobal);                                                */
/*                                                                             */
/*    drglobal     APTR        (in)     Driver-specific global data pointer    */
/*                                                                             */
/* NOTES:                                                                      */
/*    Driver must not free ANY signal bits, even if it allocated them.         */
/*                                                                             */
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
int LIBENT LOCALSDNSerTerm      (register __a0 LOCALGLOBAL tg,
                                register __a6 struct DrLibrary *DriverBase
                               )
{
   if (tg->port != NULL)
   {
      RemPort(tg->port);
      FreeMem(tg->port, sizeof(struct MsgPort));
   }
   SDNHanTerm((APTR)tg);
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/*                                                                             */
/* ROUTINE: SDNHanInit                                                         */
/*                                                                             */
/* PURPOSE: Perform Server Specific Initialization                             */
/* SYNOPSIS:                                                                   */
/* rc = SDNHanInit(drglobal, mask, data);                                      */
/*                                                                             */
/*    drglobal     APTR *        (out)    Driver-specific global data pointer  */
/*                                                                             */
/*    mask         ULONG *       (in/out) On input, mask of signal bits already*/
/*                                           being used by all other drivers;  */
/*                                        On output, mask of signal bits this  */
/*                                           driver will be using.             */
/*    data         char *        (in)     Pointer to driver specific           */
/*                                           Initialization string.            */
/*                                                                             */
/*    rc           int           (ret)    SDN_ERR, SDN_OK                      */
/*                                                                             */
/* NOTES:                                                                      */
/*    Driver is free to reuse signal bits or allocate new ones.                */
/*                                                                             */
/*    Called by handler to initialize communication.  A signal bit should be   */
/*       set when a pending write completes and when a pending read completes. */
/*                                                                             */
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
int LIBENT LOCALSDNHanInit      (register __a0 LOCALGLOBAL *tgp,
                                register __a1 ULONG *maskp,
                                register __a2 char *data,
                                register __a6 struct DrLibrary *DriverBase
                               )
{
   LOCALGLOBAL tg;

   *tgp = NULL;

   if ((tg = LocalInit(maskp, data)) == NULL)
      return(SDN_ERR);

   tg->DriverBase       = DriverBase;

   tg->replyport = (struct MsgPort *)
              AllocMem(sizeof(struct MsgPort), MEMF_CLEAR|MEMF_PUBLIC);
   if (tg->replyport == NULL)
   {
      FreeMem((void *)tg, sizeof(*tg));
      return(SDN_ERR);
   }
   tg->replyport->mp_Node.ln_Type = NT_MSGPORT;
   tg->replyport->mp_Flags = PA_SIGNAL;
   tg->replyport->mp_SigBit = tg->signalbit; /* Note shared signal bit */
   tg->replyport->mp_SigTask = FindTask(0L);
   NewList(&(tg->replyport->mp_MsgList));

   *tgp = tg;

   return(SDN_OK);
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/*                                                                             */
/* ROUTINE: LocalInit                                                          */
/*                                                                             */
/* PURPOSE: Perform Local Initializaion                                        */
/* SYNOPSIS:                                                                   */
/* drgloabl = LocalInit(drglobal, mask, data);                                 */
/*                                                                             */
/*    drglobal     LOCALGLOBAL   (out)    Driver-specific global data pointer  */
/*                                                                             */
/*    mask         ULONG *       (in/out) On input, mask of signal bits already*/
/*                                           being used by all other drivers;  */
/*                                        On output, mask of signal bits this  */
/*                                           driver will be using.             */
/*    data         char *        (in)     Pointer to driver specific           */
/*                                           Initialization string.            */
/*                                                                             */
/* NOTES:                                                                      */
/*    Driver is free to reuse signal bits or allocate new ones.                */
/*                                                                             */
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
d279 3
a281 3
   LOCALGLOBAL tg;
   int i;
   struct LOCALRPacket *ip;
d283 1
a283 1
   struct Library *SysBase = ABSEXECBASE;
d285 1
a285 1
   *maskp = 0;
d287 136
a422 101
   if(!(tg = (void *)AllocMem(sizeof(*tg), MEMF_CLEAR)))
   {
      return(NULL);
   }

   tg->tg_SysBase       = SysBase;

   tg->signalbit = AllocSignal(-1);
   if (tg->signalbit == -1)
   {
      if (!*maskp)
      {
         return(NULL);
      }
      for (i = 0; i < 32; i++)
         if (*maskp & (1L << i)) break;
      tg->signalbit = i;
   }

   /* Allocate our pool of 10 RPackets */
   if ((tg->ppack = (struct LOCALRPacket *)
                    AllocMem(DEFPACKETS*sizeof(struct LOCALRPacket), MEMF_CLEAR)) == NULL)
   {
      FreeMem((void *)tg, sizeof(*tg));
      return(NULL) ;
   }

   for (ip = tg->ppack, i=0; i < DEFPACKETS; i++)
   {
      ip->next = ip+1;
      ip->class = PACKET_FREE;
      ip++;
   }
   ip--;
   ip->next = NULL;

   if (data)
   {
      while(*data == ' ') data++;
      i = 0;
      while(*data > ' ')
      {
         if (i < MAXNAME) tg->portname[i++] = *data;
         data++;
      }
      tg->portname[i] = 0; /* Null terminate the name */
      if (i == 0)
      {
         strcpy(tg->portname, "LOCAL_NET_PORT");
      }
   }

   tg->sendport = FindPort(tg->portname);
   *maskp = 1L << tg->signalbit;
   return(tg);
}

#define SysBase    (tg->tg_SysBase)

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/*                                                                             */
/* ROUTINE: SDNHanTerm                                                         */
/*                                                                             */
/* PURPOSE: Terminate all resources associated with a handler                  */
/* SYNOPSIS:                                                                   */
/*                                                                             */
/* SDNHanTerm(drglobal);                                                       */
/*                                                                             */
/*    drglobal     APTR          (in)     Driver-specific global data pointer  */
/*                                                                             */
/* NOTES:                                                                      */
/*    Driver must not free ANY signal bits, even if it allocated them.         */
/*                                                                             */
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
int LIBENT LOCALSDNHanTerm      (register __a0 LOCALGLOBAL tg,
                                register __a6 struct DrLibrary *DriverBase
                               )
{
   if(tg != NULL)
   {
      FreeMem((void *)tg, sizeof(*tg));
   }
}


/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/*                                                                             */
/* ROUTINE: SDNAllocRPacket                                                    */
/*                                                                             */
/* PURPOSE: Allocate an RPacket for general use                                */
/*                                                                             */
/* SYNOPSIS:                                                                   */
/*    RP = SDNAllocRPacket(drglobal);                                          */
/*                                                                             */
/*    drglobal  APTR              (in)     Driver-specific global data pointer */
/*                                                                             */
/*    RP        struct RPacket *  (out)    created RPacket (or NULL for error) */
/*                                                                             */
/* NOTES:                                                                      */
/*                                                                             */
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
d424 67
a490 54
    LIBENT LOCALSDNAllocRPacket (register __a0 LOCALGLOBAL tg,
                                register __a1 APTR con,
                                register __d0 int len,
                                register __a6 struct DrLibrary *DriverBase
                               )
{
   struct LOCALRPacket *ip;

   for (ip = tg->ppack; ip != NULL && ip->class != PACKET_FREE; ip = ip->next);
   if (ip != NULL)
   {
      ip->class = PACKET_PERM;
   }
   else
   {
      /* Have to allocate a temporary one from system storage */
      ip = (struct LOCALRPacket *)AllocMem(sizeof(*ip), 0);
      if (ip == NULL) return(NULL);
      ip->next = tg->tpack;
      ip->class = PACKET_TEMP; /* mark it to be freed later     */
      tg->tpack = ip;
      ip->rp.AllocP = NULL;
   }
   ip->rp.DataP = ip->rp.AllocP;
   if (ip->rp.DataP == NULL)
   {
      ip->rp.AllocP = ip->rp.DataP = AllocMem(NETBUFSIZE, 0);
      if (ip->rp.AllocP == NULL)
      {
         SDNFreeRPacket((APTR)tg, LRP2RP(ip));
         ip = NULL;
      }
   }
   return(LRP2RP(ip));
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/*                                                                             */
/* ROUTINE: SDNDupRPacket                                                      */
/*                                                                             */
/* PURPOSE: Allocate a second RPacket on the same connection                   */
/*                                                                             */
/* SYNOPSIS:                                                                   */
/*    NewRP = SDNDupRPacket(drglobal, RP);                                     */
/*                                                                             */
/*    drglobal  APTR              (in)     Driver-specific global data pointer */
/*                                                                             */
/*    RP        struct RPacket *  (in)     RPacket to duplicate                */
/*                                                                             */
/*    NewRP     struct RPacket *  (ret)    Duplicated RPacket (NULL if error)  */
/*                                                                             */
/* NOTES:                                                                      */
/*                                                                             */
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
d492 3
a494 4
    LIBENT LOCALSDNDupRPacket   (register __a0 LOCALGLOBAL tg,
                                register __a1 struct RPacket *rp,
                                register __a6 struct DrLibrary *DriverBase
                               )
d496 127
a622 101
   struct RPacket *newrp;

   newrp = SDNAllocRPacket((APTR)tg, NULL, NETBUFSIZE);
   if (newrp != NULL)
   {
      /* Actually, this is wrong, we need to copy less, but we aren't using it  */
      /* for now...                                                             */
      memcpy(RP2LRP(newrp), rp, sizeof(struct LOCALRPacket));
   }

   return(newrp);
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/*                                                                             */
/* ROUTINE: SDNFreeRPacket                                                     */
/*                                                                             */
/* PURPOSE: Indicate that the driver may reuse a previously issued RPacket     */
/*                                                                             */
/* SYNOPSIS:                                                                   */
/*    SDNFreeRPacket(drglobal, RP);                                            */
/*                                                                             */
/*    drglobal  APTR              (in)     Driver-specific global data pointer */
/*                                                                             */
/*    RP        struct RPacket *  (in)     RPacket struct returned from        */
/*                                         PluckRPacket/AcceptRPacket          */
/*                                                                             */
/* NOTES:                                                                      */
/*    This routine must be called before the driver is allowed to reuse an     */
/*       RPacket structure.                                                    */
/*                                                                             */
/*    Both handler and server can call this routine.                           */
/*                                                                             */
/*    FreeRPacket should be called ASAP on any packets returned from           */
/*    PluckRPacket or AcceptRPacket since the returned packets are really      */
/*    driver-allocated input buffers;  holding on to them may result in lots   */
/*    of memory being allocated to the driver for buffering.  The server, in   */
/*    particular, must call FreeRPacket BEFORE calling Dispatch() to process   */
/*    the packet.                                                              */
/*                                                                             */
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
void LIBENT LOCALSDNFreeRPacket (register __a0 LOCALGLOBAL tg,
                                register __a1 struct RPacket *rp,
                                register __a6 struct DrLibrary *DriverBase
                               )
{
   struct LOCALRPacket *ipkt;
   struct LOCALRPacket *ip;

   if (rp == NULL) return;
   ipkt = RP2LRP(rp);

   switch(ipkt->class)
   {
      case PACKET_TEMP:
         if (ipkt == tg->tpack)
         {
            tg->tpack = ipkt->next;
         }
         else
         {
            for(ip = tg->tpack; ip != NULL && ip->next != ipkt; ip = ip->next);
            if (ip == NULL)
            {
               return;
            }
            ip->next = ipkt->next;
         }
         if (ipkt->rp.AllocP != NULL)
            FreeMem((void *)ipkt->rp.AllocP, NETBUFSIZE);
         FreeMem((void *)ipkt, sizeof(*ipkt));
         break;

      case PACKET_PERM:
         ipkt->class = PACKET_FREE;
         break;

      default:
         break;
   }
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/*                                                                             */
/* ROUTINE: SDNGetConData                                                      */
/*                                                                             */
/* PURPOSE: Get data associated with a connection for a RPacket                */
/*                                                                             */
/* SYNOPSIS:                                                                   */
/*    data = SDNGetConData(drglobal, RP);                                      */
/*                                                                             */
/*    drglobal  APTR              (in)     Driver-specific global data pointer */
/*                                                                             */
/*    RP        struct RPacket *  (in)     RPacket struct returned from        */
/*                                         PluckRPacket/AcceptRPacket          */
/*                                                                             */
/*    data      void *            (out)    Data for given connection           */
/*                                                                             */
/* NOTES:                                                                      */
/*                                                                             */
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
d624 2
a625 3
                                register __a1 struct RPacket *rp,
                                register __a6 struct DrLibrary *DriverBase
                               )
d627 44
a670 22
   return(tg->data);
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/*                                                                             */
/* ROUTINE: SDNSetConData                                                      */
/*                                                                             */
/* PURPOSE: Set data associated with a connection for a RPacket                */
/*                                                                             */
/* SYNOPSIS:                                                                   */
/*    SDNSetConData(drglobal, RP, data);                                       */
/*                                                                             */
/*    drglobal  APTR              (in)     Driver-specific global data pointer */
/*                                                                             */
/*    RP        struct RPacket *  (in)     RPacket struct returned from        */
/*                                         PluckRPacket/AcceptRPacket          */
/*                                                                             */
/*    data      void *            (in)     Data for given connection           */
/*                                                                             */
/* NOTES:                                                                      */
/*                                                                             */
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
d672 3
a674 4
                                register __a1 struct RPacket *rp,
                                register __a2 void *data,
                                register __a6 struct DrLibrary *DriverBase
                               )
d676 1
a676 1
   tg->data = data;
d681 1
a681 1
   return(0);
@


1.2
log
@Correct infinite loop bug with specified names for config
@
text
@d10 7
d63 1
a63 1
   if (tg->port != NULL)
d260 1
a260 1
   tg->port = FindPort(tg->portname);
@


1.1
log
@Initial revision
@
text
@d244 1
@
