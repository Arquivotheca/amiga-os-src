@database SDN.hyper
@node MAIN
@title "Software Distillery Network Documentation"

   I.    @{" Overview of Drivers " link OVERVIEW}
  II.    @{" Contents of Disk " link DISKCONTENTS}
 III.    @{" Library Functions " link LIBFUNC}
  IV.    @{" Packet Definitions " link PACKETS}
   V.    @{" Data Structures " link DATASTRUC}
  VI.    @{" Configuration " link CONFIG}
 VII.    @{" Tools Provided " link TOOLS}
VIII.    @{" Work still to be done " link TODO}
         @{" QUIT " quit}

NOTE: The Hyper.library used for this is beta software from David Junod. 
      Please do not redistribute it.  Any problems encountered can be
      sent to me.  Also, do NOT click on the close gadget unless you want
      to leave the document locked in memory.

@endnode
@node HELP
This is the document help here.  
Click on any raised area to get context information.
The buttons across the bottom are:
   INDEX    - Currently non-functional
   HELP     - It got you here didn't it
   RETRACE  - Go to previous page that you viewed
   PREVIOUS - Scroll back a screenful in the current page
   NEXT     - Scroll forward a screenful in the current page
To exit, please use the quit option for now.  Clicking on the close gadget
just doesn't seem to free up everything.  I still have some learning to
do to make this work right.
@endnode
@node LIBFUNC
@title "Library Function"

@{" SDNAccept " link SDNAccept}
@{" SDNAllocRPacket " link SDNAllocRPacket}
@{" SDNDupRPacket " link SDNDupRPacket}
@{" SDNFreeRPacket " link SDNFreeRPacket}
@{" SDNGetConData " link SDNGetConData}
@{" SDNHanInit " link SDNHanInit}
@{" SDNHanTerm " link SDNHanTerm}
@{" SDNInitNode " link SDNInitNode}
@{" SDNReceive " link SDNReceive}
@{" SDNReply " link SDNReply}
@{" SDNSend " link SDNSend}
@{" SDNSerInit " link SDNSerInit}
@{" SDNSerTerm " link SDNSerTerm}
@{" SDNSetConData " link SDNSetConData}
@{" SDNTermNode " link SDNTermNode}
@endnode
@node SDNAccept
@title "SDNAccept"

   NAME
	@{" SDNAccept " link SDNAccept} - Get any new packet or connection

   SYNOPSIS
	rc = @{" SDNAccept " link SDNAccept}(@{" drglobal " link drglobal}, RP);
	D0	 	  A0	 A1
	
	int @{" SDNAccept " link SDNAccept}(APTR, struct @{" RPacket " link RPacket} **);

   FUNCTION
	Read the next incoming packet and accept new connections

   NOTE
	This routine is only called by the server.

	Driver must be prepared to handle this being called when nothing is
	pending since multiple drivers may be sharing a signal bit.  If a
	packet did come in, but is munged, @{" SDN_ERR " link DEFINES} is returned;  if no packet
	was available, @{" SDN_NONE " link DEFINES} is returned.  If a pending write request has
	been completed, a special packet type is returned and a copy of the
	original @{" RPacket " link RPacket} structure's 'statedata' pointer is returned.

	The memory pointed to by RP is owned by the NET: code
	until @{" SDNFreeRPacket " link SDNFreeRPacket} is called.  @{" SDNFreeRPacket " link SDNFreeRPacket} should be called ASAP after
	calling @{" SDNAccept " link SDNAccept} to allow the driver to reuse the @{" RPacket " link RPacket} for the
	next read request.

	When a new connection is established, this routine will return a filled
	in @{" RPacket " link RPacket} with an action indicating the establishment of the
	connection.  For connections that are broken, a phoney rpacket is
	also returned.

   EXAMPLE

   INPUTS
	@{" drglobal " link drglobal} - Driver specific global data pointer obtained at SDNHanInit or
		SDNSerInit time.
	RP - Address of pointer to store incomming @{" RPacket " link RPacket}.

   RESULTS
   	rc - 	@{" SDN_OK " link DEFINES},
		@{" SDN_ERR " link DEFINES} == read error,
		@{" SDN_NONE " link DEFINES} == nothing to read

   SEE ALSO
	@{" SDNReply " link SDNReply}, @{" SDNFreeRPacket " link SDNFreeRPacket}

@toc LIBFUNC
@endnode
@node SDNAllocRPacket
@title "SDNAllocRPacket"

	
   NAME
	@{" SDNAllocRPacket " link SDNAllocRPacket} -- Allocate an @{" RPacket " link RPacket} for general use
	
   SYNOPSIS
	RP = @{" SDNAllocRPacket " link SDNAllocRPacket}(@{" drglobal " link drglobal}, con, len);
	D0                      A0	A1   D0
	
	int @{" SDNAllocRPacket " link SDNAllocRPacket}(APTR, APTR, int);

   FUNCTION
	Allocate an @{" RPacket " link RPacket} for general use.

   NOTE
	This routine is only called by the handler.
	
	For ease of implementation, it is convenient to call this routine
	internally with a NULL con pointer when generating packets.

   EXAMPLE

   INPUTS
	@{" drglobal " link drglobal} - Driver specific global data pointer obtained at SDNHanInit or
		SDNSerInit time.
	con - Connection to allocate packet for.
	len - minimum number of bytes that must be in the DataP field.

   RESULTS
	RP - created @{" RPacket " link RPacket} (or NULL for error)

   SEE ALSO
	@{" SDNFreeRPacket " link SDNFreeRPacket}, @{" SDNDupRPacket " link SDNDupRPacket}, SDNInitNode

@toc LIBFUNC
@endnode
@node SDNDupRPacket
@title "SDNDupRPacket"

	
   NAME
	@{" SDNDupRPacket " link SDNDupRPacket} - Allocate a second @{" RPacket " link RPacket} on the same connection
	
   SYNOPSIS
	NewRP = @{" SDNDupRPacket " link SDNDupRPacket}(@{" drglobal " link drglobal}, RP);
	D0                      A0      A1
	
	struct @{" RPacket " link RPacket} *@{" SDNDupRPacket " link SDNDupRPacket}(APTR, struct @{" RPacket " link RPacket} *);
	
   FUNCTION
	This routine makes a copy of an @{" RPacket " link RPacket} so that it may be replied to
	more han one time.  It is primarily intended for usage in situations
	where asynchronous events need to be generated such as file notification.

   NOTE

   EXAMPLE

   INPUTS
	@{" drglobal " link drglobal} - Driver specific global data pointer obtained at SDNHanInit or
		SDNSerInit time.
	RP - @{" RPacket " link RPacket} to be duplocated

   RESULTS
	NewRP - Duplicate @{" RPacket " link RPacket} structure or NULL for failure.

   SEE ALSO
	@{" SDNFreeRPacket " link SDNFreeRPacket}

@toc LIBFUNC
@endnode
@node SDNFreeRPacket
@title "SDNFreeRPacket"

	
   NAME
	@{" SDNFreeRPacket " link SDNFreeRPacket}
	
	PURPOSE: Indicate that the driver may reuse a previously issued @{" RPacket " link RPacket}
	
   SYNOPSIS
	@{" SDNFreeRPacket " link SDNFreeRPacket}(@{" drglobal " link drglobal}, RP);
			A0	 A1
	
	void @{" SDNFreeRPacket " link SDNFreeRPacket}(APTR, struct RPacker *);
	
   NOTE
	This routine must be called before the driver is allowed to reuse an
	@{" RPacket " link RPacket} structure.
	
	Both handler and server can call this routine.
	
	@{" SDNFreeRPacket " link SDNFreeRPacket} should be called ASAP on any packets returned from
	@{" SDNReceive " link SDNReceive} or @{" SDNAccept " link SDNAccept} since the returned packets are really
	driver-allocated input buffers;  holding on to them may result in lots
	of memory being allocated to the driver for buffering.  The server, in
	particular, must call @{" SDNFreeRPacket " link SDNFreeRPacket} BEFORE calling Dispatch() to process
	the packet.
	

   FUNCTION

   NOTE

   EXAMPLE

   INPUTS
	@{" drglobal " link drglobal} - Driver specific global data pointer obtained at SDNHanInit or
		SDNSerInit time.
	RP - @{" RPacket " link RPacket} structure returned from @{" SDNDupRPacket " link SDNDupRPacket}, @{" SDNAllocRPacket " link SDNAllocRPacket},
		@{" SDNReceive " link SDNReceive} or @{" SDNAccept " link SDNAccept}

   RESULTS
   	Nothing Returned

   SEE ALSO
   	@{" SDNDupRPacket " link SDNDupRPacket}, @{" SDNAllocRPacket " link SDNAllocRPacket}, @{" SDNReceive " link SDNReceive}, @{" SDNAccept " link SDNAccept}


@toc LIBFUNC
@endnode
@node SDNGetConData
@title "SDNGetConData"

	
   NAME
	@{" SDNGetConData " link SDNGetConData} - Get data associated with a connection for a @{" RPacket " link RPacket}
	
   SYNOPSIS
	data = @{" SDNGetConData " link SDNGetConData}(@{" drglobal " link drglobal}, RP);
	D0			A0     A1
	
	void *@{" SDNGetConData " link SDNGetConData}(APTR, struct @{" RPacket " link RPacket} *);
	
   FUNCTION
	Get data associated with a connection for a @{" RPacket " link RPacket}.
	
	This function is the only way to obtain a connection specific pointer
	for any given @{" RPacket " link RPacket}.  With this the server or handler can store a
	pointer to a global data item associated with an open connection.  When
	the connection closes, a @{" ACTION_NETWORK_TERM " link ACTION_NETWORK_TERM}packet with ARG1 containing
	the data value set for the connection.

   NOTE

   EXAMPLE

   INPUTS
	@{" drglobal " link drglobal} - Driver specific global data pointer obtained at SDNHanInit or
		SDNSerInit time.
	RP - @{" RPacket " link RPacket} returned from @{" SDNAccept " link SDNAccept} or @{" SDNReceive " link SDNReceive}.

   RESULTS
   	data - general pointer which was previously set for the connection through
		@{" SDNSetConData " link SDNSetConData} or NULL if nothing was ever set.

   SEE ALSO
   	@{" SDNSetConData " link SDNSetConData}


@toc LIBFUNC
@endnode
@node SDNHanInit
@title "SDNHanInit"

	
   NAME
	@{" SDNHanInit " link SDNHanInit} - Perform handler specific initialization

   SYNOPSIS
	rc = @{" SDNHanInit " link SDNHanInit}(@{" drglobal " link drglobal}, mask, data);
	D0		   A0	   A1	 A2
	
	int @{" SDNHanInit " link SDNHanInit}(APTR *, ULONG *, char *);

   FUNCTION
	Perform handler Specific Initialization.
	
	The mask value is the communications mechanism for indicating which bits
	are to be used by the handle.  On input it is a mask of bits available
	for use if the library is unable to allocate any bits.  On output it
	is a mask of the bits that the library will set whenever it needs to
	service a message.  Once the bit is set, the handler will call @{" SDNReceive " link SDNReceive}
	until @{" SDN_NONE " link DEFINES} is returned.
	
	The data string is a simple null terminated C style string that is
	for use by the library.  There is no format specified in the string and
	may contain whatever the library wants it to have.  The handler code just
	reads the string from a configuration file and passes it on to the library.
	This pointer may be NULL if no initialization string has been specified.
	In the absence of any configuration information, it is the responsibility
	of the library code to pick an appropriate default or to safely fail the
	initialization.
	
	The only difference between this routine and the SNDSerInit is that the
	handler portion does not need to set up to receive asynchronous new
	connections.  It will only be doing calls to @{" SDNReceive " link SDNReceive} and not any to
	@{" SDNAccept " link SDNAccept}.

   NOTE
	This routine is only called by the handler.

	This routine allocates and initializes the @{" drglobal " link drglobal} structure that is
	passed to all other service routines.

   EXAMPLE

   INPUTS
	mask - Mask of signal bits available for use by this driver.
	data - pointer to driver specific initialization string

   RESULTS
   	rc - @{" SDN_OK " link DEFINES} indicates successful initialization.  @{" SDN_ERR " link DEFINES} indicates
		that the handler could not be initialized for some reason.
	@{" drglobal " link drglobal} - Driver specific global data pointer to be passed to all other
		SDN service routines.
   	mask - mask of signal bits which will be set when the driver has some
		data or input to process.

   SEE ALSO
   	@{" SDNSerInit " link SDNSerInit}, @{" SDNHanTerm " link SDNHanTerm}


@toc LIBFUNC
@endnode
@node SDNHanTerm
@title "SDNHanTerm"

	
   NAME
	@{" SDNHanTerm " link SDNHanTerm} - Terminate all resources associated with a handler

   SYNOPSIS
	
	@{" SDNHanTerm " link SDNHanTerm}(@{" drglobal " link drglobal});
		      A0

	void @{" SDNHanTerm " link SDNHanTerm}(APTR);

   FUNCTION
	Terminate all resources associated with a handler.
	
	This routine should terminate all pending operations and free up all
	allocated objects in preparations for shutting down.  It must also free
	the global structure allocated at @{" SDNHanInit " link SDNHanInit} time.

   NOTE
	This routine is only called by the handler.

   	Because of fall through in initialization and termination, it is possible
	for @{" drglobal " link drglobal} to be NULL.

	Because of potential overlap in allocated signal bits, the library must not
	free any signal bits that it returned in the mask field at @{" SDNHanInit " link SDNHanInit} time.

   EXAMPLE

   INPUTS
	@{" drglobal " link drglobal} - Driver specific global data pointer obtained at @{" SDNHanInit " link SDNHanInit} or
		@{" SDNSerInit " link SDNSerInit} time.

   RESULTS
   	Nothing

   SEE ALSO
	@{" SDNHanInit " link SDNHanInit}


@toc LIBFUNC
@endnode
@node SDNInitNode
@title "SDNInitNode"

	
   NAME
	@{" SDNInitNode " link SDNInitNode} - Establish a new node connection
	
   SYNOPSIS
	rc = @{" SDNInitNode " link SDNInitNode}(@{" drglobal " link drglobal}, name, con);
	D0		    A0	     A1	  A2
	
	int @{" SDNInitNode " link SDNInitNode}(APTR, char *, APTR *);

   FUNCTION
	Establish a new node connection.

	When the handler wishes to talk to a node for which it has not established
	a connection, it will call this entry point with the name of the
	node that it is attempting to access.  If a particular driver does not
	support multiple connections then it should just return a failure after the
	first connection is set up.

   NOTE
	This routine is only called by the handler.
	
	name must be treated as non-case-sensitive.

   EXAMPLE

   INPUTS
	@{" drglobal " link drglobal} - Driver specific global data pointer obtained at @{" SDNHanInit " link SDNHanInit} or
		@{" SDNSerInit " link SDNSerInit} time.
	name - A C style string indicating the name of the node to connect to.

   RESULTS
   	con - A generic connection pointer to be passed to @{" SDNAllocRPacket " link SDNAllocRPacket}.

   SEE ALSO
   	@{" SDNAllocRPacket " link SDNAllocRPacket}, @{" SDNTermNode " link SDNTermNode}

@toc LIBFUNC
@endnode
@node SDNReceive
@title "SDNReceive"

	
   NAME
	@{" SDNReceive " link SDNReceive} - Get the next response packet
	
   SYNOPSIS
	rc = @{" SDNReceive " link SDNReceive}(@{" drglobal " link drglobal}, mask, RP);
	D0		   A0	   D0	A1
	
	int @{" SDNReceive " link SDNReceive}(APTR, ULONG, struct @{" RPacket " link RPacket} **);
	
   FUNCTION
   	Read the next incomming packet.

   NOTE
	This routine is only called by the handler.
	Driver must be prepared to handle this being called when nothing is
	pending since multiple drivers may be sharing a signal bit.  If a
	packet did come in, but is munged, @{" SDN_ERR " link DEFINES} is returned;  if no packet
	was available, @{" SDN_NONE " link DEFINES} is returned.  If a pending write request has
	been completed, a special packet type is returned and a copy of the
	original @{" RPacket " link RPacket} structure's 'statedata' pointer is returned.
	
	The memory pointed to by RP is owned by the NET: code
	until Free@{" RPacket " link RPacket} is called.  Free@{" RPacket " link RPacket} should be called ASAP after
	calling @{" SDNReceive " link SDNReceive} to allow the driver to reuse the @{" RPacket " link RPacket} for the
	next read request.

         For those drivers which support multiple connections and want some
         connections to appear on the workbench automatically, it should generate
         a phoney @{" ACTION_NETWORK_START " link ACTION_NETWORK_START} RPacket for each node that it to be
         auto-mounted.  If the user did not specify the AUTO * option in the
         @{" handler-config " link HANDCONFIG} configuration file then these packets will simply be
         noted as nodes attached to the driver and not made immediately visible.


   EXAMPLE

   INPUTS
	@{" drglobal " link drglobal} - Driver specific global data pointer obtained at @{" SDNHanInit " link SDNHanInit} or
		@{" SDNSerInit " link SDNSerInit} time.
	mask - Mask of signal bits that have gone off
	RP - Address of pointer to store incomming @{" RPacket " link RPacket}.

   RESULTS
   	rc - 	@{" SDN_OK " link DEFINES},
		@{" SDN_ERR " link DEFINES} == read error,
		@{" SDN_NONE " link DEFINES} == nothing to read
	RP - Pointer to next packet or NULL in case of error

   SEE ALSO
	@{" SDNAccept " link SDNAccept}, @{" SDNFreeRPacket " link SDNFreeRPacket}


@toc LIBFUNC
@endnode
@node SDNReply
@title "SDNReply"

	
   NAME
	@{" SDNReply " link SDNReply} - Reply to a previously obtained message
	
   SYNOPSIS
	rc = @{" SDNReply " link SDNReply}(@{" drglobal " link drglobal}, RP);
	D0		A0	A1
	
	int @{" SDNReply " link SDNReply}(APTR, struct @{" RPacket " link RPacket} *);

   FUNCTION
	Reply to a previously obtained message

   NOTE
	If @{" SDN_PEND " link DEFINES} is returned, the handler must not return the application's
	packet until a the driver signals that the write has completed.
	When the write completes, a signal bit will be set and Pluck@{" RPacket " link RPacket}
	will be called.  @{" SDNReply " link SDNReply} will return a special packet type indicating
	indicating the write has completed.
	Calling this routine automatically does a @{" SDNFreeRPacket " link SDNFreeRPacket} on the packet.
	
   EXAMPLE

   INPUTS
	@{" drglobal " link drglobal} - Driver specific global data pointer obtained at @{" SDNHanInit " link SDNHanInit} or
		@{" SDNSerInit " link SDNSerInit} time.
	RP - @{" RPacket " link RPacket} to be responded to.

   RESULTS
   	rc - @{" SDN_OK " link DEFINES} == Write has successfully completed
	     @{" SDN_PEND " link DEFINES} == Write is pending completion

   SEE ALSO
   	@{" SDNAccept " link SDNAccept}, @{" SDNReceive " link SDNReceive}

@toc LIBFUNC
@endnode
@node SDNSend
@title "SDNSend"

	
   NAME
	@{" SDNSend " link SDNSend}
	
	PURPOSE: Send a packet to a specific remote node
	
   SYNOPSIS
	rc = @{" SDNSend " link SDNSend}(@{" drglobal " link drglobal}, rp);
	D0		A0     A1
	
	int @{" SDNSend " link SDNSend}(APTR, struct @{" RPacket " link RPacket} *);
	
   FUNCTION
	Send a packet to a specific remote node
	
	The @{" RPacket " link RPacket} will have been initialized for a specific node by the
	@{" SDNAllocRPacket " link SDNAllocRPacket} code.

   NOTE
	This routine is only called by the handler.

	If @{" SDN_PEND " link DEFINES} is returned, the handler must not return the application's
	packet until a the driver signals that the write has completed.
	When the write completes, a signal bit will be set and @{" SDNReceive " link SDNReceive}
	will be called.  @{" SDNReceive " link SDNReceive} will return a special packet type
	indicating the write has completed.
	
	The packet is allocated by the server code and freed by the driver code
	when the I/O is complete.  Internally this routine is very similar to
	@{" SDNReply " link SDNReply}.
	Calling this routine automatically does a @{" SDNFreeRPacket " link SDNFreeRPacket} on the packet.

   EXAMPLE

   INPUTS
	@{" drglobal " link drglobal} - Driver specific global data pointer obtained at @{" SDNHanInit " link SDNHanInit} or
		@{" SDNSerInit " link SDNSerInit} time.
	RP - @{" RPacket " link RPacket} to be responded to.

   RESULTS
   	rc - @{" SDN_OK " link DEFINES} == Write has successfully completed
	     @{" SDN_PEND " link DEFINES} == Write is pending completion

   SEE ALSO
   	@{" SDNAllocRPacket " link SDNAllocRPacket}

@toc LIBFUNC
@endnode
@node SDNSerInit
@title "SDNSerInit"

	
   NAME
	@{" SDNSerInit " link SDNSerInit} - Perform server specific initialization

   SYNOPSIS
	rc = @{" SDNSerInit " link SDNSerInit}(@{" drglobal " link drglobal}, mask, data);
	D0		   A0	   A1	 A2
	
	int @{" SDNSerInit " link SDNSerInit}(APTR *, ULONG *, char *);

   FUNCTION
	Perform server Specific Initialization.
	
	The mask value is the communications mechanism for indicating which bits
	are to be used by the handle.  On input it is a mask of bits available
	for use if the library is unable to allocate any bits.  On output it
	is a mask of the bits that the library will set whenever it needs to
	service a message.  Once the bit is set, the server will call @{" SDNAccept " link SDNAccept}
	until @{" SDN_NONE " link DEFINES} is returned.

	The data string is a simple null terminated C style string that is
	for use by the library.  There is no format specified in the string and
	may contain whatever the library wants it to have.  The server code
	just reads the string from a configuration file and passes it on to
	the library.  This pointer may be NULL if no initialization string has
	been specified.  In the absence of any configuration information, it is
	the responsibility of the library code to pick an appropriate default
	or to safely fail the initialization.

	The only difference between this routine and the SNDHanInit is that the
	server portion needs to set up to receive asynchronous new connections.
	It will only be doing calls to @{" SDNAccept " link SDNAccept} and not any to @{" SDNReceive " link SDNReceive}.

   NOTE
	This routine is only called by the server.

	This routine allocates and initializes the @{" drglobal " link drglobal} structure that is
	passed to all other service routines.

   EXAMPLE

   INPUTS
	mask - Mask of signal bits available for use by this driver.
	data - pointer to driver specific initialization string

   RESULTS
   	rc - @{" SDN_OK " link DEFINES} indicates successful initialization.  @{" SDN_ERR " link DEFINES} indicates
		that the server could not be initialized for some reason.
	@{" drglobal " link drglobal} - Driver specific global data pointer to be passed to all other
		SDN service routines.
   	mask - mask of signal bits which will be set when the driver has some
		data or input to process.

   SEE ALSO
   	@{" SDNHanInit " link SDNHanInit}, @{" SDNSerTerm " link SDNSerTerm}


@toc LIBFUNC
@endnode
@node SDNSerTerm
@title "SDNSerTerm"


   NAME
	@{" SDNSerTerm " link SDNSerTerm} - Terminate all resources associated with a server

   SYNOPSIS
	
	@{" SDNSerTerm " link SDNSerTerm}(@{" drglobal " link drglobal});
		      A0

	void @{" SDNSerTerm " link SDNSerTerm}(APTR);

   FUNCTION
	Terminate all resources associated with a server.
	
	This routine should terminate all pending operations and free up all
	allocated objects in preparations for shutting down.  It must also free
	the global structure allocated at @{" SDNSerInit " link SDNSerInit} time.

   NOTE
	This routine is only called by the server.

   	Because of fall through in initialization and termination, it is possible
	for @{" drglobal " link drglobal} to be NULL.

	Because of potential overlap in allocated signal bits, the library must not
	free any signal bits that it returned in the mask field at @{" SDNSerInit " link SDNSerInit} time.

   EXAMPLE

   INPUTS
	@{" drglobal " link drglobal} - Driver specific global data pointer obtained at @{" SDNSerInit " link SDNSerInit} or
		@{" SDNSerInit " link SDNSerInit} time.

   RESULTS
   	Nothing

   SEE ALSO
	@{" SDNSerInit " link SDNSerInit}


@toc LIBFUNC
@endnode
@node SDNSetConData
@title "SDNSetConData"


	
   NAME
	@{" SDNSetConData " link SDNSetConData} -	Set data associated with a connection for a @{" RPacket " link RPacket}
	
   SYNOPSIS
	@{" SDNSetConData " link SDNSetConData}(@{" drglobal " link drglobal}, RP, data);
			A0	A1   A2
			
	void @{" SDNSetConData " link SDNSetConData}(APTR, struct @{" RPacket " link RPacket} *, void *);
	
   FUNCTION
	Set data associated with a connection for a @{" RPacket " link RPacket}

	This function sets the connection specific pointer or any given @{" RPacket " link RPacket}.
	With this the server or handler can store a pointer to a global data
	item associated with an open connection.  When the connection closes,
	an @{" ACTION_NETWORK_TERM " link ACTION_NETWORK_TERM}packet with ARG1 containing the data value set
	for the connection.
	
	Typically this pointer will point to a handler or server specific data
	structure that indicates access or state information.
	
   NOTE
   	This is the only way for the server to track which connection a
	particular packet is associated.

   EXAMPLE

   INPUTS
	@{" drglobal " link drglobal} - Driver specific global data pointer obtained at @{" SDNHanInit " link SDNHanInit} or
		@{" SDNSerInit " link SDNSerInit} time.
	RP - @{" RPacket " link RPacket} returned from @{" SDNAccept " link SDNAccept} or @{" SDNReceive " link SDNReceive}.
   	data - general pointer for the connection to be returned whenever
		@{" SDNGetConData " link SDNGetConData} is called on any @{" RPacket " link RPacket} for the same connection.

   RESULTS
   	Nothing

   SEE ALSO
   	@{" SDNGetConData " link SDNGetConData}

@toc LIBFUNC
@endnode
@node SDNTermNode
@title "SDNTermNode"

	
   NAME
	@{" SDNTermNode " link SDNTermNode} - Free Up all Driver resources associated with a Node
	
   SYNOPSIS
	@{" SDNTermNode " link SDNTermNode}(@{" drglobal " link drglobal}, con);
			A0     A1
	
	void SDNTerm(APTR, APTR);
	
   FUNCTION
	Free Up all Driver resources associated with a Node
	
	This routine is called by the handler when it wishes to shut down a
	connection.

   NOTE
	This routine is only called by the handler.
	
	con may be NULL due to initialization fall-through

   EXAMPLE

   INPUTS
	@{" drglobal " link drglobal} - Driver specific global data pointer obtained at @{" SDNHanInit " link SDNHanInit} or
		@{" SDNSerInit " link SDNSerInit} time.
	con - Connection pointer to terminate.  Previously obtained fron @{" SDNInitNode " link SDNInitNode}

   RESULTS
   	Nothing

   SEE ALSO
	@{" SDNInitNode " link SDNInitNode}
@toc LIBFUNC
@endnode
@node PACKETS
@title "Communication Packets"

Object Manipulation      Directory Manipulation   Handler Control
===================      ======================   ===============
@{" FIND_WRITE " link ACTION_FIND_WRITE}             @{" LOCATE_OBJECT " link ACTION_LOCATE_OBJECT}          @{" DIE " link ACTION_DIE}    @{" INHIBIT " link ACTION_INHIBIT} 
@{" FIND_INPUT " link ACTION_FIND_INPUT}             @{" COPY_DIR " link ACTION_COPY_DIR}               @{" MORE_CACHE " link ACTION_MORE_CACHE} 
@{" FIND_OUTPUT " link ACTION_FIND_OUTPUT}            @{" FREE_LOCK " link ACTION_FREE_LOCK}              @{" IS_FILESYSTEM " link ACTION_IS_FILESYSTEM} 
@{" FINDREADONLY " link ACTION_FINDREADONLY}           @{" DELETE_OBJECT " link ACTION_DELETE_OBJECT}          @{" SET_TRANS_TYPE " link ACTION_SET_TRANS_TYPE} 
@{" FINDONEWRITER " link ACTION_FINDONEWRITER}          @{" RENAME_OBJECT " link ACTION_RENAME_OBJECT}          @{" HANDLER_DEBUG " link ACTION_HANDLER_DEBUG} 
@{" READ " link ACTION_READ}   @{" READ_MORE " link ACTION_READ_MORE}     @{" SET_PROTECT " link ACTION_SET_PROTECT}            @{" NETWORK_HELLO " link ACTION_NETWORK_HELLO} 
@{" WRITE " link ACTION_WRITE}  @{" WRITE_MORE " link ACTION_WRITE_MORE}    @{" CREATE_DIR " link ACTION_CREATE_DIR}             @{" NETWORK_START " link ACTION_NETWORK_START} 
@{" END " link ACTION_END}    @{" SEEK " link ACTION_SEEK}          @{" EXAMINE_OBJECT " link ACTION_EXAMINE_OBJECT}         @{" NETWORK_INIT " link ACTION_NETWORK_INIT} 
@{" SET_FILE_SIZE " link ACTION_SET_FILE_SIZE}          @{" EXAMINE_NEXT " link ACTION_EXAMINE_NEXT}           @{" NETWORK_TERM " link ACTION_NETWORK_TERM} 
@{" FH_FROM_LOCK " link ACTION_FH_FROM_LOCK}           @{" SET_COMMENT " link ACTION_SET_COMMENT}             
@{" LOCK_RECORD " link ACTION_LOCK_RECORD}            @{" PARENT " link ACTION_PARENT}   @{" PARENT_FH " link ACTION_PARENT_FH}   Console Only
@{" FREE_RECORD " link ACTION_FREE_RECORD}            @{" SET_FILE_DATE " link ACTION_SET_FILE_DATE}          ============
                         @{" SAME_LOCK " link ACTION_SAME_LOCK}              @{" WAIT_CHAR " link ACTION_WAIT_CHAR} 
Volume Manipulation      @{" MAKE_LINK " link ACTION_MAKE_LINK} @{" READ_LINK " link ACTION_READ_LINK}  @{" SCREEN_MODE " link ACTION_SCREEN_MODE} 
===================      @{" COPY_DIR_FH " link ACTION_COPY_DIR_FH}            @{" DOUBLE " link ACTION_DOUBLE} 
@{" CURRENT_VOLUME " link ACTION_CURRENT_VOLUME}         @{" CHANGE_MODE " link ACTION_CHANGE_MODE}            @{" FORCE " link ACTION_FORCE}  @{" STACK " link ACTION_STACK} 
@{" RENAME_DISK " link ACTION_RENAME_DISK}            @{" EXAMINE_ALL " link ACTION_EXAMINE_ALL}            @{" QUEUE " link ACTION_QUEUE}  @{" DROP " link ACTION_DROP} 
@{" INFO " link ACTION_INFO}   @{" DISK_INFO " link ACTION_DISK_INFO}     @{" EXAMINE_FH " link ACTION_EXAMINE_FH}             @{" PEEK " link ACTION_PEEK}   @{" REPLACE " link ACTION_REPLACE} 
@{" FLUSH " link ACTION_FLUSH}  @{" FORMAT " link ACTION_FORMAT}        @{" ADD_NOTIFY " link ACTION_ADD_NOTIFY}             @{" GET_HISTORY " link ACTION_GET_HISTORY}    @{" SET_HISTORY " link ACTION_SET_HISTORY} 
@{" WRITE_PROTECT " link ACTION_WRITE_PROTECT}          @{" REMOVE_NOTIFY " link ACTION_REMOVE_NOTIFY}          @{" JUMP_SCREEN " link ACTION_JUMP_SCREEN} 
@endnode
@node ACTION_DIE
@title "ACTION_DIE"

ACTION_DIE - 5 - 0x0005
      ARG1: ----- Unused
      ARG2: ----- Unused
      ARG3: ----- Unused
      ARG4: ----- Unused
      DLEN: ----- Unused
      DBUF: ----- Unused

      ARG1: ----- Unused
      ARG2: ----- Unused
      DLEN: ----- Unused
      DBUF: ----- Unused
@toc PACKETS
@endnode
@node ACTION_CURRENT_VOLUME
@title "ACTION_CURRENT_VOLUME"

ACTION_CURRENT_VOLUME - 7 - 0x0007
  NOTE: At best this packet is to be implemented at the handler level and not
        passed on to the server because it contains pointers to data that exists
        only on the server side.
      ARG1: ----- Unused
      ARG2: ----- Unused
      ARG3: ----- Unused
      ARG4: ----- Unused
      DLEN: ----- Unused
      DBUF: ----- Unused

      ARG1: ----- Unused
      ARG2: ----- Unused
      DLEN: ----- Unused
      DBUF: ----- Unused


@toc PACKETS
@endnode
@node ACTION_LOCATE_OBJECT
@title "ACTION_LOCATE_OBJECT"

ACTION_LOCATE_OBJECT - 8 - 0x0008
      ARG1: BPTR  Lock that name is relative or NULL for root
      ARG2: ----- Unused
      ARG3: ULONG Type of lock (SHARED/EXCLUSIVE) that is to be obtained
      ARG4: ----- Unused
      DLEN: ULONG Length of name in DBUF
      DBUF: BSTR  Name of object to be locked

      ARG1: BOOL  Success/failure indicator
      ARG2: ULONG Secondary return code in case of failure
      DLEN: ULONG Length of name or 0 for failure
      DBUF:@{" NSTR " link NSTR} Name of lock for re-establishing in case of broken connection
@toc PACKETS
@endnode
@node ACTION_RENAME_DISK
@title "ACTION_RENAME_DISK"

ACTION_RENAME_DISK - 9 - 0x0009
  NOTE: The parameterization of this needs to be thought out because there is no
        information as to which disk to rename.
      ARG1: ????? Indicator of which disk to affect
      ARG2: ----- Unused
      ARG3: ----- Unused
      ARG4: ----- Unused
      DLEN: ULONG Length of new name
      DBUF: BSTR  New name to set for disk

      ARG1: ----- Unused
      ARG2: ----- Unused
      DLEN: ----- Unused
      DBUF: ----- Unused
@toc PACKETS
@endnode
@node ACTION_FREE_LOCK
@title "ACTION_FREE_LOCK"

ACTION_FREE_LOCK - 15 - 0x000F
      ARG1: BPTR  Lock to be freed
      ARG2: ----- Unused
      ARG3: ----- Unused
      ARG4: ----- Unused
      DLEN: ----- Unused
      DBUF: ----- Unused

      ARG1: BOOL  Sucess/Failure indicator
      ARG2: ULONG Secondary return code in case of failure
      DLEN: ----- Unused
      DBUF: ----- Unused
@toc PACKETS
@endnode
@node ACTION_DELETE_OBJECT
@title "ACTION_DELETE_OBJECT"

ACTION_DELETE_OBJECT - 16 - 0x0010
      ARG1: BPTR  Lock that name is relative to or NULL for root
      ARG2: ----- Unused
      ARG3: ----- Unused
      ARG4: ----- Unused
      DLEN: ULONG Length of name in buffer
      DBUF: BSTR  Name of file to be deleted

      ARG1: BOOL  Success/Failure indicator
      ARG2: ULONG Secondary return code in case of failure
      DLEN: ----- Unused
      DBUF: ----- Unused
@toc PACKETS
@endnode
@node ACTION_RENAME_OBJECT
@title "ACTION_RENAME_OBJECT"

ACTION_RENAME_OBJECT - 17 - 0x0011
      ARG1: BPTR  Lock that source name is relative to or NULL for ROOT
      ARG2: ----- Unused
      ARG3: BPTR  Lock that target name is relative to or NULL for ROOT
      ARG4: ----- Unused
      DLEN: ULONG Length of two names in buffer
      DBUF: BSTR  Source name of object to be renamed
                    followed by
                  Target name of object at DBUG+FILENAMELEN

      ARG1: BOOL  Sucess/Failure indicator
      ARG2: ULONG Secondary return code in case of failure
      DLEN: ----- Unused
      DBUF: ----- Unused
@toc PACKETS
@endnode
@node ACTION_MORE_CACHE
@title "ACTION_MORE_CACHE"

ACTION_MORE_CACHE - 18 - 0x0012
  NOTE: The parameterization of this needs to be thought out because there is no
        information as to which disk to set cache blocks for
      ARG1: ULONG Delta number of blocks to set
      ARG2: ????? Indicator of which disk to affect
      ARG3: ----- Unused
      ARG4: ----- Unused
      DLEN: ----- Unused
      DBUF: ----- Unused

      ARG1: BOOL  Success/Failure indicator
      ARG2: ULONG New number of blocks after applying delta value
      DLEN: ----- Unused
      DBUF: ----- Unused
@toc PACKETS
@endnode
@node ACTION_COPY_DIR
@title "ACTION_COPY_DIR"

ACTION_COPY_DIR - 19 - 0x0013
      ARG1: BPTR  Lock to be duplicated
      ARG2: ----- Unused
      ARG3: ----- Unused
      ARG4: ----- Unused
      DLEN: ----- Unused
      DBUF: ----- Unused

      ARG1: BPTR  Duplicated lock or NULL for failure
      ARG2: ULONG Secondary return code in case of failure
      DLEN: ULONG Length of name or 0 for failure
      DBUF:@{" NSTR " link NSTR} Name of lock for re-establishing in case of broken connection
@toc PACKETS
@endnode
@node ACTION_WAIT_CHAR
@title "ACTION_WAIT_CHAR"

ACTION_WAIT_CHAR - 20 - 0x0014
   NOTE: This packet requires some indication of the handler to be dealt with
      ARG1: ULONG Time out in microseconds
      ARG2: ????? Indicator of handler to do wait for char on
      ARG3: ----- Unused
      ARG4: ----- Unused
      DLEN: ----- Unused
      DBUF: ----- Unused

      ARG1: BOOL  Success/failure indicator
      ARG2: ULONG Secondary return code in case of failure
      DLEN: ----- Unused
      DBUF: ----- Unused
@toc PACKETS
@endnode
@node ACTION_SET_PROTECT
@title "ACTION_SET_PROTECT"

ACTION_SET_PROTECT - 21 - 0x0015
      ARG1: ----- Unused
      ARG2: BPTR  Lock that name is relative to or NULL for root
      ARG3: ----- Unused
      ARG4: ULONG Mask of protection to set
      DLEN: ULONG Length of name to set protection on
      DBUF: BSTR  Name of file to set protection on

      ARG1: BOOL  Success/Failure indicator
      ARG2: ULONG Secondary return code in case of failure
      DLEN: ----- Unused
      DBUF: ----- Unused
@toc PACKETS
@endnode
@node ACTION_CREATE_DIR
@title "ACTION_CREATE_DIR"

ACTION_CREATE_DIR - 22 - 0x0016
      ARG1: BPTR  Lock that name is relative to or NULL for root
      ARG2: ----- Unused
      ARG3: ----- Unused
      ARG4: ----- Unused
      DLEN: ULONG Length of name
      DBUF: BSTR  Name of directory to create

      ARG1: BOOL  Success/failure indicator
      ARG2: ULONG Secondary return code in case of failure
      DLEN: ULONG Length of name or 0 for failure
      DBUF:@{" NSTR " link NSTR} Name of lock for re-establishing in case of broken connection
@toc PACKETS
@endnode
@node ACTION_EXAMINE_OBJECT
@title "ACTION_EXAMINE_OBJECT"

ACTION_EXAMINE_OBJECT - 23 - 0x0017
      ARG1: BPTR  Lock on object to be examined
      ARG2: ----- Unused
      ARG3: ----- Unused
      ARG4: ----- Unused
      DLEN: ----- Unused
      DBUF: ----- Unused

      ARG1: BOOL  Success/Failure indicator
      ARG2: ULONG Secondary return code in case of failure
      DLEN: ULONG Length of FIB stored in DBUF or 0 for failure
      DBUF: APTR  Contents of FIB after examine has been done
@toc PACKETS
@endnode
@node ACTION_EXAMINE_NEXT
@title "ACTION_EXAMINE_NEXT"

ACTION_EXAMINE_NEXT - 24 - 0x0018
      ARG1: BPTR  Lock on object to be examined
      ARG2: ----- Unused
      ARG3: ----- Unused
      ARG4: ----- Unused
      DLEN: ULONG Length of FIB stored in DBUF
      DBUF: APTR  Contents of FIB from previous examine/exnext

      ARG1: BOOL  Success/Failure indicator
      ARG2: ULONG Secondary return code in case of failure
      DLEN: ULONG Length of FIB stored in DBUF or 0 for failure
      DBUF: APTR  Contents of FIB after examine has been done
@toc PACKETS
@endnode
@node ACTION_DISK_INFO
@title "ACTION_DISK_INFO"

ACTION_DISK_INFO - 25 - 0x0019
 NOTE: This packet has a problem with the fact that the InfoData structure has
       a pointer to memory that only exists on the server machine.  There is also
       a problem of indicating which handler to get information on
      ARG1: ----- Unused
      ARG2: ----- Unused
      ARG3: ----- Unused
      ARG4: ----- Unused
      DLEN: ----- Unused
      DBUF: ----- Unused

      ARG1: BOOL  Success/Failure indicator
      ARG2: ULONG Secondary return code in case of failure
      DLEN: ULONG Length of INFO Data structure
      DBUF: APTR  INFO Data structure returned from handler
@toc PACKETS
@endnode
@node ACTION_INFO
@title "ACTION_INFO"

ACTION_INFO - 26 - 0x001A
 NOTE: This packet has a problem with the fact that the InfoData structure has
       a pointer to memory that only exists on the server machine.
      ARG1: BPTR  Lock to get info on
      ARG2: ----- Unused
      ARG3: ----- Unused
      ARG4: ----- Unused
      DLEN: ----- Unused
      DBUF: ----- Unused

      ARG1: BOOL  Success/Failure indicator
      ARG2: ULONG Secondary return code in case of failure
      DLEN: ULONG Length of INFO Data structure
      DBUF: APTR  INFO Data structure returned from handler
@toc PACKETS
@endnode
@node ACTION_FLUSH
@title "ACTION_FLUSH"

ACTION_FLUSH - 27 - 0x001B
  NOTE: The parameterization of this needs to be thought out because there is no
        information as to which disk to flush
      ARG1: ----- Unused
      ARG2: ----- Unused
      ARG3: ----- Unused
      ARG4: ----- Unused
      DLEN: ----- Unused
      DBUF: ----- Unused

      ARG1: BOOL  DOSTRUE
      ARG2: ----- Unused
      DLEN: ----- Unused
      DBUF: ----- Unused
@toc PACKETS
@endnode
@node ACTION_SET_COMMENT
@title "ACTION_SET_COMMENT"

ACTION_SET_COMMENT - 28 - 0x001C
      ARG1: ----- Unused
      ARG2: BPTR  Lock that source name is relative to or NULL for ROOT
      ARG3: ----- Unused
      ARG4: ----- Unused
      DLEN: ULONG Length of name and comment in buffer
      DBUF: BSTR  Source name of object to be renamed
                    followed by
                  Comment string (BSTR) at next longword boundary after end of name

      ARG1: BOOL  Sucess/Failure indicator
      ARG2: ULONG Secondary return code in case of failure
      DLEN: ----- Unused
      DBUF: ----- Unused
@toc PACKETS
@endnode
@node ACTION_PARENT
@title "ACTION_PARENT"

ACTION_PARENT - 29 - 0x001D
      ARG1: BPTR  Lock to get parent of
      ARG2: ----- Unused
      ARG3: ----- Unused
      ARG4: ----- Unused
      DLEN: ----- Unused
      DBUF: ----- Unused

      ARG1: BPTR  Lock on parent or NULL for failure
      ARG2: ULONG Secondary return code in case of failure
      DLEN: ULONG Length of name or 0 for failure
      DBUF:@{" NSTR " link NSTR} Name of lock for re-establishing in case of broken connection
@toc PACKETS
@endnode
@node ACTION_INHIBIT
@title "ACTION_INHIBIT"

ACTION_INHIBIT - 31 - 0x001F
  NOTE: The parameterization of this needs to be thought out because there is no
        information as to which disk to inhibit
      ARG1: BOOL  DOSTRUE = Inhibit, DOSFALSE = Enable
      ARG2: ????? Indicator of disk to inhibit
      ARG3: ----- Unused
      ARG4: ----- Unused
      DLEN: ----- Unused
      DBUF: ----- Unused

      ARG1: BOOL  Success/Failure indicator
      ARG2: ----- Unused
      DLEN: ----- Unused
      DBUF: ----- Unused
@toc PACKETS
@endnode
@node ACTION_SET_FILE_DATE
@title "ACTION_SET_FILE_DATE"

ACTION_SET_FILE_DATE - 34 - 0x0022
      ARG1: BPTR  Lock on object to set date on
      ARG2: ----- Unused
      ARG3: ----- Unused
      ARG4: ----- Unused
      DLEN: ULONG Length of DATESTAMP array (12)
      DBUF: DSTMP DATESTAMP array of 3 longwords

      ARG1: BOOL  Success/Failure indicator of operation
      ARG2: ULONG Secondary return code in case of failure
      DLEN: ----- Unused
      DBUF: ----- Unused
@toc PACKETS
@endnode
@node ACTION_SAME_LOCK
@title "ACTION_SAME_LOCK"

ACTION_SAME_LOCK - 40 - 0x0028
      ARG1: BPTR  Lock 1 to compare
      ARG2: BPTR  Lock 2 to compare
      ARG3: ----- Unused
      ARG4: ----- Unused
      DLEN: ----- Unused
      DBUF: ----- Unused

      ARG1: ULONG Result of Comparison - LOCK_SAME/LOCKSAME_HANDLER/LOCK_DIFFERENT
      ARG2: ULONG Secondary return code in case of failure
      DLEN: ----- Unused
      DBUF: ----- Unused
@toc PACKETS
@endnode
@node ACTION_READ
@title "ACTION_READ"

ACTION_READ - 52 - 0x0034
      ARG1: APTR  Filehandle - Pointer to struct FCHAIN * entry.
      ARG2: APTR  Buffer
      ARG3: ULONG Length
      ARG4: ----- Unused
      DLEN: ----- Unused
      DBUF: ----- Unused
 
      ARG1: ULONG Bytes read or -1 for failure
      ARG2: ULONG Secondary Error for failure
      DLEN:       Number of bytes read into DBUF
      DBUF:       Actual data read.
@toc PACKETS
@endnode
@node ACTION_READ_MORE
@title "ACTION_READ_MORE"

ACTION_READ_MORE - 53 - 0x0035
      ARG1: APTR  Filehandle - Pointer to struct FCHAIN * entry.
      ARG2: APTR  Buffer
      ARG3: ULONG Length
      ARG4: ULONG Seek position indicator.  -1 indicates that no seek position has
                  been established and the server must first determine the current
                  seek position before doing the operation.  If the operation fails,
                  it is the responsibility of the server to reseek back to the
                  original position stored in this field.
      DLEN: ----- Unused
      DBUF: ----- Unused
 
      ARG1: ULONG Bytes read or -1 for failure
      ARG2: ULONG Secondary Error for failure
      ARG3: ----- Unused
      ARG4: ULONG Seek position of initial read.  (Unchanged if it wasn't -1 to start)
      DLEN:       Number of bytes read into DBUF
      DBUF:       Actual data read.
@toc PACKETS
@endnode
@node ACTION_WRITE
@title "ACTION_WRITE"

ACTION_WRITE - 57 - 0x0039
      ARG1: APTR  Filehandle - Pointer to struct FCHAIN * entry.
      ARG2: APTR  Buffer
      ARG3: ULONG Length
      ARG4: ----- Unused
      DLEN: ULONG Length (same as ARG3)
      DBUF: BUF   Data to be written
 
      ARG1: ULONG Bytes read or -1 for failure
      ARG2: ULONG Secondary Error for failure
      DLEN: ----- Unused
      DBUF: ----- Unused
@toc PACKETS
@endnode
@node ACTION_WRITE_MORE
@title "ACTION_WRITE_MORE"

ACTION_WRITE_MORE - 58 - 0x003A
      ARG1: APTR  Filehandle - Pointer to struct FCHAIN * entry.
      ARG2: APTR  Buffer
      ARG3: ULONG Length
      ARG4: ULONG Seek position indicator.  -1 indicates that no seek position has
                  been established and the server must first determine the current
                  seek position before doing the operation.  If the operation fails,
                  it is the responsibility of the server to reseek back to the
                  original position stored in this field.
      DLEN: ULONG Length (same as ARG3)
      DBUF: BUF   Data to be written
 
      ARG1: ULONG Bytes read or -1 for failure
      ARG2: ULONG Secondary Error for failure
      ARG3: ----- Unused
      ARG4: ULONG Seek position of initial read.  (Unchanged if it wasn't -1 to start)
      DLEN: ----- Unused
      DBUF: ----- Unused
@toc PACKETS
@endnode
@node ACTION_SCREEN_MODE
@title "ACTION_SCREEN_MODE"

ACTION_SCREEN_MODE - 994 - 0x03E2
      ARG1: ----- Unused
      ARG2: ----- Unused
      ARG3: ----- Unused
      ARG4: ----- Unused
      DLEN: ----- Unused
      DBUF: ----- Unused

      ARG1: ----- Unused
      ARG2: ----- Unused
      DLEN: ----- Unused
      DBUF: ----- Unused
@toc PACKETS
@endnode
@node ACTION_FIND_WRITE
@title "ACTION_FIND_WRITE"

ACTION_FIND_WRITE - 1004 - 0x03EC
      ARG1: ----- Unused
      ARG2: BPTR  Lock that file is relative to (or NULL for the root)
      ARG3: ----- Unused
      ARG4: ----- Unused
      DLEN: ULONG Length of the name
      DBUF: BSTR  Name of the file to be opened relative to the lock

      ARG1: BOOL  Success/Failure of operation
      ARG2: ULONG Secondary Error for failure
      ARG3: APTR  Filehandler - Pointer to struct FCHAIN *entry
      ARG4: ULONG Contents of fh->fh_Port (Interactive flag) after open
      DLEN: ----- Unused
      DBUF: ----- Unused
@toc PACKETS
@endnode
@node ACTION_FIND_INPUT
@title "ACTION_FIND_INPUT"

ACTION_FIND_INPUT - 1005 - 0x03ED
      ARG1: ----- Unused
      ARG2: BPTR  Lock that file is relative to (or NULL for the root)
      ARG3: ----- Unused
      ARG4: ----- Unused
      DLEN: ULONG Length of the name
      DBUF: BSTR  Name of the file to be opened relative to the lock

      ARG1: BOOL  Success/Failure of operation
      ARG2: ULONG Secondary Error for failure
      ARG3: APTR  Filehandler - Pointer to struct FCHAIN *entry
      ARG4: ULONG Contents of fh->fh_Port (Interactive flag) after open
      DLEN: ----- Unused
      DBUF: ----- Unused
@toc PACKETS
@endnode
@node ACTION_FIND_OUTPUT
@title "ACTION_FIND_OUTPUT"

ACTION_FIND_OUTPUT - 1006 - 0x03EE
      ARG1: ----- Unused
      ARG2: BPTR  Lock that file is relative to (or NULL for the root)
      ARG3: ----- Unused
      ARG4: ----- Unused
      DLEN: ULONG Length of the name
      DBUF: BSTR  Name of the file to be opened relative to the lock

      ARG1: BOOL  Success/Failure of operation
      ARG2: ULONG Secondary Error for failure
      ARG3: APTR  Filehandler - Pointer to struct FCHAIN *entry
      ARG4: ULONG Contents of fh->fh_Port (Interactive flag) after open
      DLEN: ----- Unused
      DBUF: ----- Unused
@toc PACKETS
@endnode
@node ACTION_END
@title "ACTION_END"

ACTION_END - 1007 - 0x03EF
      ARG1: APTR  Filehandle - Pointer to struct FCHAIN * entry.
      ARG2: ----- Unused
      ARG3: ----- Unused
      ARG4: ----- Unused
      DLEN: ----- Unused
      DBUF: ----- Unused

      ARG1: BOOL  Success/failure indication of operation
      ARG2: ULONG Secondary Error for failure
      DLEN: ----- Unused
      DBUF: ----- Unused
@toc PACKETS
@endnode
@node ACTION_SEEK
@title "ACTION_SEEK"

ACTION_SEEK - 1008 - 0x03F0
      ARG1: APTR  Filehandle - Pointer to struct FCHAIN * entry.
      ARG2: ULONG Position
      ARG3: ULONG Mode (-1, 0, 1)
      ARG4: ----- Unused
      DLEN: ----- Unused
      DBUF: ----- Unused
 
      ARG1: ULONG New seek position or -1 for failure
      ARG2: ULONG Secondary Error for failure
      DLEN: ----- Unused
      DBUF: ----- Unused
@toc PACKETS
@endnode
@node ACTION_FINDREADONLY
@title "ACTION_FINDREADONLY"

ACTION_FINDREADONLY - 1009 - 0x03F1
      ARG1: ----- Unused
      ARG2: BPTR  Lock that file is relative to (or NULL for the root)
      ARG3: ----- Unused
      ARG4: ----- Unused
      DLEN: ULONG Length of the name
      DBUF: BSTR  Name of the file to be opened relative to the lock

      ARG1: BOOL  Success/Failure of operation
      ARG2: ULONG Secondary Error for failure
      ARG3: APTR  Filehandler - Pointer to struct FCHAIN *entry
      ARG4: ULONG Contents of fh->fh_Port (Interactive flag) after open
      DLEN: ----- Unused
      DBUF: ----- Unused
@toc PACKETS
@endnode
@node ACTION_FINDONEWRITER
@title "ACTION_FINDONEWRITER"

ACTION_FINDONEWRITER - 1010 - 0x03F2
      ARG1: ----- Unused
      ARG2: BPTR  Lock that file is relative to (or NULL for the root)
      ARG3: ----- Unused
      ARG4: ----- Unused
      DLEN: ULONG Length of the name
      DBUF: BSTR  Name of the file to be opened relative to the lock

      ARG1: BOOL  Success/Failure of operation
      ARG2: ULONG Secondary Error for failure
      ARG3: APTR  Filehandler - Pointer to struct FCHAIN *entry
      ARG4: ULONG Contents of fh->fh_Port (Interactive flag) after open
      DLEN: ----- Unused
      DBUF: ----- Unused
@toc PACKETS
@endnode
@node ACTION_FORMAT
@title "ACTION_FORMAT"

ACTION_FORMAT - 1020 - 0x03FC
      ARG1: ----- Unused
      ARG2: ----- Unused
      ARG3: ----- Unused
      ARG4: ----- Unused
      DLEN: ----- Unused
      DBUF: ----- Unused

      ARG1: ----- Unused
      ARG2: ----- Unused
      DLEN: ----- Unused
      DBUF: ----- Unused
@toc PACKETS
@endnode
@node ACTION_MAKE_LINK
@title "ACTION_MAKE_LINK"

ACTION_MAKE_LINK - 1021 - 0x03FD
      ARG1: ----- Unused
      ARG2: ----- Unused
      ARG3: ----- Unused
      ARG4: ----- Unused
      DLEN: ----- Unused
      DBUF: ----- Unused

      ARG1: ----- Unused
      ARG2: ----- Unused
      DLEN: ----- Unused
      DBUF: ----- Unused
@toc PACKETS
@endnode
@node ACTION_SET_FILE_SIZE
@title "ACTION_SET_FILE_SIZE"

ACTION_SET_FILE_SIZE - 1022 - 0x03FE
      ARG1: ----- Unused
      ARG2: ----- Unused
      ARG3: ----- Unused
      ARG4: ----- Unused
      DLEN: ----- Unused
      DBUF: ----- Unused

      ARG1: ----- Unused
      ARG2: ----- Unused
      DLEN: ----- Unused
      DBUF: ----- Unused
@toc PACKETS
@endnode
@node ACTION_WRITE_PROTECT
@title "ACTION_WRITE_PROTECT"

ACTION_WRITE_PROTECT - 1023 - 0x03FF
      ARG1: ----- Unused
      ARG2: ----- Unused
      ARG3: ----- Unused
      ARG4: ----- Unused
      DLEN: ----- Unused
      DBUF: ----- Unused

      ARG1: ----- Unused
      ARG2: ----- Unused
      DLEN: ----- Unused
      DBUF: ----- Unused
@toc PACKETS
@endnode
@node ACTION_READ_LINK
@title "ACTION_READ_LINK"

ACTION_READ_LINK - 1024 - 0x0400
      ARG1: ----- Unused
      ARG2: ----- Unused
      ARG3: ----- Unused
      ARG4: ----- Unused
      DLEN: ----- Unused
      DBUF: ----- Unused

      ARG1: ----- Unused
      ARG2: ----- Unused
      DLEN: ----- Unused
      DBUF: ----- Unused
@toc PACKETS
@endnode
@node ACTION_FH_FROM_LOCK
@title "ACTION_FH_FROM_LOCK"

ACTION_FH_FROM_LOCK - 1026 - 0x0402
      ARG1: ----- Unused
      ARG2: ----- Unused
      ARG3: ----- Unused
      ARG4: ----- Unused
      DLEN: ----- Unused
      DBUF: ----- Unused

      ARG1: ----- Unused
      ARG2: ----- Unused
      DLEN: ----- Unused
      DBUF: ----- Unused
@toc PACKETS
@endnode
@node ACTION_IS_FILESYSTEM
@title "ACTION_IS_FILESYSTEM"

ACTION_IS_FILESYSTEM - 1027 - 0x0403
      ARG1: ----- Unused
      ARG2: ----- Unused
      ARG3: ----- Unused
      ARG4: ----- Unused
      DLEN: ----- Unused
      DBUF: ----- Unused

      ARG1: ----- Unused
      ARG2: ----- Unused
      DLEN: ----- Unused
      DBUF: ----- Unused
@toc PACKETS
@endnode
@node ACTION_CHANGE_MODE
@title "ACTION_CHANGE_MODE"

ACTION_CHANGE_MODE - 1028 - 0x0404
      ARG1: ----- Unused
      ARG2: ----- Unused
      ARG3: ----- Unused
      ARG4: ----- Unused
      DLEN: ----- Unused
      DBUF: ----- Unused

      ARG1: ----- Unused
      ARG2: ----- Unused
      DLEN: ----- Unused
      DBUF: ----- Unused
@toc PACKETS
@endnode
@node ACTION_COPY_DIR_FH
@title "ACTION_COPY_DIR_FH"

ACTION_COPY_DIR_FH - 1030 - 0x0406
      ARG1: ----- Unused
      ARG2: ----- Unused
      ARG3: ----- Unused
      ARG4: ----- Unused
      DLEN: ----- Unused
      DBUF: ----- Unused

      ARG1: BOOL  Success/failure indicator
      ARG2: ULONG Secondary return code in case of failure
      DLEN: ULONG Length of name or 0 for failure
      DBUF:@{" NSTR " link NSTR} Name of lock for re-establishing in case of broken connection
@toc PACKETS
@endnode
@node ACTION_PARENT_FH
@title "ACTION_PARENT_FH"

ACTION_PARENT_FH - 1031 - 0x0407
      ARG1: ----- Unused
      ARG2: ----- Unused
      ARG3: ----- Unused
      ARG4: ----- Unused
      DLEN: ----- Unused
      DBUF: ----- Unused

      ARG1: BOOL  Success/failure indicator
      ARG2: ULONG Secondary return code in case of failure
      DLEN: ULONG Length of name or 0 for failure
      DBUF:@{" NSTR " link NSTR} Name of lock for re-establishing in case of broken connection
@toc PACKETS
@endnode
@node ACTION_EXAMINE_ALL
@title "ACTION_EXAMINE_ALL"

ACTION_EXAMINE_ALL - 1033 - 0x0409
      ARG1: ----- Unused
      ARG2: ----- Unused
      ARG3: ----- Unused
      ARG4: ----- Unused
      DLEN: ----- Unused
      DBUF: ----- Unused

      ARG1: ----- Unused
      ARG2: ----- Unused
      DLEN: ----- Unused
      DBUF: ----- Unused
@toc PACKETS
@endnode
@node ACTION_EXAMINE_FH
@title "ACTION_EXAMINE_FH"

ACTION_EXAMINE_FH - 1034 - 0x040A
      ARG1: ----- Unused
      ARG2: ----- Unused
      ARG3: ----- Unused
      ARG4: ----- Unused
      DLEN: ----- Unused
      DBUF: ----- Unused

      ARG1: ----- Unused
      ARG2: ----- Unused
      DLEN: ----- Unused
      DBUF: ----- Unused
@toc PACKETS
@endnode
@node ACTION_DOUBLE
@title "ACTION_DOUBLE"

ACTION_DOUBLE - 2000 - 0x07D0
      ARG1: ----- Unused
      ARG2: ----- Unused
      ARG3: ----- Unused
      ARG4: ----- Unused
      DLEN: ----- Unused
      DBUF: ----- Unused

      ARG1: ----- Unused
      ARG2: ----- Unused
      DLEN: ----- Unused
      DBUF: ----- Unused
@toc PACKETS
@endnode
@node ACTION_FORCE
@title "ACTION_FORCE"

ACTION_FORCE - 2001 - 0x07D1
      ARG1: ----- Unused
      ARG2: ----- Unused
      ARG3: ----- Unused
      ARG4: ----- Unused
      DLEN: ----- Unused
      DBUF: ----- Unused

      ARG1: ----- Unused
      ARG2: ----- Unused
      DLEN: ----- Unused
      DBUF: ----- Unused
@toc PACKETS
@endnode
@node ACTION_STACK
@title "ACTION_STACK"

ACTION_STACK - 2002 - 0x07D2
      ARG1: ----- Unused
      ARG2: ----- Unused
      ARG3: ----- Unused
      ARG4: ----- Unused
      DLEN: ----- Unused
      DBUF: ----- Unused

      ARG1: ----- Unused
      ARG2: ----- Unused
      DLEN: ----- Unused
      DBUF: ----- Unused
@toc PACKETS
@endnode
@node ACTION_QUEUE
@title "ACTION_QUEUE"

ACTION_QUEUE - 2003 - 0x07D3
      ARG1: ----- Unused
      ARG2: ----- Unused
      ARG3: ----- Unused
      ARG4: ----- Unused
      DLEN: ----- Unused
      DBUF: ----- Unused

      ARG1: ----- Unused
      ARG2: ----- Unused
      DLEN: ----- Unused
      DBUF: ----- Unused
@toc PACKETS
@endnode
@node ACTION_DROP
@title "ACTION_DROP"

ACTION_DROP - 2004 - 0x07D4
      ARG1: ----- Unused
      ARG2: ----- Unused
      ARG3: ----- Unused
      ARG4: ----- Unused
      DLEN: ----- Unused
      DBUF: ----- Unused

      ARG1: ----- Unused
      ARG2: ----- Unused
      DLEN: ----- Unused
      DBUF: ----- Unused
@toc PACKETS
@endnode
@node ACTION_PEEK
@title "ACTION_PEEK"

ACTION_PEEK - 2005 - 0x07D5
      ARG1: ----- Unused
      ARG2: ----- Unused
      ARG3: ----- Unused
      ARG4: ----- Unused
      DLEN: ----- Unused
      DBUF: ----- Unused

      ARG1: ----- Unused
      ARG2: ----- Unused
      DLEN: ----- Unused
      DBUF: ----- Unused
@toc PACKETS
@endnode
@node ACTION_REPLACE
@title "ACTION_REPLACE"

ACTION_REPLACE - 2006 - 0x07D6
      ARG1: ----- Unused
      ARG2: ----- Unused
      ARG3: ----- Unused
      ARG4: ----- Unused
      DLEN: ----- Unused
      DBUF: ----- Unused

      ARG1: ----- Unused
      ARG2: ----- Unused
      DLEN: ----- Unused
      DBUF: ----- Unused
@toc PACKETS
@endnode
@node ACTION_GET_HISTORY
@title "ACTION_GET_HISTORY"

ACTION_GET_HISTORY - 2007 - 0x07D7
      ARG1: ----- Unused
      ARG2: ----- Unused
      ARG3: ----- Unused
      ARG4: ----- Unused
      DLEN: ----- Unused
      DBUF: ----- Unused

      ARG1: ----- Unused
      ARG2: ----- Unused
      DLEN: ----- Unused
      DBUF: ----- Unused
@toc PACKETS
@endnode
@node ACTION_LOCK_RECORD
@title "ACTION_LOCK_RECORD"

ACTION_LOCK_RECORD - 2008 - 0x07D8
      ARG1: ----- Unused
      ARG2: ----- Unused
      ARG3: ----- Unused
      ARG4: ----- Unused
      DLEN: ----- Unused
      DBUF: ----- Unused

      ARG1: ----- Unused
      ARG2: ----- Unused
      DLEN: ----- Unused
      DBUF: ----- Unused
@toc PACKETS
@endnode
@node ACTION_FREE_RECORD
@title "ACTION_FREE_RECORD"

ACTION_FREE_RECORD - 2009 - 0x07D9
      ARG1: ----- Unused
      ARG2: ----- Unused
      ARG3: ----- Unused
      ARG4: ----- Unused
      DLEN: ----- Unused
      DBUF: ----- Unused

      ARG1: ----- Unused
      ARG2: ----- Unused
      DLEN: ----- Unused
      DBUF: ----- Unused
@toc PACKETS
@endnode
@node ACTION_HANDLER_DEBUG
@title "ACTION_HANDLER_DEBUG"

ACTION_HANDLER_DEBUG - 2010 - 0x07DA
      ARG1: ULONG Debugging mask.  0 = disable debugging
      ARG2: ----- Unused
      ARG3: ----- Unused
      ARG4: ----- Unused
      DLEN: ----- Unused
      DBUF: ----- Unused

      ARG1: ----- Unused
      ARG2: ----- Unused
      DLEN: ----- Unused
      DBUF: ----- Unused
@toc PACKETS
@endnode
@node ACTION_SET_TRANS_TYPE
@title "ACTION_SET_TRANS_TYPE"

ACTION_SET_TRANS_TYPE - 2011 - 0x07DB
      ARG1: ----- Unused
      ARG2: ----- Unused
      ARG3: ----- Unused
      ARG4: ----- Unused
      DLEN: ----- Unused
      DBUF: ----- Unused

      ARG1: ----- Unused
      ARG2: ----- Unused
      DLEN: ----- Unused
      DBUF: ----- Unused
@toc PACKETS
@endnode
@node ACTION_NETWORK_HELLO
@title "ACTION_NETWORK_HELLO"

ACTION_NETWORK_HELLO - 2012 - 0x07DC
      ARG1: ----- Unused
      ARG2: ----- Unused
      ARG3: ----- Unused
      ARG4: ----- Unused
      DLEN: ULONG Length of login name in DBUF
      DBUF: BSTR  Name of user to be logged in

      ARG1: ----- Unused
      ARG2: ----- Unused
      DLEN: ULONG Length of Password challenge
      DBUF: PASS  Password challenge key
@toc PACKETS
@endnode
@node ACTION_JUMP_SCREEN
@title "ACTION_JUMP_SCREEN"

ACTION_JUMP_SCREEN - 2020 - 0x07E4
      ARG1: ----- Unused
      ARG2: ----- Unused
      ARG3: ----- Unused
      ARG4: ----- Unused
      DLEN: ----- Unused
      DBUF: ----- Unused

      ARG1: ----- Unused
      ARG2: ----- Unused
      DLEN: ----- Unused
      DBUF: ----- Unused
@toc PACKETS
@endnode
@node ACTION_SET_HISTORY
@title "ACTION_SET_HISTORY"

ACTION_SET_HISTORY - 2021 - 0x07E5
      ARG1: ----- Unused
      ARG2: ----- Unused
      ARG3: ----- Unused
      ARG4: ----- Unused
      DLEN: ----- Unused
      DBUF: ----- Unused

      ARG1: ----- Unused
      ARG2: ----- Unused
      DLEN: ----- Unused
      DBUF: ----- Unused
@toc PACKETS
@endnode
@node ACTION_ADD_NOTIFY
@title "ACTION_ADD_NOTIFY"

ACTION_ADD_NOTIFY - 4097 - 0x1001
      ARG1: ----- Unused
      ARG2: ----- Unused
      ARG3: ----- Unused
      ARG4: ----- Unused
      DLEN: ----- Unused
      DBUF: ----- Unused

      ARG1: ----- Unused
      ARG2: ----- Unused
      DLEN: ----- Unused
      DBUF: ----- Unused
@toc PACKETS
@endnode
@node ACTION_REMOVE_NOTIFY
@title "ACTION_REMOVE_NOTIFY"

ACTION_REMOVE_NOTIFY - 4098 - 0x1002
      ARG1: ----- Unused
      ARG2: ----- Unused
      ARG3: ----- Unused
      ARG4: ----- Unused
      DLEN: ----- Unused
      DBUF: ----- Unused

      ARG1: ----- Unused
      ARG2: ----- Unused
      DLEN: ----- Unused
      DBUF: ----- Unused
@toc PACKETS
@endnode
@node ACTION_NETWORK_START
@title "ACTION_NETWORK_START"

ACTION_NETWORK_START - 5554 - 0xffff
   NOTE: This packet is a fake packet generated to indicate the initialization
         of a session.  It should not be replied to.
      ARG1: ----- Unused
      ARG2: ----- Unused
      ARG3: ----- Unused
      ARG4: ----- Unused
      DLEN: ----- Unused
      DBUF: ----- Unused

      ARG1: ----- Unused
      ARG2: ----- Unused
      DLEN: ----- Unused
      DBUF: ----- Unused
@toc PACKETS
@endnode
@node ACTION_NETWORK_INIT,  
@title "ACTION_NETWORK_INIT"

ACTION_NETWORK_INIT - 5555 - 0xffff
This packet allows the handler to tell the server what name it is using to refer
to the server with.  The server uses this information when any examine on the
root is done.
      ARG1: ----- Unused
      ARG2: ----- Unused
      ARG3: ----- Unused
      ARG4: ----- Unused
      DLEN: ----- Length of name
      DBUF: ----- Name of node as used by the handler

      ARG1: ----- Unused
      ARG2: ----- Unused
      DLEN: ----- Unused
      DBUF: ----- Unused
@toc PACKETS
@endnode
@node ACTION_NETWORK_TERM
@title "ACTION_NETWORK_TERM"

ACTION_NETWORK_TERM - 5556 - 0xffff
   NOTE: This packet is a fake packet generated to indicate the termination
         of a session.  It should not be replied to.

      ARG1: CON   Connection Data informaition set with @{" SDNSetConData " link SDNSetConData}
      ARG2: ----- Unused
      ARG3: ----- Unused
      ARG4: ----- Unused
      DLEN: ----- Unused
      DBUF: ----- Unused

      ARG1: ----- Unused
      ARG2: ----- Unused
      DLEN: ----- Unused
      DBUF: ----- Unused
@toc PACKETS
@endnode
@node ACTION_NETWORK_PASSWORD
@title "ACTION_NETWORK_PASSWORD"

ACTION_NETWORK_PASSWORD - 5557 - 0xffff
      ARG1: ----- Unused
      ARG2: ----- Unused
      ARG3: ----- Unused
      ARG4: ----- Unused
      DLEN: ULONG Length of password information
      DBUF: PASS  Passwork challenge response data

      ARG1: ----- Unused
      ARG2: ----- Unused
      DLEN: ----- Unused
      DBUF: ----- Unused
@toc PACKETS
@endnode

@node DATASTRUC
@title "Data Structures"
 @{" Rpacket " link RPacket}
 @{" #defines " link DEFINES}
 @{" Driver Global " link drglobal}
 @{" NSTR " link NSTR}

@endnode
@node RPacket
@title "RPacket Structure"

/* NOTE: This structure has changed!  DataP and AllocP are now at the top  */
/* This allows implementation of a quick buffer concatenated at the end of */
/* the packet                                                              */

struct RPacket       /* Packet sent to remote node */
{
   char  *DataP;        /* always contains at least MINBUFSIZE bytes    */
   char  *AllocP;       /* always contains at least MINBUFSIZE bytes    */
   short Type;          /* Type of request (AmigaDos packet type)       */
   short DLen;          /* Length of data in Data buffer                */
   void  *handle;       /* Generic handle for association               */
   LONG  Arg1,          /* Equivalent to dp_Arg? in normal devices      */
         Arg2,          /* when transmitting, dp_Res? when receiving    */
         Arg3,
         Arg4;
};

#define RPBASE(rp)    ((char *)&((rp)->Type))
#define RPSIZEN       (sizeof(struct RPacket)-8)
@toc DATASTRUC
@endnode
@node DEFINES
@title "SDN Driver #defines"

#define SDN_OK   0   /* Successful completion                   */
#define SDN_ERR  1   /* Some error, operation not done          */
#define SDN_NONE 2   /* No packets pending                      */
#define SDN_PEND 3   /* Packet was sent but is now pending      */
#define SDN_FAIL 4   /* Pended packet failed                    */
#define SDN_DOWN 5   /* Node is known but not currently up      */
@toc DATASTRUC
@endnode

@node NSTR
@toc DEFINES
An NSTR is a series of names which were obtained by calling Parent/Examine for
any lock which was established by the handler.  These strings are backwards
BSTRS in a reverse order with a length byte one higher than normal.
For example, a lock on 'ROOT:dir/subdir/name' would be represented as:
   n a m e $5 s u b d i r $7 d i r $4 R O O T $5
Note that in order to construct the name you have to start at the end and work
backwards.
@endnode
@node drglobal
@title "Global data structure for driver"

drglobal is a generic pointer that is passed to the driver.  It is private
to the driver and can be anything.  In the case of the INET driver we have:

typedef struct
{
   struct sockaddr_in sin;      /* Socket handle                                   */
   int    fhscount;             /* Number of open connections                      */
   inetcon connect[MAXCONNECT]; /* All connections                                 */
   long   fhsmask;              /* Mask of all open connections                    */
   long   fhscurmask;           /* Mask of unprocessed connections                 */
   struct timeval timeout;      /* Timeout interval (defaults to 5 seconds)        */
   int    curcon;               /* Connection of current packet                    */
   int    sock;                 /* Base socket handle for pending connections      */
   long   sockmask;             /* Base socket mask                                */
   struct INETRPacket *tpack;   /* Temporary packet handles to track               */
   struct INETRPacket *ppack;   /* Permanent packet handles to track               */
   void *_socks[FD_SETSIZE];    /* Sockets of open file handles                    */
   int    socket_sigio;         /* Signal bit for sockets                          */
   int    socket_sigurg;        /* Signal bit for sockets                          */
   int    hostaddr;             /* Default host address                            */
   struct Library *tg_SysBase;
   struct Library *tg_InetBase;
   struct DrLibrary *DriverBase;/* Pointer to driver base                          */
} * INETGLOBAL;

@toc DATASTRUC
@endnode

@node CONFIG
@title "Network Configuration"

   I.    @{" Server Configuration" link SERVCONFIG}
  II.    @{" Handler Configuration" link HANDCONFIG}
 III.    @{" Icon Specifications "  link ICONS}
  IV.    @{" Network Access Configuration" link ACCESS}
@{" QUIT " quit}
@endnode
@node SERVCONFIG
@title "Server Configuration File"

  devs:networks/server-config

   - Contains the configuration information about which devices to be
     listened to.  This file will consist of individual lines in the
     form:
        <method> [<unit> [<device> [<config1> [<config2>] ] ] ]
     Where method is the name of the network handler to be utilized.
     Currently we intend support:
        INET   - Commodore's Ethernet implementation of TCPIP
        DNET   - Matt Dillon's Dnet link protocol for serial port
        PNET   - ParNet for communications over the parallel port
        SNET   - Simple serial line communicatoins
        TSSNET - Syndesis's DecNet implementation
        APTALK - Appletalk card
        LANROVER - ASDG's LAN Rover Ethernet Card
        HYDRA  - Hydra Systems Ethernet board
     <unit> is the optional unit number.  Each method has its own
            default value.
     <device> is the optional default device to be used.  Each method
              has its own default.
     <config1> is the optional numeric device specific value.  For DNET
               and SNET it is the serial baud rate to be used.  For the
               others it is currently parsed but ignored.
     <config2> is the second optional numeric device specific value.
               It is parsed but currently ignored by all methods.
     The method is not limited to the above list.  The server will
     simply take the method and open a library of the name:
          NET-<method>.library
     and call access routines in the library to perform the operations.
     The parameters to this library are detailed below.
     Note that if the server fails to open a library it will put up a
     requester indicating so and then ignore the entry.  If after
     processing all entries it has not encountered a valid entry, the
     server will immediately terminate.
   - Any line that starts with a pound sign (#) or a semicolon (;)
     will be treated as a comment and ignored.
@toc CONFIG
@endnode
@node HANDCONFIG
@title "Handler Configuration File"

  devs:networks/handler-config

   - Contains the configuration information about which devices to be
     listened to.  This file will consist of individual lines in the
     form:
        <method> [<unit> [<device> [<config1> [<config2>] ] ] ]
     Where method is the name of the network handler to be utilized.
     Currently we support:
        INET   - Commodore's Ethernet implementation of TCPIP
        DNET   - Matt Dillon's Dnet link protocol for serial port
        PNET   - ParNet for communications over the parallel port
        SNET   - Simple serial line communicatoins
        TSSNET - Syndesis's DecNet implementation
        APTALK - Appletalk card
        LANROVER - ASDG's LAN Rover Ethernet Card
        HYDRA  - Hydra Systems Ethernet board
     <unit> is the optional unit number.  Each method has its own
            default value.
     <device> is the optional default device to be used.  Each method
              has its own default.
     <config1> is the optional numeric device specific value.  For DNET
               and SNET it is the serial baud rate to be used.  For the
               others it is currently parsed but ignored.
     <config2> is the second optional numeric device specific value.
               It is parsed but currently ignored by all methods.
     The method is not limited to the above list.  The server will
     simply take the method and open a library of the name:
          NET-<method>.library
     and call access routines in the library to perform the operations.
     The parameters to this library are detailed below.
     Note that if the server fails to open a library it will put up a
     requester indicating so and then ignore the entry.  If after
     processing all entries it has not encountered a valid entry, the
     server will immediately terminate.
   - Any line that starts with a pound sign (#) or a semicolon (;)
     will be treated as a comment and ignored.
@toc CONFIG
@endnode
@node ICONS
@title "Icon Specifications"

  devs:networks/icons/

     contains all icons for high level names.  There will be two
     special names:
        __DEFAULT__.info    which will be used for any directory
                            that does not have a default icon.  If
                            this does not exist then we will assume
                            that no icons are to be returned.  These
                            should all be of type drawer.
        __NODE__.info       This is the icon to be utilized for the
                            node.  It should be of type drawer.
@toc CONFIG
@endnode
@node ACCESS
@title "Network Access Configuration"

  devs:networks/access/

     contains the default access rules for all file systems to be
     exported.  These files will be in the form:
        Default: (Include|Readonly|Shared|Exclude)
        Password: <password>
        <assign>: [(Include|Shared|Readonly|Exclude)] [Assign name]
     The Default: and Password: lines MUST be the first two lines in
     that order.   On each subsequent line will be those logical assigns
     that are to be treated as other than the default.  If no other
     assigns to be treated specially then the file may consist of only
     two lines.  The Password keyword is used to validate access to the
     network.  If no password is given, access is available to anyone.
     Default may be one of 4 selections:
         DEFAULT: INCLUDE  -  Indicates that all top level nodes are to
                              included in the root file system.  Access
                              to the nodes is in a shared R/W mode
         DEFAULT: SHARED   -  Same as DEFAULT: INCLUDE
         DEFAULT: READONLY -  Indicates that all top level nodes are to
                              be included in the root file system but in
                              a read-only mode.
         DEFAULT: EXCLUDE  -  Indicate the no nodes are to be included in
                              the root file system.
     These same keywords may be used on any assign that appears on a
     subsequent line.  It may also have the keyword ASSIGN name which
     indicates that the assigned name to appear is not really an existing
     assign, but a local assign to be made to the given directory.  Note
     that when this type of assign is used, no access to anywhere above
     in the directory tree is to be allowed.
   - Any line that starts with a pound sign (#) or a semicolon (;)
     will be treated as a comment and ignored.
   - The default access file will be called __DEFAULT__. if it is not
     present, then a default file consisting of the commands:
        DEFAULT: SHARED
        PASSWORD:
     will be assumed allowing complete access to all entries and no
     password access required.
   - Additional files will be present in the directory corresponding to
     users who are to be granted access.  This allows different users
     to have different levels of access.
@toc CONFIG
@endnode
@node TODO
@title "Network Work to be done"

*H [Doug Walker] Investigate hang after reboot
*H [John Toebes] Implement Password Encription/Validation scheme
*H [Doug Walker] Implement remaining 2.0 packets
*H [John Toebes] Implement driver code to determine Network Buffer size
*M [Doug Walker] Implement AUTO * syntax in handler config file
*M [John Toebes] Implement Driver support for AUTO *
*M [John Toebes] Implement user interface for access to the config files
*M [Doug Walker] Implement NetKeys over the network
*M [John Toebes] Implement printer support over the network.
*L [John Toebes] Implement server auto-logout
*L [Doug Walker] Add the ability to create volume nodes on the workbench
                 for individual disks.  This will allow us to make some
                 remote hard disks appear exactly as if they were a hard
                 disk on the local node.
*L [Doug Walker] Add Handler config parsing of the NODE line for pre-mounting
                 reference nodes without actually referring to them
*L [Doug Walker] Implement node aliasing
*L [John Toebes] Add new packet for saving and restoring states.  This is
                 necesary to support shutting down and reestablishing
                 connections where the cost of maintining a reliable
                 connection may be high.
*L [Doug Walker] Implement interactive lock management by creating a message
                 port.  This will allow the handler to work with console style
                 devices.
*L [John Toebes] Implement access for generic devices over the network
*L [Doug Walker] Implement access to files in the NET: root through some sort
                 of assign in the handler configuration.

@endnode
@node OVERVIEW
NOTE: THE RPACKET STRUCTURE HAS CHANGED!!!!

The network handler and server utilize a driver level interface in order to
get access to the individual hardware devices.  We have successfully tested
the handler with multiple drivers installed (the @{" INET " link INET} and @{" LOCAL " link LOCAL} driver)
but have not implemented the driver for other hardware yet.

It is the responsibility of the driver to provide reliable communications
amongst machines.  If the connection may be noisy, the driver must do some
form of error checking.  This is critical to proper operation of the
network.  It is also the responsibility of the driver to determine when
the remote node has broken or reestablished a connection and then to pass
that information back up to the handler/server.

Feel free to ask questions and point out deficiencies in the documentation.  Our
goal is to turn this disk into a network driver developer's disk with complete
online documentation and examples where possible.  We have included source code
for older versions of drivers that had worked with older versions of NET: (before
the new driver interface) so that you can utilize them as a starting point for
a given implemetation.  Due to redistribution restrictions some pieces are not
sent to all people.

One basic point is probably necessary to bring out here.  You start the network
handler and server by just running the programs @{" NETWORK-HANDLER " link NETHANDLER} and @{" NETWORK-SERVER " link NETSERVER}
respectively.  Once running, you can access a node with the syntax:
   NET:nodename/device/stuff
Where:
   nodename is the name of the node as defined by the access method
            that supports it.
   device   is the name of the remote device you wish to access - note that a
            slash (if any) terminates it instead of a colon
   stuff    is anything trailing that is specific to the device.
For example, to access DF0:xyzzy on remote machine john you would reference
   NET:john/df0/xyzzy.

Of interest here is that there is no mountlist entry required for installing the
network.

You can contact us at:
   Bix:    jtoebes  djwalker
   Plink:  jtoebes  dwalker
   Usenet: toebes@dev.sas.com  walker@dev.sas.com
   CIS:    72230,303
   USMail: 207 Livingstone Drive, Cary NC 27513 USA
   Phone:  (919) 469-4210
@endnode

@node TOOLS
@title "Tools Provided"
@{" PICKPACKET " link PICKPACKET}
@{" PICKPACKET2 " link PICKPACKET2}
@{" NETWORK-HANDLER " link NETHANDLER}
@{" NETWORK-SERVER " link NETSERVER}
@endnode

@node PICKPACKET
@title "Pick Packet test tool"
@toc TOOLS
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\
* |_o_o|\\ Copyright  1989 The Software Distillery.                      *
* |. o.| ||          All Rights Reserved.                                 *
* | .  | ||          Written by John Toebes and Doug Walker               *
* | o  | ||          The Software Distillery                              *
* |  . |//           235 Trillingham Lane                                 *
* ======             Cary, NC 27513                                       *
*                    BBS:(919)-471-6436                                   *
*      BIX: JTOEBES, DWALKER                                              *
*    PLINK: JTOEBES, DWALKER                                              *
*   Usenet: ...mcnc!rti!sas!(toebes|walker)                               *
*      CI$: sorry, charlie...                                             *
\* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

------------------------------COPYRIGHT NOTICE

PickPacket is Copyright  1989 The Software Distillery.  See the file
README.PP for distribution information.

------------------------------DISCLAIMER

Neither The Software Distillery nor any of its members will be liable for 
any damage arising from the failure of this program to perform as described,
or any destruction of other programs or data residing on a system 
attempting to run the program.  While we expect no damaging errors, the 
user of this program uses it at his or her own risk.

--------------------------------------------------------------------------

PICKPACKET - EXPLORING THE PACKET INTERFACE TO AMIGADOS

(The concepts discussed here are covered in much greater detail in an
 article in 'Transactor for the Amiga', May 1989 issue.)

We first had the idea to write this program while working on a file system
for AmigaDOS.  It turned out that we were writing lots of tiny little C
programs that sent a particular packet to our file system.  Once we had
decided to write it, however, we saw that it would be a useful tool for
new programmers to explore the packet interface to DOS.  We hope you will
enjoy it!

AmigaDOS handlers and file systems communicate with application programs
via Messages and MsgPorts, just like most other Amiga system-level tasks do.
There is a handler or file system in charge of every device you have on
your Amiga, from df0: and ram: to ser: and par:.  When you call a function
in dos.library such as Open() or Lock(), dos.library determines which
handler to call and sends it the appropriate packet to do the requested 
action.  If this explanation doesn't make sense to you, try reading the
description of the packet interface in Amiga Transactor, May 1989, or in
the AmigaDOS Technical Reference Manual (part of the AmigaDOS manual by
Bantam Books).

PickPacket gives a visual display of the DosPacket structure that is sent
to the handlers and lets you see the results.  You can actually open files,
read and write data, Examine() and ExNext() locks, and so forth, all by 
talking directly to the file system involved from PickPacket.


------------------------------GETTING STARTED

To run PickPacket, either double-click on its icon or type "PickPacket"
from the CLI.  From the CLI, you can optionally specify an initial device,
as in "PickPacket RAM:".  The default initial device is df0:, but you can
select a different one once inside the program.

------------------------------THE PICKPACKET WINDOW

The PickPacket window has many interesting little gadgets and areas.
The dp_Type field contains the packet type of the packet you are working on.
You can select new packet types from the menus, or you can cycle through
the list of packet types by clicking on the left or the right of the data
field for dp_Type.

Below the dp_Type field are four lines for dp_Arg1, dp_Arg2, dp_Arg3 and
dp_Arg4.  These four fields correspond to the four possible arguments that
you can pass to a file system.  They contain different values depending on
what packet type you have selected.  A short description of the type of
argument required in that field for that packet type is listed on the
right of the data field.  The box on the right of each dp_Arg field is
a string gadget that contains the value of that field at the moment.  The
box on the left (with the name "dp_Arg?" in it) is a boolean gadget.  You
can use the dp_Arg gadgets to enter values into the string gadgets, as
will be described below.

Below the four dp_Arg fields are two dp_Res fields.  These fields will show
the results of the packet you have sent.  Most packets return DOSTRUE in
dp_Res1 to indicate success and DOSFALSE in dp_Res1 to indicate failure.
If the packet failed, dp_Res2 contains the error code indicating why.  If
it succeeded, dp_Res2 SHOULD BE IGNORED.  Some handlers fill it in with
an error code EVEN IF THE PACKET SUCCEEDS.  Exceptions to the DOSTRUE/
DOSFALSE rule are the ACTION_READ and ACTION_WRITE packets, which return
the number of bytes read or written if successful and -1 for an error.

In the upper left-hand corner is a gadget labeled "Device".  If you started
PickPacket from the CLI and specified a device, that device name will be
in the string gadget;  otherwise, it will say "df0:".  The device listed
is the one that will receive your packets.  To change it, click on the 
device name and type in a new one.

Immediately to the right of the device gadget is the "Send Packet" gadget.
When you click here, PickPacket transmits your packet to the device.  
PickPacket does some validation of the arguments in the dp_Arg fields, but
it is VERY easy to crash your system by sending invalid or nonsense data
to a handler!!!!

The four gadgets to the right of the "Send Packet" gadget allocate various
data structures you will need to do some of the more interesting packets.
"Allocate HANDLE" allocates a FileHandle structure;  you will need a 
FileHandle structure to open files for read or write.  "Allocate INFODATA"
allocates a struct InfoData, which is used to get information about a disk
or volume mounted on a handler.  "Allocate FILEINFO" is used to allocate
a FileInfoBlock, which is passed to get information about a file or
directory.  "Allocate BUFFER" is used to allocate a data buffer to read
into or write from.  Any time you allocate a data structure, a new window
representing that data structure will pop up.  One additional window that
may pop up is the Lock window;  when you do a Lock, the file system 
allocates the lock structure on your behalf.  Therefore, the only way to
get a Lock window is to send an ACTION_LOCATE_OBJECT packet to a handler.

------------------------------KNOWING THE PLAYERS

The descriptions to the right of the dp_Arg fields can ask for several
different types of objects.  A short description of each follows.  You 
may need to look at a more detailed reference guide (Transactor or the
AmigaDOS manual) to determine what arguments are actually needed.

FileLock   - A FileLock is a structure allocated on your behalf when you 
             pass an ACTION_LOCATE_OBJECT to the handler.  NULL is a valid 
             Lock, however, and it indicates the root of the file system.  
             The first ACTION_LOCATE_OBJECT you do, therefore, will pass in
             a NULL lock and the full pathname of the object to lock.  You 
             can specify a NULL lock by selecting NULL from the "Constants"
             menu, then clicking on the appropriate dp_Arg button on the 
             left side of the screen.

STRING     - A STRING usually means the packet wants a filename.  If a
             FileLock is also asked for in the same packet, the Lock should
             be a lock on a directory, and the STRING should be a filename
             relative to that directory.  For example, if you have a Lock 
             on df0:c, you could Lock df0:c/dir by sending the lock on 
             df0:c and a relative pathname of "dir".  One exception to the 
             filename rule is in an ACTION_SET_COMMENT packet, where the 
             second STRING asked for is the comment desired.
 
Integer    - An Integer field is to contain some kind of integer constant.
             When doing Reads and Writes, an Integer indicates how many 
             bytes to read or write;  when Locking or Opening files, it 
             contains a constant from the "Constants" menu.  In particular,
             the ACTION_LOCATE_OBJECT packet wants a constant SHARED_LOCK 
             or EXCLUSIVE_LOCK, and the ACTION_FINDINPUT, ACTION_FINDOUTPUT
             and ACTION_FINDUPDATE packets (to open files) want a constant
             ACCESS_READ or ACCESS_WRITE.  To enter a constant, select it
             from the "Constants" menu, then click on the appropriate
             dp_Arg button.

FileHandle - A FileHandle field should point to a struct FileHandle.  You
             can allocate a struct FileHandle by clicking on the "Allocate
             HANDLE" button in the main window, or by selecting the menu
             item.  Once a FileHandle window is active, you can enter it
             into the appropriate dp_Arg field by clicking on the window,
             then clicking on the dp_Arg button on the left of the main
             window.  You may also type the name of the window directly
             by clicking into the argument data area and typing.

fh_Arg1    - Many packets require the fh_Arg1 field from an open FileHandle
             to do their stuff.  The ACTION_READ, ACTION_WRITE and 
             ACTION_END packets are examples.  Click on the FileHandle
             window, then on the dp_Arg button to set this up.

Data Buffer- Allocate a data buffer with the "Allocate BUFFER" button.
             You can set up a dp_Arg field to use the buffer by clicking on
             the data buffer window, then on the appropriate dp_Arg button.
             If the packet also requires a size (as in ACTION_READ and 
             ACTION_WRITE), you can click on the data buffer window and 
             then the dp_Arg field for the integer and the length of the 
             buffer will be filled into the field for you.  (If you want
             to read or write less than the length of the buffer, just
             type the value in to the field.)

FileInfoBlock- Allocate a FileInfoBlock with the "Allocate FILEINFO" button.
             You can set up a dp_Arg field to use it by clicking on its 
             window, then on the appropriate dp_Arg button.

InfoData   - Allocate an InfoData with the "Allocate INFODATA" button.
             You can set up a dp_Arg field to use it by clicking on its 
             window, then on the appropriate dp_Arg button.

BOOLEAN    - BOOLEAN values should be a constant DOSTRUE or DOSFALSE.
             Select the appropriate constant from the "Constants" menu,
             then click on the dp_Arg button for the field you want to
             enter the constant.


------------------------------DANGER!! Will Robinson.. DANGER!!

When using PickPacket, you are messing around with some low-level DOS 
functionality.  Handlers expect valid values in their argument fields.
YOU CAN AND WILL CRASH YOUR MACHINE IF YOU SEND THE WRONG THING.  For
example, one excellent way of crashing the system is to open a file
on device df0: and pass the FileHandle to RAM: with an ACTION_WRITE
packet.  PickPacket checks some things, but in general, you need to be
careful to send reasonable values, just as you would if you were writing
a program to send the packets yourself.  (Note, see disclaimer above!!!)
In particular, sending two ACTION_END packets for the same handle to the
Fast File System may cause you to have to revalidate the hard disk.

How many ways can you think of to trash your machine ?
Meditate on it for a while...
@endnode

@node PICKPACKET2
@title "Experimental verison of PickPacket"
@toc TOOLS
This is an experimental version of @{" pickpacket " link PICKPACKET} which
implementes some new 2.0 packets and adds support for some missing pieces
of the packet interface.  Note that it is not completely stable but
we include it for the extra features.
@endnode

@node NETHANDLER
@title "Network Handler"
@toc TOOLS
This program provides the network interface for a given machine.  It handles
all the dos level interface for the NET: device and talks to the given drivers.
It will get it's configuration information from the file:
  @{" devs:networks/handler-config " link HANDCONFIG}
@endnode

@node NETSERVER
@title "Network Server"
@toc TOOLS
This program provides the network exports for a given machine.  It listens
to the incomming messages from the drivers and passes them on to the
appropriate devices.
It will get it's configuration information from the file:
  @{" devs:networks/server-config " link SERVCONFIG}
@endnode

@node LOCAL
@title "Library for Local machine communications"
This driver implements a single machine communications medium.  By itself it
provides a global view of the entire device list for a single machine.
@endnode

@node INET
@title "Library for Commodore TCP/IP"
This driver implements the network protocol for the Commodore supplied TCP/IP
software.  The driver takes a single parameter - the address of the port to
talk to/listen on.
@endnode
@node DISKCONTENTS
@title "Contents of distribution disk"
     LIBS (dir)
       hyper.library                        @{" NET-INET.library " link INET}
     BIN (dir)
       more                                  SDNMore   
      @{" NETWORK-HANDLER " link NETHANDLER}                     @{" NETWORK-SERVER " link NETSERVER}
      @{" pickpacket " link PICKPACKET}                          @{" pickpacket2 " link PICKPACKET2}
     Networks (dir)
         @{" icons " link ICONS} (dir)
            CON.info                         RAW.info
            WB_2.x.info                      DF0.info
            __DEFAULT__.info                 __NODE__.info
            PRT.info
         @{" access " link ACCESS} (dir)
            __DEFAULT__
      @{" handler-config " link HANDCONFIG}                      @{" server-config " link SERVCONFIG}
     Driver (dir)
          OLD_TSSNet (dir)
            hantss.c                         iotss.c
            RCS_LINK                         sertss.c
          OLD_Dnet (dir)
            dnetlib.c                        handler-netdnet.c
            iodnet.c                         netdnet.c
            RCS_LINK                         server-netdnet.c
          OLD_ParNet (dir)
            hanpnet.c                        iopar.c
            iopnet.c                         RCS_LINK
            serpnet.c
          OLD_SANA (dir)
            hanipc.c                         ioipc.c
            RCS_LINK                         seripc.c
          @{" INet " link INET }(dir)
            lmkfile                          RCS_LINK
            readn.c                          refresh.lmk
            sdninet.c                        sdninetget.c
            SDNInetNode.c                    sdninetput.c
            sdninetutil.c
          @{" Local " link LOCAL}(dir)
            lmkfile                          RCS_LINK
            SDNLocal.h                       SDNLocalGet.c
            SDNLocalNode.c                   SDNLocalPut.c
            SDNLocalUtil.c
       net-inet.fd                      SDN.doc
     H (dir)
       channel.h                        defines.h
       dn.h                             dnet.h
       harri.h                          memdb.h
       netcomm.h                        netdev.h
       netdnet.h                        netinet.h
       netipc.h                         netpnet.h
       netroot.h                        nodepick.h
       parnet.h                         proto.h
       RCS_LINK                         sdn.h
       sdn_pragmas.h                    strdef.h
       TSSnetUInc.h
     LIB (dir)
       debug.c                          lmkfile
       membuf.c                         memdebug.c
       memwatch.lib                     net.lib
       RCS_LINK                         request.c
       sendpkt.c                        subs.c
       timer.c
  READ.ME                          SDN.hyper
@endnode
