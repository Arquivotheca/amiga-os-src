head     1.26;
branch   ;
access   ;
symbols  r37-9:1.26 v37r4:1.26 Distillery:1.26;
locks    dlarson:1.26; strict;
comment  @ * @;


1.26
date     91.03.09.21.02.17;  author J_Toebes;  state Exp;
branches ;
next     1.25;

1.25
date     91.01.22.00.01.32;  author Doug;  state Exp;
branches ;
next     1.24;

1.24
date     91.01.15.02.56.05;  author Doug;  state Exp;
branches ;
next     1.23;

1.23
date     91.01.11.10.38.33;  author Doug;  state Exp;
branches ;
next     1.22;

1.22
date     91.01.10.23.15.45;  author Doug;  state Exp;
branches ;
next     1.21;

1.21
date     91.01.06.20.55.55;  author Doug;  state Exp;
branches ;
next     1.20;

1.20
date     90.12.31.15.33.28;  author Doug;  state Exp;
branches ;
next     1.19;

1.19
date     90.12.30.15.45.48;  author Doug;  state Exp;
branches ;
next     1.18;

1.18
date     90.12.13.03.22.26;  author Doug;  state Exp;
branches ;
next     1.17;

1.17
date     90.12.03.22.18.50;  author Doug;  state Exp;
branches ;
next     1.16;

1.16
date     90.12.03.22.13.49;  author Doug;  state Exp;
branches ;
next     1.15;

1.15
date     90.12.03.20.06.10;  author Doug;  state Exp;
branches ;
next     1.14;

1.14
date     90.11.29.02.59.46;  author Doug;  state Exp;
branches ;
next     1.13;

1.13
date     90.11.29.01.46.20;  author Doug;  state Exp;
branches ;
next     1.12;

1.12
date     90.11.28.04.30.08;  author Doug;  state Exp;
branches ;
next     1.11;

1.11
date     90.11.27.22.12.54;  author Doug;  state Exp;
branches ;
next     1.10;

1.10
date     90.11.25.15.50.48;  author J_Toebes;  state Exp;
branches ;
next     1.9;

1.9
date     90.11.20.22.23.46;  author Doug;  state Exp;
branches ;
next     1.8;

1.8
date     90.11.20.01.06.27;  author Doug;  state Exp;
branches ;
next     1.7;

1.7
date     90.11.19.02.04.26;  author Doug;  state Exp;
branches ;
next     1.6;

1.6
date     90.11.18.00.03.36;  author Doug;  state Exp;
branches ;
next     1.5;

1.5
date     90.10.18.00.18.21;  author J_Toebes;  state Exp;
branches ;
next     1.4;

1.4
date     90.10.16.00.53.30;  author J_Toebes;  state Exp;
branches ;
next     1.3;

1.3
date     90.10.09.23.58.05;  author J_Toebes;  state Exp;
branches ;
next     1.2;

1.2
date     90.10.03.00.17.04;  author J_Toebes;  state Exp;
branches ;
next     1.1;

1.1
date     90.10.02.23.38.50;  author J_Toebes;  state Exp;
branches ;
next     ;


desc
@main handler dispatcher
@


1.26
log
@Correct parameters for setfiledate
@
text
@/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/* |_o_o|\\ Copyright (c) 1987, 1988 The Software Distillery.  All Rights  */
/* |. o.| || Reserved.  This program may not be distributed without the    */
/* | .  | || permission of the authors:                            BBS:    */
/* | o  | ||   John Toebes     Doug Walker    Dave Baker                   */
/* |  . |//                                                                */
/* ======                                                                  */
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/*
**      $Filename: main.c $ 
**      $Author: Doug $
**      $Revision: 1.25 $
**      $Date: 91/01/22 00:01:32 $
**      $Log:	main.c,v $
 * Revision 1.25  91/01/22  00:01:32  Doug
 * *** empty log message ***
 * 
 * Revision 1.24  91/01/15  02:56:05  Doug
 * Kill outstanding HPKTs when connection terminates
 * 
 * Revision 1.23  91/01/11  10:38:33  Doug
 * Add Network password capabilities
 * 
 * Revision 1.22  91/01/10  23:15:45  Doug
 * *** empty log message ***
 * 
 * Revision 1.21  91/01/06  20:55:55  Doug
 * Revise debugging messages
 * 
 * Revision 1.20  90/12/31  15:33:28  Doug
 * change packet array
 * 
 * Revision 1.19  90/12/30  15:45:48  Doug
 * Add ActNetInit, renumber several actions
 * Implement MEMCHK debugging
 * 
**
**/

#include "handler.h"

#if DEBUG
char *dbgwind = "CON:0/0/639/199/NET handler debug window/a";
int memcheck = 0;   /* check memory every packet */
#endif

/******************************************************************************/
/******************************************************************************/
/********************* Dispatch table to handle all packets *******************/
/******************************************************************************/
/******************************************************************************/
#define BP1 1
#define BP2 2
#define BP3 4
#define BP4 8

#if PARANOID
#undef BUGP
#define BUGP(sss) request(&global, REQ_GENERAL, sss);
#endif

struct LookupTable {
    short     num;
    short     flags;
    ifuncp  subr;
};

struct LookupTable worktab[] = {
   /*    5 */ { ACTION_DIE,            0  | 0  | 0  | 0  , ActDie           }, /* */
   /*    6****{ ACTION_EVENT,          0  | 0  | 0  | 0  , NULL             },*****/
   /*    7 */ { ACTION_CURRENT_VOLUME, BP1| 0  | 0  | 0  , ActCurentVol     }, /* */
   /*    8 */ { ACTION_LOCATE_OBJECT,  BP1| BP2| 0  | 0  , ActLock          }, /* */
   /*    9 */ { ACTION_RENAME_DISK,    BP1| BP2| 0  | 0  , ActRenameDisk    }, /* */
   /*   15 */ { ACTION_FREE_LOCK,      BP1| 0  | 0  | 0  , ActUnLock        }, /* */
   /*   16 */ { ACTION_DELETE_OBJECT,  BP1| BP2| 0  | 0  , ActDelete        }, /* */
   /*   17 */ { ACTION_RENAME_OBJECT,  BP1| BP2| BP3| BP4, ActRename        }, /* */
   /*   18****{ ACTION_MORE_CACHE,     0  | 0  | 0  | 0  , NULL             },*****/
   /*   19 */ { ACTION_COPY_DIR,       BP1| 0  | 0  | 0  , ActDupLock       }, /* */
   /*   20****{ ACTION_WAIT_CHAR,      0  | 0  | 0  | 0  , NULL             },*****/
   /*   21 */ { ACTION_SET_PROTECT,    0  | BP2| BP3| 0  , ActSetProtection }, /* */
   /*   22 */ { ACTION_CREATE_DIR,     BP1| BP2| 0  | 0  , ActCreateDir     }, /* */
   /*   23 */ { ACTION_EXAMINE_OBJECT, BP1| BP2| 0  | 0  , ActExamine       }, /* */
   /*   24 */ { ACTION_EXAMINE_NEXT,   BP1| BP2| 0  | 0  , ActExNext        }, /* */
   /*   25 */ { ACTION_DISK_INFO,      BP1| 0  | 0  | 0  , ActDiskInfo      }, /* */
   /*   26 */ { ACTION_INFO,           BP1| BP2| 0  | 0  , ActInfo          }, /* */
   /*   27 */ { ACTION_FLUSH,          0  | 0  | 0  | 0  , ActFlush         }, /* */
   /*   28 */ { ACTION_SET_COMMENT,    0  | BP2| BP3| BP4, ActSetComment    }, /* */
   /*   29 */ { ACTION_PARENT,         BP1| 0  | 0  | 0  , ActParent        }, /* */
   /*   30 */ { ACTION_TIMER,          0  | 0  | 0  | 0  , ActTimer         }, /* */
   /*   31 */ { ACTION_INHIBIT,        0  | 0  | 0  | 0  , ActInhibit       }, /* */
   /*   34 */ { ACTION_SET_FILE_DATE,  0  | BP2| BP3| 0  , ActSetFileDate   }, /* */
   /*   40 */ { ACTION_SAME_LOCK,      0  | 0  | 0  | 0  , ActSameLock      }, /* */
   /*   82 */ { ACTION_READ,           0  | 0  | 0  | 0  , ActRead          }, /* */
   /*   87 */ { ACTION_WRITE,          0  | 0  | 0  | 0  , ActWrite         }, /* */
   /* 1001****{ ACTION_READ_RETURN,    0  | 0  | 0  | 0  , NULL             },*****/
   /* 1002****{ ACTION_WRITE_RETURN,   0  | 0  | 0  | 0  , NULL             },*****/
   /* 1004 */ { ACTION_FIND_WRITE,     BP1| BP2| BP3| 0  , ActFindwrite     }, /* */
   /* 1005 */ { ACTION_FIND_INPUT,     BP1| BP2| BP3| 0  , ActFindwrite     }, /* */
   /* 1006 */ { ACTION_FIND_OUTPUT,    BP1| BP2| BP3| 0  , ActFindwrite     }, /* */
   /* 1007 */ { ACTION_END,            0  | 0  | 0  | 0  , ActEnd           }, /* */
   /* 1008 */ { ACTION_SEEK,           0  | 0  | 0  | 0  , ActSeek          }, /* */
   /* 1020 */ { ACTION_FORMAT,         0  | 0  | 0  | 0  , ActFormat        }, /* */
   /* 1021 */ { ACTION_MAKE_LINK,      BP1| BP2| BP3| 0  , ActMakeLink      }, /* */
   /* 1022****{ ACTION_SET_FILE_SIZE,  0  | 0  | 0  | 0  , NULL             },*****/
   /* 1023****{ ACTION_WRITE_PROTECT,  0  | 0  | 0  | 0  , NULL             },*****/
   /* 1024****{ ACTION_READ_LINK,      0  | 0  | 0  | 0  , NULL             },*****/
   /* 1026 */ { ACTION_FH_FROM_LOCK,   0  | 0  | 0  | 0  , ActFHFromLock    }, /* */
   /* 1027 */ { ACTION_IS_FILESYSTEM,  0  | 0  | 0  | 0  , ActIsFS          }, /* */
   /* 1028 */ { ACTION_CHANGE_MODE,    0  | 0  | 0  | 0  , ActChangeMode    }, /* */
   /* 1030 */ { ACTION_COPY_DIR_FH,    0  | 0  | 0  | 0  , ActCopyDirFH     }, /* */
   /* 1031 */ { ACTION_PARENT_FH,      0  | 0  | 0  | 0  , ActParentFH      }, /* */
   /* 1033 */ { ACTION_EXAMINE_ALL,    0  | 0  | 0  | 0  , ActExamineAll    }, /* */
   /* 1034 */ { ACTION_EXAMINE_FH,     0  | 0  | 0  | 0  , ActExamineFH     }, /* */
   /* 2010 */ { ACTION_HANDLER_DEBUG,  0  | 0  | 0  | 0  , ActSetDebug      }, /* */
   /* 2011****{ ACTION_SET_TRANS_TYPE, BP1| 0  | 0  | 0  , NULL             },*****/
   /* 2012 */ { ACTION_NETWORK_HELLO,  BP1| BP2| BP3| 0  , ActNetHello      }, /* */
   /* 4097****{ ACTION_ADD_NOTIFY,     0  | 0  | 0  | 0  , NULL             },*****/
   /* 4098****{ ACTION_REMOVE_NOTIFY,  0  | 0  | 0  | 0  , NULL             },*****/
   /* 5554****{ ACTION_NETWORK_START,  0  | 0  | 0  | 0  , NULL             },*****/
   /* 5555****{ ACTION_NETWORK_INIT,   0  | 0  | 0  | 0  , NULL             },*****/
   /* 5556****{ ACTION_NETWORK_TERM,   0  | 0  | 0  | 0  , NULL             },*****/
   /* 5557 */ { ACTION_NETWORK_PASSWD, BP1| BP2| 0  | 0  , ActNetPwd        }, /* */
  };
#define WORKSIZE (sizeof(worktab)/sizeof(struct LookupTable))


extern struct Library *SysBase;
struct DosLibrary *DOSBase;

void _main(char *x);

void
_main(char *x)
{
   HPACKET          *hpkt;       /* The RPacket for the current action*/
   HPACKET          *thp, *lhp;
   struct DosPacket *dpkt, *pkt;
   int         action;
   int         low, high, this;
   ULONG           sigmask;
   ifuncp              subr;
   int         flags;
   struct global      global;
   DRIVER           *driver;
   struct Library *DriverBase;
   struct RPacket   *RP;
   struct Message *msg;
   struct MsgPort *replyport;

   MWInit(NULL, MWF_NOCHECK, "CON:0/0/639/199/NET handler memory debug");

   /* Initialize our global data structure */
   memset((char *)&global, 0, sizeof(struct global));

   global.n.self   = (struct Process *) FindTask(0L);  /* find myself      */
   global.n.run    = 1;
   global.n.port   = CreatePort("NET Access Port", 0L);
   global.flags    = NGF_RELOCK;
   /* install our taskid ...   */


   /* Initialize the intuitext structures for the requesters we might have   */
   /* to display                                                              */
   /* Because we have no scruples we can cheat and do this with a couple of  */
   /* long word assignments.  We leave the acual C code commented out here   */
   /* so that if this structure ever changed we will still be able to work   */
#if 0
   global.n.line1.FrontPen = global.n.line1.BackPen = -1;
   global.n.line1.DrawMode = JAM1;
   global.n.line1.LeftEdge = global.n.line1.TopEdge = 4;
   global.n.line2 = global.n.line1;
   global.n.line3 = global.n.line1;
   global.n.retrytxt = global.n.line1;
   global.n.canceltxt = global.n.line1;
#else
   *(long *)&global.n.line1.FrontPen     = 0x00010000L | (JAM1<<8);
   *(long *)&global.n.line1.LeftEdge     = 0x00040004L;  /* 4,4  */
   *(long *)&global.n.line2.FrontPen     = 0x00010000L | (JAM1<<8);
   *(long *)&global.n.line2.LeftEdge     = 0x0004000EL;  /* 4,14 */
   *(long *)&global.n.line3.FrontPen     = 0x00010000L | (JAM1<<8);
   *(long *)&global.n.line3.LeftEdge     = 0x00040018L;  /* 4,24 */
   *(long *)&global.n.retrytxt.FrontPen  = 0x00010000L | (JAM1<<8);
   *(long *)&global.n.retrytxt.LeftEdge  = 0x00040004L;
   *(long *)&global.n.canceltxt.FrontPen = 0x00010000L | (JAM1<<8);
   *(long *)&global.n.canceltxt.LeftEdge = 0x00040004L;
#endif
   global.n.retrytxt.IText = "Retry";
   global.n.canceltxt.IText = "Cancel";

   BUGP("Net Handler Starting")

   InitDevice(&global);

   BUGP("Net Handler Initialized");

   Mount(&global, NULL);

   BUGP("Net Handler Main");

   OpenTimer(&global, global.n.port);

   PostTimerReq(&global, HPTICK);

   global.waitbits |= (1 << global.n.port->mp_SigBit);
   
   driver = NULL;
   while(global.n.run)    /* start of the real work */
   {
      do
      {
         hpkt = NULL;

#if DEBUG
         if(memcheck) MWCheck();
#endif

         /* Clear up any packets waiting for our action */
         while(global.donepkts) 
         {
            thp = global.donepkts;
            global.donepkts = global.donepkts->hp_WNext;
            retpkt(&global, thp);
         }

         if(driver == NULL)
         {
            /* Check for new messages from the application */
            if(msg = GetMsg(global.n.port))
            {
               /* This is a NEW packet from an application */
               pkt = (struct DosPacket *)msg->mn_Node.ln_Name;

               BUG(("NEW 0x%08lx type %d args (%08lx,%08lx,%08lx,%08lx)\n",
                  pkt, pkt->dp_Type, pkt->dp_Arg1, pkt->dp_Arg2, 
                                     pkt->dp_Arg3, pkt->dp_Arg4))

               if(!(hpkt = GetHPacket(&global)))
               {
                  pkt->dp_Res1 = DOS_FALSE;
                  pkt->dp_Res2 = ERROR_NO_FREE_STORE;
                  replyport = pkt->dp_Port;
                  msg = pkt->dp_Link;
                  pkt->dp_Port = global.n.port;
                  PutMsg(replyport, msg);
               }
               else
               {
                  /* We have a new hpkt structure - initialize it */
                  hpkt->hp_Pkt = pkt;
                  hpkt->hp_NNode = NULL;
                  hpkt->hp_RP = NULL;
                  hpkt->hp_Driver = NULL;
                  hpkt->hp_Func = NULL;
                  hpkt->hp_NPFlags = 0;
                  hpkt->hp_PktFlags = 0;
               }
               break;
            }

            sigmask = Wait(global.waitbits);
            driver = global.drivers;
         }

         while(driver != NULL)
         {
            if(!(driver->sigmask & sigmask))
            {
               /* This one can't be it, the bits don't match */
               driver = driver->next;
            }
            else
            {
               /* Looks like an eligible driver, ask if he has anything */
               DriverBase = driver->libbase;
               switch(SDNReceive(driver->drglobal, sigmask, &RP))
               {
                  case SDN_OK: 
                     /* We have a valid RPacket back from the device */
                     hpkt = (HPACKET *)RP->handle;

#if DEBUG
                     if(!hpkt) 
                     {
                        request((GLOBAL)&global, REQ_GENERAL, "RCV NO HANDLE!");
                        BUG(("RCV NO HANDLE!!!\n"))
                        break;
                     }
                     if(hpkt->hp_Pkt)
                        BUG(("RCV 0x%08lx type %d args (%08lx,%08lx,%08lx,%08lx)\n",
                           hpkt->hp_Pkt, hpkt->hp_Pkt->dp_Type, 
                           hpkt->hp_Pkt->dp_Arg1, hpkt->hp_Pkt->dp_Arg2, 
                           hpkt->hp_Pkt->dp_Arg3, hpkt->hp_Pkt->dp_Arg4))
                     else
                        BUG(("RCV NULL PKT\n"))
#endif
                     for(lhp=NULL, thp=global.qpkts; 
                         thp && thp != hpkt; 
                         lhp=thp, thp=thp->hp_WNext);

                     if(thp)
                     {
                        if(lhp) lhp->hp_WNext = hpkt->hp_WNext;
                        else    global.qpkts = hpkt->hp_WNext;
                        hpkt->hp_RP = RP;
                        retpkt(&global, hpkt);
                     }
#if DEBUG
                     else
                        request((GLOBAL)&global, REQ_GENERAL,
                                "Bad hpkt from SDNReceive!");
#endif
                     hpkt = NULL;
                     break;

                  case SDN_ERR:
#if DEBUG
                     request((GLOBAL)&global, REQ_GENERAL,
                             "SDN_ERR from SDNReceive");
#endif
                     break;

                  case SDN_NONE:
                     driver = driver->next; 
                     break;
               }
            }
         }

      }
      while(hpkt == NULL);

      dpkt = hpkt->hp_Pkt;

      action = dpkt->dp_Type;

      low = 0;
      high = WORKSIZE;
      subr = NULL;
      while (low <= high)
      {
         this = (high-low)/2 + low;
         if (worktab[this].num == action)
         {
            subr = worktab[this].subr;
            flags = worktab[this].flags;
            break;
         }
         if (worktab[this].num < action)
            low = this + 1;
         else
            high = this - 1;
      }

      dpkt->dp_Res1 = DOS_FALSE;
      dpkt->dp_Res2 = ERROR_ACTION_NOT_KNOWN;

      if (subr != NULL) 
      {
         global.n.reply = 1;
         if (flags & BP1) dpkt->dp_Arg1 <<= 2;
         if (flags & BP2) dpkt->dp_Arg2 <<= 2;
         if (flags & BP3) dpkt->dp_Arg3 <<= 2;
         if (flags & BP4) dpkt->dp_Arg4 <<= 2;
         hpkt->hp_PktFlags = flags;

         (*subr)(&global, hpkt);

      }
      else 
      {
         BUG(("***Unknown packet type %ld\n",dpkt->dp_Type));
         retpkt(&global, hpkt);
      }
   }

    /* do our final cleanup */
    global.node->dn_Task = FALSE; /* zero the taskid field of device node */
    global.node->dn_SegList = 0;  /* make us be gone */

    DisMount(&global);
    TermDevice(&global);

#if TIMEDEBUG
    CloseTimer(&global);
#endif

    MWTerm();

    BUGTERM()
}

void KillHPackets(GLOBAL global, struct NetNode *nnode, int errmsg)
{
   HPACKET *thp, *lhp, *nhp;
   thp = global->qpkts;
   lhp = NULL;
   while(thp)
   {
      if(thp->hp_NNode == nnode)
      {
         if(lhp) lhp->hp_WNext = nhp = thp->hp_WNext;
         else    global->qpkts = nhp = thp->hp_WNext;
         thp->hp_State = HPS_ERR;
         /* Best guess at a reasonable error message */
         if(thp->hp_Pkt)
         {
            thp->hp_Pkt->dp_Res1 = DOS_FALSE;
            thp->hp_Pkt->dp_Res2 = errmsg;
         }
         HPQ(global, thp);
         thp = nhp;
         BUG(("***KILLING 0x%08lx\n", thp->hp_Pkt))
      }
      else
      {
         lhp = thp;
         thp=thp->hp_WNext;
      }
   }
}

ACTFN(retpkt)
{
   struct Message *mess;
   struct MsgPort *replyport;
   struct DosPacket *pkt;
   struct Library *DriverBase;
   ifuncp func;


   if(hpkt->hp_State == HPS_RETRY)
   {
      hpkt->hp_State = HPS_NEW;
      RemotePacket(global, hpkt);
   }
   else
   {
      if(func=hpkt->hp_Func)
      {
         /* The secondary function must be called.  If the packet is to be */
         /* returned after this call, the secondary function will be NULL  */
         /* after it is called.  If there is more to do, the secondary     */
         /* function itself will replace the function pointer and requeue  */
         /* the packet when appropriate.                                   */

         hpkt->hp_Func = NULL;
         (*func)(global, hpkt);
      }

      if(!hpkt->hp_Func)
      {
         /* No more functions, might as well get rid of it now */
         if(pkt = hpkt->hp_Pkt)
         {
            if (hpkt->hp_PktFlags & BP1) pkt->dp_Arg1 >>= 2;
            if (hpkt->hp_PktFlags & BP2) pkt->dp_Arg2 >>= 2;
            if (hpkt->hp_PktFlags & BP3) pkt->dp_Arg3 >>= 2;
            if (hpkt->hp_PktFlags & BP4) pkt->dp_Arg4 >>= 2;

            replyport        = pkt->dp_Port;
            mess             = pkt->dp_Link;
            pkt->dp_Port     = global->n.port;

            if(hpkt->hp_RP)
            {
               DriverBase = hpkt->hp_Driver->libbase;
               SDNFreeRPacket(hpkt->hp_Driver->drglobal, hpkt->hp_RP);
            }

            BUG(("RET 0x%08lx type %d res %d(%08lx) %d(%08lx)\n",
               pkt, pkt->dp_Type, pkt->dp_Res1, pkt->dp_Res1, 
                                  pkt->dp_Res2, pkt->dp_Res2))

            PutMsg(replyport, mess);
         }
#if DEBUG
         else
         {
            BUG(("RET no dos pkt\n"))
         }
#endif

         FreeHPacket(global, hpkt);
      }
   }

}

#if 0
ACTFN(forwardpkt)
{
   struct DosPacket *pkt = hpkt->hp_Pkt;
   BUG(("forwardpkt: Entry, hpkt 0x%08lx\n", hpkt))

   if (hpkt->hp_PktFlags & BP1) pkt->dp_Arg1 >>= 2;
   if (hpkt->hp_PktFlags & BP2) pkt->dp_Arg2 >>= 2;
   if (hpkt->hp_PktFlags & BP3) pkt->dp_Arg3 >>= 2;
   if (hpkt->hp_PktFlags & BP4) pkt->dp_Arg4 >>= 2;

   PutMsg(global->devslock->fl_Task, (struct Message *)pkt->dp_Link);

   FreeHPacket(global, hpkt);
}
#endif

/* Arg1 - BSTR Name of node */
/* Arg2 - BSTR userid */
/* Arg3 - BPTR challenge buffer */
/* Arg4 - LONG length of challenge */
ACTFN(ActNetHello)
{
   struct RPacket *RP = hpkt->hp_RP;
   struct DosPacket *pkt = hpkt->hp_Pkt;
   NETPTR nlock;

   if(ParseName(global, (char *)pkt->dp_Arg1, &nlock, global->work) || !nlock)
   {
      pkt->dp_Res1 = DOS_FALSE;  /* Root of NET: */
      pkt->dp_Res2 = ERROR_OBJECT_WRONG_TYPE;
      HPQ(global, hpkt);
   }
   else if(!(RP = AllocRPacket(nlock->NetNode, 0)))
   {
      pkt->dp_Res1 = DOS_FALSE;
      pkt->dp_Res2 = ERROR_NO_FREE_STORE;
      HPQ(global, hpkt);
   }
   else
   {
      RP->Type = ACTION_NETWORK_HELLO;
      RP->DLen = BSTRLEN(pkt->dp_Arg2);
      RP->DataP = (char *)pkt->dp_Arg2;

      RP->handle = hpkt;

      hpkt->hp_RP = RP;
      hpkt->hp_NPFlags = 0;
      hpkt->hp_NNode = nlock->NetNode;
      hpkt->hp_Driver = nlock->NetNode->driver;
      hpkt->hp_Func = ActNetHello2;

      RemotePacket(global, hpkt);
   }
}

ACTFN(ActNetHello2)
{
   struct DosPacket *pkt = hpkt->hp_Pkt;
   struct RPacket *RP = hpkt->hp_RP;

   if(hpkt->hp_State != HPS_ERR)
   {
      if(RP->Arg1 == DOS_FALSE)
      {
         pkt->dp_Res1 = DOS_FALSE;
      }
      else
      {
         if(pkt->dp_Arg4 < RP->DLen)
         {
            pkt->dp_Res1 = DOS_FALSE;
            pkt->dp_Res2 = ERROR_OBJECT_TOO_LARGE;
         }
         else
         {
            pkt->dp_Res1 = RP->Arg1;
            memcpy((char *)pkt->dp_Arg3, RP->DataP, RP->DLen);
         }
      }
      pkt->dp_Res2 = RP->Arg2;
   }
}

/* Arg1 - BSTR Name of node */
/* Arg2 - BSTR response buffer */
ACTFN(ActNetPwd)
{
   struct RPacket *RP = hpkt->hp_RP;
   struct DosPacket *pkt = hpkt->hp_Pkt;
   NETPTR nlock;


   if(ParseName(global, (char *)pkt->dp_Arg1, &nlock, global->work) || !nlock)
   {
      pkt->dp_Res1 = DOS_FALSE;  /* Root of NET: */
      pkt->dp_Res2 = ERROR_OBJECT_WRONG_TYPE;
      HPQ(global, hpkt);
   }
   else if(!(RP = AllocRPacket(nlock->NetNode, 0)))
   {
      pkt->dp_Res1 = DOS_FALSE;
      pkt->dp_Res2 = ERROR_NO_FREE_STORE;
      HPQ(global, hpkt);
   }
   else
   {
      RP->Type = ACTION_NETWORK_PASSWD;
      RP->DLen = BSTRLEN(pkt->dp_Arg2);
      RP->DataP = (char *)pkt->dp_Arg2;

      RP->handle = hpkt;

      hpkt->hp_RP = RP;
      hpkt->hp_NPFlags = 0;
      hpkt->hp_NNode = nlock->NetNode;
      hpkt->hp_Driver = nlock->NetNode->driver;
      hpkt->hp_Func = NULL;

      RemotePacket(global, hpkt);
   }
}

                        /* DP_Arg1 - LONG type/flags 0=nodebug          */
                        /* DP_Arg2 - BPTR FileHandle for debug or NULL  */
                        /* DP_Res1 - BPTR old filehandle                */
ACTFN(ActSetDebug)
{
#if DEBUG
    /********************************************************************/
    /*                                                                  */
    /* Several possibilities:                                           */
    /* 1. Arg1 is 0:                                                    */
    /*       All debugging is turned off.  Arg2 is not looked at.       */
    /*       Res1 is DOS_TRUE.  Old log file is returned in dp_Res2.    */
    /*                                                                  */
    /* 2. Arg1 is a special handler-defined code:                       */
    /*       If the second bit from the top is ON, the code is a special*/
    /*       debugging command to the handler.  If the handler knows the*/
    /*       command, it returns DOS_TRUE in Res1.  If it doesn't, it   */
    /*       returns DOS_FALSE in Res1 and Res2.                        */
    /*                                                                  */
    /* 3. Neither of the above:                                         */
    /*       Arg2 contains a BPTR to a FileHandle to send debugging to. */
    /*       Note that if this is NULL, debugging will be turned off.   */
    /*       If Arg1 > 1, Arg3 contains a BSTR filename of a file on    */
    /*       network node the user wants to debug.  The debug request   */
    /*       should be passed along to that node.                       */
    /*       Res1 contains DOS_TRUE.  Old log file returned in dp_Res2. */
    /*                                                                  */
    /********************************************************************/

#define DEBUG_SPECIAL 0x40000000   /* Mask for handler-defined dbg type*/
#define DEBUG_WAIT    0x40000001   /* Wait for debugger to catch us    */
#define DEBUG_INFO    0x40000002   /* Send transmit info to msgport in */
                                   /* dp_Arg2                          */
#define DEBUG_OPKTS   0x40000003   /* Send info on outstanding hpkts   */
#define DEBUG_TERM    0x40000004   /* Terminate specified connection   */
#define DEBUG_MEMCHK  0x40000005   /* Change memory check frequency    */

   extern BPTR debuglog;
   struct DosPacket *pkt = hpkt->hp_Pkt;
   NETPTR nlock;

BUGP("ActSetDebug Entry")

   pkt->dp_Res1 = DOS_TRUE;
   pkt->dp_Res2 = 0;

   if(pkt->dp_Arg1 & DEBUG_SPECIAL) 
   {
BUGP("DEBUG_SPECIAL")
      if (pkt->dp_Arg1 == DEBUG_WAIT) 
      {
         pkt->dp_Res2 = NULL;
      } 
      else if(pkt->dp_Arg1 == DEBUG_INFO) 
      {
BUGP("DEBUG_INFO")
         global->n.infoport = (struct MsgPort *)BADDR(pkt->dp_Arg2);
         global->n.ntirec.m.mn_Node.ln_Type =
         global->n.ntitrans.m.mn_Node.ln_Type = NT_MESSAGE;
         if (!global->n.ntirec.m.mn_ReplyPort) 
         {
            global->n.ntirec.m.mn_ReplyPort =
            global->n.ntitrans.m.mn_ReplyPort = CreatePort(NULL,0);
         }
         global->n.inf_rec = global->n.inf_trans = 0L;
      }
      else if(pkt->dp_Arg1 == DEBUG_OPKTS)
      {
         HPACKET *thp;
         for(thp = global->qpkts; 
             thp && thp != (HPACKET *)pkt->dp_Arg2;
             thp = thp->hp_WNext);
         pkt->dp_Res1 = DOS_TRUE;
         pkt->dp_Res2 = (LONG)(thp ? thp->hp_WNext : global->qpkts);
      } 
      else if(pkt->dp_Arg1 == DEBUG_TERM)
      {
         if(ParseName(global, (char *)pkt->dp_Arg3, &nlock, global->work) || !nlock)
         {
            /* NET: root - what does this mean? */
            pkt->dp_Res1 = DOS_FALSE;
            pkt->dp_Res2 = ERROR_WRITE_PROTECTED;
         }
         else
         {
            struct Library *DriverBase = nlock->NetNode->driver->libbase;
            SDNTermNode(nlock->NetNode->driver->drglobal, nlock->NetNode->ioptr);
            nlock->NetNode->status = NODE_CRASHED;
            pkt->dp_Res1 = DOS_TRUE;
            pkt->dp_Res2 = 0;
            KillHPackets(global, nlock->NetNode, ERROR_OBJECT_NOT_FOUND);
         }
      }
      else if(pkt->dp_Arg1 = DEBUG_MEMCHK)
      {
         MWCheck();
         memcheck = pkt->dp_Arg2;
      }
      else 
      {
         BUGP("***Unknown debug type")
         pkt->dp_Res1 =
         pkt->dp_Res2 = DOS_FALSE;
      }
      HPQ(global, hpkt);
   }
   else
   {
      /* New handd puts '2' in arg1;  if we get '1', it's old-style and */
      /* there is no name in the dp_Arg3 field.                         */

      if(pkt->dp_Arg1 == 1 ||
         ParseName(global, (char *)pkt->dp_Arg3, &nlock, global->work))
      {
         /* It's the NET: root;  that means debug the handler */
         if(pkt->dp_Arg1) 
         {
            BUGP("Calling initdebug")
            pkt->dp_Res2 = initdebug((BPTR)pkt->dp_Arg2);
         } 
         else 
         {
            BUGP("Terminating debug")
            pkt->dp_Res2 = debuglog;
            debuglog = NULL;
         }
         HPQ(global, hpkt);
      }
      else if(!nlock)
      {
         /* No such node */
         pkt->dp_Res1 = DOS_FALSE;
         pkt->dp_Res2 = ERROR_OBJECT_NOT_FOUND;
         HPQ(global, hpkt);
      }
      else
      {
         /* It's a valid remote node */
         struct RPacket *RP;
         if(!(RP = AllocRPacket(nlock->NetNode, 0)))
         {
            pkt->dp_Res1 = DOS_FALSE;
            pkt->dp_Res2 = ERROR_NO_FREE_STORE;
            HPQ(global, hpkt);
            return;
         }
         RP->Type = pkt->dp_Type;
         RP->Arg1 = pkt->dp_Arg1;
         RP->Arg2 = 0;
         RP->DLen = 0;

         RP->handle = hpkt;

         hpkt->hp_RP = RP;
         hpkt->hp_NPFlags = 0;
         hpkt->hp_NNode = nlock->NetNode;
         hpkt->hp_Driver = nlock->NetNode->driver;

         RemotePacket(global, hpkt);
      }
   }
#endif
BUGP("Exiting")
}


void MemCleanup(void);
void MemCleanup(void)
{
}

#if MWDEBUG == 0
char *
DosAllocMem(global, len)
GLOBAL global;
long len;
{
    long *p;

    if ((p = (long *)AllocMem(len+4, MEMF_PUBLIC | MEMF_CLEAR)) == NULL) 
    {
	    /* Gee.  Out of memory AND there is nobody to tell about it ...  */
	    /* Only choice is to GURU.	Maybe we could do something clever   */
	    /* but I doubt it...					     */
	    BUG(("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n"));
	    BUG(("!!!!!!!!!!!!               !!!!!!!!\n"));
	    BUG(("!!!!!!!!!!!! OUT OF MEMORY !!!!!!!!\n"));
	    BUG(("!!!!!!!!!!!!               !!!!!!!!\n"));
	    BUG(("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n"));
	}
   else
   {
	   *p++ = len;
   }
   return((char *)p);
}

void
DosFreeMem(p)
char *p;
{
    long *lp;
    long len;

    lp = (long *)p;
    len = *--lp;
    FreeMem((char *)lp, len+4);
}

#endif
@


1.25
log
@*** empty log message ***
@
text
@d12 2
a13 2
**      $Revision: 1.24 $
**      $Date: 91/01/15 02:56:05 $
d15 3
d91 1
a91 1
   /*   34 */ { ACTION_SET_FILE_DATE,  0  | 0  | 0  | 0  , ActSetFileDate   }, /* */
@


1.24
log
@Kill outstanding HPKTs when connection terminates
@
text
@d12 2
a13 2
**      $Revision: 1.23 $
**      $Date: 91/01/11 10:38:33 $
d15 3
d279 6
@


1.23
log
@Add Network password capabilities
@
text
@d12 2
a13 2
**      $Revision: 1.22 $
**      $Date: 91/01/10 23:15:45 $
d15 3
d83 1
a83 1
   /*   30****{ ACTION_TIMER,          BP1| 0  | 0  | 0  , NULL             },*****/
d192 1
a192 3
#if TIMEDEBUG
OpenTimer(&global, CreatePort("NET timer port", 0L));
#endif
d194 1
a194 3
/* mypkt->dp_Res1 = DOS_TRUE;*/
/* retpkt(&global, mypkt);   */
/* PostTimerReq(&global); */
d196 1
a196 1
   BUGP("Net Handler Main");
d199 1
a199 1

d304 4
a307 1
                     /* Well, can't think of anything I can do.  Can you? */
d380 30
d464 6
d691 1
@


1.22
log
@*** empty log message ***
@
text
@d12 2
a13 2
**      $Revision: 1.21 $
**      $Date: 91/01/06 20:55:55 $
d15 3
d84 2
a85 2
   /*   52 */ { ACTION_READ,           0  | 0  | 0  | 0  , ActRead          }, /* */
   /*   57 */ { ACTION_WRITE,          0  | 0  | 0  | 0  , ActWrite         }, /* */
d107 1
a107 1
   /* 2012 */ { ACTION_NETWORK_HELLO,  BP1| 0  | 0  | 0  , ActNetHello      }, /* */
d113 1
a113 1
   /* 5557****{ ACTION_NETWORK_KLUDGE, BP1| BP2| 0  | 0  , NULL             },*****/
d456 4
d462 99
a560 2
   hpkt->hp_Pkt->dp_Res1 = DOS_TRUE; /* ???  */
   HPQ(global, hpkt);
@


1.21
log
@Revise debugging messages
@
text
@d12 2
a13 2
**      $Revision: 1.20 $
**      $Date: 90/12/31 15:33:28 $
d15 3
d273 9
a281 5
                     BUG(("RCV 0x%08lx type %d args (%08lx,%08lx,%08lx,%08lx)\n",
                        hpkt->hp_Pkt, hpkt->hp_Pkt->dp_Type, 
                        hpkt->hp_Pkt->dp_Arg1, hpkt->hp_Pkt->dp_Arg2, 
                        hpkt->hp_Pkt->dp_Arg3, hpkt->hp_Pkt->dp_Arg4))

@


1.20
log
@change packet array
@
text
@d12 2
a13 2
**      $Revision: 1.19 $
**      $Date: 90/12/30 15:45:48 $
d15 3
a197 2
      BUG(("Waiting for packet. . ."));

d221 5
d269 6
a311 2
      BUG(("action #%ld\n", action));

a341 1
         BUG(("main: calling subr\n"));
a342 1
         BUG(("main: back from subr\n"));
d347 1
a347 1
         BUG(("Unknown packet type %ld\n",dpkt->dp_Type));
a349 2

           BUG(("-----\n"));
a375 1
   BUG(("retpkt: Entry, hpkt 0x%08lx\n", hpkt))
a400 3
            BUG(("retpkt: replyport 0x%08lx mess 0x%08lx Res1 %d Res2 %d\n",
               pkt->dp_Port, pkt->dp_Link, pkt->dp_Res1, pkt->dp_Res2));

d416 4
a426 1
   BUG(("retpkt: Exit\n"))
d429 1
d444 1
a500 1
      BUG(("ActSetDebug: Special debug packet %lx\n", pkt->dp_Arg1))
d551 1
a551 1
BUGP("Unknown debug type")
@


1.19
log
@Add ActNetInit, renumber several actions
Implement MEMCHK debugging
@
text
@d12 2
a13 2
**      $Revision: 1.14 $
**      $Date: 90/11/29 02:00:20 $
d15 4
d74 1
a74 1
   /*   40****{ ACTION_SAME_LOCK,      0  | 0  | 0  | 0  , NULL             },*****/
d84 2
a85 4
   /* 1009****{ ACTION_FINDREADONLY,   0  | 0  | 0  | 0  , NULL             },*****/
   /* 1010****{ ACTION_FINDONEWRITER,  0  | 0  | 0  | 0  , NULL             },*****/
   /* 1020****{ ACTION_FORMAT,         0  | 0  | 0  | 0  , NULL             },*****/
   /* 1021****{ ACTION_MAKE_LINK,      0  | 0  | 0  | 0  , NULL             },*****/
d89 1
a89 1
   /* 1026****{ ACTION_FH_FROM_LOCK,   0  | 0  | 0  | 0  , NULL             },*****/
d91 5
a95 5
   /* 1028****{ ACTION_CHANGE_MODE,    0  | 0  | 0  | 0  , NULL             },*****/
   /* 1030****{ ACTION_COPY_DIR_FH,    0  | 0  | 0  | 0  , NULL             },*****/
   /* 1031****{ ACTION_PARENT_FH,      0  | 0  | 0  | 0  , NULL             },*****/
   /* 1033****{ ACTION_EXAMINE_ALL,    0  | 0  | 0  | 0  , NULL             },*****/
   /* 1034****{ ACTION_EXAMINE_FH,     0  | 0  | 0  | 0  , NULL             },*****/
d101 4
a104 4
   /* 5554****{ ACTION_NETWORK_START,  0  | 0  | 0  | 0  , ActNetStart      },*****/
   /* 5555****{ ACTION_NETWORK_INIT,   0  | 0  | 0  | 0  , ActNetInit       },*****/
   /* 5556****{ ACTION_NETWORK_TERM,   0  | 0  | 0  | 0  , ActNetTerm       },*****/
   /* 5557****{ ACTION_NETWORK_KLUDGE, BP1| BP2| 0  | 0  , ActNetKludge     },*****/
@


1.18
log
@Implement memory debugging
Implement reestablishing of shared locks
@
text
@d9 8
d22 1
d88 1
a88 1
   /* 1027****{ ACTION_IS_FILESYSTEM,  0  | 0  | 0  | 0  , ActIsFS          },*****/
d94 1
a94 1
   /* 2010 */ { ACTION_HANDLER_DEBUG,  0  | 0  | 0  | 0  , ActSetDebug      }  /* */
d96 1
a96 1
   /* 2012****{ ACTION_NETWORK_HELLO,  BP1| 0  | 0  | 0  , ActNetHello      },*****/
d99 4
a102 3
   /* 5554****{ ACTION_NETWORK_START,  0  | 0  | 0  | 0  , RmtNetStart      },*****/
   /* 5555****{ ACTION_NETWORK_STOP,   0  | 0  | 0  | 0  , RmtNetStop       },*****/
   /* 5556****{ ACTION_NETWORK_KLUDGE, BP1| BP2| 0  | 0  , ActNetKludge     } *****/
d199 3
a201 1
         MWCheck();
a240 2
            MWCheck();

d478 1
d535 5
@


1.17
log
@Fix minor syntax error
@
text
@d120 2
d189 2
d229 2
d345 2
d360 6
a365 1
   if(func=hpkt->hp_Func)
d367 37
a403 34
      /* The secondary function must be called.  If the packet is to be */
      /* returned after this call, the secondary function will be NULL  */
      /* after it is called.  If there is more to do, the secondary     */
      /* function itself will replace the function pointer and requeue  */
      /* the packet when appropriate.                                   */

      hpkt->hp_Func = NULL;
      (*func)(global, hpkt);
   }

   if(!hpkt->hp_Func)
   {
      /* No more functions, might as well get rid of it now */
      pkt = hpkt->hp_Pkt;

      BUG(("retpkt: replyport 0x%08lx mess 0x%08lx Res1 %d Res2 %d\n",
         pkt->dp_Port, pkt->dp_Link, pkt->dp_Res1, pkt->dp_Res2));

      if (hpkt->hp_PktFlags & BP1) pkt->dp_Arg1 >>= 2;
      if (hpkt->hp_PktFlags & BP2) pkt->dp_Arg2 >>= 2;
      if (hpkt->hp_PktFlags & BP3) pkt->dp_Arg3 >>= 2;
      if (hpkt->hp_PktFlags & BP4) pkt->dp_Arg4 >>= 2;

      replyport	     = pkt->dp_Port;
      mess	           = pkt->dp_Link;
      pkt->dp_Port     = global->n.port;

      if(hpkt->hp_RP)
      {
        DriverBase = hpkt->hp_Driver->libbase;
        SDNFreeRPacket(hpkt->hp_Driver->drglobal, hpkt->hp_RP);
      }

      PutMsg(replyport, mess);
d405 2
a406 1
      FreeHPacket(global, hpkt);
d467 1
d508 17
d598 1
a598 1

d636 1
@


1.16
log
@Implement forwardpkt for future use
@
text
@d397 1
a398 1
   struct DosPacket *pkt = hpkt->hp_Pkt;
@


1.15
log
@*** empty log message ***
@
text
@d379 1
a379 1
      pkt->dp_Port    = global->n.port;
d395 14
@


1.14
log
@,
@
text
@a119 4
#if DEBUG
   maybedebug();
#endif

d435 1
d466 9
@


1.13
log
@Fix bug with regard to queueing waiting packets
@
text
@d12 1
d14 1
d100 1
a100 1
void main(int argc, char *argv[]);
d103 1
a103 1
main(int argc, char *argv[])
d411 1
a455 1
         cprwait(global);
a477 1
#if DEBUG
d535 44
@


1.12
log
@*** empty log message ***
@
text
@d254 1
a254 1
                        else    global.qpkts = NULL;
d256 1
a256 1
                        HPQ(&global, hpkt);
d324 1
a324 2
         /* Queue the packet up for processing */
         HPQ(&global, hpkt);
@


1.11
log
@Many bug fixes, incl. proper passing of the res1 and res2 fields
@
text
@d104 1
a104 1
   HPACKET          *thp;
d247 16
a262 2
                     hpkt->hp_RP = RP;
                     HPQ(&global, hpkt);
@


1.10
log
@New cut that (almost) works
@
text
@d197 1
a197 2
         /* Check for new messages from the application */
         if(msg = GetMsg(global.n.port))
d199 2
a200 3
            /* This is a NEW packet from an application */
            pkt = (struct DosPacket *)msg->mn_Node.ln_Name;
            if(!(hpkt = GetHPacket(&global)))
d202 23
a224 6
               pkt->dp_Res1 = DOS_FALSE;
               pkt->dp_Res2 = ERROR_NO_FREE_STORE;
               replyport = pkt->dp_Port;
               msg = pkt->dp_Link;
               pkt->dp_Port = global.n.port;
               PutMsg(replyport, msg);
a225 13
            else
            {
               /* We have a new hpkt structure - initialize it */
               hpkt->hp_Pkt = pkt;
               hpkt->hp_NNode = NULL;
               hpkt->hp_RP = NULL;
               hpkt->hp_Driver = NULL;
               hpkt->hp_Func = NULL;
               hpkt->hp_NPFlags = 0;
               hpkt->hp_PktFlags = 0;
            }
            break;
         }
a226 2
         if(driver == NULL)
         {
a228 1
            continue;
d333 24
a356 4
    struct Message *mess;
    struct MsgPort *replyport;
    struct DosPacket *pkt;
    struct Library *DriverBase;
d358 11
a368 29
    if(hpkt->hp_Func)
    {
       /* The secondary function must be called - it will requeue the item  */
       /* with a null function when it is to be returned to the application */
       (*hpkt->hp_Func)(global, hpkt);
    }
     else
    {
       pkt = hpkt->hp_Pkt;

       BUG(("retpkt: Enter, replyport %08lx mess %08lx\n",
          pkt->dp_Port, pkt->dp_Link));

       if (hpkt->hp_PktFlags & BP1) pkt->dp_Arg1 >>= 2;
       if (hpkt->hp_PktFlags & BP2) pkt->dp_Arg2 >>= 2;
       if (hpkt->hp_PktFlags & BP3) pkt->dp_Arg3 >>= 2;
       if (hpkt->hp_PktFlags & BP4) pkt->dp_Arg4 >>= 2;

       replyport	     = pkt->dp_Port;
       mess	           = pkt->dp_Link;
       pkt->dp_Port    = global->n.port;

       if(hpkt->hp_RP)
       {
         DriverBase = hpkt->hp_Driver->libbase;
         SDNFreeRPacket(hpkt->hp_Driver->drglobal, hpkt->hp_RP);
       }

       PutMsg(replyport,mess);
d370 10
a379 2
       FreeHPacket(global, hpkt);
    }
d381 1
a381 1
    BUG(("retpkt: Exit\n"))
@


1.9
log
@fix probs
,
@
text
@d77 1
a77 1
   /* 1027****{ ACTION_IS_FILESYSTEM,  0  | 0  | 0  | 0  , NULL             },*****/
d249 1
a249 4
                     if(hpkt->hp_Func)
                        (*hpkt->hp_Func)(&global, hpkt);
                     else
                        retpkt(&global, hpkt);
a307 1
#if DEBUG
d311 2
a313 1
#endif
d337 1
d361 6
d392 1
a392 1
    /*       Res1 is DOS_TRUE, Res2 is a BPTR to the old filehandle.    */
d403 4
a406 3
    /*       Res1 contains DOS_TRUE, Res2 contains a BPTR to the old    */
    /*       debugging FileHandle, which may of course be NULL if no    */
    /*       debugging was on before.                                   */
a410 1
#define DEBUG_SERVER  0x20000000   /* Mask indicating server command   */
d417 1
a420 1
   HPQ(global, hpkt);
d423 1
d452 1
d455 1
a455 1
   else if(pkt->dp_Arg1) 
d457 52
a508 8
BUGP("Calling initdebug")
      pkt->dp_Res2 = initdebug((BPTR)pkt->dp_Arg2);
   } 
   else 
   {
BUGP("Terminating debug")
      pkt->dp_Res2 = debuglog;
      debuglog = NULL;
@


1.8
log
@New cut that (almost) works
@
text
@d248 1
@


1.7
log
@Fix obvious errors with previous rewrite
@
text
@d187 2
d190 9
a198 1
         for(hpkt=global.donepkts; hpkt; hpkt=thp)
d200 23
a222 2
            thp=hpkt->hp_WNext;
            retpkt(&global, hpkt);
a223 1
         global.donepkts = NULL;
d229 1
a265 26
         /* Check for new messages from the application */
         if(msg = GetMsg(global.n.port))
         {
            /* This is a NEW packet from an application */
            pkt = (struct DosPacket *)msg->mn_Node.ln_Name;
            if(!(hpkt = GetHPacket(&global)))
            {
               pkt->dp_Res1 = DOS_FALSE;
               pkt->dp_Res2 = ERROR_NO_FREE_STORE;
               replyport = pkt->dp_Port;
               msg = pkt->dp_Link;
               pkt->dp_Port = global.n.port;
               PutMsg(replyport, msg);
            }
            else
            {
               /* We have a new hpkt structure - initialize it */
               hpkt->hp_Pkt = pkt;
               hpkt->hp_NNode = NULL;
               hpkt->hp_RP = NULL;
               hpkt->hp_Driver = NULL;
               hpkt->hp_Func = NULL;
               hpkt->hp_NPFlags = 0;
               hpkt->hp_PktFlags = 0;
            }
         }
a339 7
    pkt = hpkt->hp_Pkt;

    if (hpkt->hp_PktFlags & BP1) pkt->dp_Arg1 >>= 2;
    if (hpkt->hp_PktFlags & BP2) pkt->dp_Arg2 >>= 2;
    if (hpkt->hp_PktFlags & BP3) pkt->dp_Arg3 >>= 2;
    if (hpkt->hp_PktFlags & BP4) pkt->dp_Arg4 >>= 2;

d342 2
d346 1
a346 1
    else
d348 3
a350 1
       BUG(("retpkt: Enter, replyport %08lx mess %08lx\n", 
d353 5
d363 2
a365 2

    FreeHPacket(global, hpkt);
@


1.6
log
@Rewrite for asynchronous execution
@
text
@d178 2
d187 8
a234 8
         /* Clear up any packets waiting for our action */
         for(hpkt=global.donepkts; hpkt; hpkt=thp)
         {
            thp=hpkt->hp_WNext;
            retpkt(&global, hpkt);
         }
         global.donepkts = NULL;

a328 34
void freehpkt(GLOBAL global, HPACKET *hpkt)
{
   struct Library *DriverBase;

#if 0
/* Am I supposed to be doing this? djw */
   if(hpkt->hp_RP)
   {
      DriverBase = hpkt->hp_Driver->libbase;
      SDNFreeRPacket(hpkt->hp_Driver->drglobal, hpkt->hp_RP);
   }
#endif

   if(hpkt->hp_Next == HPACKET_PERM)
      hpkt->hp_State = HPS_FREE;
   else
   {
      HPACKET *thp;
      if(global->tmphpkt == hpkt)
         global->tmphpkt = hpkt->hp_Next;
      else
      {
         for(thp=global->tmphpkt; thp && thp->hp_Next != hpkt; thp=thp->hp_Next);
         if(thp) 
         {
            thp->hp_Next = hpkt->hp_Next;
            DosFreeMem((char *)hpkt);
         }
         else 
            BUGR("HPACKET NOT ON CHAIN!");  /* Better not free it... */
      }
   }
}

d358 1
a358 1
    freehpkt(global, hpkt);
@


1.5
log
@New version
@
text
@d12 2
a28 2
typedef void (*ifuncp)(GLOBAL, struct DosPacket *);

d94 1
d103 3
a105 1
   struct DosPacket   *mypkt;       /* a pointer to the dos packet sent       */
d108 1
d112 5
a116 4

// Startup code does this now
//   SysBase = (*((struct Library **) 4));
//   DOSBase = (struct DosLibrary *)OpenLibrary(DOSNAME,0);
a161 12
#if 0
   /* since we were started as a non-BCPL module we get sent the parameter */
   /* packet (ie. parameter packet not in D1) */
   mypkt = taskwait(&global);  /* wait for parameter packet */

   global.n.devname  = (((char *)BADDR(mypkt->dp_Arg1))+1);  /* BSTR name */

   /* get pointer to our device node */
   global.node = (struct DeviceNode *) BADDR(mypkt->dp_Arg3);
   global.node->dn_Task = global.n.port;
#endif

d164 1
a164 1
   BUGP("Net Handler Inited");
d178 1
d182 81
a262 1
      mypkt = taskwait(&global);  /* wait for a packet */
d264 1
a264 1
      action = mypkt->dp_Type;
d286 2
a287 2
      mypkt->dp_Res1 = DOS_FALSE;
      mypkt->dp_Res2 = ERROR_ACTION_NOT_KNOWN;
d292 5
a296 4
         if (flags & BP1) mypkt->dp_Arg1 <<= 2;
         if (flags & BP2) mypkt->dp_Arg2 <<= 2;
         if (flags & BP3) mypkt->dp_Arg3 <<= 2;
         if (flags & BP4) mypkt->dp_Arg4 <<= 2;
d299 1
a299 1
         (*subr)(&global, mypkt);
a301 4
         if (flags & BP1) mypkt->dp_Arg1 >>= 2;
         if (flags & BP2) mypkt->dp_Arg2 >>= 2;
         if (flags & BP3) mypkt->dp_Arg3 >>= 2;
         if (flags & BP4) mypkt->dp_Arg4 >>= 2;
d306 1
a306 1
         BUG(("Unknown packet type %ld\n",mypkt->dp_Type));
a309 4
           /* Now return the packet to them */
           if (global.n.reply)
              retpkt (&global, mypkt);

a319 2
    ClearPacketBuffer(&global.RP);

d327 70
a396 4
void
ActNetHello(global, pkt)
GLOBAL global;
struct DosPacket *pkt;
d398 2
a399 1
    pkt->dp_Res1 = DOS_TRUE; /* ???  */
d402 1
a402 4
void
ActSetDebug(global, pkt)  /* ACTION_HANDLER_DEBUG */
GLOBAL global;
struct DosPacket *pkt;  /* DP_Arg1 - LONG type/flags 0=nodebug          */
d405 1
a434 1
   struct NetNode *netnode;
d436 1
d440 1
d442 2
a443 1
   if (pkt->dp_Arg1 & DEBUG_SPECIAL) 
d452 1
a452 1
      else if (pkt->dp_Arg1 == DEBUG_INFO) 
a464 9
      else if (pkt->dp_Arg1 & DEBUG_SERVER) 
      {
BUGP("DEBUG_SERVER")
         global->RP.Type = ACTION_HANDLER_DEBUG;
         global->RP.Arg1 = pkt->dp_Arg1 & ~(DEBUG_SERVER|DEBUG_SPECIAL);
         BUG(("Remote debugging code %lx\n", global->RP.Arg1))
         for(netnode=global->netchain.next; netnode; netnode=netnode->next)
            RemotePacket(global, &netnode->RootLock, &global->RP);
      } 
d473 1
a473 1
   else if (pkt->dp_Arg1) 
@


1.4
log
@Change handler to be a process
@
text
@d175 4
a178 1
/* OpenTimer(&global); */
d254 4
@


1.3
log
@Eliminate RDevice
@
text
@d22 5
d97 1
a97 1
void handler(char *x);
d100 1
a100 2
handler(x)
char *x;
d109 3
a111 2
   SysBase = (*((struct Library **) 4));
   DOSBase = (struct DosLibrary *)OpenLibrary(DOSNAME,0);
d122 1
a122 1
   global.n.port   = &(global.n.self->pr_MsgPort);
d155 3
d167 1
d171 2
d176 3
d180 1
a180 4
   mypkt->dp_Res1 = DOS_TRUE;
   retpkt(&global, mypkt);

/* PostTimerReq(&global); */
@


1.2
log
@Change dispatcher to use table lookup for actions
@
text
@a24 4
    ifuncp  subr;
    int     flags;
};
struct LookupTable {
d33 1
a33 1
   /*    7 */ { ACTION_CURRENT_VOLUME, BP1| 0  | 0  | 0  , ActCurrentVol    }, /* */
d78 1
a78 1
   /* 2010 */ { ACTION_HANDLER_DEBUG,  0  | 0  | 0  | 0  , ActSetDebug      }, /* */
d83 3
a85 2
   /*~2MEG */ { ACTION_NETWORK_START,  0  | 0  | 0  | 0  , ActNetStart      }, /* */
   /*~4MEG */ { ACTION_NETWORK_KLUDGE, BP1| BP2| 0  | 0  , ActNetKludge     }  /* */
d89 1
a89 1

d92 1
a92 1
void _main(char *x);
d95 1
a95 1
_main(x)
d105 1
a151 1

d183 1
a183 1
      while (low < high)
d189 1
a189 1
            subr = worktab[this].flags;
d321 2
a322 7
         for (netnode=global->netchain.next; netnode; netnode=netnode->next) 
         {
            if (netnode->status == NODE_UP && netnode->RootLock.RDevice) 
            {
               RemotePacket(global, &netnode->RootLock, &global->RP);
            }
         }
@


1.1
log
@Initial revision
@
text
@d28 63
a91 57
#define LO_FIRST 0
#define LO_LAST  34
struct LookupTable lowork[LO_LAST+1] = {
   { NULL,              0  | 0  | 0  | 0   }, /*  0 - ACTION_NIL           */
   { NULL,              0  | 0  | 0  | 0   }, /*  1 - Unknown              */
   { NULL,              BP1| BP2| BP3| 0   }, /*  2 - ACTION_GET_BLOCK     */
   { NULL,              0  | BP2| BP3| 0   }, /*  3 - Unknown              */
   { NULL,              BP1| BP2| BP3| 0   }, /*  4 - ACTION_SET_MAP       */
   { ActDie,            0  | 0  | 0  | 0   }, /*  5 - ACTION_DIE           */
   { NULL,              0  | 0  | 0  | 0   }, /*  6 - ACTION_EVENT         */
   { ActCurentVol,      BP1| 0  | 0  | 0   }, /*  7 - ACTION_CURRENT_VOLUME*/
   { ActLock,           BP1| BP2| 0  | 0   }, /*  8 - ACTION_LOCATE_OBJECT */
   { ActRenameDisk,     BP1| BP2| 0  | 0   }, /*  9 - ACTION_RENAME_DISK   */
   { NULL,              0  | 0  | 0  | 0   }, /* 10 - Unknown              */
   { NULL,              0  | 0  | 0  | 0   }, /* 11 - Unknown              */
   { NULL,              0  | 0  | 0  | 0   }, /* 12 - Unknown              */
   { NULL,              0  | 0  | 0  | 0   }, /* 13 - Unknown              */
   { NULL,              0  | 0  | 0  | 0   }, /* 14 - Unknown              */
   { ActUnLock,         BP1| 0  | 0  | 0   }, /* 15 - ACTION_FREE_LOCK     */
   { ActDelete,         BP1| BP2| 0  | 0   }, /* 16 - ACTION_DELETE_OBJECT */
   { ActRename,         BP1| BP2| BP3| BP4 }, /* 17 - ACTION_RENAME_OBJECT */
   { NULL,              0  | 0  | 0  | 0   }, /* 18 - ACTION_MORE_CACHE    */
   { ActDupLock,        BP1| 0  | 0  | 0   }, /* 19 - ACTION_COPY_DIR      */
   { NULL,              0  | 0  | 0  | 0   }, /* 20 - ACTION_WAIT_CHAR     */
   { ActSetProtection,  0  | BP2| BP3| 0   }, /* 21 - ACTION_SET_PROTECT   */
   { ActCreateDir,      BP1| BP2| 0  | 0   }, /* 22 - ACTION_CREATE_DIR    */
   { ActExamine,        BP1| BP2| 0  | 0   }, /* 23 - ACTION_EXAMINE_OBJECT*/
   { ActExNext,         BP1| BP2| 0  | 0   }, /* 24 - ACTION_EXAMINE_NEXT  */
   { ActDiskInfo,       BP1| 0  | 0  | 0   }, /* 25 - ACTION_DISK_INFO     */
   { ActInfo,           BP1| BP2| 0  | 0   }, /* 26 - ACTION_INFO          */
   { ActFlush,          0  | 0  | 0  | 0   }, /* 27 - ACTION_FLUSH         */
   { ActSetComment,     0  | BP2| BP3| BP4 }, /* 28 - ACTION_SET_COMMENT   */
   { ActParent,         BP1| 0  | 0  | 0   }, /* 29 - ACTION_PARENT        */
   { NULL,              BP1| 0  | 0  | 0   }, /* 30 - ACTION_TIMER         */
   { ActInhibit,        0  | 0  | 0  | 0   }, /* 31 - ACTION_INHIBIT       */
   { NULL,              BP1| 0  | 0  | 0   }, /* 32 - ACTION_DISK_TYPE     */
   { NULL,              0  | 0  | 0  | 0   }, /* 33 - ACTION_DISK_CHANGE   */
   { ActSetFileDate,    0  | BP2| BP3| 0   }  /* 34 - ACTION_SET_FILE_DATE */
      };

#define HI_FIRST 1004
#define HI_LAST  1008
struct LookupTable hiwork[5] = {
   { ActFindwrite,      BP1| BP2| BP3| 0   }, /* ACTION_FIND_WRITE  - 1004 */
   { ActFindwrite,      BP1| BP2| BP3| 0   }, /* ACTION_FIND_INPUT  - 1005 */
   { ActFindwrite,      BP1| BP2| BP3| 0   }, /* ACTION_FIND_OUTPUT - 1006 */
   { ActEnd,            0  | 0  | 0  | 0   }, /* ACTION_END         - 1007 */
   { ActSeek,           0  | 0  | 0  | 0   }  /* ACTION_SEEK        - 1008 */
   };

#define USER_FIRST 2010
#define USER_LAST  2012
struct LookupTable userwork[3] = {
   { ActSetDebug,       0  | 0  | 0  | 0   }, /* ACTION_HANDLER_DEBUG 2010 */
   { NULL,              BP1| 0  | 0  | 0   }, /* ACTION_SET_TRANS_TYPE2011 */
   { ActNetHello,       BP1| 0  | 0  | 0   }, /* ACTION_NETWORK_HELLO 2012 */
   };
d103 1
d183 4
a186 1
      switch (action) 
d188 11
a198 46
         case ACTION_NETWORK_KLUDGE:
            subr = ActNetKludge;
            flags = (BP1 | BP2);
            break;

         case ACTION_READ:
            subr = ActRead;
            flags = 0;
            break;

         case ACTION_WRITE:
            subr = ActWrite;
            flags = 0;
            break;

         case ACTION_SET_RAW_MODE:
            subr = NULL;
            flags = 0;
            break;

         case ACTION_FIND_WRITE:  /* 1004 */
         case ACTION_FIND_INPUT:  /* 1005 */
         case ACTION_FIND_OUTPUT: /* 1006 */
         case ACTION_END:        /* 1007 */
         case ACTION_SEEK:       /* 1008 */
            subr = hiwork[action-HI_FIRST].subr;
            flags = hiwork[action-HI_FIRST].flags;
            break;

         case ACTION_HANDLER_DEBUG:  /* 2010 */
         case ACTION_SET_TRANS_TYPE: /* 2011 */
         case ACTION_NETWORK_HELLO:  /* 2012 */
            subr = userwork[action-USER_FIRST].subr;
            flags = userwork[action-USER_FIRST].flags;
            break;

         default:
            if ((action >= LO_FIRST) && (action <= LO_LAST)) 
            {
               subr = lowork[action-LO_FIRST].subr;
               flags = lowork[action-LO_FIRST].flags;
            } 
            else 
            {
               subr = NULL;
            }
@
