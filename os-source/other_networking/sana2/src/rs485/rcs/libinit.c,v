head     1.7;
branch   ;
access   ;
symbols  ;
locks    kcd:1.7; strict;
comment  @ * @;


1.7
date     91.12.30.18.34.08;  author dlarson;  state Exp;
branches ;
next     1.6;

1.6
date     91.12.13.11.53.51;  author dlarson;  state Exp;
branches ;
next     1.5;

1.5
date     91.12.03.14.29.50;  author dlarson;  state Exp;
branches ;
next     1.4;

1.4
date     91.12.03.14.07.12;  author dlarson;  state Exp;
branches ;
next     1.3;

1.3
date     91.11.27.15.49.45;  author dlarson;  state Exp;
branches ;
next     1.2;

1.2
date     91.11.19.09.48.35;  author dlarson;  state Exp;
branches ;
next     1.1;

1.1
date     91.10.21.15.37.14;  author dlarson;  state Exp;
branches ;
next     ;


desc
@Original snapshot from Ameristar
@


1.7
log
@Includes various optimizations and the long packet Christmas fix.  Probably
last working version before enhancements and Novell "ARCNET Packet Header
Definition Standard."
@
text
@#ifndef RS485_H
#include "rs485.h"
#endif

#include "rs485.device_rev.h"

typedef LONG (*PFL)();   /* pointer to function returning 32-bit int        */

/* library initialization table, used for AUTOINIT libraries                */
struct InitTable {
        ULONG        *it_DataSize;        /* library data space size         */
        PFL          *it_FuncTable;      /* table of entry points           */
        APTR         it_DataInit;        /* table of data initializers      */
        PFL          it_InitFunc;        /* initialization function to run  */
};

extern PFL _LibFuncTab[];      /* my function table (Generated by Blink) */

extern char __far RESLEN;
extern long __far NEWDATAL; /* Generated by BLINK */
#define DATAWORDS ((long)&NEWDATAL)

struct InitTable __far _LibInitTab =  {
        (long *)(&RESLEN+sizeof(struct rs485Device)),
        _LibFuncTab,
        NULL,                        /* will initialize my own data */
        _LibInit,
};
extern long far _Libmergeddata;    /* Need this to determine start of MERGED DATA */


__saveds __stdargs __asm
ULONG _LibInit( register __a0 APTR seglist,
        register __d0 struct rs485Device *libbase )
{
	long *sdata, *reloc;
	char *ddata;
	long nrelocs;

        libbase->ml_SegList = (ULONG) seglist;

        /* init. library structure (since I don't do automatic data init.) */
        libbase->ml_Lib.lib_Node.ln_Type = NT_DEVICE;
        libbase->ml_Lib.lib_Node.ln_Name =  _LibName;
        libbase->ml_Lib.lib_Flags = LIBF_SUMUSED | LIBF_CHANGED;
        libbase->ml_Lib.lib_Version = VERSION;
        libbase->ml_Lib.lib_Revision = REVISION;
        libbase->ml_Lib.lib_IdString = (APTR)VSTRING;

	ddata = (char *)(libbase + 1);
	sdata = (long *)&_Libmergeddata;
	memcpy(ddata, (char *)sdata, DATAWORDS*4);

	sdata = sdata + DATAWORDS;
	nrelocs = *sdata++;

	while (nrelocs > 0)
	{
		reloc = (long *)((long)ddata + *sdata++);
		*reloc += (long)ddata;
		nrelocs--;
	}

        /* ----- Do library specific public initialization here ----- */

        return ( (ULONG) libbase );
}

LONG __saveds __stdargs __asm
_LibOpen( register __a6 struct rs485Device *libbase,
	  register __a1 struct IOSana2Req *iob,
	  register __d0 long unit,
	  register __d1 long flags )
{
	rs485Open(libbase, iob, unit, flags);
	if(iob->ios2_Req.io_Error == S2ERR_NO_ERROR){
	        libbase->ml_Lib.lib_OpenCnt++;
	        libbase->ml_Lib.lib_Flags &= ~LIBF_DELEXP;
	}
        return ( (LONG) libbase );
}

ULONG __saveds __stdargs __asm
_LibClose( register __a6 struct rs485Device *libbase,
	   register __a1 struct IOSana2Req *iob )
{
        ULONG retval = 0;

	--libbase->ml_Lib.lib_OpenCnt;

	rs485Close(libbase, iob);

        if(libbase->ml_Lib.lib_OpenCnt==0 && (libbase->ml_Lib.lib_Flags&LIBF_DELEXP)){
                retval = _LibExpunge( libbase ); /* return segment list        */
        }

        return (retval);
}

ULONG __saveds __stdargs __asm
_LibExpunge( register __a6 struct rs485Device *libbase )
{
        ULONG seglist = 0;
        LONG  libsize;

        libbase->ml_Lib.lib_Flags |= LIBF_DELEXP;
        if(libbase->ml_Lib.lib_OpenCnt == 0)
        {
		rs485Expunge(libbase);
                seglist = libbase->ml_SegList;
                Remove((struct Node *)libbase);
                libsize = libbase->ml_Lib.lib_NegSize + libbase->ml_Lib.lib_PosSize;
                FreeMem((char *)libbase - libbase->ml_Lib.lib_NegSize,(LONG) libsize );
        }

        return((ULONG)seglist);
}

@


1.6
log
@raw reads and writes work now.
@
text
@@


1.5
log
@doesn't print debugging messages...  (bad programmer)
@
text
@@


1.4
log
@Fixed online/offline/onevent.
@
text
@@


1.3
log
@First version which works with inet.library!!!
@
text
@@


1.2
log
@Getting it up to current spec...
@
text
@d1 2
a2 2
#ifndef AMIGANET_H
#include "amiganet.h"
d5 1
a5 1
#include "amiganet.device_rev.h"
d24 1
a24 1
        (long *)(&RESLEN+sizeof(struct AmiganetDevice)),
d34 1
a34 1
        register __d0 struct AmiganetDevice *libbase )
d48 1
a48 1
        libbase->ml_Lib.lib_IdString = (APTR)VSTRING VERSTAG;
d70 1
a70 1
_LibOpen( register __a6 struct AmiganetDevice *libbase,
d75 1
a75 1
	AmiganetOpen(libbase, iob, unit, flags);
d84 1
a84 1
_LibClose( register __a6 struct AmiganetDevice *libbase,
d91 1
a91 1
	AmiganetClose(libbase, iob);
d101 1
a101 1
_LibExpunge( register __a6 struct AmiganetDevice *libbase )
d107 3
a109 2
        if(libbase->ml_Lib.lib_OpenCnt == 0){
		AmiganetExpunge(libbase);
@


1.1
log
@Initial revision
@
text
@d5 1
a5 2
#include <libraries/dos.h>
#include <proto/dos.h>
a30 1
#define MYREVISION 0
d32 1
a32 1
__saveds __stdargs __asm 
d39 1
a39 1
		
d46 3
a48 3
        libbase->ml_Lib.lib_Version = 1;
        libbase->ml_Lib.lib_Revision = MYREVISION;
        libbase->ml_Lib.lib_IdString = (APTR) _LibID;
d69 2
a70 2
LONG __saveds __stdargs __asm 
_LibOpen( register __a6 struct AmiganetDevice *libbase, 
d76 1
a76 1
	if(iob->S2io_Error == S2ERR_NO_ERROR){
d83 2
a84 2
ULONG __saveds __stdargs __asm 
_LibClose( register __a6 struct AmiganetDevice *libbase, 
d100 1
a100 1
ULONG __saveds __stdargs __asm 
@
