head     1.11;
branch   ;
access   ;
symbols  ;
locks    ; strict;
comment  @@;


1.11
date     93.12.14.15.00.45;  author kcd;  state Exp;
branches ;
next     1.10;

1.10
date     93.12.14.14.53.39;  author kcd;  state Exp;
branches ;
next     1.9;

1.9
date     92.05.15.10.39.56;  author dlarson;  state Exp;
branches ;
next     1.8;

1.8
date     92.05.14.15.27.33;  author dlarson;  state Exp;
branches ;
next     1.7;

1.7
date     92.02.11.13.59.01;  author dlarson;  state Exp;
branches ;
next     1.6;

1.6
date     92.01.17.09.45.32;  author dlarson;  state Exp;
branches ;
next     1.5;

1.5
date     92.01.16.15.03.39;  author dlarson;  state Exp;
branches ;
next     1.4;

1.4
date     92.01.14.10.22.38;  author dlarson;  state Exp;
branches ;
next     1.3;

1.3
date     92.01.10.15.14.08;  author dlarson;  state Exp;
branches ;
next     1.2;

1.2
date     92.01.07.11.42.05;  author dlarson;  state Exp;
branches ;
next     1.1;

1.1
date     91.12.09.07.48.25;  author dlarson;  state Exp;
branches ;
next     ;


desc
@released as "Novemeber 7 Draft for Final Comment and Approval"
@


1.11
log
@Incorporated addenda information, and added a short note in the Unresolved
Issues section about dynamic addressing.
@
text
@


     SANA-II Network Device Driver Specification - Rev 2.0 14-Dec-93

     (C) Copyright 1992,1993 Commodore-Amiga, Inc. All Rights Reserved

     Amiga Networking Group -  Randell Jesup, Kenneth Dyke

     Warning

     The information contained herein is subject to change without
     notice. Commodore specifically does not make any endorsement or
     representation with respect to the use, results, or performance of
     the information (including without limitation its capabilities,
     appropriateness, reliability, currentness or availability).

     Disclaimer

     This information is provided ``As Is'' without warranty of any
     kind, either express or implied.  The entire risk as to the use of
     this information is assumed by the user.  In no event will
     Commodore or its affiliated companies be liable for any damages,
     direct, indirect, incidental, special or consequential, resulting
     from any claim arising out of the information presented herein,
     even if it has been advised of the possibility of such damages.
     Some states do not allow the exclusion or limitation of such
     implied warranties, so the above limitations may not apply.


     SANA-II Network Device Driver Specification

     The SANA-II Network Device Driver Specification is a standard for
     an Amiga software interface between networking hardware and network
     protocol stacks (or for software tools such as network monitors).
     A network protocol stack is a layer of software that network
     applications use to address particular processes on remote machines
     and to send data reliably in spite of hardware errors. There are
     several common network protocol stacks including TCP/IP, OSI,
     AppleTalk, DECNet and Novell.

     SANA-II device drivers are intended to allow multiple network
     protocol stacks running on the same machine to share one network
     device. For example, the TCP/IP and AppleTalk protocol stacks could
     both run on the same machine over one ethernet board. The device
     drivers are also intended to allow network protocol stacks to be
     written in a hardware-independent fashion so that a different
     version of each protocol stack doesn't have to be written for each
     networking hardware device.

     The standard does not address the writing of network applications.
     Application writers must not use SANA-II Device Drivers directly.
     Network applications must use the API provided by the network
     protocol software the application supports. There is not an Amiga
     standard network API at the time of this writing, though there is
     the AS225 TCP/IP package and its socket.library as well as other
     (third-party) packages.

     To write a SANA-II device driver, you will need to be familiar with
     the specification documents for the hardware you are writing to and
     with the SANA-II Network Device Driver Specification.




     To write a network protocol stack which will use SANA-II device
     drivers, you should have general familiarity with common network
     hardware and must be very familiar with the SANA-II Network Device
     Driver Specification as well as the specification for the protocol
     you are developing. If you are creating a new protocol, you must
     obtain a protocol type number for any hardware on which your
     protocol will be used.

     Commodore supports the SANA-II specification by providing drivers
     for the Commodore-Amiga network hardware. We have an A2065.device
     (Ethernet) and intend to produce an A2060.device (ARCNET). We also
     try to examine review copies of third-party SANA-II networking
     hardware and software to try to make sure that they interoperate
     with our products.

     This standard has undergone several drafts with long periods for
     comment from developers and the Amiga community at large. These
     drafts include a UseNet release which was also distributed on the
     Fish Disks in June, 1991 (as well as published in the '91 DevCon
     notes), and the November 7 Draft for Final Comment and Approval
     distributed via Bix, ADSP and UseNet. There were also several
     intermediate drafts with more limited distribution.

     This version of the specification is final. Any new version of the
     standard (i.e., to add new features) is planned to be backward
     compatible. No SANA-II device driver or software utilizing those
     drivers should be written to any earlier version of the
     specification.

     Distribution of this version of the standard is unlimited. Anyone
     may write Amiga software which implements a SANA-II network device
     driver or which calls a SANA-II network device driver without
     restriction and may freely distribute such software that they have
     written. Amiga is a registered trademark of Commodore-Amiga, Inc.
     Ethernet is a trademark of Xerox Corporation. ARCNET is a trademark
     of Datapoint Corporation. DECNet is a trademark of Digital
     Equipment Corporation. AppleTalk is a trademark of Apple Computer,
     Inc.

     It is important to try to test each SANA-II device driver against
     all software which uses SANA-II devices. Available example programs
     are valuable in initial testing. The Amiga Networking Group is
     interested in receiving evaluation and/or beta test copies of all
     Amiga networking hardware, SANA-II device drivers and software which
     uses SANA-II devices. However, we make no assurances regarding any
     testing which we may or may not perform with such evaluation copies.
     Contact:

         Amiga Networking Group
         Commodore International Services Corporation
         Technology Group
         1200 Wilson Drive
         West Chester, PA 19380, USA




     Driver Form

     SANA-II device drivers are Amiga Exec device drivers. They use an
     extended IORequest structure and a number of extended commands for
     tallying network statistics, sending broadcasts and multicasts,
     network addressing and the handling of unexpected packets. The
     Amiga ROM Kernel Reference Manual: Devices includes information on
     how to construct an Exec device.

     Opening a SANA-II Device

     As when opening any other Exec device, on the call to OpenDevice() a
     SANA-II device receives an IORequest structure which the device
     initializes for the opener's use. The opener must copy this
     structure if it desires to use multiple asynchronous requests. The
     SANA-II IORequest is defined as follows:

     struct IOSana2Req
     {
         struct IORequest ios2_Req;
         ULONG ios2_WireError;
         ULONG ios2_PacketType;
         UBYTE ios2_SrcAddr[SANA2_MAX_ADDR_BYTES];
         UBYTE ios2_DstAddr[SANA2_MAX_ADDR_BYTES];
         ULONG ios2_DataLength;
         APTR *ios2_Data;
         APTR *ios2_StatData;
         APTR *ios2_BufferManagement;
     };

       ios2_Req              - A standard Exec device IORequest.
       ios2_WireError        - A more specific device code which may be
                               set when there is an io_Error. See
                               <devices/sana2.h> for the defined
                               WireErrors.
       ios2_PacketType       - The type of packet requested. See the
                               section on ``Packet Types''.
       ios2_SrcAddr          - The device fills in this field with the
                               interface (network hardware) address of
                               the source of the packet that satisfied
                               a read command. The bytes used to hold
                               the address will be left justified but
                               the bit layout is dependent on the
                               particular type of network.
       ios2_DstAddr          - Before the device user sends a packet, it
                               fills this with the interface destination
                               address of the packet. On receives, the
                               device fills this with the interface
                               destination address. Other commands may
                               use this field differently (see the SANA-II
                               Network Device Driver Autodocs). The
                               bytes used to hold the address will be
                               left justified but the bit layout is
                               dependent on the particular type of network.




       ios2_DataLength       - The device user initializes this field with
                               the amount of data available in the Data
                               buffer before passing the IOSana2Req to
                               the device. The device fills in this field
                               with the size of the packet data as it was
                               sent on the wire. This does not include
                               the header and trailer information.
                               Depending on the network type and protocol
                               type, the driver may have to calculate
                               this value. This is generally used only
                               for reads and writes (including broadcast
                               and multicast).
       ios2_Data             - A pointer to some abstract data structure
                               containing packet data. Drivers may not
                               directly manipulate or examine anything
                               pointed to by Data! This is generally
                               used only for reads and writes (including
                               broadcast and multicast).
       ios2_StatData         - Pointer to a structure in which to place
                               a snapshot of device statistics. The data
                               area must be long word aligned. This is
                               only used on calls to the statistics
                               commands.
       ios2_BufferManagement - The opener places a pointer to a tag list
                               in this field before calling OpenDevice().
                               Functions pointed to in the tag list are
                               called by the device when processing
                               IORequests from the opener. When returned
                               from OpenDevice(), this field contains a
                               pointer to driver-private information
                               used to access these functions.
                               See ``Buffer Management'' below for more
                               details.

     The flags used with the device on OpenDevice() are (SANA2OPB_xxx):

       SANA2OPB_MINE  - Exclusive access to the unit requested.
       SANA2OPB_PROM  - Promiscuous mode requested. Hardware which
                        supports promiscuous mode allows all packets
                        sent over the wire to be captured whether or not
                        they are addressed to this node.

			Note: Promiscuous mode requres exclusive opening
			      of the device.

     The flags used during I/O requests are (SANA2IOB_xxx):

       SANA2IOB_RAW   - Raw packet read/write requested. Raw packets
                        should include the entire data-link layer packet.
                        Devices with the same hardware device number
                        should have the same raw packet format.
       SANA2IOB_BCAST - Broadcast packet (received).
       SANA2IOB_MCAST - Multicast packet (received).
       SANA2IOB_QUICK - Quick IO requested.




     Buffer Management

     Unlike most other Exec Device drivers, SANA-II drivers have no
     internal buffers. Instead, they read/write to/from an abstract data
     structure allocated by the driver user. The driver accesses these
     buffers only via functions that the driver user provides to the
     driver. The driver user must provide two functions--one copies data
     to the abstract data structure and one copies data from the abstract
     data structure. The driver user can therefore choose the data
     structure used for buffer management by both the driver and driver
     user in order to have efficient memory and CPU usage overall.

     The IOSana2Req contains a pointer to data and the length of said
     data. A driver is not allowed to make assumptions about how the data
     is stored. The driver cannot directly manipulate or examine the
     buffer in any manner. The driver can only access the buffer by
     calling the functions provided by the driver user.

     Before calling OpenDevice(), the driver user points
     ios2_BufferManagement to a list of tags (defined in
     <devices/sana2.h>) which include pointers to the buffer management
     functions required by the driver (defined below).  The driver will
     fail to open if the driver user does not supply all of the required
     functions.  If the device opens successfully, the driver sets
     ios2_BufferManagement to a value which this opener must use in all
     future calls to the driver.  This ``magic cookie'' is used from
     then on to access these functions (a ``magic cookie'' is a value
     which one software entity passes to another but which is only
     meaningful to one of the software entities).  The driver user may
     not use the ``magic cookie'' in any way--it is for the driver to do
     with as it wishes.  The driver could in theory choose to just copy
     the tag list to driver-owned memory and then parse the list for
     every IORequest, but it is much more efficient for the driver to
     create some sort of table of functions and to point
     ios2_BufferManagement to that table.

****New

     Another recommendation for the ``magic cookie`` is to use it to
     maintain a seperate packet read queue for each device opener.  This
     would allow multiple protocol stacks that all wish to receive the
     same packet type to work together without having to "know" about
     each other as Envoy and AS225 do right now.

     The C= SLIP and A2065 driver now do this, so it would be possible
     (for example) to run Envoy, AS225 and the AmiTCP package together
     on the same hardware without conflicts.

     In order to help system load, a new callback has been added to allow
     protocol stacks to reject packets that are known to not be useful.
     Envoy's nipc.library (for example) could be modified to reject TCP
     packets (as it never uses them).

****New

     The specification currently defines three Tags for the
     OpenDevice() ios2_BufferManagement tag list:

     S2_CopyToBuff  - This is a pointer to a function which conforms to
              the CopyToBuff Autodoc.
     S2_CopyFromBuff - This is a pointer to a function which conforms to
              the CopyFromBuff Autodoc.
     S2_PacketFilter [optional] - This is a pointer to a standard Hook
     	      to be called before S2_CopyToBuff is done.  See the
     	      PacketFilter Autodoc for more information.

     Packet Type

     Network frames always have a type field associated with them. These
     type fields vary in length, position and meaning by frame type
     (frame types generally correspond one-to-one with hardware types,
     but see ``Ethernet Packet Types'' below). The meanings of the type
     numbers are always carefully defined and every type number is
     registered with some official body. Do not use a type number which
     is not registered for any standard hardware you use or in a manner
     inconsistent with that registration.

     The type field allows the SANA-II device driver to fulfill CMD_READs
     based on the type of packet the driver user wants. Multiple
     protocols can therefore run over the same wire using the same driver
     without stepping on each other's toes.




     Packet types are specified as a long word. Unfortunately, the type
     field means different things on different wires. Driver users must
     allow their software to be configured with a SANA-II device name,
     unit number and the type number(s) used by the protocol stack with
     each device. This way, if new hardware becomes available, a
     hardware manufacturer can supply a listing of type assignments to
     configure pre-existing software.

     Ethernet Packet Types

     Ethernet has a special problem with packet types. Two types of
     ethernet frames can be sent over the same wire--ethernet and 802.3.
     These frames differ in that the Type field of an ethernet frame is
     the Length field of an 802.3 frame. This creates a problem in that
     demultiplexing incoming packets can be cumbersome and inefficient,
     as well as requiring driver users to be aware of the frame type
     used.

     All 802.3 frames have numbers less than 1500 in the Type field. The
     only frames with numbers less than 1500 in the type field are 802.3
     frames. SANA-II ethernet drivers abnormally return packets
     contained in ethernet frames when the requested Type falls within
     the 802.3 range--if the Type requested is within the 802.3 range,
     the driver returns the next packet contained within an 802.3 frame,
     regardless of the type specified for the packet within the 802.3
     frame. This requires that there be no more than one driver user
     requesting 802.3 packets and that it do its own interpretation of
     the frames.

     ARCNET Frames

     ARCNET also has a special problem with framing. ARCNET frames
     consist of a hardware header and a software header. The software
     header is in the data area of the hardware packet, and includes at
     least the protocol ID.

     There are two types of software header. Old-style ARCNET software
     headers consist entirely of a one or two byte protocol ID. New
     ARCNET software headers (defined in RFC 1201 and in the paper
     ``ARCNET Packet Header Definition Standard'', Novell, Inc., 1989)
     include more information. They allow more efficient use of ARCNET
     through data link layer fragmentation and reassembly (ARCNET has a
     small Maximum Transmission Unit) and allow sending any size packet up
     to the MTU (rather than requiring that packets of size 253, 254 and
     255 be padded to at least 256 bytes).

     SANA-II device drivers for ARCNET should implement the old ARCNET
     packet headers. Driver users which wish to interoperate with
     platforms using the new software headers must add the new fields to
     the data to be sent and must process it for incoming data. A
     SANA-II driver which implemented the data link layer fragmentation
     internally (and advertised a large MTU) could be more efficient than
     requiring the driver user to do it. This would make driver writing
     more difficult and reduce interoperability, but if there is ever a
     demand for that extra performance, a new hardware type may be
     assigned by Commodore for SANA-II ARCNET device drivers which
     implement the new framing.




     Addressing

     In the SANA-II standard, network hardware addresses are stored in an
     array of n bytes. No meaning is ascribed by the standard to the
     contents of the array.

     In case there exists a network which does not have an address field
     consisting of a number of bits not divisible by eight, add pad bits
     at the end of the bit stream. For example, if an address is ten
     bits long it will be stored like this:

         98765432 10PPPPPP
         BYTE 0   BYTE 1

     Where the numerals are bit numbers and 'P' is a pad (ignored) bit.

     Driver users which do not implement the bit shifting necessary to
     use a network with such addressing (if one exists) should at least
     check the number of significant bits in the address field (returned
     from the device's S2_DEVICEQUERY function) to make sure that it is
     evenly divisible by eight.

     Driver users will map hardware addresses to protocol addresses in a
     protocol and hardware dependent manner, as described by the relevant
     standards (i.e., RFC 826 for TCP/IP over Ethernet, RFC 1201 or 1051
     for TCP/IP over ARCNET). Some protocols will always use the same
     mapping on all hardware, but other protocols will have particular
     address mapping schemes for some particular hardware and a
     reasonable default for other (unknown) hardware.

     Some SANA-II devices will have ``hardware addresses'' which aren't
     really hardware addresses. As an example, consider PPP
     (Point-to-Point Protocol). PPP is a standard for transmitting IP
     packets over a serial line. It uses IP addresses negotiated during
     the establishment of a connection. In a SANA-II driver
     implementation of PPP, the driver would negotiate the address at
     S2_CONFIGINTERFACE. Thus, the address in SrcAddr returned by the
     device on an S2_CONFIGINTERFACE (or in a subsequent
     S2_GETSTATIONADDRESS) will be a protocol address, not a true
     hardware address.

     Note: Some hardware always uses a ROM hardware address. Other
     hardware which has a ROM address or is configurable with DIP
     switches may be overridden by software. Some hardware always
     dynamically allocates a new hardware address at initialization. See
     ``Configuration'' for details on how this is handled by driver
     writers and by driver users.

     Hardware Type

     The HardwareType returned by the device's S2_DEVICEQUERY function is
     necessary for those protocols whose standards require different
     behavior on different hardware. It is also useful for determining
     appropriate packet type numbers to use with the device. The
     HardwareType values already issued for standard network hardware are
     the same as those in RFC 1060 (assigned numbers). Hardware
     developers implementing networks without a SANA-II hardware number
     must contact CATS to have a new hardware type number assigned.
     Driver users should all have reasonable defaults which can be used
     for hardware with which they are not familiar.




     Errors

     The SANA-II extended IORequest structure (struct IOSana2Req)
     includes both the ios2_Error and ios2_WireError fields. Driver
     users must always check IOSana2Reqs on return for an error in
     ios2_Error. ios2_Error will be zero if no error occurred, otherwise
     it will contain a value from <exec/errors.h> or <devices/sana2.h>.
     If there was an error, there may be more specific information in
     ios2_WireError. Drivers are required to fill in the WireError if
     there is an applicable error code.

     Error codes are #defined in the ``defined errors'' sections of
     the file <devices/sana2.h>:

     IOSana2Req S2io_Error field (S2ERR_xxx):

     S2ERR_NO_RESOURCES  - Insufficient resources available.
     S2ERR_BAD_ARGUMENT  - Noticeably bad argument.
     S2ERR_BAD_STATE     - Command inappropriate for current state.
     S2ERR_BAD_ADDRESS   - Noticeably bad address.
     S2ERR_MTU_EXCEEDED  - Write data too large.
     S2ERR_NOT_SUPPORTED - Command is not supported by this driver. This
                           is similar to IOERR_NOCMD as defined in
                           <exec/errors.h> but S2ERR_NOT_SUPPORTED
                           indicates that the requested command is a
                           valid SANA-II command and that the driver
                           does not support it because the hardware is
                           incapable of supporting it (e.g.,
                           S2_MULTICAST). Note that IOERR_NOCMD is still
                           valid for reasons other than a lack of
                           hardware support (i.e., commands which are
                           no-ops in a SANA-II driver).
     S2ERR_SOFTWARE      - Software error of some kind.
     S2ERR_OUTOFSERVICE  - When a hardware device is taken off-line, any
                           pending requests are returned with this error.

     See also the standard errors in <exec/errors.h>.

     IOSana2Req S2io_WireError field (S2WERR_xxx):

     S2WERR_NOT_CONFIGURED  - Command requires unit to be configured.
     S2WERR_UNIT_ONLINE     - Command requires that the unit be off-line.
     S2WERR_UNIT_OFFLINE    - Command requires that the unit be on-line.
     S2WERR_ALREADY_TRACKED - Protocol is already being tracked.
     S2WERR_NOT_TRACKED     - Protocol is not being tracked.
     S2WERR_BUFF_ERROR      - Buffer management function returned an error.
     S2WERR_SRC_ADDRESS     - Problem with the source address field.
     S2WERR_DST_ADDRESS     - Problem with destination address field.
     S2WERR_BAD_BROADCAST   - Problem with an attempt to broadcast.
     S2WERR_BAD_MULTICAST   - Problem with an attempt to multicast.
     S2WERR_MULTICAST_FULL  - Multicast address list full.
     S2WERR_BAD_EVENT       - Event specified is unknown.
     S2WERR_BAD_STATDATA    - The S2IO_StatData pointer or the data it
                              points to failed a sanity check.
     S2WERR_IS_CONFIGURED   - Attempt to reconfigure the unit.
     S2WERR_NULL_POINTER    - A NULL pointer was detected in one of the
                              arguments. S2ERR_BAD_ARGUMENT should always
                              be the S2ERR.




     Standard Commands

     See the SANA-II Network Device Driver Autodocs for full details on
     each of the SANA-II device commands. Extended commands are
     explained in the sections below.

     Many of the Exec device standard commands are no-ops in SANA-II
     devices, but this may not always be the case. For example,
     CMD_RESET might someday be used for dynamically reconfiguring
     hardware. This should present no compatibility problems for
     properly written drivers.

     Broadcast and Multicast

       S2_ADDMULTICASTADDRESS        S2_MULTICAST
       S2_DELMULTICASTADDRESS        S2_BROADCAST

     Some hardware supports broadcast and/or multicast. A broadcast is a
     packet sent to all other machines. A multicast is a packet sent to a
     set of machines. Drivers for hardware which does not allow broadcast
     or multicast will return ios2_Error S2ERR_NOT_SUPPORTED as
     appropriate.

     To send a broadcast, use S2_BROADCAST instead of CMD_WRITE.
     Broadcasts are received just like any other packets (using a
     CMD_READ for the appropriate packet type).

     To send a multicast, use S2_MULTICAST instead of CMD_WRITE. The
     device keeps a list of addresses that want to receive multicasts.
     You add a receiver's address to this list by using
     S2_ADDMULTICASTADDRESS. The receiver then posts a CMD_READ for the
     type of packet to be received. Some SANA-II devices which support
     multicast may have a limit on the number of addresses that can
     simultaneously wait for packets. Always check for an
     S2WERR_MULTICAST_FULL error return when adding a multicast address.

     Note that when the device adds a multicast address, it is usually
     added for all users of the device, not just the driver user which
     called S2_ADDMULTICASTADDRESS. In other words, received multicast
     packets will fill a read request of the appropriate type regardless
     of whether the requesting driver user is the same one which added
     the multicast address.

     In general, driver users should not care how received packets were
     sent (normally or broadcast/multicast), only that it was received.
     If a driver user really must know, however, it can check for
     SANA2IOB_BCAST and/or SANA2IOB_MCAST in the ios2_Flags field.

     Drivers should keep a count for the number of opens on a multicast
     address so that they don't actually remove it until it has been
     S2_DELMULTICASTADDRESS'd as many times as it has been
     S2_ADDMULTICASTADDRESS'd.




     Stats

       S2_TRACKTYPE     S2_GETTYPESTATS      S2_GETGLOBALSTATS
       S2_UNTRACKTYPE   S2_GETSPECIALSTATS   S2_READORPHAN

     There are many statistics which may be very important to someone
     trying to debug, tune or optimize a protocol stack, as well as to
     the end user who may need to tune parameters or investigate a
     problem. Some of these statistics can only be kept by the SANA-II
     driver, thus there are several required and optional statistics and
     commands for this purpose.

     S2_TRACKTYPE tells the device driver to gather statistics for a
     particular packet type. S2_UNTRACKTYPE tells it to stop (keeping
     statistics by type causes the driver to use additional resources).
     S2_GETTYPESTATS returns any statistics accumulated by the driver for
     a type being tracked (stats are lost when a type is
     S2_UNTRACKTYPE'd). Drivers are required to implement the
     functionality of type tracking. The stats are returned in a struct
     Sana2PacketTypeStats:

     struct Sana2PacketTypeStats
     {
       ULONG PacketsSent;
       ULONG PacketsReceived;
       ULONG BytesSent;
       ULONG BytesReceived;
       ULONG PacketsDropped;
     };

     PacketsSent     - Number of packets of a particular type sent.
     PacketsReceived - Number of packets of a particular type that
                       satisfied a read command.
     BytesSent       - Number of bytes of data sent in packets of a
                       particular type.
     BytesReceived   - Number of bytes of data of a particular packet
                       type that satisfied a read command.
     PacketsDropped  - Number of packets of a particular type that were
                       received while there were no pending reads of that
                       packet type.

     S2_GETGLOBALSTATS returns global statistics kept by the driver.
     Drivers are required to keep all applicable statistics. Since all
     are applicable to most hardware, most drivers will maintain all
     statistics. The stats are returned in a struct Sana2DeviceStats:

     struct Sana2DeviceStats
     {
       ULONG PacketsReceived;
       ULONG PacketsSent;
       ULONG BadData;
       ULONG Overruns;
       ULONG UnknownTypesReceived;
       ULONG Reconfigurations;
       struct timeval LastStart;
     };




     PacketsReceived     - Number of packets that this unit has received.
     PacketsSent         - Number of packets that this unit has sent.
     BadData             - Number of bad packets received (i.e., hardware
                           CRC failed).
     Overruns            - Number of packets dropped due to insufficient
                           resources available in the network interface.
     UnknownTypeReceived - Number of packets received that had no pending
                           read command with the appropriate packet type.
     Reconfigurations    - Number of network reconfigurations since this
                           unit was last configured.
     LastStart           - The time when this unit last went on-line.

     S2_GETSPECIALSTATS returns any special statistics kept by a
     particular driver. Each new wire type will have a set of
     documented, required statistics for that wire type and a standard
     set of optional statistics for that wire type (optional because they
     might not be available from all hardware). The data returned by
     S2_GETSPECIALSTATS will require wire-specific interpretation. See
     <devices/sana2specialstats.h> for currently defined special
     statistics. The statistics are returned in the following
     structures:

     struct Sana2SpecialStatRecord
     {
       ULONG Type;
       ULONG Count;
       char *String;
     };

     Type   - Statistic identifier.
     Count  - Statistic itself.
     String - An identifying, null-terminated string for the statistic.
              Should be plain ASCII with no formatting characters.

     struct Sana2SpecialStatHeader
     {
       ULONG RecordCountMax;
       ULONG RecordCountSupplied;
       struct Sana2SpecialStatRecord[RecordCountMax];
     };

     RecordCountMax      - There is space for this many records into which
                           statistics may be placed.
     RecordCountSupplied - Number of statistic records supplied.

     S2_READORPHAN is not, strictly speaking, a statistical function. It
     is a request to read any packet of a type for which there is no
     outstanding CMD_READ. S2_READORPHAN might be used in the same
     manner as many statistics, though, such as to determine what packet
     types are causing overruns, etc.




     Configuration

       S2_DEVICEQUERY     S2_CONFIGINTERFACE    S2_GETSTATIONADDRESS

     The device driver needs to configure the hardware before using it.
     The driver user must know some network hardware parameters (hardware
     address and MTU, for example) when using it. These commands address
     those needs.

     When a driver user is initialized, it should try to
     S2_CONFIGINTERFACE even though an interface can only be configured
     once and someone else may have done it. Before you call
     S2_CONFIGINTERFACE, first call S2_GETSTATIONADDRESS to determine the
     factory address (if any). Also provide for user-override of the
     factory address (that address may be optional and the user may need
     to override it). When S2_CONFIGINTERFACE returns, check the
     ios2_SrcAddr for the actual address the hardware has been configured
     with. This is because some hardware (or serial line standards such
     as PPP) always dynamically allocates an address at initialization.

     Driver users will want to use S2_DEVICEQUERY to determine the MTU
     and other characteristics of the network. The structure returned
     from S2_DEVICEQUERY is defined as:

     struct Sana2DeviceQuery
     {
       ULONG SizeAvailable;
       ULONG SizeSupplied;
       ULONG DevQueryFormat;
       ULONG DeviceLevel;
       UWORD AddrFieldSize;
       ULONG MTU;
       ULONG BPS;
       ULONG HardwareType;
     };

     SizeAvailable  - Size, in bytes, of the space available in which to
                      place device information. This includes both size
                      fields.
     SizeSupplied   - Size, in bytes, of the data supplied.
     DevQueryFormat - The format defined here is format 0.
     DeviceLevel    - This spec defines level 0.
     AddrFieldSize  - The number of bits in an interface address.
     MTU            - Maximum Transmission Unit, the size, in bytes,
                      of the maximum packet size, not including header
                      and trailer information.
     BPS            - Best guess at the raw line rate for this network
                      in bits per second.
     HardwareType   - Specifies the type of network hardware the driver
                      controls.





     On-line

          S2_ONLINE       S2_ONEVENT       S2_OFFLINE

     In order to run hardware tests on an otherwise live system, the
     S2_OFFLINE command allows the SANA-II device driver to be ``turned
     off'' until the tests are complete and an ONLINE is sent to the
     driver. S2_ONLINE causes the interface to re-configure and
     re-initialize. Any packets destined for the hardware while the
     device is off-line will be lost. All pending and new requests to the
     driver shall be returned with S2ERR_OUTOFSERVICE when a device is
     off-line.

     All driver users must understand that any IO request may return with
     S2ERR_OUTOFSERVICE because the driver is off-line (any other program
     may call S2_OFFLINE to make it so). In such an event, the driver
     will usually want to wait until the unit comes back on-line (for the
     program which called S2_OFFLINE to call S2_ONLINE). It may do this
     by calling S2_ONEVENT to wait for S2EVENT_ONLINE. S2_ONEVENT allows
     the driver user to wait on various events.

     A driver must track events, but may not distinguish between some
     types of events. Drivers return S2_ONEVENT with S2_ERR_NOT
     SUPPORTED and S2WERR_BAD_EVENT for unsupported Events. One error
     may cause more than one Event (see below). Errors which seem to
     have been caused by a malformed or unusual request should not
     generally trigger an event.

     Event types (S2EVENT_xxx):

       ERROR    - Return when any error occurs.
       TX       - Return on any transmit error (always an error).
       RX       - Return on any receive error (always an error).
       ONLINE   - Return when unit goes on-line or return immediately if
                  unit is already on-line (not an error).
       OFFLINE  - Return when unit goes off-line or return immediately if
                  unit is already off-line (not an error.)
       BUFF     - Return on any buffer management function error (always
                  an error).
       HARDWARE - Return when any hardware error occurs (always an error,
                  may be a TX or RX, too).
       SOFTWARE - Return when any software error occurs (always an error,
                  may be a TX or RX, too).

     Driver Installation

     The standard system location for SANA-II network device driver is
     in a directory called "Networks" which exists in the "DEVS:"
     directory.

         Example:

            DEVS:Networks/a2065.device

     This is the official location for the drivers.  It may be necessary
     for your install program/script to create this directory if it doesn't
     exist in a user's system.


     Acknowledgments

     Many people and companies have contributed to the SANA-II Network
     Device Driver Specification. The original SANA-II Autodocs and
     includes were put together by Ray Brand, Perry Kivolowitz (ASDG) and
     Martin Hunt. Those original documents evolved to their current
     state and grew to include this document at the hands of Dale Larson
     and Greg Miller. Brian Jackson and John Orr provided valuable
     editing. Randell Jesup has provided sage advice on several
     occasions. The buffer management callback mechanism was his idea.
     Dale Luck (GfxBase) and Rick Spanbauer (Ameristar Technologies) have
     provided valuable comments throughout the process. Nicolas Benezan
     (ADONIS) provided many detailed and useful comments on weaknesses in
     late drafts of the specification. Thanks to all the above and the
     numerous others who have contributed with their comments, questions
     and discussions.




     Unresolved Issues

     Unfortunately, it isn't possible to completely isolate network
     protocols from the hardware they run on. Hardware types and
     addressing both remain somewhat hardware-dependent in spite of our
     efforts. See the ``Packet Type'' section for an explanation of how
     packet types are handled and why protocols cannot be isolated from
     them. See the ``Addressing'' section for an explanation of how
     addressing is handled any why protocols cannot be isolated from it.

     Additionally, there are at least two cases where a hardware type has
     multiple framing methods in use (ethernet/802.3 and arcnet/(Novell)
     ``ARCNET Packet Header Definition Standard''). In both cases,
     software which must interoperate with other platforms on this
     hardware may need to be aware of the distinctions and may have to do
     extra processing in order to use the appropriate frame type. See
     the sections on ``Ethernet Packet Types'' and on ``ARCNET frames''
     for more details.

     Another feature that SANA-II currently lacks is any concept of
     dynamic addressing.  Some hardware types such as LocalTalk or
     dialup SLIP/PPP connections may change their address on the fly.
     Currently there is no way for a device driver to report this event
     back to a protocol stack.
@


1.10
log
@Added information about new buffer management stuff and some documentation
about the new PacketFilter callback.
@
text
@d223 3
d780 15
d834 5
@


1.9
log
@Brian's update.
@
text
@d4 6
a9 7
     SANA-II Network Device Driver Specification - Rev 1.0 23-Apr-92
     
     (C) Copyright 1992 Commodore-Amiga, Inc. All Rights Reserved
     
     Amiga Networking Group -  Brian Jackson, Dale Larson
                               Greg Miller, Kenneth Dyke
     
d11 1
a11 1
    
d17 1
a17 1
    
d19 1
a19 1
    
d26 1
a26 1
     even if it has been advised of the possibility of such damages. 
d32 1
a32 1
     
d41 1
a41 1
     
d50 1
a50 1
     
d58 1
a58 1
     
d62 2
a63 2
 
      
d80 1
a80 1
     
d88 1
a88 1
  
d94 1
a94 1
     
d99 1
a99 1
     written. Amiga is a registered trademark of Commodore-Amiga, Inc. 
d104 1
a104 1
     
d113 1
a113 1
     
d119 1
a119 2
    
 
d122 1
d124 1
a124 1
     
d131 1
a131 1
     
d133 1
a133 1
     
d139 2
a140 2
     
     struct IOSana2Req 
d152 1
a152 1
     
d155 2
a156 2
                               set when there is an io_Error. See 
                               <devices/sana2.h> for the defined 
d158 1
a158 1
       ios2_PacketType       - The type of packet requested. See the 
d160 5
a164 5
       ios2_SrcAddr          - The device fills in this field with the 
                               interface (network hardware) address of 
                               the source of the packet that satisfied 
                               a read command. The bytes used to hold 
                               the address will be left justified but 
d169 3
a171 3
                               address of the packet. On receives, the 
                               device fills this with the interface 
                               destination address. Other commands may 
d173 3
a175 3
                               Network Device Driver Autodocs). The 
                               bytes used to hold the address will be 
                               left justified but the bit layout is 
d177 1
a177 1
  
d182 2
a183 2
                               the amount of data available in the Data 
                               buffer before passing the IOSana2Req to 
d186 2
a187 2
                               sent on the wire. This does not include 
                               the header and trailer information. 
d189 2
a190 2
                               type, the driver may have to calculate 
                               this value. This is generally used only 
d193 2
a194 2
       ios2_Data             - A pointer to some abstract data structure 
                               containing packet data. Drivers may not 
d196 1
a196 1
                               pointed to by Data! This is generally 
d199 1
a199 1
       ios2_StatData         - Pointer to a structure in which to place 
d201 2
a202 2
                               area must be long word aligned. This is 
                               only used on calls to the statistics 
d204 1
a204 1
       ios2_BufferManagement - The opener places a pointer to a tag list 
d206 2
a207 2
                               Functions pointed to in the tag list are 
                               called by the device when processing 
d210 2
a211 2
                               pointer to driver-private information 
                               used to access these functions. 
d214 1
a214 1
       
d216 1
a216 1
       
d218 1
a218 1
       SANA2OPB_PROM  - Promiscuous mode requested. Hardware which 
d222 1
a222 1
       
d224 2
a225 2
       
       SANA2IOB_RAW   - Raw packet read/write requested. Raw packets 
d227 1
a227 1
                        Devices with the same hardware device number 
d232 2
a233 2
  
     
d237 1
a237 1
     
d247 1
a247 1
     
d253 1
a253 1
     
d271 21
a291 2
          
     The specification currently includes only two tags for the
d293 2
a294 2
     
     S2_CopyToBuff  - This is a pointer to a function which conforms to 
d298 4
a301 1
     
d303 1
a303 1
     
d312 1
a312 1
     
d317 2
a318 2
  
     
d328 1
a328 1
     
d330 1
a330 1
     
d332 1
a332 1
     ethernet frames can be sent over the same wire--ethernet and 802.3. 
d338 1
a338 1
     
d349 1
a349 1
     
d351 1
a351 1
     
d356 1
a356 1
     
d366 1
a366 1
     
d378 1
a378 2
  
     
d381 1
d383 1
a383 1
     
d387 1
a387 1
     
d392 1
a392 1
     
d395 1
a395 1
     
d397 1
a397 1
     
d403 1
a403 1
     
d411 1
a411 1
     
d422 1
a422 1
     
d429 1
a429 1
     
d431 1
a431 1
     
d439 1
a439 1
     must contact CATS to have a new hardware type number assigned. 
d442 1
a442 2
  
     
d445 1
d447 1
a447 1
     
d452 1
a452 1
     it will contain a value from <exec/errors.h> or <devices/sana2.h>. 
d456 2
a457 2
     
     Error codes are #defined in the ``defined errors'' sections of 
d459 1
a459 1
     
d461 1
a461 1
     
d468 6
a473 6
                           is similar to IOERR_NOCMD as defined in 
                           <exec/errors.h> but S2ERR_NOT_SUPPORTED 
                           indicates that the requested command is a 
                           valid SANA-II command and that the driver 
                           does not support it because the hardware is 
                           incapable of supporting it (e.g., 
d475 2
a476 2
                           valid for reasons other than a lack of 
                           hardware support (i.e., commands which are 
d481 1
a481 1
                            
d483 1
a483 1
     
d485 1
a485 1
     
d504 2
a505 2
  
     
d509 1
a509 1
     
d513 1
a513 1
     
d519 1
a519 1
     
d521 1
a521 1
     
d524 1
a524 1
     
d529 2
a530 2
     appropriate. 
     
d533 2
a534 2
     CMD_READ for the appropriate packet type). 
     
d542 2
a543 2
     S2WERR_MULTICAST_FULL error return when adding a multicast address. 
     
d549 2
a550 2
     the multicast address. 
     
d555 1
a555 1
     
d560 1
a560 1
  
d575 1
a575 1
     
d584 1
a584 1
     
d593 1
a593 1
     
d597 1
a597 1
     BytesSent       - Number of bytes of data sent in packets of a 
d599 1
a599 1
     BytesReceived   - Number of bytes of data of a particular packet 
d604 2
a605 2
     
     S2_GETGLOBALSTATS returns global statistics kept by the driver. 
d609 1
a609 1
     
d620 2
a621 2
      
     
d632 1
a632 1
     Reconfigurations    - Number of network reconfigurations since this 
d635 1
a635 1
     
d645 1
a645 1
     
d652 1
a652 1
     
d657 1
a657 1
     
d664 2
a665 2
     
     RecordCountMax      - There is space for this many records into which 
d668 1
a668 1
     
d674 2
a675 2
  
     
d679 1
a679 1
     
d681 2
a682 2
     
     The device driver needs to configure the hardware before using it. 
d686 1
a686 1
     
d697 1
a697 1
     
d701 1
a701 1
     
d713 1
a713 1
     
d715 1
a715 1
                      place device information. This includes both size 
d721 2
a722 2
     MTU            - Maximum Transmission Unit, the size, in bytes, 
                      of the maximum packet size, not including header 
d724 1
a724 1
     BPS            - Best guess at the raw line rate for this network 
d726 1
a726 1
     HardwareType   - Specifies the type of network hardware the driver 
d728 2
a729 3
     
  
     
d732 1
d734 1
a734 1
     
d736 1
a736 1
          
d745 1
a745 1
     
d753 1
a753 1
     
d760 1
a760 1
     
d762 1
a762 1
     
d768 1
a768 1
       OFFLINE  - Return when unit goes off-line or return immediately if 
d776 1
a776 1
       
d778 1
a778 1
     
d786 1
a786 1
     occasions. The buffer management callback mechanism was his idea. 
d793 2
a794 2
  
     
d798 1
a798 1
     
d806 1
a806 1
     
d815 1
a815 1
     
@


1.8
log
@???
@
text
@a1 1
SANA-II Network Device Driver Specification
a2 2
February 12, 1992
Final Standard
d4 791
a794 879

Amiga Networking Group
Dale Larson, Greg Miller, Brian Jackson



Introduction

The SANA-II Network Device Driver Specification is a standard for an Amiga
software interface between networking hardware and network protocol stacks (or
for software tools such as network monitors).  A network protocol stack is a
layer of software that network applications use to address particular
processes on remote machines and to send data reliably in spite of hardware
errors.  There are several common network protocol stacks including TCP/IP,
OSI, AppleTalk, DECNet and Novell.

SANA-II device drivers allow multiple network protocol stacks running on the
same machine to share one network device.  For example, the TCP/IP and
AppleTalk protocol stacks could both run on the same machine over one ethernet
board.  The devices also allow network protocol stacks to be written in a
hardware-independent fashion so that a different version of each protocol stack
doesn't have to be written for each networking hardware device.

The standard does not address the writing of network applications.  Application
writers must not use SANA-II Device Drivers directly.  Network applications
must use the API provided by the network protocol software the application
supports.  There is not an Amiga standard network API at the time of this
writing, though there is the AS225 TCP/IP package and its socket.library as
well as other (third-party) packages.

To write a SANA-II device driver, you will need to be familiar with the
specification documents for the hardware you are writing to and with the
SANA-II Network Device Driver Specification.

To write a network protocol stack which will use SANA-II device drivers, you
should have general familiarity with common network hardware and must be very
familiar with the SANA-II Network Device Driver Specification as well as the
specification for the protocol you are developing.  If you are creating a new
protocol, you must obtain a protocol type number for any hardware on which
your protocol will be used.

Commodore supports the SANA-II specification by providing drivers for all
Commodore-Amiga network hardware.  We have an A2065.device (Ethernet) and will
produce an A2060.device (ARCNET).  We also examine review copies of
third-party SANA-II networking hardware and software to make sure that it
interoperates with our products.

This standard has undergone several drafts with long periods for comment from
developers and the Amiga community at large.  These drafts include a UseNet
release which was also distributed on the Fish Disks in June, 1991 (as well as
published in the '91 DevCon notes), and the November 7 Draft for Final Comment
and Approval distributed via Bix, ADSP and Usenet.  There were also several
intermediate drafts with more limited distribution.

This version of the specification is final.  Any new version of the standard
(i.e., to add new features) will be backward compatible.  No SANA-II device
driver or software utilizing those drivers should be written to any earlier
version of the specification.

Distribution of this version of the standard is unlimited. Anyone may write
Amiga software which implements a SANA-II network device driver or which calls
a SANA-II network device driver without restriction and may freely distribute
such software that they have written.  Ethernet is a trademark of Xerox
Corporation.  ARCNET is a trademark of Datapoint Corporation. DECNet is a
trademark of Digital Equipment Corporation.  AppleTalk is a trademare of Apple
Computer, Inc.

It is important to try to test each SANA-II device driver against all software
which uses SANA-II devices.  Available example programs are valuable in initial
testing.  The Amiga Networking Group is interested in receiving evaluation
and/or beta test copies of all Amiga networking hardware, SANA-II device
drivers and software which uses SANA-II devices. However, we make no assurances
regarding any testing which we may or may not perform with such evaluation
copies.  Contact:

	Amiga Networking Group
	Commodore International Services Corporation
	Technology Group
	1200 Wilson Drive
	West Chester, PA  19380, USA
	ATTN:  Dale Larson


Driver Form

SANA-II device drivers are Amiga Exec device drivers.  They use an extended
IORequest structure and a number of extended commands for tallying network
statistics, sending broadcasts and multicasts, network addressing and the
handling of unexpected packets. The Amiga ROM Kernel Reference Manual: Devices
includes information on how to construct an Exec device.


Opening a SANA-II Device

As when opening any other Exec device, on the call to OpenDevice() a SANA-II
device receives an IORequest structure which the device initializes for the
opener's use. The opener must copy this structure if it desires to use
multiple asynchronous requests.  The SANA-II IORequest is defined as follows:

	struct IOSana2Req
	{
		struct IORequest ios2_Req;
		ULONG ios2_WireError;
		ULONG ios2_PacketType;
		UBYTE ios2_SrcAddr[SANA2_MAX_ADDR_BYTES];
		UBYTE ios2_DstAddr[SANA2_MAX_ADDR_BYTES];
		ULONG ios2_DataLength;
		void *ios2_Data;
		void *ios2_StatData;
		void *ios2_BufferManagement;
	};


	ios2_Req

		A standard Exec device IORequest.

	WireError

		A more specific device code which may be set when there is an
		io_Error.  See <devices/sana2.h> for the defined WireErrors.

	PacketType

		The type of packet requested.  See the section on "Packet
		Types".

	SrcAddr

		The device fills in this field with the interface (network
		hardware) address of the source of the packet that satisfied a
		read command. The bytes used to hold the address will be left
		justified but the bit layout is dependent on the particular
		type of network.

	DstAddr

		Before the device user sends a packet, it fills this with the
		interface destination address of the packet.  On receives, the
		device fills this with the interface destination address.
		Other commands may use this field differently (see the
		SANA-II Network Device Driver Autodocs).  The bytes used to hold
		the address will be left justified but the bit layout is
		dependent on the particular type of network.

	DataLength

		The device user initializes this field with the amount of data
		available in the Data buffer before passing the IOSana2Req to
		the device.  The device fills in this field with the size of
		the packet data as it was sent on the wire.  This does not
		include the header and trailer information.  Depending on the
		network type and protocol type, the driver may have to
		calculate this value.  This is generally used only for reads
		and writes (including broadcast and multicast).

	Data

		A pointer to some abstract data structure containing packet
		data.  Drivers may not directly manipulate or examine anything
		pointed to by Data!  This is generally used only for reads and
		writes (including broadcast and multicast).

	StatData

		Pointer to a structure in which to place a snapshot of device
		statistics. The data area must be long word aligned.  This is
		only used on calls to the statistics commands.

	BufferManagement

		The opener places a pointer to a taglist in this field before
		calling OpenDevice().  Functions pointed to in the taglist are
		called by the device when processing IORequests from the
		opener. When returned from OpenDevice(), this field contains a
		pointer to driver-private information used to access these
		functions.  See "Buffer Management" below for more details.

The flags used with the device on OpenDevice() are (SANA2OPB_xxx):

	SANA2OPB_MINE

		Exclusive access to the unit requested.

	SANAOPB_PROM
		Promiscuous mode requested.  Hardware which supports
		promiscuous mode allows all packets sent over the wire to be
		captured whether or not they are addressed to this node.


The flags used during I/O requests are (SANA2IOB_xxx):

	SANA2IOB_RAW

		Raw packet read/write requested.  Raw packets should include
		the entire data-link layer packet.  Devices with the same
		hardware device number should have the same raw packet format.

	SANA2IOB_BCAST

		Broadcast packet (received).

	SANA2IOB_MCAST

		Multicast packet (received).

	SANA2IOB_QUICK

		Quick IO requested.


Buffer Management

Unlike most other Exec Device drivers, SANA-II drivers have no internal
buffers.  Instead, they read/write to/from an abstract data structure allocated
by the driver user.  The driver accesses these buffers only via functions that
the driver user provides to the driver.  The driver user must provide two
functions -- one copies data to the abstract data structure and one copies data
from the abstract data structure.  The driver user can therefore choose the
data structure used for buffer management by both the driver and driver user in
order to have efficient memory and CPU usage overall.

The Sana2IOReq contains a pointer to data and the length of said data.  A
driver is not allowed to make assumptions about how the data is stored.  The
driver cannot directly manipulate or examine the buffer in any manner.  The
driver can only access the buffer by calling the functions provided by the
driver user.

Before calling OpenDevice(), the driver user points ios2_BufferManagment to a
list of tags (defined in <devices/sana2.h>) which include pointers to the
buffer management functions required by the driver (defined below).  The
driver makes sure that all required functions are supplied and fails to open
if they are not.  If the device opens successfully, the driver sets
ios2_BufferManagement to a value which this opener must use in all future
calls to the driver.  This "magic cookie" is used from then on to access these
functions (a "magic cookie" is a value which one software entity passes to
another but which is only meaningful to one of the software entities).  The
driver user may not use the "magic cookie" in any way -- it is for the driver
to do with as it wishes.  The driver could in theory choose to just copy the
taglist to driver-owned memory and then parse the list for every IORequest, but
it is much more efficient for the driver to create some sort of table of
functions and to point ios2_BufferManagement to that table.

The specification currently includes only two tags for the OpenDevice()
ios2_BufferManagement taglist:

S2_CopyToBuff    -  This is a pointer to a function which conforms to the
		    CopyToBuff Autodoc.

S2_CopyFromBuff  -  This is a pointer to a function which conforms to the
		    CopyFromBuff Autodoc.


Packet Type

Network frames always have a type field associated with them.  These type
fields vary in length, position and meaning by frame type (frames types
generally correspond one-to-one with hardware types, but see "Ethernet Packet
Types" below.).  The meanings of the type numbers are always carefully defined
and every type number is registered with some official body.  Do not use a
type number which is not registered for any standard hardware you use or in a
manner inconsistent with that registration.

The type field allows the SANA-II device driver to fulfill CMD_READs based on
the type of packet the driver user wants.  Multiple protocols can therefore
run over the same wire using the same driver without stepping on each other's
toes.

Packet types are specified as a long word.  Unfortunately, the type field
means different things on different wires.  Driver users must allow their
software to be configured with a SANA-II device name, unit number and the type
number(s) used by the protocol stack with each device.  This way, if new
hardware becomes available, a hardware manufacturer can supply a listing of
type assignments to configure pre-existing software.


Ethernet Packet Types

Ethernet has a special problem with packet types.  Two types of ethernet
frames can be sent over the same wire -- ethernet and 802.3.  These frames
differ in that the Type field of an ethernet frame is the Length field of an
802.3 frame.  This creates a problem in that demultiplexing incoming packets
can be cumbersome and inefficient, as well as requiring driver users to be
aware of the frame type used.

All 802.3 frames have numbers less than 1500 in the type field.  The only
frames with numbers less than 1500 in the type field are 802.3 frames.  SANA-II
ethernet drivers abnormally return packets contained in ethernet frames when
the requested Type falls within the 802.3 range -- if the Type requested is
within the 802.3 range, the driver returns the next packet contained within an
802.3 frame, regardless of the type specified for the packet within the 802.3
frame.  This requires that there be no more than one driver user requesting
802.3 packets and that it do it's own interpretation of the frames.


ARCNET Frames

ARCNET also has a special problem with framing.  ARCNET frames consist of a
hardware header and a software header.  The software header is in the data
area of the hardware packet, and includes at least the protocol ID.

There are two types of software header. Old-style ARCNET software headers
consist entirely of a one or two byte protocol ID.  New ARCNET software
headers (defined in RFC 1201 and in the paper "ARCNET Packet Header Definition
Standard", Novell, Inc., 1989) include more information.  They allow more
efficient use of ARCNET through data link layer fragmentation and reassembly
(ARCNET has a small Maximum Transmisson Unit) and allow sending any size
packet up to the MTU (rather than requiring that packets of size 253, 254 and
255 be padded to at least 256 bytes).

SANA-II device drivers for ARCNET should implement the old ARCNET packet
headers.  Driver users which wish to interoperate with platforms using the new
software headers must add the new fields to the data to be sent and must
process it for incomming data.  A SANA-II driver which implemented the data
link layer fragmentation internally (and advertised a large MTU) could be more
efficient than requiring the driver user to do it.  This would make driver
writing more difficult and reduce interoperability, but if there is ever a
demand for that extra performance, a new hardware type may be assigned by
Commodore for SANA-II ARCNET device drivers which implement the new framing.


Addressing

In the SANA-II standard, network hardware addresses are stored in an array of
n bytes. No meaning is ascribed by the standard to the contents of the array.

In case there exists a network which does not have an address field consisting
of a number of bits not divisible by eight, add pad bits at the end of the bit
stream.  For example, if an address is ten bits long it will be stored like
this:

	98765432 10PPPPPP
	BYTE 0   BYTE 1

Where the numerals are bit numbers and 'P' is a pad (ignored) bit.

Driver users which do not implement the bit shifting necessary to use a network
with such addressing (should one exist) should at least check the number of
significant bits in the address field (returned from the device's
S2_DEVICEQUERY function) to make sure that it is evenly divisible by eight.

Driver users will map hardware addresses to protocol addresses in a protocol
and hardware dependent manner, as described by the relevant standards (i.e.,
RFC 826 for TCP/IP over Ethernet, RFC 1201 or 1051 for TCP/IP over ARCnet).
Some protocols will always use the same mapping on all hardware, but other
protocols will have particular address mapping schemes for some particular
hardware and a reasonable default for other (unknown) hardware.

Some SANA-II devices will have "hardware addresses" which aren't really
hardware addresses.  As an example, consider PPP (Point-to-Point Protocol).
PPP is a standard for transmitting IP packets over a serial line.  It uses IP
addresses negotiated during the establishment of a connection.  In a SANA-II
driver implementation of PPP, the driver would negotiate the address at
S2_CONFIGINTERFACE.  Thus, the address in SrcAddr returned by the device on an
S2_CONFIGINTERFACE (or in a subsequent S2_GETSTATIONADDRESS) will be a
protocol address, not a true hardware address.

Note:  Some hardware always uses a ROM hardware address.  Other hardware
which has a ROM address or is configurable with DIP switches may be overriden
by software.  Some hardware always dynamically allocates a new hardware
address at initialization.  See "Configuration" for details on how this is
handled by driver writers and by driver users.


Hardware Type

The HardwareType returned by the device's S2_DEVICEQUERY function is necessary
for those protocols whose standards require different behavior on different
hardware.  It is also useful for determining appropriate packet type numbers to
use with the device. The HardwareType values already issued for standard
network hardware are the same as those in RFC 1060 (assigned numbers).
Hardware developers implementing networks without a SANA-II hardware number
must contact CATS to have a new hardware type number assigned.  Driver users
should all have reasonable defaults which can be used for hardware with which
they are not familiar.


Errors

The SANA-II extended IORequest structure (struct IOSana2Req) includes both the
ios2_Error and ios2_WireError fields.  Driver users must always check
IOSana2Reqs on return for an error in ios2_Error.  ios2_Error will be zero if
no error occurred, otherwise it will contain a value from <exec/errors.h> or
<devices/sana2.h>.  If there was an error, there may be more specific
information in ios2_WireError.  Drivers are required to fill in the WireError
if there is an applicable error code.


Error codes are #defined in the "defined errors" sections of <devices/sana2.h>:

IOSana2Req S2io_Error field (S2ERR_xxx):

	S2ERR_NO_RESOURCES

		Insufficient resources available.

	S2ERR_BAD_ARGUMENT

		Noticeably bad argument.

	S2ERR_BAD_STATE

		Command inappropriate for current state.

	S2ERR_BAD_ADDRESS

		Noticably bad address.

	S2ERR_MTU_EXCEEDED

		Write data too large.

	S2ERR_NOT_SUPPORTED

		Command is not supported by this driver. This is similar to
		IOERR_NOCMD as defined in <exec/errors.h> but
		S2ERR_NOT_SUPPORTED indicates that the requested command is a
		valid SANA-II command and that the driver does not support it
		because the hardware is incapable of supporting it (e.g.,
		S2_MULTICAST).  Note that IOERR_NOCMD is still valid for
		reasons other than a lack of hardware support (i.e., commands
		which are no-ops in a SANA-II driver).

	S2ERR_SOFTWARE

		Software error of some kind.

	S2ERR_OUTOFSERVICE

		When a hardware device is taken offline, any pending requests
		are returned with this error.

		SEE ALSO the standard errors in <exec/errors.h>.

IOSana2Req S2io_WireError field (S2WERR_xxx):

	S2WERR_NOT_CONFIGURED

		Command requires unit to be configured.

	S2WERR_UNIT_ONLINE

		Command requires that the unit be offline.

	S2WERR_UNIT_OFFLINE

		Command requires that the unit be online.

	S2WERR_ALREADY_TRACKED

		Protocol is already being tracked.

	S2WERR_NOT_TRACKED

		Protocol is not being tracked.

	S2WERR_BUFF_ERROR

		Buffer management function returned an error.

	S2WERR_SRC_ADDRESS

		Problem with the source address field.

	S2WERR_DST_ADDRESS

		Problem with destination address field.

	S2WERR_BAD_BROADCAST

		Problem with an attempt to broadcast.

	S2WERR_BAD_MULTICAST

		Problem with an attempt to multicast.

	S2WERR_MULTICAST_FULL

		Multicast address list full.

	S2WERR_BAD_EVENT

		Event specified is unknown.

	S2WERR_BAD_STATDATA

		The S2IO_StatData pointer or the data it points to failed a
		sanity check.

	S2WERR_IS_CONFIGURED

		Attempt to reconfigure the unit.

	S2WERR_NULL_POINTER

		A NULL pointer was detected in one of the arguments.
		S2ERR_BAD_ARGUMENT should always be the S2ERR.


Standard Commands

See the SANA-II Network Device Driver Autodocs for full details on each of the
SANA-II device commands. Extended commands are explained in the sections below.

Many of the Exec device standard commands are no-ops in SANA-II devices, but
this may not always be the case.  For example, CMD_RESET might someday be used
for dynamically reconfiguring hardware.  This should present no compatibility
problems for properly written drivers.


Broadcast and Multicast

S2_ADDMULTICASTADDRESS
S2_DELMULTICASTADDRESS
S2_MULTICAST
S2_BROADCAST

Some hardware supports broadcast and/or multicast.  A broadcast is a packet
sent to all other machines.  A multicast is a packet sent to a set of
machines.  Drivers for hardware which does not allow broadcast or multicast
will return ios2_Error S2ERR_NOT_SUPPORTED as appropriate.

To send a broadcast, use S2_BROADCAST instead of CMD_WRITE.  Broadcasts are
received just like any other packets (using a CMD_READ for the appropriate
packet type).

To send a multicast, use S2_MULTICAST instead of CMD_WRITE. The device keeps a
list of addresses that want to receive multicasts. You add a receiver's
address to this list by using S2_ADDMULTICASTADDRESS. The receiver then posts
a CMD_READ for the type of packet to be received. Some SANA-II devices which
support multicast may have a limit on the number of addresses that can
simultaneously wait for packets.  Always check for an S2WERR_MULTICAST_FULL
error return when adding a multicast address.

Note that when the device adds a multicast address, it is usually added for
all users of the device, not just the driver user which called
S2_ADDMULTICASTADDRESS.  In other words, received multicast packets will fill
a read request of the appropriate type regardless of whether the requesting
driver user is the same one which added the multicast address.

In general, driver users should not care how received packets were sent
(normally or broadcast/multicast), only that it was recieved.  If a driver
user really must know, however, it can check for SANA2IOB_BCAST and/or
SANA2IOB_MCAST in the ios2_Flags field.

Drivers should keep a count for the number of opens on a multicast address so
that they don't actually remove it until it has been S2_DELMULTICASTADDRESS'd
as many times as it has been S2_ADDMULTICASTADDRESS'd


Stats

S2_TRACKTYPE
S2_UNTRACKTYPE
S2_GETTYPESTATS
S2_GETSPECIALSTATS
S2_GETGLOBALSTATS
S2_READORPHAN

There are many statistics which may be very important to someone trying to
debug, tune or optimize a protocol stack, as well as to the end user who may
need to tune parameters or investigate a problem.  Some of these statistics
can only be kept by the SANA-II driver, thus there are several required and
optional statistics and commands for this purpose.

S2_TRACKTYPE tells the device driver to gather statistics for a particular
packet type. S2_UNTRACKTYPE tells it to stop (keeping statistics by type
causes the driver to use additional resources).  S2_GETTYPESTATS returns any
statistics accumulated by the driver for a type being tracked (stats are lost
when a type is S2_UNTRACKTYPE'd).  Drivers are required to implement the
functionality of type tracking.  The stats are returned in a struct
Sana2PacketTypeStats:

	struct Sana2PacketTypeStats
	{
		ULONG PacketsSent;
		ULONG PacketsReceived;
		ULONG BytesSent;
		ULONG BytesReceived;
		ULONG PacketsDropped;
	};

	PacketsSent

		Number of packets of a particular type sent.

	PacketsReceived

		Number of packets of a particular type that satisfied a read
		command.

	BytesSent

		Number of bytes of data sent in packets of a particular type.

	BytesReceived

		Number of bytes of data of a particular packet type that
		satisfied a read command.

	PacketsDropped

		Number of packets of a particular type that were received
		while there were no pending reads of that packet type.


S2_GETGLOBALSTATS returns global statistics kept by the driver.  Drivers are
required to keep all applicable statistics.  Since all are applicable to most
hardware, most drivers will maintain all statistics.  The stats are returned
in a struct Sana2DeviceStats:

	struct Sana2DeviceStats
	{
		ULONG PacketsReceived;
		ULONG PacketsSent;
		ULONG BadData;
		ULONG Overruns;
		ULONG UnknownTypesReceived;
		ULONG Reconfigurations;
		struct timeval LastStart;
	};

	PacketsReceived

		Number of packets that this unit has received.

	PacketsSent

		Number of packets that this unit has sent.

	BadData

		Number of bad packets received (i.e., hardware CRC failed).

	Overruns

		Number of packets dropped due to insufficient resources
		available in the network interface.

	UnknownTypeReceived

		Number of packets received that had no pending read command
		with the appropriate packet type.


	Reconfigurations

		Number of network reconfigurations since this unit was last
		configured.

	LastStart

		The time when this unit last went online.


S2_GETSPECIALSTATS returns any special statistics kept by a particular driver.
Each new wire type will have a set of documented, required statistics for that
wire type and a standard set of optional statistics for that wire type
(optional because they might not be available from all hardware).  The data
returned by S2_GETSPECIALSTATS will require wire-specific interpretation.  See
<devices/sana2specialstats.h> for currently defined special statistics.  The
statistics are returned in the following structures:

	struct Sana2SpecialStatRecord
	{
		ULONG Type;
		ULONG Count;
		char *String;
	};

	Type

		Statistic identifier.

	Count

		Statistic itself.

	String

		An identifying, null-terminated string for the statistic.
		Should be plain ASCII with no formatting characters.


	struct Sana2SpecialStatHeader
	{
		ULONG RecordCountMax;
		ULONG RecordCountSupplied;
		struct Sana2SpecialStatRecord[RecordCountMax];
	};

	RecordCountMax

		There is space for this many records into which statistics
		may be placed.

	RecordCountSupplied

		Number of statistic records supplied.


S2_READORPHAN is not, strictly speaking, a statistical function.  It is a
request to read any packet of a type for which there is no outstanding
CMD_READ.  S2_READORPHAN might be used in the same manner as many statistics,
though, such as to determine what packet types are causing overruns, etc.


Configuration

S2_DEVICEQUERY
S2_GETSTATIONADDRESS
S2_CONFIGINTERFACE

The device driver needs to configure the hardware before using it.  The driver
user must know some network hardware parameters (hardware address and MTU, for
example) when using it.  These commands address those needs.

When a driver user is initialized, it should try to S2_CONFIGINTERFACE even
though an interface can only be configured once and someone else may have done
it. Before calling S2_CONFIGINTERFACE, first call S2_GETSTATIONADDRESS to
determine the factory address (if any).  Also provide for user-override of the
factory address (that address may be optional and the user may need to override
it).  When S2_CONFIGINTERFACE returns, check the ios2_SrcAddr for the actual
address the hardware has been configured with. This is because some hardware
(or serial line standards such as PPP) always dynamically allocates an address
at initialization.

Driver users will want to use S2_DEVICEQUERY to determine the MTU and other
characteristics of the network.  The structure returned from S2_DEVICEQUERY is
defined as:

	struct Sana2DeviceQuery
	{
		ULONG SizeAvailable;
		ULONG SizeSupplied;
		ULONG DevQueryFormat;
		ULONG DeviceLevel;
		UWORD AddrFieldSize;
		ULONG MTU;
		ULONG BPS;
		ULONG HardwareType;
	};

	SizeAvailable

		Size, in bytes, of the space available in which to place
		device information. This includes both size fields.

	SizeSupplied

		Size, in bytes, of the data supplied.

	DevQueryFormat

		The format defined here is format 0.

	DeviceLevel

		This spec defines level 0.

	AddrFieldSize

		The number of bits in an interface address.

	MTU

		Maximum Transmission Unit, the size, in bytes, of the maximum
		packet size, not including header and trailer information.

	BPS

		Best guess at the raw line rate for this network in bits per
		second.

	HardwareType

		Specifies the type of network hardware the driver controls.


Online

S2_ONLINE
S2_OFFLINE
S2_ONEVENT

In order to run hardware tests on an otherwise live system, the S2_OFFLINE
command allows the SANA-II device driver to be "turned off" until the tests
are complete and an ONLINE is sent to the driver.  S2_ONLINE causes the
interface to re-configure and re-initialize.  Any packets destined for the
hardware while the device is offline will be lost. All pending and new
requests to the driver shall be returned with S2ERR_OUTOFSERVICE when a device
is offline.

All driver users must understand that any IO request may return with
S2ERR_OUTOFSERVICE because the driver is offline (any other program may call
S2_OFFLINE to make it so).  In such an event, the driver will usually want to
wait until the unit comes back online (for the program which called S2_OFFLINE
to call S2_ONLINE).  It may do this by calling S2_ONEVENT to wait for
S2EVENT_ONLINE. S2_ONEVENT allows the driver user to wait on various events.

A driver must track events, but may not distinguish between some types of
events.  Drivers return S2_ONEVENT with S2_ERR_NOT SUPPORTED and
S2WERR_BAD_EVENT for unsupported Events.  One error may cause more than one
Event (see below). Errors which seem to have been caused by a malformed or
unusual request should not generally trigger an event.

Event types (S2EVENT_xxx):

	ERROR

		Return when any error occurs.

	TX

		Return on any transmit error.  (Always an Error.)

	RX

		Return on any receive error.  (Always an Error.)

	ONLINE

		Return when unit goes online or return immediately if unit is
		already online. (Not an Error.)

	OFFLINE

		Return when unit goes offline or return immediately if unit is
		already offline. (Not an Error.)

	BUFF

		Return on any buffer management function error.  (Always an
		Error.)

	HARDWARE

		Return when any hardware error occurs.  (Always an Error, may
		be a TX or RX, too.)

	SOFTWARE

		Return when any software error occurs.  (Always an Error, may
		be a TX or RX, too.)


Acknowledgements

Many people and companies have contributed to the SANA-II Network Device
Driver Specification.  The original SANA-II Autodocs and includes were put
together by Ray Brand, Perry Kivolowitz (ASDG) and Martin Hunt.  Those
original documents evolved to their current state and grew to include this
document at the hands of Dale Larson and Greg Miller.  Brian Jackson and John
Orr provided valuable editing.  Randell Jesup has provided sage advice on
several occasions.  The buffer management callback mechanism was his idea.
Dale Luck (GfxBase) and Rick Spanbauer (Ameristar Technologies) have provided
valuable comments throughout the process.  Nicolas Benezan (ADONIS) provided
many detailed and useful comments on weaknesses in late drafts of the
specification.  Thanks to all the above and the numerous others who have
contributed with their comments, questions and discussions.


Unresolved Issues

Unfortunately, it isn't possible to completely isolate network protocols from
the hardware they run on.  Hardware types and addressing both remain somewhat
hardware-dependent in spite of our efforts.  See the "Packet Type" section for
an explanation of how packet types are handled and why protocols cannot be
isolated from them.  See the "Addressing" section for an explanation of how
addressing is handled any why protocols cannot be isolated from it.

Additionally, there are at least two cases where a hardware type has multiple
framing methods in use (ethernet/802.3 and arcnet/(Novell)"ARCNET Packet
Header Definition Standard").  In both cases, software which must interoperate
with other platforms on this hardware may need to be aware of the distinctions
and may have to do extra processing in order to use the appropriate frame type.
See the sections on "Ethernet Packet Types" and on "ARCNET frames" for more
details.

@


1.7
log
@Final version, approved by Brian.
@
text
@d4 1
a4 1
February 10, 1992
d20 2
a21 13
errors.  There are several standard network protocol stacks including TCP/IP,
OSI, AppleTalk, DECNet and Novell.  SANA-II device drivers allow multiple
network protocol stacks running on the same machine to share one network
device.  For example, the TCP/IP and AppleTalk protocol stacks could both run
on the same machine over one ethernet board.  The devices also allow network
protocol stacks to be written in a hardware-independent fashion so that a
different version of each protocol stack doesn't have to be written for each
networking hardware device.  The standard does not address the writing of
network applications.  Application writers must not use SANA-II Device Drivers
directly.  Network applications must use the API provided by the network
protocol software the application supports.  There is not an Amiga standard
network API at the time of this writing, though there is the AS225 TCP/IP
package and its socket.library as well as other (third-party) packages.
d23 14
d66 15
a80 8
Distribution of this version of the standard is unlimited.

It is important to test as many SANA-II devices as possible against as much
SANA-II using software as possible.  Available example programs are valuable
in initial testing.  The Amiga Networking Group is interested in receiving
evaluation and/or beta copies of any SANA-II using hardware and software
developed by third parties, but makes no assurances regarding any testing
which it may or may not perform with such evaluation copies.  Contact:
d93 4
a96 4
IORequest structure and a number of extended commands for network statistics,
broadcast/multicast, addressing and unexpected packets.  The Amiga ROM Kernel
Reference Manual: Devices includes information on how to construct an Exec
device.
d148 3
a150 3
		Autodocs).  The bytes used to hold the address will be left
		justified but the bit layout is dependent on the particular
		type of network.
d187 1
a187 1
	MINE
d191 1
a191 1
	PROM
d199 1
a199 1
	RAW
d205 1
a205 1
	BCAST
d209 1
a209 1
	MCAST
d213 1
a213 1
	QUICK
d221 7
a227 6
buffers, but read/write to/from a driver-user-allocated abstract data
structure via calls to functions provided by the driver user.  The driver user
must provide two functions -- one copies data to the abstract data structure
and one copies data from the abstract data structure.  The driver user can
therefore choose the data structure used for buffer management by both the
driver and driver user in order to have efficient memory and CPU usage overall.
d230 4
a233 3
driver is not allowed to make assumptions about how the data is stored and
therefore cannot directly manipulate or examine the buffer in any manner
whatsoever except by calling the functions provided by the driver user.
d246 2
a247 2
taglist to driver-owned memory and then to parse the list for every IORequest,
but it is much more efficient for the driver to create some sort of table of
d292 8
a299 10

SANA-II ethernet drivers return packets contained in ethernet frames
abnormally when the requested Type falls within the 802.3 range.  All 802.3
frames have numbers less than 1500 in the type field.  The only frames with
numbers less than 1500 in the type field are 802.3 frames.  If the Type
requested is within the 802.3 range, the driver returns the next packet
contained within an 802.3 frame, regardless of the type specified for the
packet within the 802.3 frame.  This requires that there be no more than one
driver user requesting 802.3 packets and that it do it's own interpretation of
the frames.
d324 2
a325 2
demand for that extra performance, a new hardware type may be allocated for
SANA-II ARCNET device drivers which implement the new framing.
d343 1
a343 1
Driver users who do not implement the bit shifting necessary to use a network
d345 2
a346 2
significant bits in the address field (returned from S2_DEVICEQUERY) to make
sure that it is evenly divisible by eight.
d373 9
a381 9
The HardwareType returned by S2_DEVICEQUERY is necessary for those protocols
whose standards require different behavior on different hardware.  It is also
useful for determining appropriate packet type numbers to use with the device.
The HardwareType values already issued for standard network hardware are the
same as those in RFC 1060 (assigned numbers).  Hardware developers
implementing networks without a SANA-II hardware number must contact CATS to
have a new hardware type number assigned.  Driver users should all have
reasonable defaults which can be used for hardware with which they are not
familiar.
d508 2
a509 2
See the Autodocs for full details on each of the SANA-II device commands.
Extended commands are explained in the sections below.
d615 1
a615 1
hardware. most drivers will maintain all statistics.  The stats are returned
d726 7
a732 7
it.  In order to properly S2_CONFIGINTERFACE, first call S2_GETSTATIONADDRESS
to determine the factory address (if any).  Also provide for user-override of
the factory address (that address may be optional and the user may need to
override it).  When S2_CONFIGINTERFACE returns, check the ios2_SrcAddr for the
actual address the hardware has been configured with. This is because some
hardware (or serial line standards such as PPP) always dynamically allocates
an address at initialization.
d801 5
a805 4
S2ERR_OUTOFSERVICE because the driver is offline.  In such an event, the
driver will usually want to wait until the unit comes back S2_ONLINE.  It
may do this by calling S2_ONEVENT to wait for S2EVENT_ONLINE. S2_ONEVENT
allows the driver user to wait on various events.
@


1.6
log
@few minor english corrections
@
text
@d4 1
a4 1
January 1, 1991
d15 35
a49 16
The SANA-II Network Device Driver Specification is a standard for the
interface to any Amiga networking hardware.  It is a specification for an
Amiga software interface to the data link layer in the ISO 7-Layer Reference
Model of Open Systems Interconnection.  All Amiga network hardware vendors
should supply a SANA-II device driver for their hardware. All protocol writers
should talk to SANA-II device drivers rather than to network hardware.  Any
protocol stack should work with any SANA-II device driver.  The standard is
simple and straight-forward such that SANA-II device drivers should be easy to
write and to use.  They should be highly efficient and have low resource
usage.  Any SANA-II device driver should behave very much like any other
SANA-II device driver.

Application writers must not use SANA-II Device Drivers directly.
Applications must use the API provided by the network protocol software the
application supports.  There is not an Amiga standard network API at the time
of this writing.
d52 5
a56 5
developers and the Amiga community at large.  These drafts include that
released to UseNet and distributed on the Fish Disks in June, 1991 (as well
as published in the '91 DevCon notes), the November 7 Draft for Final Comment
and Approval distributed via Bix, ADSP and Usenet and several inbetween drafts
with more limited distribution.
d66 5
a70 7
SANA-II using software as possible.  The example programs available on Bix,
the Internet, ADSP and the Networking Developer's Disk (availble from CATS
or your local support manager) are valuable in initial testing.  The Amiga
Networking Group is interested in receiving evaluation and/or beta copies of
any SANA-II using hardware and software developed by third parties, but makes
no assurances regarding any testing which it may or may not perform with such
evaluation copies.  Contact:
d73 2
a74 2
	Engineering Dept.
	c/o Commodore Business Machines
d92 3
a94 3
device is passed an IORequest structure to initialize for use by the opener.
This structure is copied by the opener if it desires to use multiple
asynchronous requests.  The SANA-II IORequest is defined as follows:
a110 1
A standard Exec device IORequest.
d112 2
d115 3
a117 2
A more specific device code which may be set when there is an
io_Error.  See <devices/sana2.h> for the defined WireErrors.
a119 1
The type of packet requested.  See the section on "Packet Types".
d121 3
d125 6
a130 4
The device fills in this field with the interface (network hardware) address
of the source of the packet that satisfied a read command. The bytes used to
hold the address will be left justified but the bit layout is dependent on the
particular type of network.
a132 3
This field is filled in with the interface destination address of the packet
for a send command. The bytes used to hold the address will be left justified
but the bit layout is dependent on the particular type of network.
d134 8
d143 9
a151 6
This field is initialized with the amount of data available in the buffer
before passing the IOSana2Req to the device.  The device fills in this field
with the size of the packet data as it was sent on the wire. This does not
include the header and trailer information. Depending on the network type and
protocol type, the driver may have to calculate this value. This is generally
used only for reads and writes (including broadcast and multicast).
d154 5
a158 3
A pointer to some abstract data structure containing packet data.  Drivers may
not directly manipulate or examine anything pointed to by Data!  This is
generally used only for reads and writes (including broadcast and multicast).
a160 3
Pointer to a data area in memory to place a snapshot of device statistics.
The data area must be long word aligned.  This is only used on calls to the
statistics commands.
d162 4
d167 7
a173 5
A pointer to a taglist when OpenDevice() is called.  Functions pointed to in
the taglist are called by the device when processing IORequests from the
opener. When returned from OpenDevice(), this field contains a pointer to
driver-private information used to access these functions.  See "Buffer
Management" below for more details.
d178 2
a179 1
Exclusive access to the unit requested.
d182 3
a184 3
Promiscuous mode requested.  Hardware which supports promiscuous mode allows
all packets being sent over the wire to be captured whether or not they are
addressed to this node.
a189 3
Raw packet read/write requested.  Raw packets should include the entire
data-link layer packet.  Devices with the same hardware device number should
have the same raw packet format.
d191 4
d196 2
a197 1
Broadcast packet (received).
d200 2
a201 1
Multicast packet (received).
a203 1
Quick IO requested.
d205 1
d207 1
d211 26
a236 24
buffers, but read and write to and from a protocol-allocated abstract data
structure via calls to functions provided by the protocol.  The protocol must
provide two functions -- one to copy data to the abstract data structure and
one to copy data from the abstract data structure.  The protocol can therefore
use it's choice of data structure for buffer management and allow this to be
used by the driver in order to have efficient memory and CPU usage overall.

The Sana2IOReq contains a pointer to data and the length of the data pointed
to.  A driver is allowed to make no assumptions about how the data is stored
and therefore cannot directly manipulate or examine the buffer in any manner
whatsoever except by calling the protocol-provided functions.

At OpenDevice() a protocol points ios2_BufferManagment to a list of tags
(defined in <devices/sana2.h>) which include pointers to the buffer management
functions required by the driver (defined below).  The driver makes sure that
all required functions are supplied and fails the open if they are not.  If
the open is successful, the driver sets ios2_BufferManagement to a value which
must be used in all future calls to the driver by this opener.  This "magic
cookie" is used from then on to access these functions.  The protocol
may not use the "magic cookie" in any way -- it is for the driver to do with
as it wishes.  The driver could in theory choose to just copy the taglist to
driver-owned memory and then to parse the list for every IORequest, but it is
much more efficient for the driver to create some sort of table of functions
and to point ios2_BufferManagement to that table.
d255 2
a256 2
type number which is not registered for the standard hardware being accessed
or in a manner inconsistent with that registration.
d259 3
a261 2
the type of packet the protocol wants.  Multiple protocols can therefore run
over the same wire using the same driver without stepping on each other's toes.
d264 5
a268 5
means different things on different wires. Protocol writers must allow their
software to be configured with a SANA-II device name, unit number and the
type number(s) to be used by the protocol stack with each device.  This way if
new hardware becomes available, the manufacturer-supplied listing of type
assignments can be used to configure the protocol.
d277 1
a277 1
can be cumbersome and inefficient, as well as requiring protocol writers to be
d281 4
a284 3
SANA-II ethernet drivers return packets contained in ethernet frames normally
when the requested Type does not fall within the 802.3 range (all and only
802.3 frames have numbers less than 1500 in the type field).  If the Type
d288 2
a289 2
protocol stack requesting 802.3 packets and that it do it's own interpretation
of the frames.
d299 7
a305 7
consist entirely of a one, possibly two, byte protocol ID.  New ARCNET
software headers (defined in RFC 1201 and in the paper "ARCNET Packet Header
Definition Standard", Novell, Inc., 1989) include more information.  They allow
more efficient use of ARCNET through data link layer fragmentation and
reassembly (ARCNET has a small Maximum Transmisson Unit) and allow any size
packet up to the MTU to be sent (rather than requiring that packets of size
253, 254 and 255 be padded to at least 256 bytes).
d308 8
a315 8
headers.  Protocols which wish to interoperate with platforms using the new
software headers must add the new fields to the data being sent and process it
for incomming data.  A SANA-II driver which implemented the data link layer
fragmentation internally (and advertised a large MTU) could be more efficient
than requiring the protocol stack to do it.  This would make driver writing
more difficult and reduce interoperability, but if there is ever a demand for
that extra performance, a new hardware type may be allocated for SANA-II
ARCNET device drivers which implement the new framing.
d320 2
a321 3
Network hardware addresses are stored under the SANA-II standard in an array
of n bytes. No meaning is ascribed to the contents of the array by the
standard.
d324 1
a324 3
of a number of bits not divisible by eight, here is how such addresses should
be represented.  Padding necessary because the number of significant bits
in an address is not evenly divisible by eight belongs at the end of the bit
d333 4
a336 4
Protocols which choose not to implement the bit shifting necessary to use a
network with such addressing (should one exist) should at least check the
number of significant bits in the address field (returned from S2_DEVICEQUERY)
to make sure that it is evenly divisible by eight.
d338 6
a343 5
Protocol software will map hardware addresses to protocol addresses in a
protocol and hardware dependent manner, as described by the relevant
standards.  Some protocols will always use the same mapping on all hardware,
but other protocols will have particular address mapping schemes for some
particular hardware and a reasonable default for other (unknown) hardware.
d346 7
a352 7
hardware addresses.  As an example, consider PPP.  PPP (Point-to-Point
Protocol) is a standard for transmitting packets over a serial line.  It uses
IP addresses as "hardware addresses."  The specific address is negotiated
during the establishment of a connection.  Thus, the address in SrcAddr
returned from the SANA-II device commands S2_CONFIGINTERFACE (or in a
subsequent S2_GETSTATIONADDRESS) from a PPP driver will be the length of an IP
address and will only be valid after the device has been configured.
d358 1
a358 1
handled.
d364 8
a371 7
whose standards require different behavior on different hardware and for
determining appropriate packet type numbers to use with the device.  The
HardwareType values already issued for standard network hardware are the same
as those in RFC 1060 (assigned numbers).  Hardware developers implementing
networks without a SANA-II hardware number must contact CATS to have a new
hardware type number assigned.  Protocols should all have reasonable defaults
which can be used for hardware with which they are not familiar.
d377 3
a379 3
ios2_Error and ios2_WireError fields.  IOSana2Reqs must always be checked on
return for an error in ios2_Error.  ios2_Error will be zero if no error
occurred, otherwise it will contain a value from <exec/errors.h> or
d389 1
a389 22
	NO_RESOURCES
Insufficient resources available.

	BAD_ARGUMENT
Noticeably bad argument.

	BAD_STATE
Command inappropriate for current state.

	BAD_ADDRESS
Noticably bad address.

	MTU_EXCEEDED
Write data too large.

	NOT_SUPPORTED
Command is not supported by this driver. This is similar to IOERR_NOCMD as
defined in <exec/errors.h> but S2ERR_NOT_SUPPORTED indicates that the
requested command is a valid SANA-II command and that the driver does not
support it because the hardware is incapable of supporting it (e.g.,
S2_MULTICAST).  Note that IOERR_NOCMD is still valid for reasons other than a
lack of hardware support (i.e., commands which are no-ops in a SANA-II driver).
d391 1
a391 2
	SOFTWARE
Software error of some kind.
d393 35
a427 3
	OUTOFSERVICE
When a protocol is taken offline, any pending requests are returned with this
error.
d429 1
a429 1
	SEE ALSO the standard errors in <exec/errors.h>.
d431 1
d433 1
d435 1
a435 1
IOSana2Req S2io_WireError field (S2WERR_xxx):
d437 54
a490 2
	NOT_CONFIGURED
Command requires unit to be configured.
d492 2
a493 42
	UNIT_ONLINE
Command requires that the unit be offline.

	UNIT_OFFLINE
Command requires that the unit be online.

	ALREADY_TRACKED
Protocol is already being tracked.

	NOT_TRACKED
Protocol is not being tracked.

	BUFF_ERROR
Buffer management function returned an error.

	SRC_ADDRESS
Problem with the source address field.

	DST_ADDRESS
Problem with destination address field.

	BAD_BROADCAST
Problem with an attempt to broadcast.

	BAD_MULTICAST
Problem with an attempt to multicast.

	MULTICAST_FULL
Multicast address list full.

	BAD_EVENT
Event specified is unknown.

	BAD_STATDATA
The S2IO_StatData pointer or the data it points to failed a sanity check.

	IS_CONFIGURED
Attempt to reconfigure the unit.

	NULL_POINTER
A NULL pointer was detected in one of the arguments.  S2ERR_BAD_ARGUMENT
should always be the S2ERR.
d502 1
a502 1
this may not always be the case  For example, CMD_RESET might someday be used
d515 3
a517 3
which is sent to all other machines.  A multicast is a packet which is sent to
a set of machines. Drivers for hardware which does not allow broadcast or
multicast will return ios2_Error S2ERR_NOT_SUPPORTED as needed.
d523 7
a529 6
To send a multicast, use S2_MULTICAST instead of CMD_WRITE.  To receive a
multicast, the multicast address to be received on must be added with
S2_ADDMULTICASTADDRESS and then a CMD_READ must be placed for the type of
packet to be received.  Some SANA-II devices which support multicast may have
a limited number of multicast addresses which can be received simultaneously,
so check for S2WERR_MULTICAST_FULL when adding a multicast address.
d531 3
a533 3
Note that when the device adss a multicast address, it is usually added for
all users of the device, not just the protocol which called
S2_ADDMULTICASTADDRESS.  In other words, multicast packets received will fill
d535 1
a535 1
protocol stack is the same which added the multicast address.
d537 3
a539 3
In general, protocol stacks should not care how received packets were sent
(normally or broadcast/multicast), only that it was recieved.  If a protocol
really must know, however, it can check for SANA2IOB_BCAST and/or
d580 2
a581 1
Number of packets of a particular type sent.
d584 3
a586 1
Number of packets of a particular type that satisfied a read command.
a588 1
Number of bytes of data sent in packets of a particular type.
d590 2
d593 3
a595 2
Number of bytes of data of a particular packet type that satisfied a read
command.
d598 3
a600 2
Number of packets of a particular type that were received while there were no
pending reads of that packet type.
d604 3
a606 2
required to keep all applicable statistics, and most drivers will therefore
keep all of them.  The stats are returned in a struct Sana2DeviceStats:
a619 1
Number of packets that this unit has received.
d621 2
d624 2
a625 1
Number of packets that this unit has sent.
d628 2
a629 1
Number of bad packets received (i.e., hardware CRC failed).
a631 2
Number of packets dropped due to insufficient resources available in the
network interface.
d633 3
d637 3
a639 2
Number of packets received that had no pending read command with the
appropriate packet type.
a642 1
Number of network reconfigurations since this unit was last configured.
d644 3
d648 2
a649 1
The time when this unit last went online.
d653 1
a653 1
Each new wire type will have a set of documented required statistics for that
a667 1
Statistic identifier.
d669 2
d672 4
a675 1
Statistic itself.
d677 2
a678 3
String
Identifying null-terminated string for the statistic. Should be plain ASCII
with no formatting characters.
a688 2
Space for this many number of records is available to place statistics
information in.
d690 3
d694 2
a695 1
Number of statistic records supplied.
d710 3
a712 3
The device driver needs to configure the hardware before using it.  The
protocol stack must know some network hardware parameters (hardware address
and MTU, for example) when using it.  These commands address those needs.
d714 9
a722 9
When a network protocol is initialized, it should try to S2_CONFIGINTERFACE
even though an interface can only be configured once and someone else may have
done it.  In order to properly S2_CONFIGINTERFACE, first call
S2_GETSTATIONADDRESS to determine the factory address (if any).  Also provide
for user-override of the factory address (that address may be optional and the
user may need to override it).  When S2_CONFIGINTERFACE returns, check the
ios2_SrcAddr for the actual address the hardware has been configured with.
This is because some hardware (or serial line standards such as PPP) always
dynamically allocates an address at initialization.
d724 3
a726 3
Protocol writers will want to use S2_DEVICEQUERY to determine the MTU and
other characteristics of the network.  The structure returned from
S2_DEVICEQUERY is defined as:
d741 3
a743 2
Size, in bytes, of the space available in which to place device information.
This includes both size fields.
a745 1
Size, in bytes, of the data supplied.
d747 2
d750 2
a751 1
The format defined here is format 0.
d754 2
a755 1
This spec defines level 0.
a757 1
The number of bits in an interface address.
d759 2
d762 5
a766 2
Maximum Transmission Unit, the size, in bytes, of the maximum packet size, not
including header and trailer information.
d768 2
a769 2
BPS
Best guess at the raw line rate for this network in bits per second.
a771 1
Specifies the type of network hardware the driver controls.
d773 1
d775 1
d790 1
a790 1
All protocol software must understand that any IO request may return with
d792 1
a792 1
protocol will usually want to wait until the unit comes back S2_ONLINE.  It
d794 1
a794 1
allows various events for the driver to wait on.
d797 4
a800 4
events.  S2_ONEVENT is returned with S2_ERR_NOT SUPPORTED and S2WERR_BAD_EVENT
for unsupported Events.  One error may cause more than one Event (see below).
Errors which seem to have been caused by a malformed or unusual request should
not generally trigger an event.
d805 2
a806 1
Return when any error occurs.
d809 2
a810 1
Return on any transmit error.  (Always an Error.)
a812 1
Return on any receive error.  (Always an Error.)
d814 2
d817 3
a819 2
Return when unit goes online or return immediately if unit is already online.
(Not an Error.)
d822 3
a824 2
Return when unit goes offline or return immediately if unit is already
offline. (Not an Error.)
a826 1
Return on any buffer management function error.  (Always an Error.)
d828 3
d832 3
a834 2
Return when any hardware error occurs.  (Always an Error, may be a TX or RX,
too.)
d837 3
a839 2
Return when any software error occurs.  (Always an Error, may be a TX or RX,
too.)
@


1.5
log
@incorporated more johno/bj critisism
@
text
@d211 3
a213 3
and every type number is registered with some official body.  You must not use
a type number which is not registered for the standard hardware you are
accessing or in a manner inconsistent with that registration.
d324 4
a327 4
as those in RFC 1060 (assigned numbers).  If you are a hardware developer implementing a
a new type of network, contact CATS to have a hardware type number assigned to
you.  Protocols should all have reasonable defaults which can be used for
hardware with which they are not familiar.
d459 2
a460 2
a limited number of multicast addresses which can be received simultaneously
so you must check for S2WERR_MULTICAST_FULL when adding a multicast address.
@


1.4
log
@incorporated suggested johno changes
@
text
@d21 5
a25 5
protocol stack should work with any SANA-II device driver.  The standard has
been kept simple and straight-forward so that SANA-II device drivers should be
easy to write and to use.  They should be highly efficient and have low
resource usage.  Any SANA-II device driver should behave very much like any
other SANA-II device driver.
d65 1
a65 1
SANA-II device drivers are Amiga Exec device drivers.  They have an extended
a70 42
Buffer Management

Most Exec Device drivers read and write contiguous blocks of data and keep
internal buffers.  Networking software is very good at physically fragmenting
a logical block of data with headers and trailers as well as requiring
dynamically tunable buffers for optimal performance.  To allow the efficient
implementation of networking protocols therefore requires a non-contiguous
physical data structure with a buffering scheme which is easily externally
tunable.

Unlike most other Exec Device drivers, SANA-II drivers have no internal
buffers, but read and write to and from a protocol-allocated abstract data
structure via calls to functions provided by the protocol.  The protocol must
provide two functions -- one to copy data to the abstract data structure and
one to copy data from the abstract data structure.  The protocol can therefore
use it's choice of data structure for buffer management and allow this to be
used by the driver in order to have efficient memory and CPU usage overall.

The Sana2IOReq contains a pointer to data and the length of the data pointed
to, but a driver is allowed to make no assumptions about how the data is
stored and therefore cannot directly manipulate or examine the buffer in any
manner whatsoever other than by calling the protocol-provided functions.

At OpenDevice() a protocol points ios2_BufferManagment to a list of tags which
include pointers to the functions required by the driver.  The driver makes
sure that all required functions are supplied and fails the open if they are
not.  If the open is successful, the driver sets ios2_BufferManagement to a
"magic cookie" which it uses from then on to access these functions.  The
protocol may not use the "magic cookie" in any way -- it is for the driver to
do with as it wishes.  The driver could in theory choose to just copy the
taglist to driver-owned memory and then to parse the list for every IORequest,
but it is much more efficient for the driver to create some sort of table of
functions and to point ios2_BufferManagement to that table.

The specification currently includes only two tags for the OpenDevice()
ios2_BufferManagement taglist:

S2_CopyToBuff    -  This is a pointer to a function which conforms to the
		    CopyToBuff autodoc.

S2_CopyFromBuff  -  This is a pointer to a function which conforms to the
		    CopyFromBuff autodoc.
a71 1

d76 2
a77 2
This structure is copied by the opener if it desires to use multiple async
requests.  The SANA-II IORequest is defined as follows:
d101 1
a101 1
The type of packet requested.  See the section on Packet Types.
d115 6
a120 6
Before given to the device, this field is initialized with the amount of data
available in the buffer.  The device fills in this field with the size of the
packet data as it was sent on the wire. This does not include the header and
trailer information. Depending on the network type and protocol type, the
driver may have to calculate this value. This is generally used only for reads
and writes (including broadcast and multicast).
d124 2
a125 3
not directly manipulate or examine anything pointed to by Data!  This pointer
is generally used only for reads and writes (including broadcast and
multicast).
d129 2
a130 2
The data area must be long word aligned.  This pointer is only used on calls
to the statistics commands.
d133 5
a137 4
A pointer to a taglist when OpenDevice() is called.  Functions pointed to in the
taglist are called by the device when processing IORequests from the opener.
When returned from OpenDevice(), this field contains a pointer to driver
private information used to access these functions.
d167 38
d210 1
a210 1
Types" below.).  The meaning of the type numbers are always carefully defined
d212 2
a213 5
a type number which is not registered with the governing body for the standard
hardware you are accessing.  Basically, this means that if you want to write a
new protocol (rather than implementing an existing one), you've got a lot of
paperwork ahead of you.  This is one of the reasons why applications cannot be
written directly on top of SANA-II device drivers.
d219 6
a224 13
Packet types are specified simply as a long word.  No current hardware uses
more than a long word type and it is at all likely that a longer type field
would be adapted for use in a common hardware frame within the lifetime of
this standard.  Furthermore, if such a problem ever did arise, it is certainly
the case that there wouldn't be more than a longword of types in use and we
could provide some kind of mapping in the drivers for such a wire.

Unfortunately, the type field means different things on different wires.
Protocol writers must allow their protocol to be configurable with a SANA-II
device name, unit number and the type number(s) used by the protocol stack
with this device.  This way if new hardware becomes available, the
manufacturer-supplied listing of type assignments can be used to configure the
protocol.
a235 10
The original standard called for a generalized "Packet Magic" which all
drivers and protocols had to deal with, even though few people should ever
have to worry about the problem.  We could also have specified that there are
802.3 SANA-II drivers and that there are ethernet drivers and that if you want
802.3 and ethernet (even if on the same wire) from the same machine, use two
ethernet boards.  This didn't make sense because we don't anticipate multiple
protocols needing to use 802.3 frames nor much encouragement for hardware
manufactures to provide special 802.3 drivers.  The current solution keeps the
standard simple and allows highly efficient implementations, but it does make
ethernet drivers a little more complex and does make using 802.3 frames harder.
d239 6
a244 5
802.3 frames have numbers less than 1500 in the type field).  If a Type within
the 802.3 range is requested, the driver returns the next packet contained
within an 802.3 frame, regardless of the type of the packet within the 802.3
frame.  This requires that there be no more than one requestor of 802.3
packets and that it do it's own interpretation of the frames.
d251 1
a251 2
area of the hardware packet, and includes at least the protocol ID.  There
are two types of software header.
d253 8
a260 9
Old-style ARCNET software headers consist entirely of a one, possibly two,
byte protocol ID.

New ARCNET software headers (defined in RFC 1201 and in the paper "ARCNET
Packet Header Defintion Standard", Novell, Inc., 1989) include more
information.  They allow more efficient use of ARCNET through data link layer
fragmentation and reassembly (ARCNET has a small Maximum Transmisson Unit) and
allow any size packet up to the MTU to be sent (rather than requiring that
packets of size 253, 254 and 255 be padded to at least 256 bytes).
d264 7
a270 5
software headers must can add the new fields to the data being sent.  This
isn't quite as efficient as a SANA-II driver which used the new framing and
advertised a large MTU could be, but it makes writing drivers simpler.  If
there is ever a demand for that extra performance, a new hardware type may be
allocated for SANA-II ARCNET device drivers which implement the new framing.
d279 6
a284 5
We know of no network which does not have an address field consisting of a
number of bits not divisible by eight.  In case one exists, however, any
padding necessary because the number of significant bits in an address is not
evenly divisible by eight belongs at the end of the bit stream.  For example,
if an address is ten bits long it will be stored like this:
d296 5
a300 5
Protocols will map hardware addresses to protocol addresses in a protocol and
hardware dependent manner.  Some protocols will always use the same mapping on
all hardware, but other protocols will have particular address mapping schemes
for some particular hardware and a reasonable default for other (unknown)
hardware.
d305 11
a315 11
IP addresses as "hardware addresses."  The specific address to be used is
negotiated during the establishment of a connection.  Thus, the address in
SrcAddr returned from S2_CONFIGINTERFACE (or in a subsequent
S2_GETSTATIONADDRESS) from a PPP driver will be the length of an IP address
and will only be valid after the device has been configured.

Note that some hardware always uses a ROM hardware address, while other
hardware which has a ROM address or is configurable with DIP switches may be
overriden by software and that some hardware always dynamically allocates a
new hardware address at initialization. See Configuration for details on how
this is handled.
d324 1
a324 1
as those in RFC 1060 (assigned numbers).  If you are a hardware developer with
d326 2
a327 2
you and added to the SANA-II includes.  Protocols should all have reasonable
defaults for hardware with which they are not familiar.
d333 3
a335 3
ios2_Error and ios2_WireError fields.  IOSana2Reqs returned to the requester
must always be checked for an error in ios2_Error.  ios2_Error will be zero if
no error occurred, else it will contain a value from <exec/errors.h> or from
d378 1
d397 1
a397 1
Buffer management function error return caused error.
d430 2
a431 3
See the autodocs for full details on each of the Exec device standard and
SANA-II device extended commands.  Extended commands are explained in the
sections below.
d434 3
a436 4
some of these might become used in the future depending on the needs of new
hardware for which SANA-II devices are implemented.  For example, CMD_RESET
might someday be used for dynamically reconfiguring hardware on which this is
useful.  This should present no compatibility problems.
d449 1
a449 2
multicast will return ios2_Error S2ERR_NOT_SUPPORTED on an attempt to use an
inappropriate function.
d451 3
a453 3
To send a broadcast, just use S2_BROADCAST instead of CMD_WRITE.  Broadcasts
are received just like any other packets, with a CMD_READ for the appropriate
packet type.
d455 2
a456 2
To send a multicast, just use S2_MULTICAST instead of CMD_WRITE.  To receive a
multicast, the multicast address to be listened on must be added with
d459 2
a460 9
a limited number of multicast addresses which can be listened on
simultaneously so you must thus check for S2WERR_MULTICAST_FULL when adding a
multicast address.

Note that when a multicast address is added, it is usually added for all users
of the device, not just the protocol which called S2_ADDMULTICASTADDRESS.  In
other words, if packets of a type you are requesting are multicast to an
address for which S2_ADDMULTICAST has been called, you will receive these
packets even if you weren't the protocol calling S2_ADDMULTICAST.
d462 10
a471 3
In general, when you receive a packet, you should not care how the packet was
sent, only that it got to you.  If you really want to know, however, you can
check for SANA2IOB_BCAST and/or SANA2IOB_MCAST in the ios2_Flags field.
d487 5
a491 5
There are many statistics which may be very important to the protocol writer
trying to debug, optimize and tune an implementation as well as to the end
user who may need to tune parameters or investigate a problem.  Some of these
statistics can only be kept by the SANA-II driver, and there are thus many
required and optional statistics and commands to get at these.
d569 6
a574 6
It is hoped that each wire type will have a set of documented required
statistics for that wire type and a standard set of optional statistics for
that wire type (optional because they might not be available from all
hardware).  The data returned by S2_GETSPECIALSTATS will require wire-specific
interpretation, see <devices/sana2specialstats.h> for currently defined
special statistics.  The statistics are returned in the following structures:
d590 2
a591 2
Identifying string for the statistic. Should be plain ASCII with no formatting
characters.
d621 3
a623 3
Network hardware needs to be configured before it is used.  Some parameters
about the hardware must be known by protocol software (hardware address and
MTU, for example) when it is used.  These commands address those needs.
d625 9
a633 9
When a network protocol is started, it should try to S2_CONFIGINTERFACE even
though an interface can only be configured once and someone else may have done
it.  In order to properly S2_CONFIGINTERFACE, you must first
S2_GETSTATIONADDRESS to determine the factory address (if any).  You must also
provide for user-override of the factory address (that address may be optional
and the user may need to override it).  When S2_CONFIGINTERFACE returns, you
must check the ios2_SrcAddr for the actual address the hardware has been
configured with.  This is because some hardware (or serial line standards such
as PPP) always dynamically allocates an address at initialization.
d684 19
a702 19
In order to allow hardware tests to be run on an otherwise live system, the
S2_OFFLINE command allows the SANA-II device driver to be "turned off" until
the tests are complete and an ONLINE is sent to the driver.  S2_ONLINE causes
the interface will be re- configured and re-initialized, and any packets
destined for the hardware while the device was offline will have been lost.
All pending and new requests to the driver should be returned with
S2ERR_OUTOFSERVICE when a device is offline.

All protocol software must understand that any IO request may be returned with
S2ERR_OUTOFSERVICE because the driver has been taken offline.  In such an
event, the protocol will usually want to wait until the unit comes back
S2_ONLINE.  It may do this by calling S2_ONEVENT to wait for S2EVENT_ONLINE.
S2_ONEVENT allows various events for the driver to be waited on.

Events usually happen in multiples.  A driver must track events, but may not
distinguish between some types of events.  If an event is not tracked, an
S2_ONEVENT for the event is returned with S2_ERR_NOT SUPPORTED and
S2WERR_BAD_EVENT.  Errors which seem caused by a malformed or unusual request
should not generally trigger an event.
d738 1
a738 1
Driver Specification.  The original SANA-II autodocs and includes were put
d741 8
a748 7
document at the hands of Dale Larson and Greg Miller.  Randell Jesup has
provided sage advice on several occasions and the buffer management callback
mechanism was his idea.  Dale Luck (GfxBase) and Rick Spanbauer (Ameristar
Technologies) have provided valuable comments throughout the process.  Nicolas
Benezan (ADONIS) provided many very detailed and useful comments on weaknesses
in late drafts of the specification.  Thanks to all the above and the numerous
others who have contributed with their comments, questions and discussions.
@


1.3
log
@fixed again
@
text
@d29 2
a30 2
application supports.  It is hoped that a standard network API for all Amigas
will be made available by Commodore in the near future.
a62 60
Changes

There have been no substantive changes from the Novemeber 7 Draft for Final
Comment and approval.  There have been minor clarifications and typographical
corrections and a section was added to clarify ARCNET framing.

Since the Fish Disk/'91 DevCon draft of the SANA-II standard, here is a
summary list of the important changes:

- Packet type specification has been drastically simplified.  Protocols no
longer specify any framing information -- packet magic is eliminated and a
convention is adopted for handling the framing problem faced by ethernet
drivers.

- NetBuffs are removed from the standard and replaced with a function callback.

- Station aliasing has been eliminated from the standard.

- Since the IOSana2Req structure had to be changed anyway, many names in
<devices/sana2.h> have been changed to be more consistent with other system
names. It is believed that global search and replace should make this a mostly
trivial change and that the benefits gained from consistent naming outweigh
the inconvenience to those few who have existing SANA-II code.

- Events are now defined as a bit mask rather than as scalars.


Acknowledgements

Many people and companies have contributed to the SANA-II Network Device
Driver Specification.  The original SANA-II autodocs and includes were put
together by Ray Brand, Perry Kivolowitz (ASDG) and Martin Hunt.  Those
original documents evolved to their current state and grew to include this
document at the hands of Dale Larson and Greg Miller.  Randell Jesup has
provided sage advice on several occasions and the buffer management callback
mechanism was his idea.  Dale Luck (GfxBase) and Rick Spanbauer (Ameristar
Technologies) have provided valuable comments throughout the process.  Nicolas
Benezan (ADONIS) provided many very detailed and useful comments on weaknesses
in late drafts of the specification.  Thanks to all the above and the numerous
others who have contributed with their comments, questions and discussions.


Unresolved Issues

Unfortunately, it isn't possible to completely isolate network protocols from
the hardware they run on.  Hardware types and addressing both remain somewhat
hardware-dependent in spite of our efforts.  See the "Packet Type" section for
an explanation of how packet types are handled and why protocols cannot be
isolated from them.  See the "Addressing" section for an explanation of how
addressing is handled any why protocols cannot be isolated from it.

Additionally, there are at least two cases where a hardware type has multiple
framing methods in use (ethernet/802.3 and arcnet/(Novell)"ARCNET Packet
Header Definition Standard").  In both cases, software which must interoperate
with other platforms on this hardware may need to be aware of the distinctions
and may have to do extra processing in order to use the appropriate frame type.
See the sections on "Ethernet Packet Types" and on "ARCNET frames" for more
details.


d69 1
a69 2
device.  We plan to release source to an example SANA-II device driver in the
near future.
a70 1

d73 1
a73 1
Most Exec device drivers read and write contiguous blocks of data and keep
d76 4
a79 3
dynamically tunable buffers.  To allow the efficient implementation of
networking protocols therefore requires a non-contiguous physical data
structure with a buffering scheme which is easily externally tunable.
d81 7
a87 15
The original SANA-II device driver specification therefore called for drivers
to have no internal buffers and to get all buffers from protocols in the form
of a data structure called a NetBuff. Hence, all protocols were required to
use NetBuffs.  This was highly unsatisfactory since most protocols are
implemented from an existing code base which includes its own buffer
management scheme.

To solve this problem, the standard has been revised so that drivers still
have no internal buffers, but now they read and write to and from an abstract
data structure via calls to functions provided by the protocol.  The protocol
must provide two functions -- one to copy data to the abstract data structure
and one to copy data from the abstract data structure.  The protocol can
therefore use it's choice of data structure for buffer management and allow
this to be used by the driver in order to have very efficient memory and CPU
usage overall.
d97 7
a103 6
not.  If the open is successful, the driver points ios2_BufferManagement to a
magic cookie which it uses from then on to access these functions.  The driver
could in theory choose to just copy the taglist to driver-owned memory and
then to parse the list for every IORequest, but it is much more efficient for
the driver to create some sort of table of functions and to point
ios2_BufferManagement to that table.
d141 1
a141 1
io_Error.
d144 1
a144 1
The type of packet requested.
d147 4
a150 4
The device fills in this field with the interface address of the source of the
packet that satisfied a read command. The bytes used to hold the address will
be left justified but the bit layout is dependent on the particular type of
network.
d158 6
a163 6
The requestor fills this field with the amount of data available in the
buffer. The device fills in this field with the size of the packet data as it
was sent on the wire. This does not include the header and trailer
information. Depending on the network type and protocol type, the driver may
have to calculate this value. This is generally used only for reads and writes
(including broadcast and multicast).
d188 3
a190 1
Promiscuous mode requested.
d227 6
a232 6
Packet types are now specified simply as a long word.  No current hardware
uses more than a long word type and it is at all likely that a longer type
field would be adapted for use in a common hardware frame within the lifetime
of this standard.  Furthermore, if such a problem ever did arise, it is
certainly the case that there wouldn't be more than a longword of types in use
and we could provide some kind of mapping in the drivers for such a wire.
d284 3
a286 3
fragmentation and reassembly (ARCNET has a small MTU) and allow any size
packet up to the MTU to be sent (rather than requiring that packets of size
253, 254 and 255 be padded to at least 256 bytes).
a340 14
Station Aliases

The original standard called for an interface to the ability of some hardware
to simultaneously accept packets for several hardware addresses.  Such a
feature is of dubious usefulness.  In order to simplify the standard, station
aliases are no longer part of the SANA-II Network Device Driver Specification.

If station aliasing does turn out to be a useful feature available on some
hardware for the Amiga, the standard can easily be extended to re-introduce
station aliasing.  Remember that all Exec drivers must check for io_Command
values not supported by the driver. Hence, SANA-II commands can be added
without requiring that existing drivers be rev'd.


a432 6
	ALIAS_LIST_FULL
Station alias list full.

	BAD_ALIAS
Bad or unknown station alias.

d492 1
a492 1
packets even if you didn't add any multicast addresses.
d758 34
@


1.2
log
@January 1 final
@
text
@d8 2
a9 2
Dale Larson, Greg Miller
Amiga Networking Group, New Siberia Office
@


1.1
log
@Initial revision
@
text
@d4 2
a5 2
November 7, 1991
Draft for Final Comments and Approval
d32 11
a42 14
This version of the standard addresses issues from the original SANA-II
standard which were raised in the 1991 North American and European Amiga
DevCons as well as in the conversion of existing protocols to the use of the
standard.  This draft reflects several rounds of comments from active
implementors of SANA-II software.  Most of the changes are simplifications and
should be easy to incorporate into any work in progress.  The changes should
make the writing and use of SANA-II drivers much easier.  Commodore's internal
versions of the A2065 and other drivers and the AS225 software package are
currently compliant with this version of the SANA-II spec.

This version of the specification is very solid and will stand as final unless
comments containing very compelling objections are received by December 31,
1991.  All SANA-II device drivers and software utilizing those drivers should
be written to this version of the specification.
d46 15
a60 3
Comments should be emailed to dlarson@@cmbvax.commodore.com or sent to Dale
Larson, Software Engineer, Commodore, 1200 Wilson Drive, West Chester, PA
19380, USA.
d65 3
a67 3
Most changes are explained in detail below, but for those already familiar
with the 1991 DevCon draft of the SANA-II standard, here is a summary list of
the important points:
d69 3
d114 7
a120 7
Finally, some protocol standards are simply very hardware specific.  They have
particular issues which can't be dealt with from a general data link layer
specification designed to isolate protocols from hardware.  For example,
TCP/IP RFC 1201 cannot be implemented without a special hardware driver.  The
impact of such issues should be negligible for most protocols running on most
hardware, and the issues won't be made significantly more difficult to address
by virtue of existence the SANA-II standard.
d262 3
a264 1
Raw packet read/write requested.
d335 26
@
