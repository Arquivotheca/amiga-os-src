head     40.7;
branch   ;
access   ;
symbols  ;
locks    ; strict;
comment  @*   @;


40.7
date     93.07.19.10.27.42;  author peter;  state Exp;
branches ;
next     40.6;

40.6
date     93.07.01.18.38.22;  author peter;  state Exp;
branches ;
next     40.5;

40.5
date     93.06.07.16.21.04;  author peter;  state Exp;
branches ;
next     40.4;

40.4
date     93.05.05.09.55.54;  author peter;  state Exp;
branches ;
next     40.3;

40.3
date     93.04.29.10.53.59;  author peter;  state Exp;
branches ;
next     40.2;

40.2
date     93.02.15.18.08.34;  author peter;  state Exp;
branches ;
next     40.1;

40.1
date     93.02.11.12.07.00;  author peter;  state Exp;
branches ;
next     39.5;

39.5
date     93.02.11.12.01.50;  author peter;  state Exp;
branches ;
next     39.4;

39.4
date     92.11.23.10.00.28;  author peter;  state Exp;
branches ;
next     39.3;

39.3
date     92.11.20.11.50.51;  author peter;  state Exp;
branches ;
next     39.2;

39.2
date     92.10.06.09.41.02;  author peter;  state Exp;
branches ;
next     39.1;

39.1
date     92.08.25.11.46.58;  author peter;  state Exp;
branches ;
next     37.2;

37.2
date     92.06.23.13.50.00;  author peter;  state Exp;
branches ;
next     37.1;

37.1
date     91.11.09.15.33.11;  author peter;  state Exp;
branches ;
next     36.31;

36.31
date     91.11.09.00.12.22;  author peter;  state Exp;
branches ;
next     36.30;

36.30
date     91.11.08.22.21.48;  author peter;  state Exp;
branches ;
next     36.29;

36.29
date     91.11.08.11.55.23;  author peter;  state Exp;
branches ;
next     36.28;

36.28
date     91.10.18.15.55.33;  author peter;  state Exp;
branches ;
next     36.27;

36.27
date     91.05.17.02.08.46;  author jesup;  state Exp;
branches ;
next     36.26;

36.26
date     91.05.07.00.38.29;  author jesup;  state Exp;
branches ;
next     36.25;

36.25
date     91.04.01.04.54.27;  author jesup;  state Exp;
branches ;
next     36.24;

36.24
date     91.03.29.01.01.15;  author jesup;  state Exp;
branches ;
next     36.23;

36.23
date     91.03.27.17.10.52;  author jesup;  state Exp;
branches ;
next     36.22;

36.22
date     91.01.25.02.01.30;  author kevin;  state Exp;
branches ;
next     36.21;

36.21
date     90.11.06.15.58.25;  author kevin;  state Exp;
branches ;
next     36.20;

36.20
date     90.11.06.15.10.16;  author kevin;  state Exp;
branches ;
next     36.19;

36.19
date     90.11.06.12.44.33;  author kevin;  state Exp;
branches ;
next     36.18;

36.18
date     90.11.02.23.53.32;  author kevin;  state Exp;
branches ;
next     36.17;

36.17
date     90.11.02.23.49.03;  author andy;  state Exp;
branches ;
next     36.16;

36.16
date     90.05.23.13.15.22;  author kodiak;  state Exp;
branches ;
next     36.15;

36.15
date     90.05.23.13.01.38;  author kodiak;  state Exp;
branches ;
next     36.14;

36.14
date     90.05.01.13.27.13;  author kodiak;  state Exp;
branches ;
next     36.13;

36.13
date     90.04.06.10.17.52;  author kodiak;  state Exp;
branches ;
next     36.12;

36.12
date     90.04.02.13.54.10;  author kodiak;  state Exp;
branches ;
next     36.11;

36.11
date     90.04.02.11.42.23;  author kodiak;  state Exp;
branches ;
next     36.10;

36.10
date     90.03.30.17.17.43;  author kodiak;  state Exp;
branches ;
next     36.9;

36.9
date     90.03.30.15.19.03;  author kodiak;  state Exp;
branches ;
next     36.8;

36.8
date     90.03.30.14.56.36;  author kodiak;  state Exp;
branches ;
next     36.7;

36.7
date     90.03.30.12.52.57;  author kodiak;  state Exp;
branches ;
next     36.6;

36.6
date     90.03.29.16.40.52;  author kodiak;  state Exp;
branches ;
next     36.5;

36.5
date     90.03.29.11.30.35;  author kodiak;  state Exp;
branches ;
next     36.4;

36.4
date     90.03.29.09.59.19;  author kodiak;  state Exp;
branches ;
next     36.3;

36.3
date     90.03.28.15.13.02;  author kodiak;  state Exp;
branches ;
next     36.2;

36.2
date     90.03.27.15.35.28;  author kodiak;  state Exp;
branches ;
next     36.1;

36.1
date     90.03.22.17.23.31;  author kodiak;  state Exp;
branches ;
next     36.0;

36.0
date     90.03.22.10.08.58;  author kodiak;  state Exp;
branches ;
next     ;


desc
@read .xfd files and produce various other public function description files
@


40.7
log
@Private comments no longer placed into fd file 
@
text
@%{
/******	sfd **********************************************************
*
*   NAME
*	sfd -- compile .sfd files
*
*   SYNOPSIS
*	sfd <_lib.sfd files>+		[lib/sfd useage]
*	sfd -h <_lib.sfd files>+	[lib/sfd useage w/o RAM/ROM]
*	sfd -i <_lib.sfd files>+	[local usage: create .i]
*	sfd -f <_lib.sfd files>+	[local usage: create .fd]
*	sfd -v				[determine version]
*
*   FUNCTION
*	sfd consumes files that describe a library's entry points
*	and generates other files in different forms.
*
*   INPUT
*	_lib.sfd file - a file with the file suffix "_lib.sfd"
*	    containing lines describing the library entry points:
*
*	This file has the following format:
*
*	SFD COMMANDS
*
*	SFD Commands exist one to a line, introduced by the character
*	string "==" at the beginning of the line, and extending to the
*	end of the line.
*
*	id: to describe the RCS Id string for the sfd file.  Required
*	    to be the first line in the file.
*	base: to describe the link address for the source for the
*	    module a6 in the RAM/module/*.asm interfaces files, and the
*	    offset off of a6 for the module a6 in the ROM/module/*.asm
*	    interfaces.
*		==base _ModuleBase
*	    The offset is constructed from this: _ModuleBaseOffset
*
*	include: to cause an #include to be generated for the
*	    prototype file to resolve a typedef or #define used
*	    to describe arguments to some of the functions.
*		==include <graphics/gfx.h>
*	    [This defines PLANEPTR for use by graphics functions]
*	    
*	bias: to start the function off
*		==bias 30
*	    This skips over Open/Close/Expunge/Reserved for libraries.
*	    Use 42 for standard devices.
*
*	alias: to alias a function.  The following function definition
*	    keeps the bias of the previous one.
*		LONG DoPkt( struct MsgPort *port, LONG action, LONG arg1,
*			LONG arg2, LONG arg3, LONG arg4 ) (d1,d2,d3,d4,d5,d6)
*		==alias
*		LONG DoPkt1( struct MsgPort *port, LONG action, LONG arg1 )
*			(d1,d2,d3)
*	    
*	varargs: to introduce a varargs alias.  The following function
*	    definition keeps the bias of the previous one, and includes
*	    a prototype with one instance of the varargs parameter,
*	    followed by ...
*		struct Menu *CreateMenusA( struct NewMenu *newmenu,
*			struct TagItem *taglist ) (A0,A1)
*		==varargs
*		struct Menu *CreateMenus( struct NewMenu *newmenu,
*			Tag tag1, ... ) (A0,A1)
*
*	private: to declare the following functions as system use only,
*	    and hide them somewhat.  No #pragma nor RAM/module/*.asm
*	    interfaces are built.
*		==private
*
*	public: to declare the following functions for general use.
*		==public
*
*	reserve: to reserve space in the function table without
*	    generating *any* symbols.  Comments are placed in the
*	    _lib.fd, _pragmas.h, and _protos.h files, and the .fd
*	    file has a ##bias generated for the next function entry.
*	    If a _lib.i file is being created (with the -i option),
*	    FUNCDEF macros are generated for the names moduleReservedNN,
*	    where NN is the -bias of the reserved entry.
*		==reserve 2
*	    reserves two function slots.
*
*	    This is preferred over private/function-declaration/public
*	    as a way to skip over reserved entry points that have no
*	    meaning.
*
*	version: to describe the version of the module that subsequent
*	    functions appear in.  This causes comments to be generated
*	    in _lib.fd, _pragmas.h, and _protos.h files.
*		==version 33
*	    this causes the following comment in the .fd file and similar
*	    ones in the pragma & proto files:
*	    *--- functions in V33 or higher (distributed as Release 1.2) ---
*
*	end: to declare the end of the sfd file.  Required.
*		==end
*
*
*	COMMENTS
*
*	Comments are any line starting with a "*", and last to the
*	end of the line.
*
*		* this is a comment.
*
*	They are converted to comments in the _lib.fd, _pragmas.h,
*	and _protos.h files.
*	o   .fd comments are identical to .sfd comments
*	o   .h comments use the following rules
*	    o   a "/" is prepended to the line
*	    o   if the second character is a blank or a tab, the
*		line is appended with " *\", otherwise, it is
*		appended with "*\".
*	
*
*	FUNCTION DEFINITION
*
*	Anything that is not an sfd command or a comment must be
*	part of a function definition.  A function definition
*	consists of three parts: the return value/function part,
*	the parameter definition, and the register definition:
*	    <return/function>(<parameters>)(<registers>)
*	All three parts must be present.  They may cross lines.
*	A particular function definition is terminated by the
*	second close paranthesis.  A function definition must
*	start on a fresh line.
*
*	    EXAMPLES
*		VOID OpenIntuition() ()
*
*		o   Even an empty parameter list needs an empty register
*		    list.
*		o   The C types void, unsigned, int, short, char, float
*		    and double are not allowed.  Use VOID, [U]LONG,
*		    [U]WORD, [U]BYTE, FLOAT or DOUBLE.  Use APTR, not VOID *.
*		o   Don't put a VOID in an empty parameter list.
*		    Currently, the sfd tool will put one there for you.
*
*		PLANEPTR AllocRaster( UWORD width, UWORD height ) (D0,D1)
*
*		o   The sfd tool must be taught about all-caps primitive
*		    types.  It knows about BPTR, BSTR, STRPTR, IX, and
*		    PLANEPTR so far.
*		o   The parameter list must contain typed variables.
*		o   The register list is generally delimited by commas.
*		    The sfd tool figures out which to cluster for the
*		    resulting _lib.fd file.
*
*		DOUBLE IEEEDPDiv( DOUBLE dividend, DOUBLE divisor )
*			(d0-d1,d2-d3)
*
*		o   The function definition can cross lines.
*		o   DOUBLE registers must be delimited by a dash.
*		o   The register list may use either capital or lower case.
*
*		struct Layer *CreateUpfrontLayer(struct Layer_Info *li,
*			struct BitMap *bm, LONG x0, LONG y0, LONG x1, LONG y1,
*			LONG flags, [struct BitMap *bm2] )
*			(A0,A1,D0,D1,D2,D3,D4,A2)
*
*		o   Optional parameters are indicated by being enclosed
*		    in braces.  Admittedly, the sfd tool currently
*		    outputs the same results as if they were not there,
*		    but we can change that by changing the tool if we
*		    decide to.  Changing the tool instead of changing
*		    the input is an important concept.
*
*		struct Window *OpenWindowTagList( struct NewWindow *newWindow,
*			struct TagItem *tagList ) (A0,A1)
*		==varargs
*		struct Window *OpenWindowTags( struct NewWindow *newWindow,
*			ULONG tag1Type, ... ) (A0,A1)
*		
*		o   The only time ... may appear is for a varargs definition.
*		o   A varargs definition must have one instance of the type.
*
*
*   OUTPUT
*	[lib/sfd usage]
*	    FD/module_lib.fd - an .fd file
*	    HDR/MODULELIBHDR - a bcpl manifest for the function offsets
*	    LVO/module_lib.asm - assembler source for the _LVO offsets
*	    PROTOS/module_protos.h - an ANSI C prototype file
*	    PRAGMAS/module_pragmas.h - a Lattice C #pragma file
*	[...lib/sfd usage w/ RAM/ROM adds...]
*	    RAM/module/*.asm - stack-based C to assembler interfaces
*		for each function, w/ library base at absolute link address
*	    ROM/module/*.asm - stack-based C to assembler interfaces
*		for each function, w/ library base at offset off of a6
*	[local usage]
*	    module_lib.i - macro file for function entries
*
*********************************************************************/

#ifdef   DEBUG
#define  D(a)		printf a
#else
#define  D(a)
#endif

#define  PROTONAMES	1	/* whether _protos.h have names */
#define  PROTOLONGS	1	/* whether num arguments are forced to longs */
#define  SYSBASEPRAGMA	0	/* whether exec #pragmas are special */

#ifdef   LATTICE

#include <string.h>
#define  MKDIR(d,p)	mkdir(d)
#define  RINDEX(s,c)	strrchr(s,c)

#else	/* SUN */

#include <strings.h>
#define  MKDIR(d,p)	mkdir(d,p)
#define  RINDEX(s,c)	rindex(s,c)

#endif

#define	TOKEN_NEWLINE		1
#define	TOKEN_ID		2
#define	TOKEN_BASE		3
#define	TOKEN_INCLUDE		4
#define	TOKEN_BIAS		5
#define	TOKEN_ALIAS		6
#define	TOKEN_VARARGS		7
#define	TOKEN_PRIVATE		8
#define	TOKEN_PUBLIC		9
#define	TOKEN_RESERVE		10
#define	TOKEN_VERSION		11
#define	TOKEN_END		12
#define	TOKEN_COMMENT		13
#define	TOKEN_RCSIDHEAD		14
#define	TOKEN_RCSIDTAIL		15
#define	TOKEN_FILEPATH		16
#define	TOKEN_NUMBER		17
#define	TOKEN_REGISTER		18
#define	TOKEN_BADNAME		19
#define	TOKEN_NAME		20
#define	TOKEN_STARS		21
#define	TOKEN_ELLIPSIS		22
#define	TOKEN_OPENPARAN		23
#define	TOKEN_CLOSEPARAN	24
#define	TOKEN_OPENBRACKET	25
#define	TOKEN_CLOSEBRACKET	26
#define	TOKEN_COMMA		27
#define	TOKEN_DASH		28

/* (see LEX grammar at the end of this file) */

char *Prog;
FILE *FDFile,			/* output library .fd file */
     *AFile,			/* output library .asm file */
     *BFile,			/* output library BCPL header file */
     *CPFile,			/* output library prototype file */
     *LPFile;			/* output library lattice #pragma file */
FILE *MCFile,			/* output RAM/system/Makefile */
     *MRFile;			/* output ROM/system/Makefile */
FILE *CFile,			/* output function C ram interface .asm file */
     *RFile;			/* output function C rom interface .asm file */


void
EndGame(format, arg1, arg2, arg3, arg4)
char *format, *arg1, *arg2, *arg3, *arg4;
{
    if (format) {
	fprintf(stderr, "%s: ERROR -- ", Prog);
	fprintf(stderr, format, arg1, arg2, arg3, arg4);
    }
    if (yyin) fclose(yyin);
    if (FDFile) fclose(FDFile);
    if (AFile) fclose(AFile);
    if (BFile) fclose(BFile);
    if (CPFile) fclose(CPFile);
    if (LPFile) fclose(LPFile);
    if (MCFile) fclose(MCFile);
    if (MRFile) fclose(MRFile);
    if (CFile) fclose(CFile);
    if (RFile) fclose(RFile);
    if (format) exit(100);
    exit(0);
}


int
yywrap() {
    return (1);
}

#define	STATE_START	0	/* first state */
#define	STATE_ID	1	/* waiting for Id string */
#define	STATE_RCSID	2	/* waiting for Id string tail */
#define	STATE_INACTIVE	3	/* nothing active */
#define	STATE_WAITNL	4	/* waiting for \r */
#define	STATE_WAITEOF	5	/* waiting for EOF */
#define	STATE_BASE	6	/* waiting for BaseName */
#define	STATE_INCLUDE	7	/* waiting for include file path */
#define	STATE_BIAS	8	/* waiting for Bias */
#define	STATE_RESERVE	9	/* waiting for Reserve */
#define	STATE_VERSION	10	/* waiting for Version */
#define	STATE_RETVALUE	11	/* waiting for first open paran */
#define	STATE_PARMS	12	/* waiting for first close paran */
#define	STATE_MIDDLE	13	/* waiting for second open paran */
#define	STATE_REGS	14	/* waiting for second close paran */

#define	NAMEMAX	31
char  SFDName[32];		/* "module_lib.sfd" */
char  LibName[32];		/* "module_lib" */
char  SysName[32];		/* "module" */
char  CapsName[32];		/* "MODULE" */
char  IdName[256];		/* rcs Id string */
char  BaseName[32];		/* "_ModuleBase" */
char  FunctionName[NAMEMAX];	/* "Foo" -- a module function */
char  PrevToken[NAMEMAX];	/* the previous name token while parsing */
char  FileName[64];		/* store for building file paths */
char  ProtectedRegs[48];	/* store for saved move[m] registers */
char  ArgRegs[48];		/* store for current move[m] argument */
char  ProtoGroup[80];		/* store for tokens for prototype group */
short LVOCount;			/* count of LVO entries so far */
short ObjCount;			/* count of number of obj files */
int   Bias;			/* current bias -6n offset in .fd file */
short ProtoLen;			/* length of current line in prototype file */
char  ParmRegs[16];		/* order of appearance of parms in d0-a7 */
char  Public;			/* true if ==public, false if ==private */
int   PrivateCount;		/* sequence number of private fcns for FD file */
char  FForm;			/* true if sfd -f */
char  HForm;			/* true if sfd -h */
char  IForm;			/* true if sfd -i */
char  NumRegs;			/* number of entries in ParmRegs */
char  NumArgs;			/* number of arguments in prototype */
char  Alias;			/* true if ==alias */
char  VarArgs;			/* true if ==varargs */
char  OptArg;			/* nest count of [] in STATE_PARMS */
char  OptArgExists;		/* true after first [ */
char  SuppressCPSpace;		/* e.g. previous writeCP was star(s) */
char  FuncParm;			/* actually nest count of () in STATE_PARMS */
char  FuncArg;			/* set going into second ()() in STATE_PARMS */
char  PrevParmToken;		/* nonzero if parameter was typed */

#define  BASE_RELEASE	30
#define  KNOWN_RELEASES	40
char *Release[KNOWN_RELEASES-BASE_RELEASE+1] = {
    "Release 1.0",		/* V30 */
    "Release 1.1",		/* V31 */
    "Preliminary Release 1.2",	/* V32 */
    "Release 1.2",		/* V33 */
    "Release 1.3",		/* V34 */
    "Release 1.3 A2024",	/* V35 */
    "Release 2.0",		/* V36 */
    "Release 2.04",		/* V37 */
    "Release 2.1",		/* V38 */
    "Release 3",		/* V39 */
    "Release 3.1",		/* V40 */
};

#define  NUM_SCALERS	4
#define  LEN_SCALERS	2
char *Scaler[NUM_SCALERS] = {
    "BY", "WO", "LO", "BO"	/* BYTE, WORD, LONG, BOOL */
};

void
writeCP(string)
char *string;
{
#if	PROTOLONGS
    char *pg, localProto[90];
#endif
    char *lp;
    short i;

    if (FForm || (*string == '\0'))
	return;

    /*
     * tokens that are not preceeded by '*' and are not the first name
     * within a function parameter, and are not ',' or '(',
     * are preceeded by a space
     */
    if ((!SuppressCPSpace) && (*string != ',') && (*string != '('))
	strcat(ProtoGroup, " ");

    if (strcmp(string, "VOID") == 0)
	strcat(ProtoGroup, "void");
    else
	strcat(ProtoGroup, string);

    /* ProtoGroups ending in ',', '(', or ')' don't cross line boundaries */
    if ((FuncParm == 0) &&
	    ((*string == ',') || (*string == '(') || (*string == ')'))) {
#if	PROTOLONGS
	if ((*string == ',') || (*string == ')')) {
	    pg = ProtoGroup;
	    lp = localProto;
	    if (*pg == ' ') {
		*lp++ = ' ';
		pg++;
	    }
	    if ((*pg == 'U') && (pg[6] != '*')) {
		/* must be UBYTE, UWORD, or ULONG */
		strcpy(lp, "unsigned long");
		strcpy(lp+13, pg+5);
		lp = localProto;
	    }
	    else {
		if (pg[5] != '*') {
		    for (i = 0; i < NUM_SCALERS; i++) {
			if (strncmp(pg, Scaler[i], LEN_SCALERS) == 0) {
			    /* must be BYTE, WORD, LONG, or BOOL */
			    strcpy(lp, "long");
			    strcpy(lp+4, pg+4);
			    lp = localProto;
			    goto gotLP;
			}
		    }
		}
		lp = ProtoGroup;
	    }
	}
	else {
	    lp = ProtoGroup;
	}
gotLP:
#else
	lp = ProtoGroup;
#endif
	i = strlen(lp);
	if ((ProtoLen + i) >= 80) {
	    /* wrap lines */
	    if (*lp == ' ') {
		fprintf(CPFile, "\n\t%s", lp + 1);
		ProtoLen = i + 8;
	    }
	    else {
		fprintf(CPFile, "\n\t%s", lp);
		ProtoLen = i + 7;
	    }
	}
	else {
	    fprintf(CPFile, lp);
	    ProtoLen += i;
	}
	ProtoGroup[0] = '\0';
    }

    if (FuncParm)
	SuppressCPSpace = ((*string == '*') ||
		(*string == '(') || (*string == ')'));
    else
	SuppressCPSpace = (*string == '*');
}


void
genInterface()
{
    short varReg, stackOffset, stackSave, DvarReg = 0;
    short argNum, reg, testReg;
    char *s;

    /* do all the work for a function definition */
    if (!HForm) {
	/* open C interface files */
	strcpy(FileName, "ROM/");
	strcat(FileName, SysName);
	strcat(FileName, "/");
	strcat(FileName, FunctionName);
	strcat(FileName, ".asm");
	RFile = fopen(FileName, "w");
	if (RFile == 0)
	    EndGame("cannot create file \"%s\"\n", FileName);
	/* add this to the Makefile */
	/* We break every 100 objects to prevent getting a
	 * "$? list too long" error, which would occur
	 * in our biggest modules.
	 */
	if ( ( ObjCount % 100 ) == 0 ) {
	    fprintf(MRFile, "\n\nOBJS%ld=", ObjCount/100 );
	    fprintf(MCFile, "\n\nOBJS%ld=", ObjCount/100 );
	}
	fprintf(MRFile, "\\\n	%s.obj", FunctionName);

	if (Public) {
	    FileName[1] = 'A';		/* RAM/ */
	    CFile = fopen(FileName, "w");
	    if (CFile == 0)
		EndGame("cannot create file \"%s\"\n", FileName);
	    /* add this to the Makefile */
	    fprintf(MCFile, "\\\n	%s.obj", FunctionName);
	}
	else
	    CFile = 0;

	/* write C interface files */
	fprintf(RFile, "*** DO NOT EDIT: FILE BUILT AUTOMATICALLY\n");
	fprintf(RFile, "*** %s rom interface\n", FunctionName);
	if (BaseName[0] != '\0')
	    fprintf(RFile, "	XREF	%sOffset\n", BaseName);
	fprintf(RFile, "	SECTION	%s\n", SysName);
	fprintf(RFile, "	XDEF	_%s\n", FunctionName);
	fprintf(RFile, "_%s:\n", FunctionName);

	if (CFile) {
	    fprintf(CFile, "*** DO NOT EDIT: FILE BUILT AUTOMATICALLY\n");
	    fprintf(CFile, "*** %s ram interface\n", FunctionName);
	    if (BaseName[0] != '\0')
		fprintf(CFile, "	XREF	%s\n", BaseName);
	    fprintf(CFile, "	SECTION	%s\n", SysName);
	    fprintf(CFile, "	XDEF	_%s\n", FunctionName);
	    fprintf(CFile, "_%s:\n", FunctionName);
	}
	ObjCount++;
    }

    /* save protected registers and a6 */
    stackOffset = 4;
    s = ProtectedRegs;
    for (reg = 2; reg <= 7; reg++) {
	if (ParmRegs[reg]) {
	    *s++ = '/';
	    *s++ = 'd';
	    *s++ = '0' + reg;
	    stackOffset += 4;
	}
    }
    for (reg = 2; reg <= 5; reg++) {
	if (ParmRegs[8+reg]) {
	    *s++ = '/';
	    *s++ = 'a';
	    *s++ = '0' + reg;
	    stackOffset += 4;
	}
    }
    *s = '\0';
    if (!HForm) {
	if (ProtectedRegs[0]) {
	    fprintf(RFile, "\t	movem.l	%s/a6,-(a7)\n", ProtectedRegs+1);
	    if (CFile)
		fprintf(CFile, "\t\tmovem.l\t%s/a6,-(a7)\n", ProtectedRegs+1);
	}
	else {
	    fprintf(RFile, "\t	move.l	a6,-(a7)\n");
	    if (CFile)
		fprintf(CFile, "\t	move.l	a6,-(a7)\n");
	}
	if (ParmRegs[14 /* a6 */] == 0) {
	    /* check for valid BaseName */
	    if (BaseName[0] == '\0')
		EndGame("%s: ==base required\n", SFDName);
	    fprintf(RFile, "\t\tmove.l\t%sOffset(a6),a6\n", BaseName);
	    if (CFile)
		fprintf(CFile, "\t\tmove.l\t%s,a6\n", BaseName);
	}


	if (VarArgs) {
	    if (NumRegs == 0)
		EndGame("%s %s: missing vararg register\n", SFDName,
			FunctionName);
	    /* remove varReg from ParmRegs */
	    for (reg = 0; ParmRegs[reg] != NumRegs; reg++);
	    varReg = reg;
/*	    if (varReg<8)
**		EndGame("%s %s: d%ld illegal vararg\n", SFDName, FunctionName,
**			varReg);
*/
	    ParmRegs[reg] = 0;
	    NumRegs--;

	    /* lea now and use to grab any other parameters */
	    if(varReg >= 8)
	    {
		varReg -= 8;
		/* points at first arg - will be incremented by movem */
		fprintf(RFile, "\t\tlea\t%ld(a7),a%d\n", stackOffset + 4, varReg);
	    	if (CFile)
			fprintf(CFile, "\t\tlea\t%ld(a7),a%d\n", stackOffset + 4,
				varReg);
	    }
	    else
	    {
		DvarReg = 1;	/* remember! */
		/* pea calculates address first!!! */
		/* unlike regular varargs, point it at the right entry */
		/* regular ones point it at the first arg, then movem (an)+,...
		   where an is the varargs ptr, leaving it pointing past the
		   last one. */

		/* NumRegs is the number of parameters on the stack before */
		/* the first vararg param.				   */

	        fprintf(RFile, "\t\tpea\t%ld(a7)\n", stackOffset + 4 +
						     4*NumRegs);
		fprintf(RFile, "\t\tmove.l\t(a7)+,d%ld\n", varReg);
	        if (CFile)
		{
		    /* pea decrements stack first! */
		    fprintf(CFile, "\t\tpea\t%ld(a7)\n", stackOffset + 4 +
							 4*NumRegs);
		    fprintf(CFile, "\t\tmove.l\t(a7)+,d%ld\n", varReg);
		}
	    }
	}
    }

    argNum = 1;
    while (argNum <= NumRegs) {
	stackSave = stackOffset;
	for (reg = 0; ParmRegs[reg] != argNum; reg++);
	/* argNum is parameter order, reg is register number */

	/* grok parameter register clustering */
	if ((!Alias) && (!VarArgs) && (argNum != 1)) {
	    /* there was a cluster preceeding this one, update FD File */
	    if (Public)fprintf(FDFile, ",");
	}

	/* build register cluster */
	s = ArgRegs;
	do {
	    *s++ = '/';
	    *s++ = (reg<8)?'d':'a';
	    *s++ = '0'+(reg&7);
	    stackOffset += 4;

	    /* look first for double */
	    testReg = reg;
	    do {
		reg++;
	    }
		while ((reg < 16) && (ParmRegs[reg] != argNum));

	    if (reg == 16) {
		/* look next at next parameter */
		reg = testReg;
		argNum++;
		do {
		    reg++;
		}
		    while ((reg < 16) && (ParmRegs[reg] != argNum));
	    }
	}
	    while (reg != 16);
	*s = '\0';

	if ((!Alias) && (!VarArgs)) {
	    /* update FD File */
	    if (Public)fprintf(FDFile, ArgRegs+1);
	}

	if (!HForm) {
	    /* don't use varReg if it was a Data reg */
	    if (VarArgs && !DvarReg) {
		/* use autoincrementing varReg */
		if (strlen(ArgRegs) == 3) {
		    /* move single register */
		    fprintf(RFile, "\t\tmove.l\t(a%ld)+,%s\n", varReg,
			    ArgRegs+1);
		    if (CFile)
			fprintf(CFile, "\t\tmove.l\t(a%ld)+,%s\n", varReg,
				ArgRegs+1);
		}
		else {
		    /* move multiple registers */
		    fprintf(RFile, "\t\tmovem.l\t(a%ld)+,%s\n", varReg,
			    ArgRegs+1);
		    if (CFile)
			fprintf(CFile, "\t\tmovem.l\t(a%ld)+,%s\n", varReg,
				ArgRegs+1);
		}
	    }
	    else {
		/* use explicit stack offset */
		if (strlen(ArgRegs) == 3) {
		    /* move single register */
		    fprintf(RFile, "\t\tmove.l\t%ld(a7),%s\n", stackSave + 4,
			    ArgRegs+1);
		    if (CFile)
			fprintf(CFile, "\t\tmove.l\t%ld(a7),%s\n",
				stackSave + 4, ArgRegs+1);
		}
		else {
		    /* move multiple registers */
		    fprintf(RFile, "\t\tmovem.l\t%ld(a7),%s\n", stackSave + 4,
			    ArgRegs+1);
		    if (CFile)
			fprintf(CFile, "\t\tmovem.l\t%ld(a7),%s\n",
				stackSave + 4, ArgRegs+1);
		}
	    }
	}
    }

    if ((!Alias) && (!VarArgs)) {
	/* terminate FD line */
	fprintf(FDFile, ")\n");
    }

    if (!HForm) {
	fprintf(RFile, "\t	jsr	%ld(a6)\n", Bias);
	if (CFile)
	    fprintf(CFile, "\t	jsr	%ld(a6)\n", Bias);
	if (ProtectedRegs[0]) {
	    fprintf(RFile, "		movem.l	(a7)+,%s/a6\n",
		    ProtectedRegs+1);
	    if (CFile)
		fprintf(CFile, "\t	movem.l	(a7)+,%s/a6\n",
			ProtectedRegs+1);
	}
	else {
	    fprintf(RFile, "		move.l	(a7)+,a6\n");
	    if (CFile)
		fprintf(CFile, "\t	move.l	(a7)+,a6\n");
	}
	fprintf(RFile, "		rts\n");
	fprintf(RFile, "	END\n");
	fclose(RFile);
	if (CFile) {
	    fprintf(CFile, "		rts\n");
	    fprintf(CFile, "	END\n");
	    fclose(CFile);
	}
	CFile = RFile = NULL;
    }
}


main(argc, argv)
int argc;
char *argv[];
{
    char *s, *t;
    short state, token;
    char pragmaWord[32];
    short pragmaCount, pragmaOK;
    int i, j;

    Prog = *argv++;
    if (s = RINDEX(Prog, '/'))
	Prog = s + 1;

    FForm = HForm = IForm = 0;
    if ((argc >= 2) && ((*argv)[0] == '-')) {
	switch ((*argv)[1]) {
	  case 'f':
	    FForm = 1;
	  case 'h':
	    HForm = 1;
	    argv++;
	    argc--;
	    break;
	  case 'i':
	    IForm = 1;
	    argv++;
	    argc--;
	    break;
	  default:
	    fprintf(stderr, "sfd $Revision: 40.6 $\n");
	    fprintf(stderr,
		    "\tsfd <_lib.sfd files>+\t\t[lib/sfd useage]\n");
	    fprintf(stderr,
		"\tsfd -h <_lib.sfd files>+\t[lib/sfd useage w/o RAM/ROM]\n");
	    fprintf(stderr,
		    "\tsfd -i <_lib.sfd files>+\t[local usage: create .i]\n");
	    fprintf(stderr,
		    "\tsfd -f <_lib.sfd files>+\t[local usage: create .fd]\n");
	    exit(1);
	}
    }

    while (--argc > 0) {
	yyin = FDFile = AFile = BFile = CPFile = LPFile =
		CFile = RFile = MCFile = MRFile = NULL;

	PrivateCount = 0;

	/* get the library name */
	strcpy(SFDName, *argv++);
	strcpy(LibName, SFDName);
	s = RINDEX(LibName, '.');
	if ((s == NULL) || (strcmp(s, ".sfd") != 0))
	    EndGame(".sfd file name \"%s\" ill formed\n", SFDName);
	*s = '\0';
	
	/* get the system name */
	strcpy(SysName, LibName);
	s = RINDEX(SysName, '_');
	if ((s == NULL) || (strcmp(s, "_lib") != 0))
	    EndGame(".sfd file name \"%s\" ill formed\n", SFDName);
	*s = '\0';

	/* open the .sfd file */
	yyin = fopen(SFDName, "r");
	if (yyin == 0)
	    EndGame("cannot open file \"%s\"\n", SFDName);

	if (FForm || IForm) {
	    /* open the function description file */
	    strcpy(FileName, LibName);
	    if (FForm)
		strcat(FileName, ".fd");
	    else
		strcat(FileName, ".i");
	    FDFile = fopen(FileName, "w");
	    if (FDFile == 0)
		EndGame("cannot create file \"%s\"\n", FileName);
	}
	else {
	    /* ensure the directories are there */

	    /* open the .fd file */
	    MKDIR("FD", 0777);
	    strcpy(FileName, "FD/");
	    strcat(FileName, LibName);
	    strcat(FileName, ".fd");
	    FDFile = fopen(FileName, "w");
	    if (FDFile == 0)
		EndGame("cannot create file \"%s\"\n", FileName);

	    /* open the .asm file */
	    MKDIR("LVO", 0777);
	    strcpy(FileName, "LVO/");
	    strcat(FileName, LibName);
	    strcat(FileName, ".asm");
	    AFile = fopen(FileName, "w");
	    if (AFile == 0)
		EndGame("cannot create file \"%s\"\n", FileName);

	    /* open the .b file */
	    MKDIR("HDR", 0777);
	    strcpy(FileName, "HDR/");
	    strcat(FileName, SysName);
	    s = FileName+4;
	    while (*s)
		*s++ &= 0x5f;
	    strcat(FileName, "LIBHDR");
	    BFile = fopen(FileName, "w");
	    if (BFile == 0)
		EndGame("cannot create file \"%s\"\n", FileName);

	    /* open the proto file */
	    MKDIR("PROTOS", 0777);
	    strcpy(FileName, "PROTOS/");
	    strcat(FileName, SysName);
	    strcat(FileName, "_protos.h");
	    CPFile = fopen(FileName, "w");
	    if (CPFile == 0)
		EndGame("cannot create file \"%s\"\n", FileName);

	    /* open the pragma file */
	    MKDIR("PRAGMAS", 0777);
	    strcpy(FileName, "PRAGMAS/");
	    strcat(FileName, SysName);
	    strcat(FileName, "_pragmas.h");
	    LPFile = fopen(FileName, "w");
	    if (LPFile == 0)
		EndGame("cannot create file \"%s\"\n", FileName);

	    if (!HForm) {
		/* open the RAM Makefile file */
		MKDIR("RAM", 0777);
		MKDIR("ROM", 0777);
		strcpy(FileName, "ROM/");
		strcat(FileName, SysName);
		MKDIR(FileName, 0777);
		FileName[1] = 'A';		/* RAM/ */
		MKDIR(FileName, 0777);

		strcat(FileName, "/Makefile");
		MCFile = fopen(FileName, "w");
		if (MCFile == 0)
		    EndGame("cannot create file \"%s\"\n", FileName);

		/* open the ROM Makefile file */
		FileName[1] = 'O';		/* ROM/ */
		MRFile = fopen(FileName, "w");
		if (MRFile == 0)
		    EndGame("cannot create file \"%s\"\n", FileName);
	    }

	    /* initialize system files */
	    fprintf(AFile, "*** DO NOT EDIT: FILE BUILT AUTOMATICALLY\n");
	    fprintf(AFile, "*** %s.asm function offsets\n", LibName);
	    fprintf(AFile, "	IDNT	%s_LVO\n", SysName);

	    fprintf(BFile, "MANIFEST\n$(\n");

	    s = SysName;
	    t = CapsName;
	    while (*s) {
		if (*s == '.')
		    *t++ = '_';
		else
		    if (*s > 0x60)
			*t++ = *s & 0x5f;
		    else
			*t++ = *s;
		s++;
	    }
	    *t = '\0';
	    fprintf(CPFile, "#ifndef  CLIB_%s_PROTOS_H\n", CapsName);
	    fprintf(CPFile, "#define  CLIB_%s_PROTOS_H\n", CapsName);

	    if (!HForm) {
		fprintf(MCFile, "########################################\n");
		fprintf(MCFile, "MAKEMETA=	../../../../tools/makemeta\n");

		fprintf(MRFile, "########################################\n");
		fprintf(MRFile, "MAKEMETA=	../../../../tools/makemeta\n");
	    }
	}

	/* parse the .sfd file */
	LVOCount = 0;
	ObjCount = 0;
	BaseName[0] = BaseName[1] = '\0';
	Bias = -6;
	Alias = 0;
	VarArgs = 0;
	Public = 0;
	strcpy(FunctionName, "[before 1st function]");

	state = STATE_START;
	while (token = yylex()) {
	    switch (state) {
	      case STATE_START:		/* waiting for ==id */
		if (token != TOKEN_ID)
		    EndGame("%s: ==id required as first line\n", SFDName);
		state = STATE_ID;
		break;
	      case STATE_ID:		/* waiting for rcs Id string */
		if (token != TOKEN_RCSIDHEAD)
		    EndGame("%s: illegal rcs Id \"%s\"... after ==id\n",
			    SFDName, yytext);
		state = STATE_RCSID;
		break;
	      case STATE_RCSID:		/* waiting for rcs Id string tail */
		if (token != TOKEN_RCSIDTAIL)
		    EndGame("%s: illegal rcs Id ...\"%s\" after ==id\n",
			    SFDName, yytext);
		strcpy(IdName, yytext);
		if ((!FForm) && (!IForm)) {
		    fprintf(CPFile,
			    "\n/*\n**\t$Id: %s_protos.h,v %s\n", SysName, IdName);
		    fprintf(CPFile, "**\n**\tC prototypes. For use with 32 bit integers only.\n**\n");
		    fprintf(CPFile,
			    "**\t(C) Copyright 1990 Commodore-Amiga, Inc.\n");
		    fprintf(CPFile, "**\t    All Rights Reserved\n*/\n\n");

		    fprintf(LPFile,
			    "/*\n**\t$Id: %s_pragmas.h,v %s\n", SysName, IdName);
		    fprintf(LPFile, "**\n**\tSAS/C format pragma files.\n");
		    fprintf(LPFile, "**\n**\tContains private definitions. COMMODORE INTERNAL USE ONLY!\n*/\n\n");
		}
		state = STATE_WAITNL;
		break;
	      case STATE_INACTIVE:	/* nothing active */
		switch (token) {
		  case TOKEN_NEWLINE:
		    break;
		  case TOKEN_BASE:
		    state = STATE_BASE;
		    break;
		  case TOKEN_INCLUDE:
		    state = STATE_INCLUDE;
		    break;
		  case TOKEN_BIAS:
		    state = STATE_BIAS;
		    break;
		  case TOKEN_ALIAS:
		    Bias += 6;
		    Alias = 1;
		    state = STATE_WAITNL;
		    break;
		  case TOKEN_VARARGS:
		    Bias += 6;
		    VarArgs = 1;
		    state = STATE_WAITNL;
		    break;
		  case TOKEN_PRIVATE:
		    Public = 0;
		    if (!IForm)
			fprintf(FDFile, "##private\n");
		    state = STATE_WAITNL;
		    break;
		  case TOKEN_PUBLIC:
		    Public = 1;
		    if (!IForm)
			fprintf(FDFile, "##public\n");
		    state = STATE_WAITNL;
		    break;
		  case TOKEN_RESERVE:
		    state = STATE_RESERVE;
		    break;
		  case TOKEN_VERSION:
		    state = STATE_VERSION;
		    break;
		  case TOKEN_END:
		    if (!IForm)
			fprintf(FDFile, "##end\n");
		    state = STATE_WAITEOF;
		    break;
		  case TOKEN_COMMENT:
		    if (!IForm) {
			if (Public)fprintf(FDFile, "*%s\n", yytext+1);
			if (!FForm) {
			    if (yytext[1] == '\0') {
				/* Output blank lines as truly blank */
				if (Public)fprintf(CPFile, "\n");
				fprintf(LPFile, "\n");
			    }
			    else
			    if ((yytext[1] == ' ') || (yytext[1] == '\t')) {
				/* whitespace at front -> whitespace at back */
				if (Public)fprintf(CPFile, "/*%s */\n", yytext+1);
				fprintf(LPFile, "/*%s */\n", yytext+1);
			    }
			    else {
				if (Public)fprintf(CPFile, "/*%s*/\n", yytext+1);
				fprintf(LPFile, "/*%s*/\n", yytext+1);
			    }
			}
		    }
		    break;
		  case TOKEN_REGISTER:
		    fprintf(stderr, "%s: WARNING -- %s\n", Prog, SFDName);
		    fprintf(stderr,
		    "    function return type \"%s\" looks like a register\n",
			    yytext);
		  case TOKEN_NAME:
		    PrevToken[0] = '\0';
		    if (!IForm) {
			ProtoLen = 0;
			ProtoGroup[0] = '\0';
			SuppressCPSpace = 1;	/* suppress initial space */
			if(Public)writeCP(yytext);
		    }
		    for (i = 0; i < 16; i++)
			ParmRegs[i] = 0;
		    NumRegs = 0;
		    NumArgs = 0;
		    state = STATE_RETVALUE;
		    break;
		  default:
		    EndGame("%s near %s: illegal occurrence of \"%s\"\n",
			    SFDName, FunctionName, yytext);
		}
		break;
	      case STATE_WAITNL:	/* waiting for \r */
		if (token != TOKEN_NEWLINE)
		    EndGame("%s: newline expected, got \"%s\"\n",
			    SFDName, yytext);
		state = STATE_INACTIVE;
		break;
	      case STATE_WAITEOF:	/* waiting for EOF */
		if (token != TOKEN_NEWLINE)
		    EndGame("%s: illegal occurrence of \"%s\" after ==end\n",
			    SFDName, yytext);
		break;
	      case STATE_BASE:		/* waiting for BaseName */
		switch (token) {
		  case TOKEN_REGISTER:
		    fprintf(stderr, "%s: WARNING -- %s\n", Prog, SFDName);
		    fprintf(stderr,
			    "    base name \"%s\" looks like a register\n",
			    yytext);
		  case TOKEN_NAME:
		    strcpy(BaseName, yytext);
		    if (!IForm)
			fprintf(FDFile, "##base %s\n", BaseName);
		    state = STATE_WAITNL;
		    break;
		  default:
		    EndGame("%s: illegal name \"%s\" after ==base\n",
			    SFDName, yytext);
		    break;
		}
		break;
	      case STATE_INCLUDE:	/* waiting for include file path */
		switch (token) {
		  case TOKEN_FILEPATH:
		    if ((!FForm) && (!IForm)) {
			s = yytext + 1;
			t = FileName;
			while (*s != '>') {
			    if ((*s == '/') || (*s == '.'))
				*t++ = '_';
			    else
				if (*s > 0x60)
				    *t++ = *s & 0x5f;
				else
				    *t++ = *s;
			    s++;
			}
			*t = '\0';
			fprintf(CPFile, "#ifndef  %s\n", FileName);
			fprintf(CPFile, "#include %s\n", yytext);
			fprintf(CPFile, "#endif\n");
		    }
		    state = STATE_WAITNL;
		    break;
		  default:
		    EndGame("%s: illegal path \"%s\" after ==include\n",
			    SFDName, yytext);
		    break;
		}
		break;
	      case STATE_BIAS:		/* waiting for Bias */
		switch (token) {
		  case TOKEN_NUMBER:
		    i = Bias;
		    Bias = -atoi(yytext);
		    if (Bias > i)
			EndGame("%s: bias overlap %ld to %ld\n", SFDName,
				i, Bias);
		    if (IForm) {
			if (i != -6) {
			    for (; i > Bias; i -= 6)
				fprintf(FDFile, "\tFUNCDEF\t%sReserved%ld\n",
					SysName, -i);
			}
		    }
		    else
			fprintf(FDFile, "##bias %ld\n", -Bias);
		    state = STATE_WAITNL;
		    break;
		  default:
		    EndGame("%s: illegal bias \"%s\" after ==bias\n",
			    SFDName, yytext);
		}
		break;
	      case STATE_RESERVE:	/* waiting for Reserve */
		switch (token) {
		  case TOKEN_NUMBER:
		    i = atoi(yytext);
		    if (IForm) {
			for (j = 0; j < i; j++) {
			    fprintf(FDFile, "\tFUNCDEF\t%sReserved%ld\n",
				    SysName, -Bias);
			    Bias -= 6;
			}
		    }
		    else {
			Bias -= i * 6;
			fprintf(FDFile,
			"*--- (%ld function slot%s reserved here) ---\n",
				i, (i == 1)?"":"s");
			fprintf(FDFile, "##bias %ld\n", -Bias);
			if (!FForm) {
			    fprintf(LPFile,
			    "/*--- (%ld function slot%s reserved here) ---*/\n",
				    i, (i == 1)?"":"s");
			}
		    }
		    state = STATE_WAITNL;
		    break;
		  default:
		    EndGame("%s: illegal number \"%s\" after ==reserve\n",
			    SFDName, yytext);
		}
		break;
	      case STATE_VERSION:	/* waiting for Version */
		switch (token) {
		  case TOKEN_NUMBER:
		    i = atoi(yytext);
		    if (i < BASE_RELEASE)
			EndGame("%s: version %ld unheard of\n", SFDName, i);
		    if (!IForm) {
			char *releasename = "Beta release for developers only";

			if ( i <= KNOWN_RELEASES )
			{
			    releasename = Release[i-BASE_RELEASE];
			}
			fprintf( FDFile,
		"*--- functions in V%ld or higher (%s) ---\n",
				i, releasename );
			if (!FForm) {
			    fprintf( CPFile,
		"/*--- functions in V%ld or higher (%s) ---*/\n",
				    i, releasename );
			    fprintf( LPFile,
		"/*--- functions in V%ld or higher (%s) ---*/\n",
				    i, releasename );
			}
		    }
		    state = STATE_WAITNL;
		    break;
		  default:
		    EndGame("%s: illegal version \"%s\" after ==version\n",
			    SFDName, yytext);
		}
		break;
	      case STATE_RETVALUE:	/* waiting for first open paran */
		switch (token) {
		  case TOKEN_REGISTER:
		    fprintf(stderr, "%s: WARNING -- %s\n", Prog, SFDName);
		    fprintf(stderr,
		"    return value/function name \"%s\" looks like a register\n",
			    yytext);
		  case TOKEN_NAME:
		    if (strlen(yytext) >= NAMEMAX)
			EndGame("%s after %s: name \"%s\" too long\n",
				SFDName, FunctionName, yytext);
		    strcpy(PrevToken, yytext);
		  case TOKEN_STARS:
		    if (!IForm) {
			if(Public)writeCP(yytext);
		    }
		    break;
		  case TOKEN_OPENPARAN:
		    /* PrevToken is the function name */
		    if (!PrevToken[0])
			EndGame("%s after %s: missing function name\n",
				SFDName, FunctionName);
		    if (IForm) {
			fprintf(FDFile, "\tFUNCDEF\t%s\n", PrevToken);
		    }
		    else {
			strcpy(FunctionName, PrevToken);
			if ((!Alias) && (!VarArgs)) {
			    if (Public) fprintf(FDFile, "%s(", FunctionName);
			    else fprintf(FDFile, "%sPrivate%ld(", SysName, ++PrivateCount);
			}
			if(Public)writeCP(yytext);
		    }
		    PrevToken[0] = '\0';
		    PrevParmToken = 0;
		    FuncParm = 0;
		    FuncArg = 0;
		    OptArg = 0;
		    OptArgExists = 0;
		    state = STATE_PARMS;
		    break;
		  case TOKEN_NEWLINE:
		    break;
		  default:
		    EndGame("%s after %s: format error: \"%s\"\n",
			    SFDName, FunctionName, yytext);
		}
		break;
	      case STATE_PARMS:		/* waiting for first close paran */
		switch (token) {
		  case TOKEN_NEWLINE:
		    break;
		  case TOKEN_REGISTER:
		    fprintf(stderr, "%s: WARNING -- %s %s\n", Prog, SFDName,
			    FunctionName);
		    fprintf(stderr,
			    "    parameter name \"%s\" looks like a register\n",
			    yytext);
		  case TOKEN_NAME:
		    PrevParmToken = PrevToken[0];
		  case TOKEN_STARS:
		    if ((strcmp(yytext, "*") == 0) &&
			    (strcmp(PrevToken, "VOID") == 0))
			EndGame("%s %s: need to use APTR, not VOID *\n",
				SFDName, FunctionName);
		  case TOKEN_ELLIPSIS:
		    if (strcmp(PrevToken, "...") == 0)
			EndGame("%s %s: mispositioned vararg \"...\"\n",
				SFDName, FunctionName);
		    if (!IForm) {
			if(Public)writeCP(PrevToken);
			if (strlen(yytext) >= NAMEMAX)
			    EndGame("%s %s: name \"%s\" too long\n", SFDName,
				    FunctionName, yytext);
			strcpy(PrevToken, yytext);
		    }
		    break;
		  case TOKEN_OPENPARAN:
		    if (strcmp(PrevToken, "...") == 0)
			EndGame("%s %s: mispositioned vararg \"...\"\n",
				SFDName, FunctionName);
		    if (++FuncParm > 1)
			EndGame("%s %s: \"(\" nested too deep\n", SFDName,
				FunctionName);
		    if (!IForm) {
			if(Public)writeCP(PrevToken);
			SuppressCPSpace = 1;
			if (!FuncArg) {
			    if(Public)writeCP(" ");
			    SuppressCPSpace = 1;
			}
			if(Public)writeCP(yytext);
			SuppressCPSpace = 1;
			PrevToken[0] = '\0';
		    }
		    break;
		  case TOKEN_CLOSEPARAN:
		    if (FuncParm == 0) {
			/* final parameter closing paranthesis */
			if (OptArg)
			    EndGame("%s %s: unclosed \"]\"\n", SFDName,
				    FunctionName);
			if (!IForm) {
			    if ((!Alias) && (!VarArgs)) {
				if ((PrevToken[0] >= 'A')
					&& (PrevToken[0] <= 'Z')) {
				    fprintf(stderr,
				    "%s: WARNING -- %s %s: parameter \"%s",
					    Prog, SFDName, FunctionName,
					    PrevToken);
				    PrevToken[0] |= 0x20;
				    fprintf(stderr, "\" converted to \"%s\"\n",
					    PrevToken);
				}
			    	if (Public)fprintf(FDFile, "%s)(", PrevToken);
				else fprintf(FDFile, ")(");
			    }
			    if (strcmp(PrevToken, "...") == 0) {
				if (!VarArgs)
				    EndGame("%s %s: missing ==varargs\n",
					    SFDName, FunctionName);
				if(Public)writeCP("...");
			    }
			    else {
				if (PrevToken[0] || FuncArg) {
				    if (!PrevParmToken) {
					EndGame(
					"%s %s: untyped parameter \"%s\"\n",
						SFDName, FunctionName,
						PrevToken);
				    }
				    NumArgs++;
#if	PROTONAMES
				    if(Public)writeCP(PrevToken);
#endif
				}
				else
				    if(Public)writeCP("VOID");
			    }
			    SuppressCPSpace = 0;
			    if(Public)writeCP(");\n");
			}
			state = STATE_MIDDLE;
		    }
		    else {
			if (strcmp(PrevToken, "...") == 0)
			    EndGame("%s %s: mispositioned vararg \"...\"\n",
				    SFDName, FunctionName);
			if (!IForm) {
			    if ((!Alias) && (!VarArgs) && (!FuncArg)) {
				if ((PrevToken[0] >= 'A')
					&& (PrevToken[0] <= 'Z')) {
				    fprintf(stderr,
					"%s: WARNING -- %s %s: parameter \"%s",
					Prog, SFDName, FunctionName, PrevToken);
				    PrevToken[0] |= 0x20;
				    fprintf(stderr, "\" converted to \"%s\"\n",
					    PrevToken);
				}
				if (Public)fprintf(FDFile, "%s", PrevToken);
			    }
#if	PROTONAMES
			    if(Public)writeCP(PrevToken);
#endif
			    SuppressCPSpace = 1;
			    if(Public)writeCP(yytext);
			    PrevToken[0] = '\0';
			}
			FuncParm--;
			if (!FuncArg)
			    FuncArg = 1;
		    }
		    break;
		  case TOKEN_OPENBRACKET:
		    if (OptArg)
			EndGame("%s %s: nested \"[\" not allowed\n",
				SFDName, FunctionName);
		    OptArg++;
		    OptArgExists = 1;
		    break;
		  case TOKEN_CLOSEBRACKET:
		    OptArg--;
		    break;
		  case TOKEN_COMMA:
		    if (OptArgExists && (!OptArg))
			EndGame(
			"%s %s: all parms after first \"[\" must be optional\n",
				SFDName, FunctionName);
		    if (strcmp(PrevToken, "...") == 0)
			EndGame("%s %s: mispositioned vararg \"...\"\n",
				SFDName, FunctionName);
		    if (PrevToken[0] && (!PrevParmToken))
			EndGame("%s %s: untyped parameter \"%s\"\n",
				SFDName, FunctionName, PrevToken);
		    if (!IForm) {
			if ((!Alias) && (!VarArgs) && (!FuncArg)) {
			    if ((PrevToken[0] >= 'A')
				    && (PrevToken[0] <= 'Z')) {
				fprintf(stderr,
					"%s: WARNING -- %s %s: parameter \"%s",
					Prog, SFDName, FunctionName, PrevToken);
				PrevToken[0] |= 0x20;
				fprintf(stderr, "\" converted to \"%s\"\n",
					PrevToken);
			    }
			    if (Public)fprintf(FDFile, "%s", PrevToken);
			}
#if	PROTONAMES
			if(Public)writeCP(PrevToken);
#endif
			if(Public)writeCP(yytext);
			PrevToken[0] = '\0';
			if (!FuncParm) {
			    if ((!Alias) && (!VarArgs))
				if (Public)fprintf(FDFile, ",");
			    FuncArg = 0;
			    NumArgs++;
			}
		    }
		    break;
		  default:
		    EndGame("%s %s: format error before 1st ): \"%s\"\n",
			    SFDName, FunctionName, yytext);
		}
		break;
	      case STATE_MIDDLE:	/* waiting for second open paran */
		switch (token) {
		  case TOKEN_NEWLINE:
		    break;
		  case TOKEN_OPENPARAN:
		    state = STATE_REGS;
		    break;
		  default:
		    EndGame("%s %s: format error before 2nd (: \"%s\"\n",
			    SFDName, FunctionName, yytext);
		}
		break;
	      case STATE_REGS:		/* waiting for second close paran */
		switch (token) {
		  case TOKEN_DASH:
		    NumRegs--;		/* keep same ParmReg entry for next */
		  case TOKEN_NEWLINE:
		  case TOKEN_COMMA:
		    break;
		  case TOKEN_REGISTER:
		    i = yytext[1] - '0';
		    if ((yytext[0] | 0x20) == 'a') i += 8;
		    if ( ParmRegs[i] == 0 )
		    {
			ParmRegs[i] = ++NumRegs;
		    }
		    else
		    {
			EndGame("%s %s: duplicate reference to register %s\n", SFDName, FunctionName, yytext );
		    }
		    break;
		  case TOKEN_CLOSEPARAN:
		    if ((!FForm) && (!IForm)) {
			/* Number of arguments must match number of registers,
			 * except that varargs functions can have one less
			 * argument, to handle cases like printf() where the
			 * first vararg is optional.
			 */
			if ( ( NumArgs != NumRegs ) &&
			     ( (!VarArgs) || ( (NumArgs+1) != NumRegs ) ) )
			    EndGame("%s %s: %ld parms vs. %ld registers\n",
				    SFDName, FunctionName, NumArgs, NumRegs);
			if (!VarArgs) {
			    /* write this entry into the library files */
			    if (!Alias) {
				if ((LVOCount & 0x7f) == 0) {
				    /* create a new section every 128 names */
				    /* so as to not overflow BLINK 5.04's */
				    /* 150 symbol limit */
				    if (LVOCount) {
					/* generate something that looks */
					/* like code so that the symbols */
					/* associated with the prev section */
					/* get flushed by the assembler */
					fprintf(AFile, "	OFFSET	0\n");
					fprintf(AFile,
						"%s_FlushLVO%d	ds.w	1\n",
						SysName, (LVOCount>>7)-1);
				    }
				    fprintf(AFile, "	SECTION	%s_LVO%d\n",
					    SysName, LVOCount>>7);
				}
				LVOCount++;
				fprintf(AFile, "	XDEF	_LVO%s\n",
					FunctionName);
				fprintf(AFile, "_LVO%s EQU	%ld\n",
					FunctionName, Bias);

				fprintf(BFile, "    e.%s = %ld\n",
					FunctionName, Bias);
			    }
			}

			/* write pragma file */
			pragmaCount = 0;
			pragmaOK = 1;
			/*     gather pragma */
			for (i = 1; i <= NumRegs; i++) {
			    for (j = 0; ParmRegs[j] != i; j++);
			    pragmaWord[NumRegs - i] = (j <= 9 ? '0' + j :
							    'A' + j-10);
			    if (j >= 14 /* a6 */)
				pragmaOK = 0;
			}
			    pragmaWord[NumRegs] = '0';
			    pragmaWord[NumRegs+1] = (NumRegs <= 9 ?
							'0' + NumRegs :
							'A' + NumRegs-10);
			    pragmaWord[NumRegs+2] = '\0';

			if ( !Public )
			{
			    fprintf(LPFile, "#ifdef %s_PRIVATE_PRAGMAS\n", CapsName);
			}

#if SYSBASEPRAGMA
			if (strcmp(BaseName, "_SysBase") == 0) {
			    if (pragmaOK)
				fprintf(LPFile,
					"#pragma syscall %s %x %s\n",
					FunctionName, -Bias, pragmaWord);
			    else
				fprintf(LPFile,
					"/*pragma syscall %s %x %s*/\n",
					FunctionName, -Bias, pragmaWord);
			}
			else
#endif
			if (BaseName[1])
			{
			    if (pragmaOK)
			    {
				if (!VarArgs)
				{
				    fprintf(LPFile,
					    "#pragma libcall %s %s %x %s\n",
					    BaseName+1, FunctionName, -Bias,
					    pragmaWord);
				}
				else
				{
				    fprintf(LPFile,
					    "#ifdef __SASC_60\n#pragma tagcall %s %s %x %s\n#endif\n",
					    BaseName+1, FunctionName, -Bias,
					    pragmaWord);
				}
			    }
			    else
			    {
				if (!VarArgs)
				{
				    fprintf(LPFile,
					    "/*pragma libcall %s %s %x %s*/\n",
					    BaseName+1, FunctionName, -Bias,
					    pragmaWord);
				}
				else
				{
				    fprintf(LPFile,
					    "/*pragma tagcall %s %s %x %s*/\n",
					    BaseName+1, FunctionName, -Bias,
					    pragmaWord);
				}
			    }
			}
			else
			{
			    if (!VarArgs)
			    {
				fprintf(LPFile,
					"/*pragma libcall  %s %x %s*/\n",
					FunctionName, -Bias, pragmaWord);
			    }
			    else
			    {
				fprintf(LPFile,
					"/*pragma tagcall  %s %x %s*/\n",
					FunctionName, -Bias, pragmaWord);
			    }
			}
			if ( !Public )
			{
			    fprintf(LPFile, "#endif\n");
			}
		    }

		    if (!IForm)
			genInterface();

		    /* decrement Bias */
		    Bias -= 6;
		    Alias = 0;
		    VarArgs = 0;

		    state = STATE_WAITNL;
		    break;

		  default:
		    EndGame("%s %s: format error before 2nd ): \"%s\"\n",
			    SFDName, FunctionName, yytext);
		}
		break;
	    }
	}
	if (state != STATE_WAITEOF)
	    EndGame("%s: missing ==end\n", SFDName);
	fclose(yyin);
	fclose(FDFile);
	if ((!FForm) && (!IForm)) {
	    fprintf(AFile, "	END\n");
	    fclose(AFile);
	    fprintf(BFile, "$)\n");
	    fclose(BFile);
	    fprintf(CPFile, "#endif   /* CLIB_%s_PROTOS_H */\n", CapsName);
	    fclose(CPFile);
	    fclose(LPFile);
	    if (!HForm) {
		fprintf(MCFile, "\n\n");
		fprintf(MCFile, "lib.timestamp:	asm.timestamp\n");
		fprintf(MCFile, "	make ");
		/* We break every 100 objects to prevent getting a
		 * "$? list too long" error, which would occur
		 * in our biggest modules.
		 */
		for ( i = 0; i <= (ObjCount-1)/100; i++ ) {
		    fprintf(MCFile, "objs%ld ", i );
		}
		fprintf(MCFile, "${MFLAGS} ${MARGS}\n");
		fprintf(MCFile, "	cat *.obj >../%s.lib\n", SysName);
		fprintf(MCFile, "	rm -f *.obj\n");
		fprintf(MCFile, "	touch lib.timestamp\n");
		fprintf(MCFile, "\n");
		fprintf(MCFile, "asm.timestamp:\n");

		/* We break every 100 objects to prevent getting a
		 * "$? list too long" error, which would occur
		 * in our biggest modules.
		 */
		for ( i = 0; i <= (ObjCount-1)/100; i++ ) {
		    fprintf(MCFile, "\n");
		    fprintf(MCFile, "objs%ld:		${OBJS%ld}\n",i,i);
		}
		fprintf(MCFile, "	rm -f *.asm\n");
		fprintf(MCFile, "	touch asm.timestamp\n");
		fprintf(MCFile, "\n");
		fprintf(MCFile, ".INCLUDE=${MAKEMETA}\n");
		fclose(MCFile);
		fprintf(MRFile, "\n\n");
		fprintf(MRFile, "lib.timestamp:	asm.timestamp\n");
		fprintf(MRFile, "	make ");
		for ( i = 0; i <= (ObjCount-1)/100; i++ ) {
		    fprintf(MRFile, "objs%ld ", i );
		}
		fprintf(MRFile, "${MFLAGS} ${MARGS}\n");
		fprintf(MRFile, "	cat *.obj >../%s.lib\n", SysName);
		fprintf(MRFile, "	rm -f *.obj\n");
		fprintf(MRFile, "	touch lib.timestamp\n");
		fprintf(MRFile, "\n");
		fprintf(MRFile, "asm.timestamp:\n");
		for ( i = 0; i <= (ObjCount-1)/100; i++ ) {
		    fprintf(MRFile, "\n");
		    fprintf(MRFile, "objs%ld:		${OBJS%ld}\n",i,i);
		}
		fprintf(MRFile, "	rm -f *.asm\n");
		fprintf(MRFile, "	touch asm.timestamp\n");
		fprintf(MRFile, "\n");
		fprintf(MRFile, ".INCLUDE=${MAKEMETA}\n");
		fclose(MRFile);
	    }
	}
    }
}
%}
%a 3000
%o 3500
%%
[ \t]					{ ; }
\n					{ return(TOKEN_NEWLINE); }
^==id					{ return(TOKEN_ID); }
^==base					{ return(TOKEN_BASE); }
^==include				{ return(TOKEN_INCLUDE); }
^==bias					{ return(TOKEN_BIAS); }
^==alias				{ return(TOKEN_ALIAS); }
^==varargs				{ return(TOKEN_VARARGS); }
^==private				{ return(TOKEN_PRIVATE); }
^==public				{ return(TOKEN_PUBLIC); }
^==reserve				{ return(TOKEN_RESERVE); }
^==version				{ return(TOKEN_VERSION); }
^==end					{ return(TOKEN_END); }
^[*;].*$				{ return(TOKEN_COMMENT); }
\$(Id|Header):\ [_a-zA-Z0-9./]+\,v	{ return(TOKEN_RCSIDHEAD); }
[0-9]+\.[0-9]+\ .*\$			{ return(TOKEN_RCSIDTAIL); }
\<[_a-zA-Z0-9./]+\>			{ return(TOKEN_FILEPATH); }
[0-9]+					{ return(TOKEN_NUMBER); }
[adAD][0-7]				{ return(TOKEN_REGISTER); }
void|unsigned|int|long|short|char |
float|double				{ return(TOKEN_BADNAME); }
VOID|U?BYTE|U?WORD|U?LONG|APTR|BPTR|BSTR|STRPTR|FLOAT|DOUBLE|BOOL |
IX|PLANEPTR				{ return(TOKEN_NAME); }
[_A-Z][_A-Z0-9]+			{ return(TOKEN_BADNAME); }
[_a-zA-Z][_a-zA-Z0-9]*			{ return(TOKEN_NAME); }
"*"+					{ return(TOKEN_STARS); }
"..."					{ return(TOKEN_ELLIPSIS); }
"("					{ return(TOKEN_OPENPARAN); }
")"					{ return(TOKEN_CLOSEPARAN); }
"["					{ return(TOKEN_OPENBRACKET); }
"]"					{ return(TOKEN_CLOSEBRACKET); }
","					{ return(TOKEN_COMMA); }
"-"					{ return(TOKEN_DASH); }
.					{ return(TOKEN_BADNAME); }
@


40.6
log
@No longer crashes if a register is used twice 
@
text
@d761 1
a761 1
	    fprintf(stderr, "sfd $Revision: 40.5 $\n");
d1008 1
a1008 1
			fprintf(FDFile, "*%s\n", yytext+1);
@


40.5
log
@OBJn= is emitted into Makefile even for private functions 
@
text
@d761 1
a761 1
	    fprintf(stderr, "sfd $Revision: 40.4 $\n");
d1048 1
a1048 1
		    EndGame("%s near %s: illegal occurance of \"%s\"\n",
d1060 1
a1060 1
		    EndGame("%s: illegal occurance of \"%s\" after ==end\n",
d1444 8
a1451 1
		    ParmRegs[i] = ++NumRegs;
@


40.4
log
@Now gens makefiles that avert $? list too long make warnings
@
text
@d482 1
a491 7
	    /* We break every 100 objects to prevent getting a
	     * "$? list too long" error, which would occur
	     * in our biggest modules.
	     */
	    if ( ( ObjCount % 100 ) == 0 ) {
		fprintf(MCFile, "\n\nOBJS%ld=", ObjCount/100 );
	    }
d761 1
a761 1
	    fprintf(stderr, "sfd $Revision: 40.3 $\n");
@


40.3
log
@Changed name for version 40 to 3.1 
@
text
@d323 1
a342 1

d476 7
d491 7
d521 1
d767 1
a767 1
	    fprintf(stderr, "sfd $Revision: 40.2 $\n");
a915 2
		fprintf(MCFile, "\n");
		fprintf(MCFile, "OBJS=");
a918 2
		fprintf(MRFile, "\n");
		fprintf(MRFile, "OBJS=");
d924 1
d1620 9
a1628 1
		fprintf(MCFile, "	make objs ${MFLAGS} ${MARGS}\n");
d1634 9
a1642 2
		fprintf(MCFile, "\n");
		fprintf(MCFile, "objs:		${OBJS}\n");
d1650 5
a1654 1
		fprintf(MRFile, "	make objs ${MFLAGS} ${MARGS}\n");
d1660 4
a1663 2
		fprintf(MRFile, "\n");
		fprintf(MRFile, "objs:		${OBJS}\n");
@


40.2
log
@private pragmas now enclosed in #idef MODULE_PRIVATE_PRAGMAS 
@
text
@d356 1
a356 1
    "Release 3.01",		/* V40 */
d752 1
a752 1
	    fprintf(stderr, "sfd $Revision: 40.1 $\n");
@


40.1
log
@Bumped revision to V40
@
text
@d752 1
a752 1
	    fprintf(stderr, "sfd $Revision: 39.5 $\n");
d1501 1
a1501 1
			    fprintf(LPFile, "/* System-private function: %s */\n", FunctionName );
d1568 4
@


39.5
log
@Added sfd definition for V40 
@
text
@d752 1
a752 1
	    fprintf(stderr, "sfd $Revision: 39.4 $\n");
@


39.4
log
@Pragma tagcall now enabled for printf-style functions 
@
text
@d344 1
a344 1
#define  KNOWN_RELEASES	39
d356 1
d752 1
a752 1
	    fprintf(stderr, "sfd $Revision: 39.3 $\n");
@


39.3
log
@Gave pragmas a better header.  No longer comment out private pragmas. 
@
text
@d751 1
a751 1
	    fprintf(stderr, "sfd $Revision: 39.2 $\n");
a1496 11

			/* TEMPORARY KLUDGE FOR SAS 6.0:
			 * The new pragma tagcall stuff can't handle printf
			 * style functions that don't require the last
			 * argument.  Until they fix that, we fail to
			 * emit those pragma tagcall lines.
			 */
			if ( ( VarArgs ) && ( ( NumArgs+1 ) == NumRegs ) )
			{
			    pragmaOK = 0;
			}
@


39.2
log
@Now knows V39 to be "Release 3".  Now handles versions > known.
@
text
@d251 1
a251 1
/* (see LEX grammer at the end of this file) */
d940 1
a940 1
			    "/*\n**\t$Id: %s_protos.h,v %s\n", SysName, IdName);
d944 6
a949 1
		    fprintf(CPFile, "**\t    All Rights Reserved\n*/\n");
d1483 1
a1483 1
			pragmaOK = Public;
d1508 6
@


39.1
log
@Now handles SAS-6 #pragma tagcall stuff.
Note: printf-style vararg functions (where the last parameter can be omitted)
have their pragma lines generated in comments, since SAS 6.0's initial
release doesn't support that (gives an error).
@
text
@d346 10
a355 10
    "distributed as Release 1.0",		/* V30 */
    "distributed as Release 1.1",		/* V31 */
    "distributed as Preliminary Release 1.2",	/* V32 */
    "distributed as Release 1.2",		/* V33 */
    "distributed as Release 1.3",		/* V34 */
    "distributed as Release 1.3 A2024",		/* V35 */
    "distributed as Release 2.0",		/* V36 */
    "distributed as Release 2.04",		/* V37 */
    "distributed as Release 2.1",		/* V38 */
    "beta release for developers only",		/* V39 */
d751 1
a751 1
	    fprintf(stderr, "sfd $Revision: 39.1 $\n");
d1157 1
a1157 1
		    if ((i < BASE_RELEASE) || (i > KNOWN_RELEASES))
d1160 7
a1166 1
			fprintf(FDFile,
d1168 1
a1168 1
				i, Release[i-BASE_RELEASE]);
d1170 1
a1170 1
			    fprintf(CPFile,
d1172 2
a1173 2
				    i, Release[i-BASE_RELEASE]);
			    fprintf(LPFile,
d1175 1
a1175 1
				    i, Release[i-BASE_RELEASE]);
@


37.2
log
@V39 is now marked as a beta release.
@
text
@d751 1
a751 1
	    fprintf(stderr, "sfd $Revision: 37.1 $\n");
d1468 1
d1470 7
a1476 7
			    /* write pragma file */
			    pragmaCount = 0;
			    pragmaOK = Public;
			    /*     gather pragma */
			    for (i = 1; i <= NumRegs; i++) {
				for (j = 0; ParmRegs[j] != i; j++);
				pragmaWord[NumRegs - i] = (j <= 9 ? '0' + j :
d1478 3
a1480 3
				if (j >= 14 /* a6 */)
				    pragmaOK = 0;
			    }
d1487 29
a1515 10
/*			    if (pragmaCount > 6) {
				pragmaOK = 0;
				pragmaCount = 7;
			    }
			    pragmaWord = (pragmaWord << 8) | pragmaCount; 
*/

#if	SYSBASEPRAGMA
			    if (strcmp(BaseName, "_SysBase") == 0) {
				if (pragmaOK)
d1517 4
a1520 2
					    "#pragma syscall %s %x %s\n",
					    FunctionName, -Bias, pragmaWord);
d1522 1
d1524 4
a1527 2
					    "/*pragma syscall %s %x %s*/\n",
					    FunctionName, -Bias, pragmaWord);
d1530 3
a1532 3
#endif
			    if (BaseName[1]) {
				if (pragmaOK)
d1534 1
a1534 1
					    "#pragma libcall %s %s %x %s\n",
d1537 1
d1539 1
d1541 1
a1541 1
					    "/*pragma libcall %s %s %x %s*/\n",
d1544 1
d1546 5
a1550 1
			    else
d1554 7
d1563 1
d1574 1
@


37.1
log
@Bumped version number to 37.1 for good measure.
@
text
@d346 10
a355 10
    "Release 1.0",			/* V30 */
    "Release 1.1",			/* V31 */
    "Preliminary Release 1.2",		/* V32 */
    "Release 1.2",			/* V33 */
    "Release 1.3",			/* V34 */
    "Release 1.3 A2024",		/* V35 */
    "Release 2.0",			/* V36 */
    "Release 2.04",			/* V37 */
    "Release 2.1",			/* V38 */
    "Release 3.0",			/* V39 */
d1161 1
a1161 1
		"*--- functions in V%ld or higher (distributed as %s) ---\n",
d1165 1
a1165 1
		"/*--- functions in V%ld or higher (distributed as %s) ---*/\n",
d1168 1
a1168 1
		"/*--- functions in V%ld or higher (distributed as %s) ---*/\n",
@


36.31
log
@PrivateCount reset for each file.
@
text
@d751 1
a751 1
	    fprintf(stderr, "sfd $Revision: 36.30 $\n");
@


36.30
log
@Private functions are omitted from the FD file.
(comments inside ==private still appear in the FD, though)
@
text
@a734 2
    PrivateCount = 0;

d751 1
a751 1
	    fprintf(stderr, "sfd $Revision: 36.29 $\n");
d767 3
@


36.29
log
@Now support printf()-style varargs functions (ones that don't require
any of the variable arguments).  Fully blank lines in the sfd file
"*\n" come out as blank in the prototypes and pragmas, instead of
"/**/".  Comments in the private part of the sfd file are no longer
emitted to the prototype file.
@
text
@d327 1
d608 1
a608 1
	    fprintf(FDFile, ",");
d641 1
a641 1
	    fprintf(FDFile, ArgRegs+1);
d735 2
d753 1
a753 1
	    fprintf(stderr, "sfd $Revision: 36.28 $\n");
d1205 4
a1208 2
			if ((!Alias) && (!VarArgs))
			    fprintf(FDFile, "%s(", FunctionName);
d1292 2
a1293 1
			    	fprintf(FDFile, "%s)(", PrevToken);
d1337 1
a1337 1
				fprintf(FDFile, "%s", PrevToken);
d1383 1
a1383 1
			    fprintf(FDFile, "%s", PrevToken);
d1392 1
a1392 1
				fprintf(FDFile, ",");
@


36.28
log
@Bumped KNOWN_RELEASES to 39, and added descriptive strings for V37-V39.
@
text
@d750 1
a750 1
	    fprintf(stderr, "sfd $Revision: 36.27 $\n");
d994 6
d1002 1
a1002 1
				fprintf(CPFile, "/*%s */\n", yytext+1);
d1006 1
a1006 1
				fprintf(CPFile, "/*%s*/\n", yytext+1);
d1423 7
a1429 1
			if (NumArgs != NumRegs)
@


36.27
log
@ARGH!!  pea DOESN'T decrement stack first, the books lie.
Also, the real problem is that the old varargs code assumed that you
were going to load An with the first arg ptr, then get the args into
regs with a movem.l (An)+,..., leaving An pointing at the first vararg.
With a D register, you can't do that, so it must point the the right
place from the start.
ARGH
@
text
@d343 1
a343 1
#define  KNOWN_RELEASES	36
d345 10
a354 6
    "Release 1.0",
    "Release 1.1", "Preliminary Release 1.2",
    "Release 1.2",
    "Release 1.3",
    "Release 1.3 A2024",
    "Release 2.0"
d750 1
a750 1
	    fprintf(stderr, "sfd $Revision: 36.26 $\n");
@


36.26
log
@Pea decrements BEFORE calculating the address!
this messed up dos stubs again!
@
text
@d562 1
d571 11
a581 2
		/* pea decrements stack first! */
	        fprintf(RFile, "\t\tpea\t%ld(a7)\n", stackOffset + 4 + 4);
d586 2
a587 1
		    fprintf(CFile, "\t\tpea\t%ld(a7)\n", stackOffset + 4 + 4);
d746 1
a746 1
	    fprintf(stderr, "sfd $Revision: 36.25 $\n");
@


36.25
log
@Didn't have TRUE/FALSE
@
text
@d570 2
a571 1
	        fprintf(RFile, "\t\tpea\t%ld(a7)\n", stackOffset + 4);
d575 2
a576 1
		    fprintf(CFile, "\t\tpea\t%ld(a7)\n", stackOffset + 4);
d735 1
a735 1
	    fprintf(stderr, "sfd $Revision: 36.23 $\n");
@


36.24
log
@Fixed varargs D-reg pragmas
(I meant stubs, not pragmas)
@
text
@d454 1
a454 1
    short varReg, stackOffset, stackSave, DvarReg = FALSE;
d569 1
a569 1
		DvarReg = TRUE;	/* remember! */
@


36.23
log
@Fixed sfd to handle > 6 parameters
@
text
@d454 1
a454 1
    short varReg, stackOffset, stackSave;
d569 3
a571 4
		fprintf(RFile, "\t\tmove.l\ta1,-(a7)\n");
	        fprintf(RFile, "\t\tlea\t%ld(a7),a1\n", stackOffset + 8);
		fprintf(RFile, "\t\tmove.l\ta1,d%ld\n", varReg);
		fprintf(RFile, "\t\tmove.l\t(a7)+,a1\n");
d574 2
a575 4
		    fprintf(CFile, "\t\tmove.l\ta1,-(a7)\n");
		    fprintf(CFile, "\t\tlea\t%ld(a7),a1\n", stackOffset + 8);
		    fprintf(CFile, "\t\tmove.l\ta1,d%ld\n", varReg);
		    fprintf(CFile, "\t\tmove.l\t(a7)+,a1\n");
d627 2
a628 1
	    if (VarArgs) {
d733 1
a733 1
	    fprintf(stderr, "sfd $Revision: 36.22 $\n");
@


36.22
log
@VarArgs was wrong - was incrementing stack frame pointer by 4 instead of
8.  This was bad.
@
text
@d711 1
a711 1
    unsigned long pragmaWord;
d735 1
a735 1
	    fprintf(stderr, "sfd $Revision: 36.19 $\n");
a1435 1
			    pragmaWord = 0;
d1441 2
a1442 1
				pragmaWord |= j << (pragmaCount++ * 4);
d1446 7
a1452 1
			    if (pragmaCount > 6) {
d1456 2
a1458 1
			    pragmaWord = (pragmaWord << 8) | pragmaCount; 
d1463 1
a1463 1
					    "#pragma syscall %s %x %lx\n",
d1467 1
a1467 1
					    "/*pragma syscall %s %x %lx*/\n",
d1475 1
a1475 1
					    "#pragma libcall %s %s %x %lx\n",
d1480 1
a1480 1
					    "/*pragma libcall %s %s %x %lx*/\n",
d1486 1
a1486 1
					"/*pragma libcall  %s %x %lx*/\n",
@


36.21
log
@Checkpointing the modifications I've made to stop it from making
the Makefile for a ==base _None  file.
@
text
@a262 2
unsigned char BASE_NONE;	/* Flag to tell us that were dealing with a
				   linkable library */
d466 3
a468 6
	if(!BASE_NONE)
	{
	    RFile = fopen(FileName, "w");
	    if (RFile == 0)
		EndGame("cannot create file \"%s\"\n", FileName);
	}
d470 1
a470 2
	if(MRFile)
	    fprintf(MRFile, "\\\n	%s.obj", FunctionName);
d474 3
a476 6
	    if(!BASE_NONE)
	    {
		CFile = fopen(FileName, "w");
	    	if (CFile == 0)
		    EndGame("cannot create file \"%s\"\n", FileName);
	    }
d478 1
a478 2
	    if(MCFile)
		fprintf(MCFile, "\\\n	%s.obj", FunctionName);
d484 7
a490 10
	if(RFile)
	{
	    fprintf(RFile, "*** DO NOT EDIT: FILE BUILT AUTOMATICALLY\n");
	    fprintf(RFile, "*** %s rom interface\n", FunctionName);
	    if (BaseName[0] != '\0')
		fprintf(RFile, "	XREF	%sOffset\n", BaseName);
	    fprintf(RFile, "	SECTION	%s\n", SysName);
	    fprintf(RFile, "	XDEF	_%s\n", FunctionName);
	    fprintf(RFile, "_%s:\n", FunctionName);
	}
d525 1
a525 2
	    if(RFile)
		fprintf(RFile, "\t	movem.l	%s/a6,-(a7)\n", ProtectedRegs+1);
d530 1
a530 2
	    if(RFile)
		fprintf(RFile, "\t	move.l	a6,-(a7)\n");
d538 1
a538 2
	    if(RFile)
		fprintf(RFile, "\t\tmove.l\t%sOffset(a6),a6\n", BaseName);
d562 1
a562 2
		if(RFile)
		    fprintf(RFile, "\t\tlea\t%ld(a7),a%d\n", stackOffset + 4, varReg);
d567 1
a567 1
	    else if(RFile)
d570 1
a570 1
	        fprintf(RFile, "\t\tlea\t%ld(a7),a1\n", stackOffset + 4);
d576 1
a576 1
		    fprintf(CFile, "\t\tlea\t%ld(a7),a1\n", stackOffset + 4);
d593 1
a593 2
	    if(!BASE_NONE)
		fprintf(FDFile, ",");
d626 1
a626 2
	    if(!BASE_NONE)
		fprintf(FDFile, ArgRegs+1);
d634 1
a634 2
		    if(RFile)
			fprintf(RFile, "\t\tmove.l\t(a%ld)+,%s\n", varReg,
d642 1
a642 2
		    if(RFile)
			fprintf(RFile, "\t\tmovem.l\t(a%ld)+,%s\n", varReg,
d653 1
a653 2
		    if(RFile)
			fprintf(RFile, "\t\tmove.l\t%ld(a7),%s\n", stackSave + 4,
d661 1
a661 2
		    if(RFile)
			fprintf(RFile, "\t\tmovem.l\t%ld(a7),%s\n", stackSave + 4,
d671 1
a671 1
    if ((!BASE_NONE) && (!Alias) && (!VarArgs)) {
d673 1
a673 1
	    fprintf(FDFile, ")\n");
d677 1
a677 2
	if(RFile)
	    fprintf(RFile, "\t	jsr	%ld(a6)\n", Bias);
d681 1
a681 2
	    if(RFile)
		fprintf(RFile, "		movem.l	(a7)+,%s/a6\n",
d688 1
a688 2
	    if(RFile)
		fprintf(RFile, "		move.l	(a7)+,a6\n");
d692 4
a695 8
	if(RFile)
	{
	    fprintf(RFile, "		rts\n");
	    fprintf(RFile, "	END\n");
	    fclose(RFile);
	}
	if (CFile)
	{
a714 1
    BASE_NONE = 0;
d735 1
a735 1
	    fprintf(stderr, "sfd $Revision: 36.20 $\n");
d778 3
a780 6
	    if(!BASE_NONE)
	    {
		FDFile = fopen(FileName, "w");
	    	if (FDFile == 0)
		    EndGame("cannot create file \"%s\"\n", FileName);
	    }
d790 3
a792 6
	    if(!BASE_NONE)
	    {
		FDFile = fopen(FileName, "w");
	    	if (FDFile == 0)
		    EndGame("cannot create file \"%s\"\n", FileName);
	    }
d799 3
a801 6
	    if(!BASE_NONE)
	    {
		AFile = fopen(FileName, "w");
		if (AFile == 0)
		    EndGame("cannot create file \"%s\"\n", FileName);
	    }
d829 3
a831 6
	    if(!BASE_NONE)
	    {
		LPFile = fopen(FileName, "w");
		if (LPFile == 0)
		    EndGame("cannot create file \"%s\"\n", FileName);
	    }
d844 3
a846 5
		if(!BASE_NONE)
		{
		    MCFile = fopen(FileName, "w");
		    if (MCFile == 0)
			EndGame("cannot create file \"%s\"\n", FileName);
d848 5
a852 7
		    /* open the ROM Makefile file */
		    FileName[1] = 'O';		/* ROM/ */
puts("We're opening up MRFile for some reason");
		    MRFile = fopen(FileName, "w");
		    if (MRFile == 0)
			EndGame("cannot create file \"%s\"\n", FileName);
		}
d856 3
a858 6
	    if(!BASE_NONE)
	    {
		fprintf(AFile, "*** DO NOT EDIT: FILE BUILT AUTOMATICALLY\n");
		fprintf(AFile, "*** %s.asm function offsets\n", LibName);
		fprintf(AFile, "	IDNT	%s_LVO\n", SysName);
	    }
d879 4
a882 7
		if(MCFile)
		{
		    fprintf(MCFile, "########################################\n");
		    fprintf(MCFile, "MAKEMETA=	../../../../tools/makemeta\n");
		    fprintf(MCFile, "\n");
		    fprintf(MCFile, "OBJS=");
		}
d884 4
a887 7
		if(MRFile)
		{
		    fprintf(MRFile, "########################################\n");
		    fprintf(MRFile, "MAKEMETA=	../../../../tools/makemeta\n");
		    fprintf(MRFile, "\n");
		    fprintf(MRFile, "OBJS=");
		}
d954 1
a954 1
		    if ((!BASE_NONE) && (!IForm))
d960 1
a960 1
		    if ((!BASE_NONE) && (!IForm))
d971 1
a971 1
		    if ((!BASE_NONE) && (!IForm))
d977 1
a977 2
			if(!BASE_NONE)
			    fprintf(FDFile, "*%s\n", yytext+1);
d982 1
a982 2
				if(!BASE_NONE)
				    fprintf(LPFile, "/*%s */\n", yytext+1);
d986 1
a986 2
				if(!BASE_NONE)
				    fprintf(LPFile, "/*%s*/\n", yytext+1);
d1035 1
a1035 4
printf("yytext = \"%s\" BASE_NONE = %d\n", yytext, BASE_NONE);
		    if(strcmp(yytext,"_None") == 0)
			BASE_NONE = 1;
		    if ((!BASE_NONE) && (!IForm))
d1082 1
a1082 1
		    if ((!BASE_NONE) && (IForm)) {
d1089 1
a1089 1
		    else if(!BASE_NONE)
d1102 1
a1102 1
		    if ((!BASE_NONE) && (IForm)) {
d1105 1
a1105 1
				SysName, -Bias);
d1111 2
a1112 3
			if(!BASE_NONE)
			    fprintf(FDFile,
				"*--- (%ld function slot%s reserved here) ---\n",
d1114 2
a1115 3
			if(!BASE_NONE)
			    fprintf(FDFile, "##bias %ld\n", -Bias);
			if ((!BASE_NONE) && !FForm) {
d1134 2
a1135 2
		    if ((!BASE_NONE) && (!IForm)) {
			    fprintf(FDFile,
d1142 1
a1142 2
			    if(!BASE_NONE)
				fprintf(LPFile,
d1176 1
a1176 1
		    if ((!BASE_NONE) && IForm) {
d1181 1
a1181 1
			if ((!Alias) && (!VarArgs) && (!BASE_NONE))
d1266 1
a1266 2
			    	if(!BASE_NONE)
				    fprintf(FDFile, "%s)(", PrevToken);
d1310 1
a1310 2
				if(!BASE_NONE)
				    fprintf(FDFile, "%s", PrevToken);
d1356 1
a1356 2
			    if(!BASE_NONE)
				fprintf(FDFile, "%s", PrevToken);
d1364 1
a1364 1
			    if ((!BASE_NONE) && (!Alias) && (!VarArgs))
d1407 1
a1407 1
			    if ((!BASE_NONE) && (!Alias)) {
a1433 3
			    else
				if(!Alias)
				    LVOCount++;
d1454 1
a1454 1
				if ((!BASE_NONE) && pragmaOK)
d1458 1
a1458 1
				else if(!BASE_NONE)
d1466 1
a1466 1
				if ((!BASE_NONE) && pragmaOK)
d1472 1
a1472 2
				    if(!BASE_NONE)
					fprintf(LPFile,
d1478 3
a1480 4
				if(!BASE_NONE)
					fprintf(LPFile,
					    "/*pragma libcall  %s %x %lx*/\n",
					    FunctionName, -Bias, pragmaWord);
d1505 7
a1511 19
	    if(!BASE_NONE)
	    {
		fprintf(AFile, "	END\n");
		fclose(AFile);
	    }
	    if(BFile)
	    {
		fprintf(BFile, "$)\n");
		fclose(BFile);
	    }

	    if(CPFile)
	    {
		fprintf(CPFile, "#endif   /* CLIB_%s_PROTOS_H */\n", CapsName);
		fclose(CPFile);
	    }
	
	    if(LPFile)
		fclose(LPFile);
d1513 30
a1542 37
		if(MCFile)
		{
		    fprintf(MCFile, "\n\n");
		    fprintf(MCFile, "lib.timestamp:	asm.timestamp\n");
		    fprintf(MCFile, "	make objs ${MFLAGS} ${MARGS}\n");
		    fprintf(MCFile, "	cat *.obj >../%s.lib\n", SysName);
		    fprintf(MCFile, "	rm -f *.obj\n");
		    fprintf(MCFile, "	touch lib.timestamp\n");
		    fprintf(MCFile, "\n");
		    fprintf(MCFile, "asm.timestamp:\n");
		    fprintf(MCFile, "\n");
		    fprintf(MCFile, "objs:		${OBJS}\n");
		    fprintf(MCFile, "	rm -f *.asm\n");
		    fprintf(MCFile, "	touch asm.timestamp\n");
		    fprintf(MCFile, "\n");
		    fprintf(MCFile, ".INCLUDE=${MAKEMETA}\n");
		    fclose(MCFile);
		}

		if(MRFile)
		{
		    fprintf(MRFile, "\n\n");
		    fprintf(MRFile, "lib.timestamp:	asm.timestamp\n");
		    fprintf(MRFile, "	make objs ${MFLAGS} ${MARGS}\n");
		    fprintf(MRFile, "	cat *.obj >../%s.lib\n", SysName);
		    fprintf(MRFile, "	rm -f *.obj\n");
		    fprintf(MRFile, "	touch lib.timestamp\n");
		    fprintf(MRFile, "\n");
		    fprintf(MRFile, "asm.timestamp:\n");
		    fprintf(MRFile, "\n");
		    fprintf(MRFile, "objs:		${OBJS}\n");
		    fprintf(MRFile, "	rm -f *.asm\n");
		    fprintf(MRFile, "	touch asm.timestamp\n");
		    fprintf(MRFile, "\n");
		    fprintf(MRFile, ".INCLUDE=${MAKEMETA}\n");
		    fclose(MRFile);
		}
@


36.20
log
@Modified to handle a base of "_None" which means that this
modules does not pertain to a loadable library, but rather
a linkable one.  As such, stubs, fds, and pragmas are not
generated.
@
text
@d766 1
a766 1
	    fprintf(stderr, "sfd $Revision: 36.19 $\n");
d895 1
d1027 1
a1027 1
		    if ((!BASE_NONE) && (!IForm)
d1094 1
@


36.19
log
@Changed the output string for version = 36
@
text
@d263 2
d468 6
a473 3
	RFile = fopen(FileName, "w");
	if (RFile == 0)
	    EndGame("cannot create file \"%s\"\n", FileName);
d475 2
a476 1
	fprintf(MRFile, "\\\n	%s.obj", FunctionName);
d480 6
a485 3
	    CFile = fopen(FileName, "w");
	    if (CFile == 0)
		EndGame("cannot create file \"%s\"\n", FileName);
d487 2
a488 1
	    fprintf(MCFile, "\\\n	%s.obj", FunctionName);
d494 10
a503 7
	fprintf(RFile, "*** DO NOT EDIT: FILE BUILT AUTOMATICALLY\n");
	fprintf(RFile, "*** %s rom interface\n", FunctionName);
	if (BaseName[0] != '\0')
	    fprintf(RFile, "	XREF	%sOffset\n", BaseName);
	fprintf(RFile, "	SECTION	%s\n", SysName);
	fprintf(RFile, "	XDEF	_%s\n", FunctionName);
	fprintf(RFile, "_%s:\n", FunctionName);
d538 2
a539 1
	    fprintf(RFile, "\t	movem.l	%s/a6,-(a7)\n", ProtectedRegs+1);
d544 2
a545 1
	    fprintf(RFile, "\t	move.l	a6,-(a7)\n");
d553 2
a554 1
	    fprintf(RFile, "\t\tmove.l\t%sOffset(a6),a6\n", BaseName);
d578 2
a579 1
		fprintf(RFile, "\t\tlea\t%ld(a7),a%d\n", stackOffset + 4, varReg);
d584 1
a584 1
	    else
d610 2
a611 1
	    fprintf(FDFile, ",");
d644 2
a645 1
	    fprintf(FDFile, ArgRegs+1);
d653 2
a654 1
		    fprintf(RFile, "\t\tmove.l\t(a%ld)+,%s\n", varReg,
d662 2
a663 1
		    fprintf(RFile, "\t\tmovem.l\t(a%ld)+,%s\n", varReg,
d674 2
a675 1
		    fprintf(RFile, "\t\tmove.l\t%ld(a7),%s\n", stackSave + 4,
d683 2
a684 1
		    fprintf(RFile, "\t\tmovem.l\t%ld(a7),%s\n", stackSave + 4,
d694 1
a694 1
    if ((!Alias) && (!VarArgs)) {
d696 1
a696 1
	fprintf(FDFile, ")\n");
d700 2
a701 1
	fprintf(RFile, "\t	jsr	%ld(a6)\n", Bias);
d705 2
a706 1
	    fprintf(RFile, "		movem.l	(a7)+,%s/a6\n",
d713 2
a714 1
	    fprintf(RFile, "		move.l	(a7)+,a6\n");
d718 8
a725 4
	fprintf(RFile, "		rts\n");
	fprintf(RFile, "	END\n");
	fclose(RFile);
	if (CFile) {
d745 1
d766 1
a766 1
	    fprintf(stderr, "sfd $Revision: 36.18 $\n");
d809 6
a814 3
	    FDFile = fopen(FileName, "w");
	    if (FDFile == 0)
		EndGame("cannot create file \"%s\"\n", FileName);
d824 6
a829 3
	    FDFile = fopen(FileName, "w");
	    if (FDFile == 0)
		EndGame("cannot create file \"%s\"\n", FileName);
d836 6
a841 3
	    AFile = fopen(FileName, "w");
	    if (AFile == 0)
		EndGame("cannot create file \"%s\"\n", FileName);
d869 6
a874 3
	    LPFile = fopen(FileName, "w");
	    if (LPFile == 0)
		EndGame("cannot create file \"%s\"\n", FileName);
d887 5
a891 3
		MCFile = fopen(FileName, "w");
		if (MCFile == 0)
		    EndGame("cannot create file \"%s\"\n", FileName);
d893 6
a898 5
		/* open the ROM Makefile file */
		FileName[1] = 'O';		/* ROM/ */
		MRFile = fopen(FileName, "w");
		if (MRFile == 0)
		    EndGame("cannot create file \"%s\"\n", FileName);
d902 6
a907 3
	    fprintf(AFile, "*** DO NOT EDIT: FILE BUILT AUTOMATICALLY\n");
	    fprintf(AFile, "*** %s.asm function offsets\n", LibName);
	    fprintf(AFile, "	IDNT	%s_LVO\n", SysName);
d928 7
a934 4
		fprintf(MCFile, "########################################\n");
		fprintf(MCFile, "MAKEMETA=	../../../../tools/makemeta\n");
		fprintf(MCFile, "\n");
		fprintf(MCFile, "OBJS=");
d936 7
a942 4
		fprintf(MRFile, "########################################\n");
		fprintf(MRFile, "MAKEMETA=	../../../../tools/makemeta\n");
		fprintf(MRFile, "\n");
		fprintf(MRFile, "OBJS=");
d1009 1
a1009 1
		    if (!IForm)
d1015 1
a1015 1
		    if (!IForm)
d1026 1
a1026 1
		    if (!IForm)
d1032 2
a1033 1
			fprintf(FDFile, "*%s\n", yytext+1);
d1038 2
a1039 1
				fprintf(LPFile, "/*%s */\n", yytext+1);
d1043 2
a1044 1
				fprintf(LPFile, "/*%s*/\n", yytext+1);
d1093 3
a1095 1
		    if (!IForm)
d1142 1
a1142 1
		    if (IForm) {
d1149 1
a1149 1
		    else
d1162 1
a1162 1
		    if (IForm) {
d1165 1
a1165 1
				    SysName, -Bias);
d1171 3
a1173 2
			fprintf(FDFile,
			"*--- (%ld function slot%s reserved here) ---\n",
d1175 3
a1177 2
			fprintf(FDFile, "##bias %ld\n", -Bias);
			if (!FForm) {
d1196 2
a1197 2
		    if (!IForm) {
			fprintf(FDFile,
d1204 2
a1205 1
			    fprintf(LPFile,
d1239 1
a1239 1
		    if (IForm) {
d1244 1
a1244 1
			if ((!Alias) && (!VarArgs))
d1329 2
a1330 1
			    	fprintf(FDFile, "%s)(", PrevToken);
d1374 2
a1375 1
				fprintf(FDFile, "%s", PrevToken);
d1421 2
a1422 1
			    fprintf(FDFile, "%s", PrevToken);
d1430 1
a1430 1
			    if ((!Alias) && (!VarArgs))
d1473 1
a1473 1
			    if (!Alias) {
d1500 3
d1523 1
a1523 1
				if (pragmaOK)
d1527 1
a1527 1
				else
d1535 1
a1535 1
				if (pragmaOK)
d1541 2
a1542 1
				    fprintf(LPFile,
d1548 4
a1551 3
				fprintf(LPFile,
					"/*pragma libcall  %s %x %lx*/\n",
					FunctionName, -Bias, pragmaWord);
d1576 19
a1594 7
	    fprintf(AFile, "	END\n");
	    fclose(AFile);
	    fprintf(BFile, "$)\n");
	    fclose(BFile);
	    fprintf(CPFile, "#endif   /* CLIB_%s_PROTOS_H */\n", CapsName);
	    fclose(CPFile);
	    fclose(LPFile);
d1596 37
a1632 30
		fprintf(MCFile, "\n\n");
		fprintf(MCFile, "lib.timestamp:	asm.timestamp\n");
		fprintf(MCFile, "	make objs ${MFLAGS} ${MARGS}\n");
		fprintf(MCFile, "	cat *.obj >../%s.lib\n", SysName);
		fprintf(MCFile, "	rm -f *.obj\n");
		fprintf(MCFile, "	touch lib.timestamp\n");
		fprintf(MCFile, "\n");
		fprintf(MCFile, "asm.timestamp:\n");
		fprintf(MCFile, "\n");
		fprintf(MCFile, "objs:		${OBJS}\n");
		fprintf(MCFile, "	rm -f *.asm\n");
		fprintf(MCFile, "	touch asm.timestamp\n");
		fprintf(MCFile, "\n");
		fprintf(MCFile, ".INCLUDE=${MAKEMETA}\n");
		fclose(MCFile);
		fprintf(MRFile, "\n\n");
		fprintf(MRFile, "lib.timestamp:	asm.timestamp\n");
		fprintf(MRFile, "	make objs ${MFLAGS} ${MARGS}\n");
		fprintf(MRFile, "	cat *.obj >../%s.lib\n", SysName);
		fprintf(MRFile, "	rm -f *.obj\n");
		fprintf(MRFile, "	touch lib.timestamp\n");
		fprintf(MRFile, "\n");
		fprintf(MRFile, "asm.timestamp:\n");
		fprintf(MRFile, "\n");
		fprintf(MRFile, "objs:		${OBJS}\n");
		fprintf(MRFile, "	rm -f *.asm\n");
		fprintf(MRFile, "	touch asm.timestamp\n");
		fprintf(MRFile, "\n");
		fprintf(MRFile, ".INCLUDE=${MAKEMETA}\n");
		fclose(MRFile);
@


36.18
log
@Modified by kevin and Randell to handle varargs in D registers.
This is done by having the following code generated:

	move.l	a1,-(a7)
	lea	xx,a1
	move.l	a1,dn
	move.l	(a7)+,a1
@
text
@d350 1
a350 1
    "Preliminary Release 2.0"
d735 1
a735 1
	    fprintf(stderr, "sfd $Revision: 36.16 $\n");
@


36.17
log
@This is kevin checking in whatever it was that Andy
was doing to this file.
@
text
@d551 4
a554 3
	    if (varReg<8)
		EndGame("%s %s: d%ld illegal vararg\n", SFDName, FunctionName,
			varReg);
d559 22
a580 5
	    varReg -= 8;
	    fprintf(RFile, "\t\tlea\t%ld(a7),a%d\n", stackOffset + 4, varReg);
	    if (CFile)
		fprintf(CFile, "\t\tlea\t%ld(a7),a%d\n", stackOffset + 4,
			varReg);
@


36.16
log
@rename known releases
@
text
@d717 1
a717 1
	    fprintf(stderr, "sfd $Revision: 36.15 $\n");
d904 1
a904 1
		    fprintf(CPFile, "**\n**\tC prototypes\n**\n");
d984 1
a984 1
			writeCP(yytext);
d1150 1
a1150 1
			writeCP(yytext);
d1165 1
a1165 1
			writeCP(yytext);
d1204 1
a1204 1
			writeCP(PrevToken);
d1219 1
a1219 1
			writeCP(PrevToken);
d1222 1
a1222 1
			    writeCP(" ");
d1225 1
a1225 1
			writeCP(yytext);
d1254 1
a1254 1
				writeCP("...");
d1266 1
a1266 1
				    writeCP(PrevToken);
d1270 1
a1270 1
				    writeCP("VOID");
d1273 1
a1273 1
			    writeCP(");\n");
d1295 1
a1295 1
			    writeCP(PrevToken);
d1298 1
a1298 1
			    writeCP(yytext);
d1341 1
a1341 1
			writeCP(PrevToken);
d1343 1
a1343 1
			writeCP(yytext);
@


36.15
log
@add PROTOLONGS define and set it to force numeric arguments to longs
@
text
@d346 1
a346 1
    "Release 1.1", "?V32",
d350 1
a350 1
    "Release 2.0 Preliminary"
d717 1
a717 1
	    fprintf(stderr, "sfd $Revision: 36.14 $\n");
@


36.14
log
@add and require ==id line
@
text
@d198 5
a202 2
#define  PROTONAMES	1		/* whether _protos.h have names */
#define  SYSBASEPRAGMA	0		/* whether exec #pragmas are special */
d204 4
d342 2
a343 2
#define	BASE_RELEASE	30
#define	KNOWN_RELEASES	36
d350 1
a350 1
    "Release 2.0 Beta"
d353 6
d363 4
d388 37
a424 1
	i = strlen(ProtoGroup);
d427 2
a428 2
	    if (*ProtoGroup == ' ') {
		fprintf(CPFile, "\n\t%s", ProtoGroup + 1);
d432 1
a432 1
		fprintf(CPFile, "\n\t%s", ProtoGroup);
d437 1
a437 1
	    fprintf(CPFile, ProtoGroup);
d717 1
a717 1
	    fprintf(stderr, "sfd $Revision: 36.13 $\n");
@


36.13
log
@CLIB_MODULE_PROTOS_H, not ...PROTO_H
@
text
@d30 2
d216 27
a242 24
#define	TOKEN_BASE		2
#define	TOKEN_INCLUDE		3
#define	TOKEN_BIAS		4
#define	TOKEN_ALIAS		5
#define	TOKEN_VARARGS		6
#define	TOKEN_PRIVATE		7
#define	TOKEN_PUBLIC		8
#define	TOKEN_RESERVE		9
#define	TOKEN_VERSION		10
#define	TOKEN_END		11
#define	TOKEN_COMMENT		12
#define	TOKEN_FILEPATH		13
#define	TOKEN_NUMBER		14
#define	TOKEN_REGISTER		15
#define	TOKEN_BADNAME		16
#define	TOKEN_NAME		17
#define	TOKEN_STARS		18
#define	TOKEN_ELLIPSIS		19
#define	TOKEN_OPENPARAN		20
#define	TOKEN_CLOSEPARAN	21
#define	TOKEN_OPENBRACKET	22
#define	TOKEN_CLOSEBRACKET	23
#define	TOKEN_COMMA		24
#define	TOKEN_DASH		25
d286 15
a300 12
#define	STATE_INACTIVE	0	/* nothing active */
#define	STATE_WAITNL	1	/* waiting for \r */
#define	STATE_WAITEOF	2	/* waiting for EOF */
#define	STATE_BASE	3	/* waiting for BaseName */
#define	STATE_INCLUDE	4	/* waiting for include file path */
#define	STATE_BIAS	5	/* waiting for Bias */
#define	STATE_RESERVE	6	/* waiting for Reserve */
#define	STATE_VERSION	7	/* waiting for Version */
#define	STATE_RETVALUE	8	/* waiting for first open paran */
#define	STATE_PARMS	9	/* waiting for first close paran */
#define	STATE_MIDDLE	10	/* waiting for second open paran */
#define	STATE_REGS	11	/* waiting for second close paran */
d307 1
d664 1
a664 1
	    fprintf(stderr, "sfd $Revision: 36.12 $\n");
d829 1
a829 1
	state = STATE_INACTIVE;
d832 26
d945 1
a945 5
		switch (token) {
		  case TOKEN_NEWLINE:
		    state = STATE_INACTIVE;
		    break;
		  default:
d948 1
a948 1
		}
d951 1
a951 4
		switch (token) {
		  case TOKEN_NEWLINE:
		    break;
		  default:
a953 1
		}
d1482 1
d1494 2
@


36.12
log
@include d7 & a5 in registers protected
@
text
@d655 1
a655 1
	    fprintf(stderr, "sfd $Revision: 36.11 $\n");
d795 2
a796 2
	    fprintf(CPFile, "#ifndef  CLIB_%s_PROTO_H\n", CapsName);
	    fprintf(CPFile, "#define  CLIB_%s_PROTO_H\n", CapsName);
d1411 1
a1411 1
	    fprintf(CPFile, "#endif   /* CLIB_%s_PROTO_H */\n", CapsName);
@


36.11
log
@fix stack offset for multiple parameters
add -f form and default help option
@
text
@d444 1
a444 1
    for (reg = 2; reg < 7; reg++) {
d452 1
a452 1
    for (reg = 2; reg < 5; reg++) {
d655 1
a655 1
	    fprintf(stderr, "sfd $Revision$\n");
@


36.10
log
@add -f flag
add and don't use SYSBASEPRAGMA define
@
text
@d12 1
d442 1
a442 1
    stackSave = 4;
d449 1
a449 1
	    stackSave += 4;
d457 1
a457 1
	    stackSave += 4;
d497 1
a497 1
	    fprintf(RFile, "\t\tlea\t%ld(a7),a%d\n", stackSave + 4, varReg);
d499 2
a500 1
		fprintf(CFile, "\t\tlea\t%ld(a7),a%d\n", stackSave + 4, varReg);
a504 1
    stackOffset = stackSave;
d506 1
d573 1
a573 1
		    fprintf(RFile, "\t\tmove.l\t%ld(a7),%s\n", stackOffset,
d576 2
a577 2
			fprintf(CFile, "\t\tmove.l\t%ld(a7),%s\n", stackOffset,
				ArgRegs+1);
d581 1
a581 1
		    fprintf(RFile, "\t\tmovem.l\t%ld(a7),%s\n", stackOffset,
d584 2
a585 2
			fprintf(CFile, "\t\tmovem.l\t%ld(a7),%s\n", stackOffset,
				ArgRegs+1);
d641 5
a645 2
	if ((*argv)[1] == 'f') {
	    FForm = HForm = 1;
d648 2
a649 2
	}
	else if ((*argv)[1] == 'h') {
d653 12
a664 5
	}
	else if ((*argv)[1] == 'i') {
	    IForm = 1;
	    argv++;
	    argc--;
@


36.9
log
@add and turn on PROTONAME flag
use lattice strrchr instead of home grown rindex
@
text
@d10 2
a11 1
*	sfd -i <_lib.sfd files>+	[local usage]
d196 1
d310 1
d342 1
a342 1
    if (*string == '\0')
d637 1
a637 1
    HForm = IForm = 0;
d639 2
a640 2
	if ((*argv)[1] == 'h') {
	    HForm = 1;
d644 5
d679 1
a679 1
	if (IForm) {
d682 4
a685 1
	    strcat(FileName, ".i");
d860 10
a869 4
			if ((yytext[1] == ' ') || (yytext[1] == '\t')) {
			    /* whitespace at front -> whitespace at back */
			    fprintf(CPFile, "/*%s */\n", yytext+1);
			    fprintf(LPFile, "/*%s */\n", yytext+1);
a870 4
			else {
			    fprintf(CPFile, "/*%s*/\n", yytext+1);
			    fprintf(LPFile, "/*%s*/\n", yytext+1);
			}
d938 1
a938 1
		    if (!IForm) {
d1005 5
a1009 3
			fprintf(LPFile,
			"/*--- (%ld function slot%s reserved here) ---*/\n",
				i, (i == 1)?"":"s");
d1028 2
a1029 1
			fprintf(CPFile,
d1031 2
a1032 2
				i, Release[i-BASE_RELEASE]);
			fprintf(LPFile,
d1034 2
a1035 1
				i, Release[i-BASE_RELEASE]);
d1291 1
a1291 1
		    if (!IForm) {
d1342 2
a1343 1
			    if (strcmp(BaseName, "_SysBase") == 0)
d1352 4
a1355 1
			    else if (BaseName[1])
d1366 1
d1372 3
a1375 2
			genInterface();
		    }
d1394 1
a1394 1
	if (!IForm) {
@


36.8
log
@-h option
@
text
@d194 2
d200 1
d206 1
a619 16
#ifdef	LATTICE
char *rindex(char *string, char data)
{
    int len;

    len = strlen(string);
    string += len;
    while (len--) {
	if (*--string == data)
	    return(string);
    }
    return(0);
}
#endif	/* LATTICE rindex */


d631 1
a631 1
    if (s = rindex(Prog, '/'))
d654 1
a654 1
	s = rindex(LibName, '.');
d661 1
a661 1
	s = rindex(SysName, '_');
d1156 3
d1185 3
d1231 4
a1235 1
			writeCP(yytext);
@


36.7
log
@disallow "long"
@
text
@d8 3
a10 2
*	sfd <_lib.sfd files>*	[lib/sfd useage]
*	sfd -i <_lib.sfd file>	[local usage]
d184 1
d304 1
d389 9
a397 16
    /* open C interface files */
    strcpy(FileName, "ROM/");
    strcat(FileName, SysName);
    strcat(FileName, "/");
    strcat(FileName, FunctionName);
    strcat(FileName, ".asm");
    RFile = fopen(FileName, "w");
    if (RFile == 0)
	EndGame("cannot create file \"%s\"\n", FileName);
    /* add this to the Makefile */
    fprintf(MRFile, "\\\n	%s.obj", FunctionName);

    if (Public) {
	FileName[1] = 'A';		/* RAM/ */
	CFile = fopen(FileName, "w");
	if (CFile == 0)
d400 1
a400 4
	fprintf(MCFile, "\\\n	%s.obj", FunctionName);
    }
    else
	CFile = 0;
d402 10
a411 8
    /* write C interface files */
    fprintf(RFile, "*** DO NOT EDIT: FILE BUILT AUTOMATICALLY\n");
    fprintf(RFile, "*** %s rom interface\n", FunctionName);
    if (BaseName[0] != '\0')
	fprintf(RFile, "	XREF	%sOffset\n", BaseName);
    fprintf(RFile, "	SECTION	%s\n", SysName);
    fprintf(RFile, "	XDEF	_%s\n", FunctionName);
    fprintf(RFile, "_%s:\n", FunctionName);
d413 3
a415 3
    if (CFile) {
	fprintf(CFile, "*** DO NOT EDIT: FILE BUILT AUTOMATICALLY\n");
	fprintf(CFile, "*** %s ram interface\n", FunctionName);
d417 14
a430 4
	    fprintf(CFile, "	XREF	%s\n", BaseName);
	fprintf(CFile, "	SECTION	%s\n", SysName);
	fprintf(CFile, "	XDEF	_%s\n", FunctionName);
	fprintf(CFile, "_%s:\n", FunctionName);
d453 19
a471 18
    if (ProtectedRegs[0]) {
	fprintf(RFile, "\t	movem.l	%s/a6,-(a7)\n", ProtectedRegs+1);
	if (CFile)
	    fprintf(CFile, "\t	movem.l	%s/a6,-(a7)\n", ProtectedRegs+1);
    }
    else {
	fprintf(RFile, "\t	move.l	a6,-(a7)\n");
	if (CFile)
	    fprintf(CFile, "\t	move.l	a6,-(a7)\n");
    }
    if (ParmRegs[14 /* a6 */] == 0) {
	/* check for valid BaseName */
	if (BaseName[0] == '\0')
	    EndGame("%s: ==base required\n", SFDName);
	fprintf(RFile, "\t\tmove.l\t%sOffset(a6),a6\n", BaseName);
	if (CFile)
	    fprintf(CFile, "\t\tmove.l\t%s,a6\n", BaseName);
    }
d474 12
a485 11
    if (VarArgs) {
	if (NumRegs == 0)
	    EndGame("%s %s: missing vararg register\n", SFDName, FunctionName);
	/* remove varReg from ParmRegs */
	for (reg = 0; ParmRegs[reg] != NumRegs; reg++);
	varReg = reg;
	if (varReg<8)
	    EndGame("%s %s: d%ld illegal vararg\n", SFDName, FunctionName,
		    varReg);
	ParmRegs[reg] = 0;
	NumRegs--;
d487 6
a492 5
	/* lea now and use to grab any other parameters */
	varReg -= 8;
	fprintf(RFile, "\t\tlea\t%ld(a7),a%d\n", stackSave + 4, varReg);
	if (CFile)
	    fprintf(CFile, "\t\tlea\t%ld(a7),a%d\n", stackSave + 4, varReg);
d540 6
a545 7
	if (VarArgs) {
	    /* use autoincrementing varReg */
	    if (strlen(ArgRegs) == 3) {
		/* move single register */
		fprintf(RFile, "\t\tmove.l\t(a%ld)+,%s\n", varReg, ArgRegs+1);
		if (CFile)
		    fprintf(CFile, "\t\tmove.l\t(a%ld)+,%s\n", varReg,
d547 12
d561 4
a564 4
		/* move multiple registers */
		fprintf(RFile, "\t\tmovem.l\t(a%ld)+,%s\n", varReg, ArgRegs+1);
		if (CFile)
		    fprintf(CFile, "\t\tmovem.l\t(a%ld)+,%s\n", varReg,
d566 7
a572 10
	    }
	}
	else {
	    /* use explicit stack offset */
	    if (strlen(ArgRegs) == 3) {
		/* move single register */
		fprintf(RFile, "\t\tmove.l\t%ld(a7),%s\n", stackOffset,
			ArgRegs+1);
		if (CFile)
		    fprintf(CFile, "\t\tmove.l\t%ld(a7),%s\n", stackOffset,
d574 4
a578 8
	    else {
		/* move multiple registers */
		fprintf(RFile, "\t\tmovem.l\t%ld(a7),%s\n", stackOffset,
			ArgRegs+1);
		if (CFile)
		    fprintf(CFile, "\t\tmovem.l\t%ld(a7),%s\n", stackOffset,
			    ArgRegs+1);
	    }
d587 2
a588 6
    fprintf(RFile, "\t	jsr	%ld(a6)\n", Bias);
    if (CFile)
	fprintf(CFile, "\t	jsr	%ld(a6)\n", Bias);
    if (ProtectedRegs[0]) {
	fprintf(RFile, "		movem.l	(a7)+,%s/a6\n",
		ProtectedRegs+1);
d590 3
a592 1
	    fprintf(CFile, "\t	movem.l	(a7)+,%s/a6\n",
d594 18
a612 14
    else {
	fprintf(RFile, "		move.l	(a7)+,a6\n");
	if (CFile)
	    fprintf(CFile, "\t	move.l	(a7)+,a6\n");
    }
    fprintf(RFile, "		rts\n");
    fprintf(RFile, "	END\n");
    fclose(RFile);
    if (CFile) {
	fprintf(CFile, "		rts\n");
	fprintf(CFile, "	END\n");
	fclose(CFile);
    }
    CFile = RFile = NULL;
d646 12
a657 5
    if ((argc == 3) && (strcmp(*argv, "-i") == 0)) {
	/* second form: sfd -i <.sfd-file> */
	argv++;
	argc--;
	IForm = 1;
d659 1
a659 3
    else {
	IForm = 0;
    }
d742 9
a750 8
	    /* open the RAM Makefile file */
	    MKDIR("RAM", 0777);
	    MKDIR("ROM", 0777);
	    strcpy(FileName, "ROM/");
	    strcat(FileName, SysName);
	    MKDIR(FileName, 0777);
	    FileName[1] = 'A';		/* RAM/ */
	    MKDIR(FileName, 0777);
d752 4
a755 4
	    strcat(FileName, "/Makefile");
	    MCFile = fopen(FileName, "w");
	    if (MCFile == 0)
		EndGame("cannot create file \"%s\"\n", FileName);
d757 6
a762 5
	    /* open the ROM Makefile file */
	    FileName[1] = 'O';		/* ROM/ */
	    MRFile = fopen(FileName, "w");
	    if (MRFile == 0)
		EndGame("cannot create file \"%s\"\n", FileName);
d787 5
a791 4
	    fprintf(MCFile, "########################################\n");
	    fprintf(MCFile, "MAKEMETA=	../../../../tools/makemeta\n");
	    fprintf(MCFile, "\n");
	    fprintf(MCFile, "OBJS=");
d793 5
a797 4
	    fprintf(MRFile, "########################################\n");
	    fprintf(MRFile, "MAKEMETA=	../../../../tools/makemeta\n");
	    fprintf(MRFile, "\n");
	    fprintf(MRFile, "OBJS=");
d1382 32
a1413 30
	    fprintf(MCFile, "\n\n");
	    fprintf(MCFile, "lib.timestamp:	asm.timestamp\n");
	    fprintf(MCFile, "	make objs ${MFLAGS} ${MARGS}\n");
	    fprintf(MCFile, "	cat *.obj >../%s.lib\n", SysName);
	    fprintf(MCFile, "	rm -f *.obj\n");
	    fprintf(MCFile, "	touch lib.timestamp\n");
	    fprintf(MCFile, "\n");
	    fprintf(MCFile, "asm.timestamp:\n");
	    fprintf(MCFile, "\n");
	    fprintf(MCFile, "objs:		${OBJS}\n");
	    fprintf(MCFile, "	rm -f *.asm\n");
	    fprintf(MCFile, "	touch asm.timestamp\n");
	    fprintf(MCFile, "\n");
	    fprintf(MCFile, ".INCLUDE=${MAKEMETA}\n");
	    fclose(MCFile);
	    fprintf(MRFile, "\n\n");
	    fprintf(MRFile, "lib.timestamp:	asm.timestamp\n");
	    fprintf(MRFile, "	make objs ${MFLAGS} ${MARGS}\n");
	    fprintf(MRFile, "	cat *.obj >../%s.lib\n", SysName);
	    fprintf(MRFile, "	rm -f *.obj\n");
	    fprintf(MRFile, "	touch lib.timestamp\n");
	    fprintf(MRFile, "\n");
	    fprintf(MRFile, "asm.timestamp:\n");
	    fprintf(MRFile, "\n");
	    fprintf(MRFile, "objs:		${OBJS}\n");
	    fprintf(MRFile, "	rm -f *.asm\n");
	    fprintf(MRFile, "	touch asm.timestamp\n");
	    fprintf(MRFile, "\n");
	    fprintf(MRFile, ".INCLUDE=${MAKEMETA}\n");
	    fclose(MRFile);
@


36.6
log
@fix vararg to output ... argument
LATTICEize
@
text
@d1394 1
d1412 1
a1412 1
void|unsigned|int|short|char |
@


36.5
log
@add doc
add float, double to bad words
@
text
@d192 1
a192 1
#include	<strings.h>
d194 10
d244 1
d267 1
d326 1
d378 1
d447 1
a447 1
    *s++ = '\0';
d525 1
a525 1
	*s++ = '\0';
d602 16
d673 2
d676 1
d685 1
d694 1
d706 1
d715 1
d724 3
a726 1
	    strcpy(FileName, "RAM/");
d728 4
d762 1
a762 1
	    *s = '\0';
d1134 1
d1391 1
a1391 1
};
@


36.4
log
@function parameters working
@
text
@d8 2
a9 2
*	sfd <.sfd files>*	[lib/sfd useage]
*	sfd -i <.sfd file>	[local usage]
d12 2
d16 2
d19 157
d177 12
d1349 1
a1349 1

d1367 2
a1368 1
void|unsigned|int|short|char		{ return(TOKEN_BADNAME); }
@


36.3
log
@correctly find undeclared ALLCAPSNAMES and flag as bad
add IX to list of OK names [for commodities]
add CLIB_MODULE_PROTO_H ifdefs to prototype file
use lea ax trick for varargs functions
require ==end
@
text
@d126 1
d157 4
a160 1
    strcat(ProtoGroup, string);
d834 1
d859 4
d879 3
a881 1
		    FuncParm++;
d883 3
a885 1
			if (PrevToken[0] == '\0')
d887 2
d891 1
d920 1
a920 1
				if (PrevToken[0]) {
d942 13
d956 1
d959 2
d985 1
a985 1
			if ((!Alias) && (!VarArgs)) {
d995 1
a995 1
			    fprintf(FDFile, "%s,", PrevToken);
d999 6
a1004 1
			NumArgs++;
@


36.2
log
@understands and checks for 31 character name limit
"==" prefix for commands
support for optional argument specification
V36 known as 2.0 
support for double registers bound w/ "-"
elimination of "/" in register specification
renamed xfd to sfd
added "==reserve" support, 
enforce lower case variable names
closed all open files correctly
@
text
@d104 1
d288 6
d341 16
a356 6
	if (strlen(ArgRegs) == 3) {
	    /* move single register */
	    fprintf(RFile, "\t\tmove.l\t%ld(a7),%s\n", stackOffset, ArgRegs+1);
	    if (CFile)
		fprintf(CFile, "\t\tmove.l\t%ld(a7),%s\n", stackOffset,
			ArgRegs+1);
d359 4
a362 4
	    /* move multiple registers */
	    fprintf(RFile, "\t\tmovem.l\t%ld(a7),%s\n", stackOffset, ArgRegs+1);
	    if (CFile)
		fprintf(CFile, "\t\tmovem.l\t%ld(a7),%s\n", stackOffset,
d364 12
d379 3
a381 8
    /* wrap up interface */
    if (VarArgs) {
	/* lea varReg data */
	fprintf(RFile, "\t\tlea\t%ld(a7),a%d\n",
		stackOffset + 4, varReg&7);
	if (CFile)
	    fprintf(CFile, "\t\tlea\t%ld(a7),a%d\n",
		    stackOffset + 4, varReg&7);
a382 4
    else {
	if (!Alias)
	    fprintf(FDFile, ")\n");
    }
d530 16
d1093 2
d1102 1
d1158 3
a1160 1
VOID|U?BYTE|U?WORD|U?LONG|APTR|BPTR|BSTR|STRPTR|PLANEPTR|FLOAT|DOUBLE|BOOL |
a1161 1
[_A-Z][_A-Z0-9]+			{ return(TOKEN_BADNAME); }
@


36.1
log
@includes :include, :varargs, and new alias & varargs generation
@
text
@d2 16
a17 10
/*********************************************************************
 *
 *  NAME
 *	xfd -- compile .xfd files
 *
 *  SYNOPSIS
 *	xfd <.xfd files>*
 *	xfd -i <.xfd file>
 *
 ********************************************************************/
d29 17
a45 14
#define	TOKEN_VERSION		9
#define	TOKEN_END		10
#define	TOKEN_COMMENT		11
#define	TOKEN_FILEPATH		12
#define	TOKEN_NUMBER		13
#define	TOKEN_REGISTER		14
#define	TOKEN_BADNAME		15
#define	TOKEN_NAME		16
#define	TOKEN_STARS		17
#define	TOKEN_ELLIPSIS		18
#define	TOKEN_OPENPARAN		19
#define	TOKEN_CLOSEPARAN	20
#define	TOKEN_COMMA		21
#define	TOKEN_SLASH		22
d93 6
a98 5
#define	STATE_VERSION	6	/* waiting for Version */
#define	STATE_RETVALUE	7	/* waiting for first open paran */
#define	STATE_PARMS	8	/* waiting for first close paran */
#define	STATE_MIDDLE	9	/* waiting for second open paran */
#define	STATE_REGS	10	/* waiting for second close paran */
d100 2
a101 1
char  XFDName[32];		/* "module_lib.xfd" */
d105 2
a106 2
char  FunctionName[32];		/* "Foo" -- a module function */
char  PrevToken[32];		/* the previous name token while parsing */
d115 2
a116 2
char  Public;			/* true if :public, false if :private */
char  IForm;			/* true if xfd -i */
d119 7
a125 3
char  Alias;			/* true if :alias */
char  VarArgs;			/* true if :varargs */
char  PrevStar;			/* previous writeCP was star(s) */
d127 1
d136 1
a136 1
    "Release 1.4 Beta"
d144 9
a152 3
    /* tokens that are not preceeded by '*', and are not ',' or '(', */
    /* are preceeded by a space */
    if ((!PrevStar) && (*string != ',') && (*string != '('))
d158 2
a159 1
    if ((*string == ',') || (*string == '(') || (*string == ')')) {
d179 5
a183 1
    PrevStar = (*string == '*');
d269 1
a269 1
	    EndGame("%s: :base required\n", XFDName);
d278 1
a278 1
	    EndGame("%s %s: missing vararg register\n", XFDName, FunctionName);
d283 1
a283 1
	    EndGame("%s %s: d%ld illegal vararg\n", XFDName, FunctionName,
d290 1
a301 1
	stackOffset = stackSave + (argNum * 4);
d307 1
d309 2
a310 1
	    argNum++;
d315 10
d354 1
a354 1
		stackSave + (NumArgs * 4), varReg&7);
d357 1
a357 1
		    stackSave + (NumArgs * 4), varReg&7);
d402 3
d406 1
a406 1
	/* second form: xfd -i <.xfd-file> */
d418 2
a419 2
	strcpy(XFDName, *argv++);
	strcpy(LibName, XFDName);
d421 2
a422 2
	if ((s == NULL) || (strcmp(s, ".xfd") != 0))
	    EndGame(".xfd file name \"%s\" ill formed\n", XFDName);
d429 1
a429 1
	    EndGame(".xfd file name \"%s\" ill formed\n", XFDName);
d432 2
a433 2
	/* open the .xfd file */
	yyin = fopen(XFDName, "r");
d435 1
a435 1
	    EndGame("cannot open file \"%s\"\n", XFDName);
d521 1
a521 1
	/* parse the .xfd file */
d568 3
d582 9
a590 2
			fprintf(CPFile, "/*%s\n", yytext+1);
			fprintf(LPFile, "/*%s\n", yytext+1);
d594 1
a594 1
		    fprintf(stderr, "%s: WARNING -- %s\n", Prog, XFDName);
d603 1
a603 1
			PrevStar = 1;	/* suppress initial space */
d614 1
a614 1
			    XFDName, FunctionName, yytext);
d624 1
a624 1
			    XFDName, yytext);
d632 2
a633 2
		    EndGame("%s: illegal occurance of \"%s\" after :end\n",
			    XFDName, yytext);
d639 1
a639 1
		    fprintf(stderr, "%s: WARNING -- %s\n", Prog, XFDName);
d650 2
a651 2
		    EndGame("%s: illegal name \"%s\" after :base\n",
			    XFDName, yytext);
d679 2
a680 2
		    EndGame("%s: illegal path \"%s\" after :include\n",
			    XFDName, yytext);
d690 1
a690 1
			EndGame("%s: bias overlap %ld to %ld\n", XFDName,
d692 8
a699 1
		    if (!IForm)
d704 2
a705 2
		    EndGame("%s: illegal bias \"%s\" after :bias\n",
			    XFDName, yytext);
d708 28
d741 1
a741 1
			EndGame("%s: version %ld unheard of\n", XFDName, i);
d756 2
a757 2
		    EndGame("%s: illegal version \"%s\" after :version\n",
			    XFDName, yytext);
d763 1
a763 1
		    fprintf(stderr, "%s: WARNING -- %s\n", Prog, XFDName);
d768 3
d781 1
a781 1
				XFDName, FunctionName);
d792 4
d801 2
a802 2
		    EndGame("%s after %s: format error before 1st (: \"%s\"\n",
			    XFDName, FunctionName, yytext);
d810 1
a810 1
		    fprintf(stderr, "%s: WARNING -- %s %s\n", Prog, XFDName,
d816 1
d821 1
a821 1
				XFDName, FunctionName);
d823 4
d828 10
d839 1
d843 39
a881 7
		    if (!IForm) {
			if ((!Alias) && (!VarArgs))
			    fprintf(FDFile, "%s)(", PrevToken);
			if (strcmp(PrevToken, "...") == 0) {
			    if (!VarArgs)
				EndGame("%s %s: missing :varargs\n",
					XFDName, FunctionName);
d883 8
a890 5
			else {
			    if (PrevToken[0])
				NumArgs++;
			    else
				writeCP("VOID");
d892 1
a892 1
			writeCP(");\n");
a893 1
		    state = STATE_MIDDLE;
d895 10
d906 4
d912 4
a915 1
				XFDName, FunctionName);
d917 10
a926 1
			if ((!Alias) && (!VarArgs))
d928 2
d936 1
a936 1
			    XFDName, FunctionName, yytext);
d948 1
a948 1
			    XFDName, FunctionName, yytext);
d953 2
a956 1
		  case TOKEN_SLASH:
d967 29
a995 11
				    XFDName, FunctionName, NumArgs, NumRegs);
			/* write this entry into the library files */
			if ((LVOCount & 0x7f) == 0) {
			    /* create a new section every 128 names so as to */
			    /* not overflow BLINK 5.04's 150 symbol limit */
			    if (LVOCount) {
				/* generate something that looks like code so */
				/* that the symbols associated with the prev */
				/* section get flushed by the assembler */
				fprintf(AFile, "	OFFSET	0\n");
				fprintf(AFile, "_LVO%d	ds.w	1\n");
a996 7
			    fprintf(AFile, "	SECTION	_LVO%d\n", LVOCount>>7);
			}
			LVOCount++;
			fprintf(AFile, "	XDEF	_LVO%s\n",
				FunctionName);
			fprintf(AFile, "_LVO%s EQU	%ld\n",
				FunctionName, Bias);
a997 4
			fprintf(BFile, "    e.%s = %ld\n", FunctionName, Bias);


			if (!VarArgs) {
d1052 1
a1052 1
			    XFDName, FunctionName, yytext);
d1058 39
a1096 35
	fprintf(AFile, "	END\n");
	fclose(AFile);
	fprintf(BFile, "$)\n");
	fclose(BFile);
	fclose(LPFile);
	fprintf(MCFile, "\n\n");
	fprintf(MCFile, "lib.timestamp:	asm.timestamp\n");
	fprintf(MCFile, "	make objs ${MFLAGS} ${MARGS}\n");
	fprintf(MCFile, "	cat *.obj >../%s.lib\n", SysName);
	fprintf(MCFile, "	rm -f *.obj\n");
	fprintf(MCFile, "	touch lib.timestamp\n");
	fprintf(MCFile, "\n");
	fprintf(MCFile, "asm.timestamp:\n");
	fprintf(MCFile, "\n");
	fprintf(MCFile, "objs:		${OBJS}\n");
	fprintf(MCFile, "	rm -f *.asm\n");
	fprintf(MCFile, "	touch asm.timestamp\n");
	fprintf(MCFile, "\n");
	fprintf(MCFile, ".INCLUDE=${MAKEMETA}\n");
	fclose(MCFile);
	fprintf(MRFile, "\n\n");
	fprintf(MRFile, "lib.timestamp:	asm.timestamp\n");
	fprintf(MRFile, "	make objs ${MFLAGS} ${MARGS}\n");
	fprintf(MRFile, "	cat *.obj >../%s.lib\n", SysName);
	fprintf(MRFile, "	rm -f *.obj\n");
	fprintf(MRFile, "	touch lib.timestamp\n");
	fprintf(MRFile, "\n");
	fprintf(MRFile, "asm.timestamp:\n");
	fprintf(MRFile, "\n");
	fprintf(MRFile, "objs:		${OBJS}\n");
	fprintf(MRFile, "	rm -f *.asm\n");
	fprintf(MRFile, "	touch asm.timestamp\n");
	fprintf(MRFile, "\n");
	fprintf(MRFile, ".INCLUDE=${MAKEMETA}\n");
	fclose(MRFile);
d1104 10
a1113 9
^:base					{ return(TOKEN_BASE); }
^:include				{ return(TOKEN_INCLUDE); }
^:bias					{ return(TOKEN_BIAS); }
^:alias					{ return(TOKEN_ALIAS); }
^:varargs				{ return(TOKEN_VARARGS); }
^:private				{ return(TOKEN_PRIVATE); }
^:public				{ return(TOKEN_PUBLIC); }
^:version				{ return(TOKEN_VERSION); }
^:end					{ return(TOKEN_END); }
d1120 1
a1120 1
[_a-zA-Z][_a-zA-Z0-9]+			{ return(TOKEN_NAME); }
d1126 2
d1129 2
a1130 1
"/"					{ return(TOKEN_SLASH); }
@


36.0
log
@initial release
@
text
@d17 20
a36 16
#define	TOKEN_BIAS		3
#define	TOKEN_ALIAS		4
#define	TOKEN_PRIVATE		5
#define	TOKEN_PUBLIC		6
#define	TOKEN_VERSION		7
#define	TOKEN_END		8
#define	TOKEN_COMMENT		9
#define	TOKEN_NUMBER		10
#define	TOKEN_REGISTER		11
#define	TOKEN_NAME		12
#define	TOKEN_STARS		13
#define	TOKEN_ELLIPSIS		14
#define	TOKEN_OPENPARAN		15
#define	TOKEN_CLOSEPARAN	16
#define	TOKEN_COMMA		17
#define	TOKEN_SLASH		18
d40 1
d55 4
a58 1
    if (format) fprintf(stderr, format, arg1, arg2, arg3, arg4);
d82 7
a88 6
#define	STATE_BIAS	4	/* waiting for Bias */
#define	STATE_VERSION	5	/* waiting for Version */
#define	STATE_RETVALUE	6	/* waiting for first open paran */
#define	STATE_PARMS	7	/* waiting for first close paran */
#define	STATE_MIDDLE	8	/* waiting for second open paran */
#define	STATE_REGS	9	/* waiting for second close paran */
a89 1
char *Prog;
d99 1
d102 3
a104 1
char  Public;			/* true if ##public, false if ##private */
d106 4
a109 5
short ProtoLen;			/* length of current line in prototype file */
char  ParmRegs[16];
char  NumRegs;
char  NumArgs;
char  VarArgs;
d120 1
a120 1
    "Release 1.4 (Beta)"
d128 26
a153 4
    i = strlen(string) + 1;
    if ((ProtoLen + i) >= 80) {
	fprintf(CPFile, "\n\t%s", string);
	ProtoLen = i + 8;
d155 1
a155 7
    else {
	if (PrevStar || (*string == ',') || (*string == '('))
	    fprintf(CPFile, "%s", string);
	else
	    fprintf(CPFile, " %s", string);
	ProtoLen += i;
    }
d160 1
a160 2
genInterface(varArgs)
char varArgs;
d175 1
a175 1
	EndGame("%s: ERROR  cannot create file \"%s\"\n", Prog, FileName);
d183 1
a183 1
	    EndGame("%s: ERROR  cannot create file \"%s\"\n", Prog, FileName);
d242 1
a242 1
	    EndGame("%s: ERROR  no ##base for \"%s\"\n", Prog, s);
d249 3
a251 1
    if (varArgs) {
d256 2
a257 2
	    EndGame("%s: ERROR cannot support register d%ld as vararg\n",
		    Prog, varReg);
d262 2
a263 1
    for (argNum = 1; argNum <= NumRegs; argNum++) {
d268 1
a268 1
	if ((!varArgs) && (argNum != 1)) {
d280 4
a283 5
	    for (testReg = reg + 1;
		    (testReg < 16) && (ParmRegs[testReg] == 0); testReg++);
	    if (ParmRegs[testReg] == (argNum + 1)) {
		argNum++;
		reg = testReg;
d285 1
d287 1
a287 1
	    while (reg == testReg);
d290 1
a290 1
	if (!varArgs) {
d312 2
a313 2
    if (varArgs) {
	/* lea varArg data */
d321 2
a322 1
	fprintf(FDFile, ")\n");
d356 1
a356 1
    char *s;
d380 1
a380 2
	    EndGame("%s: ERROR  .xfd file name \"%s\" ill formed\n",
		    Prog, XFDName);
d387 1
a387 2
	    EndGame("%s: ERROR  .xfd file name \"%s\" ill formed\n",
		    Prog, XFDName);
d393 1
a393 2
	    EndGame("%s: ERROR  cannot open file \"%s\"\n",
		    Prog, XFDName);
d401 1
a401 2
		EndGame("%s: ERROR  cannot create file \"%s\"\n",
			Prog, FileName);
d410 1
a410 2
		EndGame("%s: ERROR  cannot create file \"%s\"\n",
			Prog, FileName);
d418 1
a418 2
		EndGame("%s: ERROR  cannot create file \"%s\"\n",
			Prog, FileName);
d429 1
a429 2
		EndGame("%s: ERROR  cannot create file \"%s\"\n",
			Prog, FileName);
d437 1
a437 2
		EndGame("%s: ERROR  cannot create file \"%s\"\n",
			Prog, FileName);
d445 1
a445 2
		EndGame("%s: ERROR  cannot create file \"%s\"\n",
			Prog, FileName);
d453 1
a453 2
		EndGame("%s: ERROR  cannot create file \"%s\"\n",
			Prog, FileName);
d459 1
a459 2
		EndGame("%s: ERROR  cannot create file \"%s\"\n",
			Prog, FileName);
d483 2
d486 1
d498 3
d505 2
a506 1
		    Bias -= 6;
d509 5
d542 1
d544 1
a544 1
			    "%s: WARNING function return type \"%s\"\n", Prog,
a545 2
		    fprintf(stderr,
			    "    could be confused with register definition\n");
d549 4
a552 2
			fprintf(CPFile, "%s", yytext);
			ProtoLen = strlen(yytext);
a557 1
		    VarArgs = 0;
d561 2
a562 1
		    EndGame("%s: ERROR in .xfd format: \"%s\"\n", Prog, yytext);
d571 2
a572 3
		    EndGame(
		    "%s: ERROR in .xfd format: NewLine expected, got \"%s\"\n",
			    Prog, yytext);
d580 2
a581 3
		    EndGame(
		    "%s: ERROR in .xfd format: got \"%s\" after ##end\n",
			    Prog, yytext);
d587 1
d589 2
a590 3
			    "%s: WARNING base name \"%s\"\n", Prog, yytext);
		    fprintf(stderr,
			    "    could be confused with register definition\n");
d598 2
a599 3
		    EndGame(
		    "%s: ERROR in .xfd format: missing name after ##base\n",
			    Prog);
d603 29
d638 1
a638 1
			EndGame("%s: ERROR bias overlap: %ld to %ld\n", Prog,
d645 2
a646 3
		    EndGame(
		    "%s: ERROR in .xfd format: missing bias after ##bias\n",
			    Prog);
d654 1
a654 1
			EndGame("%s: ERROR version %ld unheard of\n", Prog, i);
d669 2
a670 3
		    EndGame(
		    "%s: ERROR in .xfd format: no version after ##version\n",
			    Prog);
d676 1
d678 2
a679 4
			    "%s: WARNING return value/function name \"%s\"\n",
			    Prog, yytext);
		    fprintf(stderr,
			    "    could be confused with register definition\n");
d690 2
a691 2
			EndGame("%s: ERROR in .xfd format [no function name]\n",
				Prog);
d697 2
a698 1
			fprintf(FDFile, "%s(", FunctionName);
d707 2
a708 2
		    EndGame("%s: ERROR in .xfd format [before 1st (: \"%s\"]\n",
			    Prog, yytext);
d716 2
a717 2
		    fprintf(stderr, "%s: WARNING parameter name \"%s\"\n",
			    Prog, yytext);
d719 2
a720 1
			    "    could be confused with register definition\n");
d724 3
d734 6
a739 3
			fprintf(FDFile, "%s)(", PrevToken);
			if (PrevToken[0]) {
			    NumArgs++;
d742 4
a745 1
			    writeCP("VOIDP");
a747 2
			if (strcmp(PrevToken, "...") == 0)
			    VarArgs = 1;
d752 3
d756 2
a757 1
			fprintf(FDFile, "%s,", PrevToken);
d763 2
a764 2
		    EndGame("%s: ERROR in .xfd format [before 1st ): \"%s\"]\n",
			    Prog, yytext);
d775 2
a776 2
		    EndGame("%s: ERROR in .xfd format [before 2nd (: \"%s\"]\n",
			    Prog, yytext);
d793 2
a794 3
			    EndGame(
			    "%s: ERROR function %s %ld parms, %ld registers\n",
				    Prog, FunctionName, NumArgs, NumRegs);
d817 13
a829 9
			/* write pragma file */
			pragmaWord = 0;
			pragmaCount = 0;
			pragmaOK = Public;
			/*     gather pragma */
			for (i = 1; i <= NumRegs; i++) {
			    for (j = 0; ParmRegs[j] != i; j++);
			    pragmaWord |= j << (pragmaCount++ * 4);
			    if (j >= 14 /* a6 */)
d831 2
a832 5
			}
			if (pragmaCount > 6) {
			    pragmaOK = 0;
			    pragmaCount = 7;
			}
d834 21
a854 5
			pragmaWord = (pragmaWord << 8) | pragmaCount; 
			if (strcmp(BaseName, "_SysBase") == 0)
			    if (pragmaOK)
				fprintf(LPFile, "#pragma syscall %s %x %lx\n",
					FunctionName, -Bias, pragmaWord);
d857 1
a857 1
					"/*pragma syscall %s %x %lx*/\n",
d859 1
a859 16
			else if (BaseName[1])
			    if (pragmaOK)
				fprintf(LPFile,
					"#pragma libcall %s %s %x %lx\n",
					BaseName+1, FunctionName, -Bias,
					pragmaWord);
			    else
				fprintf(LPFile,
					"/*pragma libcall %s %s %x %lx*/\n",
					BaseName+1, FunctionName, -Bias,
					pragmaWord);
			else
			    fprintf(LPFile, "/*pragma libcall  %s %x %lx*/\n",
				    FunctionName, -Bias, pragmaWord);
			
			genInterface(0);
d861 1
a861 7
			if (VarArgs) {
			    s = FunctionName + strlen(FunctionName);
			    /* trim name from last capital to end */
			    while (*--s & 0x20);
			    *s = '\0';
			    genInterface(1);
			}
d865 2
d871 2
a872 2
		    EndGame("%s: ERROR in .xfd format [before 2nd ): \"%s\"]\n",
			    Prog, yytext);
d918 25
a942 19
[ \t]			{ ; }
\n			{ return(TOKEN_NEWLINE); }
^##base			{ return(TOKEN_BASE); }
^##bias			{ return(TOKEN_BIAS); }
^##alias		{ return(TOKEN_ALIAS); }
^##private		{ return(TOKEN_PRIVATE); }
^##public		{ return(TOKEN_PUBLIC); }
^##version		{ return(TOKEN_VERSION); }
^##end			{ return(TOKEN_END); }
^[*;].*$		{ return(TOKEN_COMMENT); }
[0-9]+			{ return(TOKEN_NUMBER); }
[adAD][0-7]		{ return(TOKEN_REGISTER); }
[_a-zA-Z][_a-zA-Z0-9]+	{ return(TOKEN_NAME); }
"*"+			{ return(TOKEN_STARS); }
"..."			{ return(TOKEN_ELLIPSIS); }
"("			{ return(TOKEN_OPENPARAN); }
")"			{ return(TOKEN_CLOSEPARAN); }
","			{ return(TOKEN_COMMA); }
"/"			{ return(TOKEN_SLASH); }
@
