
/* Code generated by Toolmaker V1.19 */

/* Includes */
 
#include <stdlib.h>
#include <exec/types.h>
#include <intuition/intuition.h>
#include <intuition/gadgetclass.h>
#include <libraries/gadtools.h>
#include <exec/memory.h>
#include <graphics/view.h>
#include <graphics/displayinfo.h>

#include "db.h"

#include <clib/exec_protos.h>
#include <clib/intuition_protos.h>
#include <clib/gadtools_protos.h>

/* static function prototypes */
 
static BOOL TM_WindowSignal(struct TMData *);
static VOID TM_RemoveWindow(struct TMWindowInfo *);
static BOOL WindowIDCMP_GFXDATAB(struct TMData *, struct IntuiMessage *);

/* Mouse pointer data for disabled window */
 
#ifdef _DCC    /* For DICE compatibiliity */
__chip UWORD WaitPointer[36] =
#else
UWORD __chip WaitPointer[36] =
#endif
  {
  0x0000, 0x0000,
  0x0400, 0x07C0,
  0x0000, 0x07C0,
  0x0100, 0x0380,
  0x0000, 0x07E0,
  0x07C0, 0x1FF8,
  0x1FF0, 0x3FEC,
  0x3FF8, 0x7FDE,
  0x3FF8, 0x7FBE,
  0x7FFC, 0xFF7F,
  0x7EFC, 0xFFFF,
  0x7FFC, 0xFFFF,
  0x3FF8, 0x7FFE,
  0x3FF8, 0x7FFE,
  0x1FF0, 0x3FFC,
  0x07C0, 0x1FF8,
  0x0000, 0x07E0,
  0x0000, 0x0000,
  };

/* Screen data */
 
/* Window data */
 
struct List *ModeIDList = NULL;
struct List *BuildModeIDList(struct TMData *TMData, ULONG *ordinal);
void FreeModeIDList(struct List *list);

/* Font data */
 
struct TextAttr topaz8 =
  {
  (STRPTR)"topaz.font",	/* ta_Name */
  8,	/* ta_YSize */
  FS_NORMAL,	/* ta_Style */
  0x0	/* ta_Flags */
  };

/****** db_tm.c/TM_Request *****************************
*
*   NAME
*	TM_Request -- display a message in a system requester.
*
*   SYNOPSIS
*	num = TM_Request(Window, Title, TextFormat, GadgetFormat,
*	                 IDCMP_ptr, Arg1, Arg2, ...)
*
*	LONG TM_Request(struct Window *, UBYTE *, UBYTE *, UBYTE *,
*	                ULONG *, APTR, ...);
*
*   FUNCTION
*	Calls EasyRequestArgs to display a message in a system
*	requester without having to fill in an EasyStruct structure.
*	This function uses a varargs calling convention.
*
*	EasyRequestArgs has the capability to display more than one
*	gadget by separating the GadgetText with the '|' character.
*	Also printf style formatting may be used in the TextFormat
*	and GadgetFormat strings.  The formatting arguments should
*	be added first for the TextFormat, then for the GadgetFormat.
*
*   INPUTS
*	Window = pointer to window (passed to EasyRequestArgs()).
*	Title = title bar string (passed to EasyRequestArgs()).
*	TextFormat = body text (passed to EasyRequestArgs()).
*	GadgetFormat = gadget text (passed to EasyRequestArgs()).
*	IDCMP_ptr = IDCMP value (passed to EasyRequestArgs()).
*	Args = arguments (passed to EasyRequestArgs()).
*
*   RESULT
*	num = gadget number returned by EasyRequestArgs().
*
*   EXAMPLE
*	To display a requester with two choices:
*
*	result = TM_Request(NULL, "Question", "Are you sure?",
*	                    "OK|Cancel", NULL, NULL);
*
*   NOTES
*	The intuition library must be open before calling this
*	function.
*
*   BUGS
*
*   SEE ALSO
*	intuition.library/EasyRequestArgs()
*
**************************************************************
*
*/
LONG TM_Request(struct Window *Window, UBYTE *Title, UBYTE *TextFormat, UBYTE *GadgetFormat, ULONG *IDCMP_ptr, APTR Arg1, ...)
  {
  struct EasyStruct es;

  es.es_StructSize = sizeof(struct EasyStruct);
  es.es_Flags = 0;
  es.es_Title = Title;
  es.es_TextFormat = TextFormat;
  es.es_GadgetFormat = GadgetFormat;

  return(EasyRequestArgs(Window, &es, IDCMP_ptr, &Arg1));
  }

/****** db_tm.c/TM_Open *****************************
*
*   NAME
*	TM_Open -- initialize user-interface data.
*
*   SYNOPSIS
*	TMData = TM_Open(ErrorCode)
*
*	struct TMData *TM_Open(ULONG *error);
*
*   FUNCTION
*	Creates an initializes a TMData structure.  This
*	includes allocating memory for a TMData structure,
*	creating a message port for window IDCMP messages,
*	and opening any fonts on disk.
*
*   INPUTS
*	error = pointer to ULONG to store an error number.
*	        Error numbers are defined in the _tm.h file.
*
*   RESULT
*	TMData = pointer to an initialized TMData structure
*	         or NULL if an error occurred.
*
*   EXAMPLE
*	if(!(TMData = TM_Open(&error)))
*	  {
*	  switch(error)
*	    {
*	    case TMERR_MEMORY:
*	      TM_Request(NULL, "Error", "Out of memory", "Abort", NULL, NULL);
*	      break;
*	    case TMERR_MSGPORT:
*	      TM_Request(NULL, "Error", "Error creating\nmessage port", "Abort", NULL, NULL);
*	      break;
*	    }
*	  CleanExit(NULL, RETURN_FAIL);
*	  }
*
*   NOTES
*	The intuition and gadtools libraries must be open before
*	calling this function.  If any fonts other than topaz 8
*	and topaz 9 are used, the diskfont and graphics libraries
*	must also be open.
*
*   BUGS
*
*   SEE ALSO
*	TM_Close()
*
**************************************************************
*
*/
struct TMData *TM_Open(ULONG *error)
  {
  struct TMData *tmdata;

  if(tmdata = AllocMem(sizeof(struct TMData), MEMF_CLEAR))
    {
    tmdata->Size = sizeof(struct TMData);

    if(tmdata->WindowMsgPort = CreateMsgPort())
      {
      *error = TMERR_OK;
      return(tmdata);
      }
    else
      {
      *error = TMERR_MSGPORT;
      }
    FreeMem(tmdata, sizeof(struct TMData));
    }
  else
    {
    *error = TMERR_MEMORY;
    }

  return(NULL);
  }

/****** db_tm.c/TM_Close *****************************
*
*   NAME
*	TM_Close -- frees user-interface data.
*
*   SYNOPSIS
*	TM_Close(TMData)
*
*	VOID TM_Close(struct TMData *TMData);
*
*   FUNCTION
*	Frees resources allocated by TM_Open().
*
*   INPUTS
*	TMData = pointer to TMData structure returned by TM_Open.
*
*   RESULT
*
*   EXAMPLE
*	if(TMData) TM_Close(TMData);
*
*   NOTES
*
*   BUGS
*
*   SEE ALSO
*	TM_Open()
*
**************************************************************
*
*/
VOID TM_Close(struct TMData *TMData)
  {
  if(TMData)
    {
    if(TMData->WindowMsgPort) DeleteMsgPort(TMData->WindowMsgPort);
    FreeMem(TMData, TMData->Size);
    }
  }

/****** db_tm.c/TM_EventLoop *****************************
*
*   NAME
*	TM_EventLoop -- waits for all events.
*
*   SYNOPSIS
*	TM_EventLoop(TMData)
*
*	VOID TM_EventLoop(struct TMData *);
*
*   FUNCTION
*	Waits for any events to signal program.  All IDCMP, ARexx,
*	and a user signal messages received are sent to the
*	appropriate signal function.  A return value of TRUE from
*	any of the signal functions will terminate the loop.
*
*   INPUTS
*	TMData = pointer to TMData structure returned by TM_Open.
*
*   RESULT
*
*   EXAMPLE
*	TM_EventLoop(TMData);
*
*   NOTES
*	An event signal must be set up before calling TM_EventLoop.
*	Either a window must be open, the SimpleRexx option selected,
*	or a user signal set up.
*
*   BUGS
*
*   SEE ALSO
*	TM_WindowSignal(), TM_ARexxSignal(), exec.library/Wait()
*
**************************************************************
*
*/
VOID TM_EventLoop(struct TMData *TMData)
  {
  BOOL done=FALSE, result;
  ULONG windowsignal, signals;

  windowsignal = 1L << TMData->WindowMsgPort->mp_SigBit;

  while(!done)
    {
    signals = Wait(windowsignal);

    if(signals & windowsignal)
      {
      if(result = TM_WindowSignal(TMData)) done = result;
      }
    }
  }

/****** db_tm.c/OpenScreen_Workbench *****************************
*
*   NAME
*	OpenScreen_Workbench -- Use the default public screen.
*
*   SYNOPSIS
*	success = OpenScreen_Workbench(TMData)
*
*	BOOL OpenScreen_Workbench(struct TMData *);
*
*   FUNCTION
*	Locks the default public screen and gets its visual info.  If the
*	screen was already locked, it will be brought to front.
*
*   INPUTS
*	TMData = pointer to the TMData structure returned by TM_Open.
*
*   RESULT
*	success = TRUE if command was successfully completed.
*	          FALSE if not.
*
*   EXAMPLE
*	if(!(OpenScreen_Workbench(TMData)))
*	  {
*	  TM_Request(NULL, "Error", "Error opening screen", "Abort", NULL, NULL);
*	  CleanExit(TMData, RETURN_FAIL);
*	  }
*
*   NOTES
*
*   BUGS
*
*   SEE ALSO
*	CloseScreen_Workbench()
*
**************************************************************
*
*/
BOOL OpenScreen_Workbench(struct TMData *TMData)
  {
  if(ScreenInfo_Workbench.Screen)
    {
    ScreenToFront(ScreenInfo_Workbench.Screen);
    return(TRUE);
    }
  else
    {
    if(ScreenInfo_Workbench.Screen = LockPubScreen(NULL))
      {
      if(ScreenInfo_Workbench.VisualInfo = GetVisualInfo(ScreenInfo_Workbench.Screen, TAG_DONE))
        {
        return(TRUE);
        }
      UnlockPubScreen(NULL, ScreenInfo_Workbench.Screen);
      }
    }

  return(FALSE);
  }

/****** db_tm.c/CloseScreen_Workbench *****************************
*
*   NAME
*	CloseScreen_Workbench -- Free the default public screen.
*
*   SYNOPSIS
*	CloseScreen_Workbench(TMData)
*
*	VOID CloseScreen_Workbench(struct TMData *);
*
*   FUNCTION
*	Unlocks the default public screen and frees the visual info.
*	It's ok to re-close a screen that is already closed.
*
*   INPUTS
*	TMData = pointer to the TMData structure returned by TM_Open.
*
*   RESULT
*
*   EXAMPLE
*	CloseScreen_Workbench(TMData);
*
*   NOTES
*
*   BUGS
*
*   SEE ALSO
*	OpenScreen_Workbench()
*
**************************************************************
*
*/
VOID CloseScreen_Workbench(struct TMData *TMData)
  {
  if(ScreenInfo_Workbench.VisualInfo)
    {
    FreeVisualInfo(ScreenInfo_Workbench.VisualInfo);
    ScreenInfo_Workbench.VisualInfo = NULL;
    }
  if(ScreenInfo_Workbench.Screen)
    {
    UnlockPubScreen(NULL, ScreenInfo_Workbench.Screen);
    ScreenInfo_Workbench.Screen = NULL;
    }
  }

/****** db_tm.c/OpenWindow_GFXDATAB *****************************
*
*   NAME
*	OpenWindow_GFXDATAB -- Open window "GFXDATAB".
*
*   SYNOPSIS
*	success = OpenWindow_GFXDATAB(TMData)
*
*	BOOL OpenWindow_GFXDATAB(struct TMData *);
*
*   FUNCTION
*	Opens the window with label "GFXDATAB"
*	along with any gadgets it contains.  If the window was already
*	open, it will be brought to front.
*
*   INPUTS
*	TMData = pointer to the TMData structure returned by TM_Open.
*
*   RESULT
*	success = TRUE if command was successfully completed.
*	          FALSE if not.
*
*   EXAMPLE
*	if(!OpenWindow_GFXDATAB(TMData))
*	  {
*	  TMRequest(NULL, "Error", "Error opening window", "Abort", NULL, NULL);
*	  CleanExit(TMData, RETURN_FAIL);
*	  }
*   NOTES
*
*   BUGS
*
*   SEE ALSO
*	CloseWindow_GFXDATAB()
*
**************************************************************
*
*/
BOOL OpenWindow_GFXDATAB(struct TMData *TMData)
  {
  ULONG lasttag;
  ULONG ordinal;
  struct NewGadget ng;

  if(WindowInfo_GFXDATAB.Window)
    {
    WindowToFront(WindowInfo_GFXDATAB.Window);
    ActivateWindow(WindowInfo_GFXDATAB.Window);
    return(TRUE);
    }
  else
    {
    ModeIDList = BuildModeIDList(TMData, &ordinal);
    WindowInfo_GFXDATAB.FirstGadget = NULL;
    WindowInfo_GFXDATAB.ContextGadget = CreateContext(&WindowInfo_GFXDATAB.FirstGadget);

    ng.ng_VisualInfo = ScreenInfo_Workbench.VisualInfo;

    ng.ng_LeftEdge = 12;
    ng.ng_Width = 204;
    ng.ng_Flags = PLACETEXT_BELOW;
    ng.ng_TextAttr = &topaz8;
    ng.ng_TopEdge = 280+ScreenInfo_Workbench.Screen->BarHeight;
    ng.ng_Height = 20;
    ng.ng_GadgetText = (UBYTE *)GADGETTEXT_MODEID,
    ng.ng_GadgetID = ID_MODEID;
    lasttag = GadgetInfo_MODEID.MoreTags ? TAG_MORE : TAG_DONE;
    GadgetInfo_MODEID.Gadget = CreateGadget(STRING_KIND, WindowInfo_GFXDATAB.ContextGadget, &ng,
		lasttag, GadgetInfo_MODEID.MoreTags);

    ng.ng_Flags = PLACETEXT_ABOVE;
    ng.ng_TopEdge = 21+ScreenInfo_Workbench.Screen->BarHeight;
    ng.ng_Height = 244;
    ng.ng_GadgetText = (UBYTE *)GADGETTEXT_MODEIDS;	/* ModeIDs */
    ng.ng_GadgetID = ID_MODEIDS;
    lasttag = GadgetInfo_MODEIDS.MoreTags ? TAG_MORE : TAG_DONE;
    GadgetInfo_MODEIDS.Gadget = CreateGadget(LISTVIEW_KIND, GadgetInfo_MODEID.Gadget, &ng,
		GTLV_Labels, ModeIDList,
		GTLV_Selected, ordinal,
		GTLV_Top, ordinal,
		GTLV_ShowSelected, GadgetInfo_MODEID.Gadget,
		lasttag, GadgetInfo_MODEIDS.MoreTags);


    ng.ng_LeftEdge = 252;
    ng.ng_TopEdge = 31+ScreenInfo_Workbench.Screen->BarHeight;
    ng.ng_Width = 26;
    ng.ng_Height = 11;
    ng.ng_Flags = PLACETEXT_RIGHT;
    ng.ng_GadgetText = (UBYTE *)GADGETTEXT_NAME;	/* _Name */
    ng.ng_GadgetID = ID_NAME;
    lasttag = GadgetInfo_NAME.MoreTags ? TAG_MORE : TAG_DONE;
    GadgetInfo_NAME.Gadget = CreateGadget(CHECKBOX_KIND, GadgetInfo_MODEIDS.Gadget, &ng,
		GT_Underscore, '_',
		GTCB_Checked, TRUE,
		lasttag, GadgetInfo_NAME.MoreTags);

    ng.ng_TopEdge = 79+ScreenInfo_Workbench.Screen->BarHeight;
    ng.ng_GadgetText = (UBYTE *)GADGETTEXT_MONITOR;	/* M_onitor */
    ng.ng_GadgetID = ID_MONITOR;
    lasttag = GadgetInfo_MONITOR.MoreTags ? TAG_MORE : TAG_DONE;
    GadgetInfo_MONITOR.Gadget = CreateGadget(CHECKBOX_KIND, GadgetInfo_NAME.Gadget, &ng,
		GT_Underscore, '_',
		GTCB_Checked, TRUE,
		lasttag, GadgetInfo_MONITOR.MoreTags);

    ng.ng_TopEdge = 131+ScreenInfo_Workbench.Screen->BarHeight;
    ng.ng_GadgetText = (UBYTE *)GADGETTEXT_DIMENSIO;	/* _Dimension */
    ng.ng_GadgetID = ID_DIMENSIO;
    lasttag = GadgetInfo_DIMENSIO.MoreTags ? TAG_MORE : TAG_DONE;
    GadgetInfo_DIMENSIO.Gadget = CreateGadget(CHECKBOX_KIND, GadgetInfo_MONITOR.Gadget, &ng,
		GT_Underscore, '_',
		GTCB_Checked, TRUE,
		lasttag, GadgetInfo_DIMENSIO.MoreTags);

    ng.ng_TopEdge = 179+ScreenInfo_Workbench.Screen->BarHeight;
    ng.ng_GadgetText = (UBYTE *)GADGETTEXT_DISPLAY;	/* D_isplay */
    ng.ng_GadgetID = ID_DISPLAY;
    lasttag = GadgetInfo_DISPLAY.MoreTags ? TAG_MORE : TAG_DONE;
    GadgetInfo_DISPLAY.Gadget = CreateGadget(CHECKBOX_KIND, GadgetInfo_DIMENSIO.Gadget, &ng,
		GT_Underscore, '_',
		GTCB_Checked, TRUE,
		lasttag, GadgetInfo_DISPLAY.MoreTags);

    ng.ng_TopEdge = 231+ScreenInfo_Workbench.Screen->BarHeight;
    ng.ng_GadgetText = (UBYTE *)GADGETTEXT_VECTOR;	/* _Vector */
    ng.ng_GadgetID = ID_VECTOR;
    lasttag = GadgetInfo_VECTOR.MoreTags ? TAG_MORE : TAG_DONE;
    GadgetInfo_VECTOR.Gadget = CreateGadget(CHECKBOX_KIND, GadgetInfo_DISPLAY.Gadget, &ng,
		GT_Underscore, '_',
		GTCB_Checked, TRUE,
		lasttag, GadgetInfo_VECTOR.MoreTags);

    ng.ng_LeftEdge = 244;
    ng.ng_TopEdge = 261+ScreenInfo_Workbench.Screen->BarHeight;
    ng.ng_Width = 114;
    ng.ng_Height = 28;
    ng.ng_Flags = PLACETEXT_IN;
    ng.ng_TextAttr = &topaz8;
    ng.ng_GadgetText = (UBYTE *)GADGETTEXT_PRINT;	/* _Print */
    ng.ng_GadgetID = ID_PRINT;
    lasttag = GadgetInfo_PRINT.MoreTags ? TAG_MORE : TAG_DONE;
    GadgetInfo_PRINT.Gadget = CreateGadget(BUTTON_KIND, GadgetInfo_VECTOR.Gadget, &ng,
		GT_Underscore, '_',
		lasttag, GadgetInfo_PRINT.MoreTags);

    ng.ng_LeftEdge = 252;
    ng.ng_TopEdge = 313+ScreenInfo_Workbench.Screen->BarHeight;
    ng.ng_Width = 26;
    ng.ng_Height = 11;
    ng.ng_Flags = PLACETEXT_RIGHT;
    ng.ng_TextAttr = &topaz8;
    ng.ng_GadgetText = (UBYTE *)GADGETTEXT_DATA;	/* D_ata */
    ng.ng_GadgetID = ID_DATA;
    lasttag = GadgetInfo_DATA.MoreTags ? TAG_MORE : TAG_DONE;
    GadgetInfo_DATA.Gadget = CreateGadget(CHECKBOX_KIND, GadgetInfo_PRINT.Gadget, &ng,
		GT_Underscore, '_',
		lasttag, GadgetInfo_DATA.MoreTags);

    ng.ng_LeftEdge = 24;
    ng.ng_TopEdge = 356+ScreenInfo_Workbench.Screen->BarHeight;
    ng.ng_Width = 355;
    ng.ng_Height = 20;
    ng.ng_Flags = PLACETEXT_ABOVE;
    ng.ng_GadgetText = (UBYTE *)GADGETTEXT_BESTMODE;	/* _BestModeIDAttrs */
    ng.ng_GadgetID = ID_BESTMODE;
    lasttag = GadgetInfo_BESTMODE.MoreTags ? TAG_MORE : TAG_DONE;
    GadgetInfo_BESTMODE.Gadget = CreateGadget(STRING_KIND, GadgetInfo_DATA.Gadget, &ng,
		GT_Underscore, '_',
		GTST_String, GTST_String_BESTMODE,
		lasttag, GadgetInfo_BESTMODE.MoreTags);


    if(GadgetInfo_VECTOR.Gadget)
      {
      lasttag = WindowInfo_GFXDATAB.MoreTags ? TAG_MORE : TAG_DONE;

      if((WindowInfo_GFXDATAB.Window = OpenWindowTags(NULL,
		WA_PubScreen, ScreenInfo_Workbench.Screen,
		WA_Title, WINDOWTEXT_GFXDATAB,	/* Gfx DataBase Browser */
		WA_IDCMP, NULL,
		WA_Gadgets, WindowInfo_GFXDATAB.FirstGadget,
		WA_Left, 169,
		WA_Top, 14,
		WA_Width, 401,
		WA_Height, 431,
		WA_InnerWidth, 379,
		WA_InnerHeight, 418,
		WA_MinWidth, 70,
		WA_MinHeight, 30,
		WA_MaxWidth, -1,
		WA_MaxHeight, -1,
		WA_DragBar, TRUE,
		WA_CloseGadget, TRUE,
		WA_DepthGadget, TRUE,
		WA_Activate, TRUE,
		WA_SimpleRefresh, TRUE,
		lasttag, WindowInfo_GFXDATAB.MoreTags)))
        {
        WindowInfo_GFXDATAB.Window->UserPort = TMData->WindowMsgPort;
        ModifyIDCMP(WindowInfo_GFXDATAB.Window,
			IDCMP_REFRESHWINDOW |
			LISTVIEWIDCMP |
			STRINGIDCMP |
			CHECKBOXIDCMP |
			IDCMP_GADGETUP |
			IDCMP_CLOSEWINDOW |
			IDCMP_VANILLAKEY);
        GT_RefreshWindow(WindowInfo_GFXDATAB.Window, NULL);
        WindowInfo_GFXDATAB.Flags |= TMWF_OPENED;
        return(TRUE);
        }
      FreeGadgets(WindowInfo_GFXDATAB.FirstGadget);
      }
    }
  return(FALSE);
  }

/****** db_tm.c/CloseWindow_GFXDATAB *****************************
*
*   NAME
*	CloseWindow_GFXDATAB -- Close window "GFXDATAB".
*
*   SYNOPSIS
*	CloseWindow_GFXDATAB(TMData)
*
*	VOID CloseWindow_GFXDATAB(struct TMData *);
*
*   FUNCTION
*	Closes the window with label "GFXDATAB"
*	and frees its resources.  It's ok to re-close a window
*	that is already closed.
*
*   INPUTS
*	TMData = pointer to the TMData structure returned by TM_Open.
*
*   RESULT
*
*   EXAMPLE
*
*   NOTES
*
*   BUGS
*
*   SEE ALSO
*	OpenWindow_GFXDATAB()
*
**************************************************************
*
*/
VOID CloseWindow_GFXDATAB(struct TMData *TMData)
  {
  FreeModeIDList(ModeIDList);
  TM_RemoveWindow(&WindowInfo_GFXDATAB);
  }

/****** db_tm.c/DisableWindow_GFXDATAB *****************************
*
*   NAME
*	DisableWindow_GFXDATAB -- disable input to window "GFXDATAB".
*
*   SYNOPSIS
*	DisableWindow_GFXDATAB(TMData)
*
*	VOID DisableWindow_GFXDATAB(struct TMData *);
*
*   FUNCTION
*	Disables all input to window with label "GFXDATAB"
*	and changes its mouse pointer.
*
*   INPUTS
*	TMData = pointer to the TMData structure returned by TM_Open.
*
*   RESULT
*
*   EXAMPLE
*
*   NOTES
*
*   BUGS
*
*   SEE ALSO
*	EnableWindow_GFXDATAB()
*
**************************************************************
*
*/
VOID DisableWindow_GFXDATAB(struct TMData *TMData)
  {
  if((WindowInfo_GFXDATAB.DisableCount == 0) && (WindowInfo_GFXDATAB.Flags & TMWF_OPENED))
    {
    InitRequester(&WindowInfo_GFXDATAB.Requester);
    if(Request(&WindowInfo_GFXDATAB.Requester, WindowInfo_GFXDATAB.Window))
      {
      WindowInfo_GFXDATAB.Flags |= TMWF_DISABLED;
      SetPointer(WindowInfo_GFXDATAB.Window, WaitPointer, 16, 16, -6, 0);
      }
    }
  WindowInfo_GFXDATAB.DisableCount++;
  }

/****** db_tm.c/EnableWindow_GFXDATAB *****************************
*
*   NAME
*	EnableWindow_GFXDATAB -- enable input to window "GFXDATAB".
*
*   SYNOPSIS
*	EnableWindow_GFXDATAB(TMData)
*
*	VOID EnableWindow_GFXDATAB(struct TMData *);
*
*   FUNCTION
*	Enables input to window with label "GFXDATAB"
*	and clears its mouse pointer.
*
*   INPUTS
*	TMData = pointer to the TMData structure returned by TM_Open.
*
*   RESULT
*
*   EXAMPLE
*
*   NOTES
*
*   BUGS
*
*   SEE ALSO
*	DisableWindow_GFXDATAB()
*
**************************************************************
*
*/
VOID EnableWindow_GFXDATAB(struct TMData *TMData)
  {
  WindowInfo_GFXDATAB.DisableCount--;
  if((WindowInfo_GFXDATAB.DisableCount == 0) && (WindowInfo_GFXDATAB.Flags & (TMWF_DISABLED | TMWF_OPENED)))
    {
    EndRequest(&WindowInfo_GFXDATAB.Requester, WindowInfo_GFXDATAB.Window);
    WindowInfo_GFXDATAB.Flags &= ~TMWF_DISABLED;
    ClearPointer(WindowInfo_GFXDATAB.Window);
    }
  }

/* *********************************************************** */
/* Static functions (available only to functions in this file) */
/* *********************************************************** */
 
static BOOL TM_WindowSignal(struct TMData *TMData)
  {
  BOOL done=FALSE;
  BOOL result;
  struct IntuiMessage *imessage;

  while(imessage = GT_GetIMsg(TMData->WindowMsgPort))
    {
    if(imessage->IDCMPWindow == WindowInfo_GFXDATAB.Window)
      {
      WindowInfo_GFXDATAB.GT_IMsg = imessage;
      if(result = WindowIDCMP_GFXDATAB(TMData, imessage)) done = result;
      if(WindowInfo_GFXDATAB.GT_IMsg)
        {
        GT_ReplyIMsg(WindowInfo_GFXDATAB.GT_IMsg);
        WindowInfo_GFXDATAB.GT_IMsg = NULL;
        }
      }
    }

  return(done);
  }

static BOOL WindowIDCMP_GFXDATAB(struct TMData *TMData, struct IntuiMessage *imessage)
  {
  BOOL done=FALSE;
  BOOL result;

  switch(imessage->Class)
    {
    case IDCMP_REFRESHWINDOW:	/* Always refresh */
      GT_BeginRefresh(WindowInfo_GFXDATAB.Window);
      GT_EndRefresh(WindowInfo_GFXDATAB.Window, TRUE);
      break;

    case IDCMP_GADGETUP:
      if(result = Window_GFXDATAB_GADGETUP(TMData, imessage)) done = result;
      break;

    case IDCMP_CLOSEWINDOW:
      if(result = Window_GFXDATAB_CLOSEWINDOW(TMData, imessage)) done = result;
      break;

    case IDCMP_VANILLAKEY:
      if(result = Window_GFXDATAB_VANILLAKEY(TMData, imessage)) done = result;
      break;

    }

  return(done);
  }

static VOID TM_RemoveWindow(struct TMWindowInfo *TMWindowInfo)
  {
  struct IntuiMessage *imessage;
  struct Node *succ;

  if(TMWindowInfo->Window)
    {
    if(TMWindowInfo->Menu)
      {
      ClearMenuStrip(TMWindowInfo->Window);
      FreeMenus(TMWindowInfo->Menu);
      TMWindowInfo->Menu = NULL;
      }

    if(TMWindowInfo->GT_IMsg)
      {
      GT_ReplyIMsg(TMWindowInfo->GT_IMsg);
      TMWindowInfo->GT_IMsg = NULL;
      }

    if(TMWindowInfo->Window->UserPort)
      {
      Forbid();
      imessage = (struct IntuiMessage *) TMWindowInfo->Window->UserPort->mp_MsgList.lh_Head;
      while(succ = imessage->ExecMessage.mn_Node.ln_Succ)
        {
        if(imessage->IDCMPWindow == TMWindowInfo->Window)
          {
          Remove((struct Node *) imessage);
          ReplyMsg((struct Message *) imessage);
          }
        imessage = (struct IntuiMessage *) succ;
        }
      TMWindowInfo->Window->UserPort = NULL;
      ModifyIDCMP(TMWindowInfo->Window, 0L);
      Permit();
      }

    CloseWindow(TMWindowInfo->Window);
    TMWindowInfo->Window = NULL;
    TMWindowInfo->Flags = 0;
    }

  if(TMWindowInfo->FirstGadget)
    {
    FreeGadgets(TMWindowInfo->FirstGadget);
    TMWindowInfo->FirstGadget = NULL;
    }
  }

