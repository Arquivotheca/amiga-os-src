head     36.68;
access   ;
symbols  ;
locks    bart:36.68; strict;
comment  @*   @;


36.68
date     89.03.17.18.43.58;  author bart;  state Exp;
branches ;
next     36.67;

36.67
date     89.03.16.13.26.29;  author bart;  state Exp;
branches ;
next     36.66;

36.66
date     89.03.14.18.11.12;  author bart;  state Exp;
branches ;
next     36.65;

36.65
date     89.03.14.18.05.39;  author bart;  state Exp;
branches ;
next     36.64;

36.64
date     89.03.13.19.58.37;  author bart;  state Exp;
branches ;
next     36.63;

36.63
date     89.03.13.14.11.14;  author bart;  state Exp;
branches ;
next     36.62;

36.62
date     89.03.07.16.58.35;  author bart;  state Exp;
branches ;
next     36.61;

36.61
date     89.03.01.13.51.38;  author bart;  state Exp;
branches ;
next     36.60;

36.60
date     89.02.24.13.22.03;  author bart;  state Exp;
branches ;
next     36.59;

36.59
date     89.02.23.18.32.26;  author bart;  state Exp;
branches ;
next     36.58;

36.58
date     89.02.23.14.22.25;  author bart;  state Exp;
branches ;
next     36.57;

36.57
date     89.02.22.11.27.58;  author bart;  state Exp;
branches ;
next     36.56;

36.56
date     89.02.22.11.08.57;  author bart;  state Exp;
branches ;
next     36.55;

36.55
date     89.02.22.10.36.53;  author bart;  state Exp;
branches ;
next     36.54;

36.54
date     89.02.21.16.53.18;  author bart;  state Exp;
branches ;
next     36.53;

36.53
date     89.02.21.11.34.23;  author bart;  state Exp;
branches ;
next     36.52;

36.52
date     89.02.21.11.28.41;  author bart;  state Exp;
branches ;
next     36.51;

36.51
date     89.02.21.11.27.07;  author bart;  state Exp;
branches ;
next     36.50;

36.50
date     89.02.17.21.57.20;  author bart;  state Exp;
branches ;
next     36.49;

36.49
date     89.02.17.21.54.16;  author bart;  state Exp;
branches ;
next     36.48;

36.48
date     89.02.17.21.52.02;  author bart;  state Exp;
branches ;
next     36.47;

36.47
date     89.02.17.21.41.03;  author bart;  state Exp;
branches ;
next     36.46;

36.46
date     89.02.17.21.20.42;  author bart;  state Exp;
branches ;
next     36.45;

36.45
date     89.02.17.21.18.36;  author bart;  state Exp;
branches ;
next     36.44;

36.44
date     89.02.17.17.15.10;  author bart;  state Exp;
branches ;
next     36.43;

36.43
date     89.02.17.17.02.44;  author bart;  state Exp;
branches ;
next     36.42;

36.42
date     89.02.17.16.53.41;  author bart;  state Exp;
branches ;
next     36.41;

36.41
date     89.02.17.13.15.08;  author bart;  state Exp;
branches ;
next     36.40;

36.40
date     89.02.17.13.14.28;  author bart;  state Exp;
branches ;
next     36.39;

36.39
date     89.02.17.13.13.32;  author bart;  state Exp;
branches ;
next     36.38;

36.38
date     89.02.17.13.12.31;  author bart;  state Exp;
branches ;
next     36.37;

36.37
date     89.02.17.12.49.18;  author bart;  state Exp;
branches ;
next     36.36;

36.36
date     89.02.16.16.43.37;  author bart;  state Exp;
branches ;
next     36.35;

36.35
date     89.02.16.16.35.00;  author bart;  state Exp;
branches ;
next     36.34;

36.34
date     89.02.16.11.48.57;  author bart;  state Exp;
branches ;
next     36.33;

36.33
date     89.02.16.11.04.53;  author bart;  state Exp;
branches ;
next     36.32;

36.32
date     89.02.16.11.03.55;  author bart;  state Exp;
branches ;
next     36.31;

36.31
date     89.02.16.11.02.46;  author bart;  state Exp;
branches ;
next     36.30;

36.30
date     89.02.16.11.00.10;  author bart;  state Exp;
branches ;
next     36.29;

36.29
date     89.02.16.10.54.47;  author bart;  state Exp;
branches ;
next     36.28;

36.28
date     89.02.15.16.55.15;  author bart;  state Exp;
branches ;
next     36.27;

36.27
date     89.02.15.15.25.20;  author bart;  state Exp;
branches ;
next     36.26;

36.26
date     89.02.15.14.11.29;  author bart;  state Exp;
branches ;
next     36.25;

36.25
date     89.02.15.14.04.03;  author bart;  state Exp;
branches ;
next     36.24;

36.24
date     89.02.14.18.19.54;  author bart;  state Exp;
branches ;
next     36.23;

36.23
date     89.02.13.11.50.31;  author bart;  state Exp;
branches ;
next     36.22;

36.22
date     89.02.11.12.15.57;  author bart;  state Exp;
branches ;
next     36.21;

36.21
date     89.02.11.11.06.06;  author bart;  state Exp;
branches ;
next     36.20;

36.20
date     89.02.06.13.24.30;  author bart;  state Exp;
branches ;
next     36.19;

36.19
date     89.02.02.16.15.31;  author bart;  state Exp;
branches ;
next     36.18;

36.18
date     89.02.02.16.07.45;  author bart;  state Exp;
branches ;
next     36.17;

36.17
date     89.02.02.15.03.55;  author bart;  state Exp;
branches ;
next     36.16;

36.16
date     89.02.02.13.54.05;  author bart;  state Exp;
branches ;
next     36.15;

36.15
date     89.01.31.17.16.14;  author bart;  state Exp;
branches ;
next     36.14;

36.14
date     89.01.27.14.29.12;  author bart;  state Exp;
branches ;
next     36.13;

36.13
date     89.01.26.17.41.43;  author bart;  state Exp;
branches ;
next     36.12;

36.12
date     89.01.26.16.37.28;  author bart;  state Exp;
branches ;
next     36.11;

36.11
date     89.01.26.16.30.57;  author bart;  state Exp;
branches ;
next     36.10;

36.10
date     89.01.26.14.59.39;  author bart;  state Exp;
branches ;
next     36.9;

36.9
date     89.01.26.14.47.30;  author bart;  state Exp;
branches ;
next     36.8;

36.8
date     89.01.26.14.30.42;  author bart;  state Exp;
branches ;
next     36.7;

36.7
date     89.01.26.13.55.15;  author bart;  state Exp;
branches ;
next     36.6;

36.6
date     89.01.26.11.43.39;  author bart;  state Exp;
branches ;
next     36.5;

36.5
date     89.01.26.11.35.45;  author bart;  state Exp;
branches ;
next     36.4;

36.4
date     89.01.25.14.57.01;  author bart;  state Exp;
branches ;
next     36.3;

36.3
date     89.01.25.14.52.49;  author bart;  state Exp;
branches ;
next     36.2;

36.2
date     89.01.25.14.12.57;  author bart;  state Exp;
branches ;
next     36.1;

36.1
date     89.01.25.14.10.01;  author bart;  state Exp;
branches ;
next     36.0;

36.0
date     89.01.25.13.20.01;  author bart;  state Exp;
branches ;
next     ;


desc
@@


36.68
log
@check for avail when matching to open
@
text
@/******************************************************************************
*
*	Source Control
*	--------------
*	$Header: db.c,v 36.67 89/03/16 13:26:29 bart Exp $
*
*	$Locker: bart $
*
******************************************************************************/

#include <exec/types.h>
#include <exec/memory.h>
#include <graphics/gfxbase.h>
#include <graphics/gfx.h>
#include <graphics/rastport.h>
#include <graphics/view.h>
#include <graphics/display.h>
#include <graphics/monitor.h>
#include <graphics/displayinfo.h>
#include <graphics/videocontrol.h>
#include <libraries/dos.h>

#ifndef KPRINTF
#define kprintf printf
#endif

#ifdef DEBUG
#define X(x) 	x
#define D(x) 	x
#else
#define X(x) 	;
#define D(x) 	x
#endif

#define MAX(a,b)        ((a)>(b)?(a):(b))
#define MIN(a,b)        ((a)<(b)?(a):(b))

#define STREQ(a,b)	(!strcmp((a),(b)))

#define V1_POINT_4      36

#define EOF 			-1

struct DisplayBase *DisplayBase = NULL;
struct GfxBase  *GfxBase = NULL;

#define TXTOSCAN 1
#define STDOSCAN 2
#define MAXOSCAN 3
#define VIDOSCAN 4

int otype = NULL;

int debug = FALSE;
int test = FALSE;
int all = FALSE;

struct TagItem vc[] =
{
	{ VTAG_ATTACH_CM_SET, NULL },
	{ VTAG_VIEWPORTEXTRA_SET, NULL },
	{ VTAG_NORMAL_DISP_SET, NULL },
	{ VTAG_END_CM, NULL }
};

struct TagItem end_vc[] =
{
	{ VTAG_VIEWPORTEXTRA_GET, NULL },
	{ VTAG_END_CM, NULL }
};

struct DisplayInfo queryinfo;
struct NameInfo queryname;
struct DimensionInfo querydims;
struct MonitorInfo querymonitor;

pow( a, b )
{
	if(b-- <= 0) { return( 1 ); } else { return( a * pow( a, b ) ); }
}

md( ID, matchID )
ULONG ID;
ULONG matchID;
{
	int    success = FALSE;
	int    name = FALSE;
	int    info = FALSE;
	int    norm = FALSE;
	int    mntr = FALSE;

	if(info = 
	GetDisplayInfoData(NULL,&queryinfo,sizeof(queryinfo),DTAG_DISP,ID))
	{
		if(!~matchID) 
		{
			D(kprintf("\nID%08lx ",queryinfo.Header.DisplayID);)
			D(kprintf("%sactive ",queryinfo.NotAvailable?"in":"");)
			if(queryinfo.NotAvailable)
			{
				D(kprintf("\( ");)
				if(queryinfo.NotAvailable & DI_AVAIL_NOCHIPS)
				{
					D(kprintf("no chips ");)
				}
				if(queryinfo.NotAvailable & DI_AVAIL_NOMONITOR)
				{
					D(kprintf("no monitor ");)
				}
				D(kprintf("\) ");)
			}
		}
		else
		{
			if(queryinfo.Header.DisplayID == matchID) 
			{
				if(!(queryinfo.NotAvailable)) success= TRUE; 
			}
		}

		if(name = 
		GetDisplayInfoData(NULL,&queryname,sizeof(queryname),DTAG_NAME,ID))
		{
			if(!~matchID) D(kprintf("%s ",queryname.Name);)
		}

		if(mntr = 
		GetDisplayInfoData(NULL,&querymonitor,sizeof(querymonitor),DTAG_MNTR,ID))
		{
			if(debug) 
			{
				if( querymonitor.Mspc ) 
				D(kprintf(" \(%s\):",querymonitor.Mspc->ms_Node.xln_Name);)
				else 
				D(kprintf(" \(no current mspc\):");)
				D(kprintf("\n      ");)
			}

			if(debug) 
			{ 
				struct Rectangle *range = &querymonitor.ViewPositionRange;

				D(kprintf(" origin x = %02lx",querymonitor.ViewPosition.x);)
				D(kprintf(" y = %02lx",querymonitor.ViewPosition.y );)
				D(kprintf(" \n      ");)

				D(kprintf(" view range");)
				D(kprintf(" %4ld",range->MinX);)
				D(kprintf(" %4ld",range->MinY);)
				D(kprintf(" %4ld",range->MaxX);)
				D(kprintf(" %4ld",range->MaxY);)
				D(kprintf(" \n      ");)
			}
		}
		else
		{
			if(debug) D(kprintf(" \(monitor_not_found\): \n      ");)
		}

		if(debug)
		{
			D(kprintf(" ");)
			if(queryinfo.PropertyFlags)
			{

				if(queryinfo.PropertyFlags & DIPF_IS_LACE)
				{
					D(kprintf("LACE ");)
				}
				if(queryinfo.PropertyFlags & DIPF_IS_DUALPF)
				{
					D(kprintf("DUALPF ");)
				}
				if(queryinfo.PropertyFlags & DIPF_IS_PF2PRI)
				{
					D(kprintf("PF2PRI ");)
				}
				if(queryinfo.PropertyFlags & DIPF_IS_HAM)
				{
					D(kprintf("HAM ");)
				}
				if(queryinfo.PropertyFlags & DIPF_IS_ECS)
				{
					D(kprintf("ECS ");)
				}
				if(queryinfo.PropertyFlags & DIPF_IS_PAL)
				{
					D(kprintf("PAL ");)
				}
				if(queryinfo.PropertyFlags & DIPF_IS_SPRITES)
				{
					D(kprintf("SPRITES ");)
				}
				if(queryinfo.PropertyFlags & DIPF_IS_GENLOCK)
				{
					D(kprintf("GENLOCK ");)
				}
				if(queryinfo.PropertyFlags & DIPF_IS_WB)
				{
					D(kprintf("WB ");)
				}
				if(queryinfo.PropertyFlags & DIPF_IS_DRAGGABLE)
				{
					D(kprintf("DRAGGABLE ");)
				}
				if(queryinfo.PropertyFlags & DIPF_IS_PANELLED)
				{
					D(kprintf("PANELLED ");)
				}
				if(queryinfo.PropertyFlags & DIPF_IS_BEAMSYNC)
				{
					D(kprintf("BEAMSYNC");)
				}
			}
			else
			{
					D(kprintf("NULL ");)
			}
			D(kprintf("\n      ");)
		}
	}
	else
	{
		D(kprintf("\nID%08lx ",ID);)
		D(kprintf(" \(unavailable\): \n      ");)
	}

	if(norm = 
	GetDisplayInfoData(NULL,&querydims,sizeof(querydims),DTAG_DIMS,ID))
	{
		struct Rectangle *oscan;

		if(debug) 
		{ 
			D(kprintf(" minimum rasterwidth  ");)
			D(kprintf(" %4ld",querydims.MinRasterWidth);)
			D(kprintf(" ");)

			D(kprintf(" minimum rasterheight ");)
			D(kprintf(" %4ld",querydims.MinRasterHeight);)
			D(kprintf(" \n      ");)

			D(kprintf(" maximum rasterwidth  ");)
			D(kprintf(" %4ld",querydims.MaxRasterWidth);)
			D(kprintf(" ");)

			D(kprintf(" maximum rasterheight ");)
			D(kprintf(" %4ld",querydims.MaxRasterHeight);)
			D(kprintf(" \n      ");)

			D(kprintf(" maximum depth  %1ld",querydims.MaxDepth );) 
			D(kprintf(" \n      ");)

			oscan = &querydims.Nominal;

			D(kprintf(" nominal rectangle");)
			D(kprintf(" %4ld",oscan->MinX);)
			D(kprintf(" %4ld",oscan->MinY);)
			D(kprintf(" %4ld",oscan->MaxX);)
			D(kprintf(" %4ld",oscan->MaxY);)
			D(kprintf(" \n      ");)

			oscan = &querydims.TxtOScan;

			D(kprintf(" text_oscan");)
			D(kprintf(" %4ld",oscan->MinX);)
			D(kprintf(" %4ld",oscan->MinY);)
			D(kprintf(" %4ld",oscan->MaxX);)
			D(kprintf(" %4ld",oscan->MaxY);)
			D(kprintf(" \n      ");)

			oscan = &querydims.StdOScan;

			D(kprintf(" std__oscan");)
			D(kprintf(" %4ld",oscan->MinX);)
			D(kprintf(" %4ld",oscan->MinY);)
			D(kprintf(" %4ld",oscan->MaxX);)
			D(kprintf(" %4ld",oscan->MaxY);)
			D(kprintf(" \n      ");)

			oscan = &querydims.MaxOScan;

			D(kprintf(" max__oscan");)
			D(kprintf(" %4ld",oscan->MinX);)
			D(kprintf(" %4ld",oscan->MinY);)
			D(kprintf(" %4ld",oscan->MaxX);)
			D(kprintf(" %4ld",oscan->MaxY);)
			D(kprintf(" \n      ");)

			oscan = &querydims.VideoOScan;

			D(kprintf(" videooscan");)
			D(kprintf(" %4ld",oscan->MinX);)
			D(kprintf(" %4ld",oscan->MinY);)
			D(kprintf(" %4ld",oscan->MaxX);)
			D(kprintf(" %4ld",oscan->MaxY);)
			D(kprintf(" \n      ");)
			}
	}

	return( (info && mntr && norm)? success : FALSE );
}

display_db(argv)
UBYTE *argv;
{
	ULONG       ID = INVALID_ID;
	ULONG found_id = INVALID_ID;
	ULONG match_id = INVALID_ID;


	if(argv) 
	{ 
		if(sscanf(argv,"%lx",&match_id) == EOF) return(INVALID_ID); 
	}
	else 
	{ 
		D(kprintf("----- mode information -----\n");) 
	}

	while((ID = NextDisplayInfo( ID )) != INVALID_ID)
	{
		if(all) 
		{
			if(md( ID, ID)) 
			{
				open(ID);
			}
		}
		else
		{
			if(md( ID, match_id)) 
			{
				if(!(~found_id)) found_id = ID; break;
			}
		}
	}

	if(!argv) 
	{ 
		D(kprintf("\n----------------------------\n");) 
	}

	return( found_id );
}


create_display( ID, vp, rp )
ULONG ID;
struct ViewPort *vp;
struct RastPort *rp;
{
    int error = FALSE;
    int i,j,k;
    char text[1];


    if(vp && rp)
    {
        SetAPen(  rp,  1 );

		RectFill( rp, 0, 0, vp->DWidth-1, vp->DHeight-1 );

        SetAPen(  rp,  -1 );
		SetDrMd(  rp,  JAM1 );

		/* circle in the center, radius 1/4 the width of the screen */
		{
			WORD x_center = vp->DWidth  >> 1;
			WORD y_center = vp->DHeight >> 1;
			WORD width  =   vp->DWidth  >> 2;
			WORD height = 
			(((LONG)(width * queryinfo.Resolution.x))/queryinfo.Resolution.y);
			DrawEllipse( rp, x_center, y_center, width, height );
		}

		/* outline the rectangle */
		{
                Move( rp, 0, 			0 );
                Draw( rp, 0, 			vp->DHeight-1);
                Draw( rp, vp->DWidth-1, vp->DHeight-1);
                Draw( rp, vp->DWidth-1, 0);
                Draw( rp, 0, 			0);
		}

		/* indicate diagonals */
		{
                Move( rp, 0, 			0 );
                Draw( rp, vp->DWidth-1, vp->DHeight-1);
                Move( rp, 0, 			vp->DHeight-1);
                Draw( rp, vp->DWidth-1, 0);
		}

		/* dimension counters */
        for(i=0; i < vp->DWidth; i+=(1<<4))
        {
                Move( rp, i, 0 );
                Draw( rp, i, vp->DHeight-1);
                if(i == 0)
                for(k=0; k+12 < vp->DHeight-1; k+=(1<<4))
                {
                        *text = '0'+((k>>4)%10);
                        Move( rp, i+4, k+12 );
                        Text( rp, text, 1);
                }
        }

        for(j=0; j < vp->DHeight; j+=(1<<4))
        {
                Move( rp, 0, j );
                Draw( rp, vp->DWidth-1, j);
                if(j == 0)
                for(k=0; k+12 < vp->DWidth-1; k+=(1<<4))
                {
                        *text = '0'+((k>>4)%10);
                        Move( rp, k+4, j+12 );
                        Text( rp, text, 1);
                }
        }
    }
    else
    {
        error = TRUE;
    }

    return( error );
}

struct RastPort *create_rp( ID, bm )
ULONG ID;
struct BitMap *bm;
{
    struct RastPort *rp = NULL;

    if( rp = AllocMem( sizeof(*rp), MEMF_PUBLIC|MEMF_CLEAR ) )
    {
        InitRastPort( rp );
        rp->BitMap = bm;
    }

    return( rp );
}

dispose_rp( rp )
struct RastPort *rp;
{
    int error = FALSE;

    if( rp )
    {
        FreeMem( rp, sizeof(*rp));
    }
    else
    {
        error = TRUE;
    }

    return( error );
}

struct RasInfo *create_ri( ID, bm )
ULONG ID;
struct BitMap *bm;
{
    struct RasInfo *ri = NULL;

    if( ri = AllocMem( sizeof(*ri), MEMF_PUBLIC|MEMF_CLEAR ) )
    {
        ri->BitMap = bm;
    }

    return( ri );
}

dispose_ri( ri )
struct RasInfo *ri;
{
    int error = FALSE;

    if( ri )
    {
        FreeMem( ri, sizeof(*ri));
    }
    else
    {
        error = TRUE;
    }

    return( error );
}

struct BitMap *create_bm( ID, vp )
ULONG ID;
struct ViewPort *vp;
{
    struct BitMap  *bm = NULL;
	ULONG DEPTH = querydims.MaxDepth;

	if( DEPTH )
	{
		if( bm = AllocMem( sizeof(*bm), MEMF_PUBLIC|MEMF_CLEAR ) )
		{
			int i;

			InitBitMap(bm, DEPTH, vp->DWidth, vp->DHeight );

			/* allocate chip memory for bitmap planes */
			for (i = 0; i < bm->Depth; i++)
			{
				if( bm->Planes[i] = 
					AllocMem( RASSIZE(vp->DWidth, vp->DHeight), MEMF_CHIP | MEMF_CLEAR ) )
				{
					continue;
				}
				else
				{
					dispose_bm( bm );
					return( NULL );
				}
			}
		}
	}

    return( bm ); 
}

dispose_bm( bm )
struct BitMap *bm;
{
    int error = FALSE;

    if( bm )
    {
        int i;

        for(i=0; i < bm->Depth; i++)
        {
            if( bm->Planes[i] ) 
            {
                FreeMem( bm->Planes[i], bm->BytesPerRow * bm->Rows );
            }
        }
        FreeMem( bm, sizeof(*bm));
    }
    else
    {
        error = TRUE;
    }

    return( error );
}

struct ViewPort *create_vp( ID, view )
ULONG ID;
struct View *view;
{
    struct ViewPort    *vp     = NULL;
	struct Rectangle   *oscan;
	LONG   DX;
	LONG   DY;
	ULONG  WIDTH;
	ULONG  HEIGHT;

	switch( otype )
	{
		case TXTOSCAN: oscan = &querydims.TxtOScan; break;
		case STDOSCAN: oscan = &querydims.StdOScan; break;
		case MAXOSCAN: oscan = &querydims.MaxOScan; break;
		case VIDOSCAN: oscan = &querydims.VideoOScan; break;
		default:       oscan = &querydims.Nominal; break;
	}

	DX     = oscan->MinX;
	DY     = oscan->MinY;
	WIDTH  = oscan->MaxX-oscan->MinX+1;
	HEIGHT = oscan->MaxY-oscan->MinY+1;

	if( WIDTH && HEIGHT )  
	if( vp = AllocMem( sizeof(*vp), MEMF_PUBLIC|MEMF_CLEAR ) )
	{
		int	error = FALSE;
		struct ViewPortExtra *vpx = NULL;

		InitVPort( vp );

		/* wow! -- 1.2 compatibility mode */

		vp->Modes    = (ID & 0xFFFF); 

		/* standard size and position productivity viewport */

		vp->DxOffset = DX;
		vp->DyOffset = DY;
		vp->DWidth   = WIDTH;
		vp->DHeight  = HEIGHT;

		/* determine displayclip rectangle for this viewport */

		if (view->Modes & EXTEND_VSTRUCT)
		{
			struct ViewExtra *vx;

			if( vx = GfxLookUp( view ) )
			{
				struct MonitorSpec *mspc;

				if( mspc = vx->Monitor )
				{
					WORD  SHIFT_X =  0;
					WORD  SHIFT_Y =  0;
					struct Rectangle rect;

					X(kprintf("mspc == %lx\n",mspc);)

					/* specify displayclip in view relative coordinates */

					if( !( mspc->ms_Flags & REQUEST_A2024 ) )
					{
						struct Rectangle *oscan;

						switch( otype )
						{
							case TXTOSCAN: oscan = &querydims.TxtOScan; break;
							case STDOSCAN: oscan = &querydims.StdOScan; break;
							case MAXOSCAN: oscan = &querydims.MaxOScan; break;
							case VIDOSCAN: oscan = &querydims.VideoOScan; break;
							default:       oscan = &querydims.Nominal; break;
						}

						if( vpx = GfxNew( VIEWPORT_EXTRA_TYPE ) )
						{
							vpx->DisplayClip.MinX = oscan->MinX;
							vpx->DisplayClip.MinY = oscan->MinY;
							vpx->DisplayClip.MaxX = oscan->MaxX;
							vpx->DisplayClip.MaxY = oscan->MaxY;
						}
					}
				}
			}
		}

		/* pass new information to the system via colormap structure */

		vc[0].ti_Data = vp;
		vc[1].ti_Data = vpx;

		if(!test) 
		{
			vc[2].ti_Data = (ULONG) FindDisplayInfo( ID );
		}
		else
		{
			vc[2].ti_Data = NULL;
		}

		/* get a full colormap */

		error = VideoControl( GetColorMap(32), vc );

		/* set the global lace */

		if(!error && !test)
		{
			view->Modes |= ((DIPF_IS_LACE & queryinfo.PropertyFlags)? LACE: 0);
		}
		else
		{
			view->Modes |= (LACE & vp->Modes);
		}
	}

    return( vp ); 
}

dispose_vp( vp)
struct ViewPort *vp;
{
    int error = FALSE;

    if( vp )
    {
		struct ViewPortExtra *vpx;

		error = VideoControl( vp->ColorMap, end_vc );

		if(!error)
		{
			if(vpx = end_vc[0].ti_Data)
			{
				GfxFree( vpx );
			}
		}

        if ( vp->ColorMap )
        {
            FreeColorMap( vp->ColorMap );
        }
        FreeVPortCopLists( vp );
        FreeMem( vp, sizeof(*vp) );
    }
    else
    {
        error = TRUE;
    }

    return( error );
}

struct View *create_view( ID, mspc )
ULONG ID;
struct MonitorSpec *mspc;
{
    struct View *view;

    if( view = AllocMem( sizeof(*view), MEMF_PUBLIC|MEMF_CLEAR ) )
    {
        struct ViewExtra *vx;

        InitView( view );

        if( vx = GfxNew( VIEW_EXTRA_TYPE ) )
        {
            vx->Monitor = mspc; 
            GfxAssociate( view, vx );
            view->Modes |= EXTEND_VSTRUCT;
        }

        view->DxOffset = querymonitor.ViewPosition.x ;
        view->DyOffset = querymonitor.ViewPosition.y ;
    }

    return( view );
}

dispose_view( view)
struct View *view;
{
    int error = FALSE;

    if( view )
    {
        if (view->Modes & EXTEND_VSTRUCT)
        {
            struct ViewExtra *vx;

            if( vx = GfxLookUp( view ) )
            {
                GfxFree( vx );
            }
        }
        if ( view->LOFCprList ) FreeCprList ( view->LOFCprList );
        if ( view->SHFCprList ) FreeCprList ( view->SHFCprList );

        FreeMem( view, sizeof(*view) );
    }
    else
    {
        error = TRUE;
    }

    return( error );
}

open( ID )
ULONG ID;
{
	int error = FALSE;
	struct MonitorSpec *mspc, *OpenMonitor();

	X(kprintf("open: ID = %lx\n",ID);)

	if(!test)
	{
		mspc = OpenMonitor( NULL, ID ) ;
	}
	else
	{
		mspc = OpenMonitor( NULL, NULL ) ;
	}

	if( mspc )
	{
		struct View *view, *create_view();

		X(kprintf("open: mspc = %lx\n",mspc);)

		if( view = create_view( ID, mspc ) )
		{
			struct ViewPort *vp, *create_vp();

			X(kprintf("open: view = %lx\n",view);)

			if( vp = create_vp( ID, view ) )
			{
				struct BitMap *bm, *create_bm();

				X(kprintf("open: vp = %lx\n",vp);)

				view->ViewPort = vp;

				if( bm = create_bm( ID, vp ) )
				{
					struct RasInfo *ri, create_ri();

					X(kprintf("open: bm = %lx\n",bm);)

					if( ri = create_ri( ID, bm ) )
					{
						struct RastPort *rp, create_rp();

						X(kprintf("open: ri = %lx\n",ri);)

						vp->RasInfo = ri;

						if( rp = create_rp( ID, bm ) )
						{
							/* show the productivity viewport */

							X(kprintf("open: rp = %lx\n",rp);)

							if(!(error = create_display(ID,vp,rp)))
							{
								struct View *restore_view;
								restore_view = GfxBase->ActiView;

								MakeVPort( view, vp );
								MrgCop( view );
								LoadView( view );

								X(kprintf("open: wait for CTRL_C\n");)
								Wait(SIGBREAKF_CTRL_C);

								LoadView( restore_view );
							}
							
							dispose_rp( rp );
						}
						
						dispose_ri( ri );
					}
					
					dispose_bm( bm );
				}
				
				dispose_vp( vp );
			}
			
			dispose_view( view );
		}
		else
		{
			error = TRUE;
		}

		CloseMonitor( mspc );
	}
	else
	{
			error = TRUE;
	}

	return(error);
}

main(argc,argv)
int argc;
UBYTE *argv[];
{
	int error = FALSE;

	if( (argc) && ( GfxBase = OpenLibrary( "graphics.library", V1_POINT_4 )) )
	{
		/* display database by name */

		if(argc == 1)
		{
			display_db(NULL);
		}
		else
		{
			if( STREQ(*(argv+1),"-debug") ) debug = TRUE;
			if( STREQ(*(argv+1),"-all") ) all = TRUE;

			if((argc == 2 && debug)||(argc == 2 && all))
			{
				display_db(NULL);
			}
			else
			{
				debug = FALSE;
				all = FALSE;

				while(--argc) 
				{	
					if( **(++argv) == '-' ) 
					{
						if( STREQ(*argv  ,"-test") ) test = TRUE;
						if( STREQ(*argv,"-txt") ) otype = TXTOSCAN;
						if( STREQ(*argv,"-std") ) otype = STDOSCAN;
						if( STREQ(*argv,"-max") ) otype = MAXOSCAN;
						if( STREQ(*argv,"-vid") ) otype = VIDOSCAN;
						D(kprintf("db: use overscan %s option\n",(*argv)+1);)
						continue;
					}
					else
					{
						ULONG id = display_db(*argv);
						D(kprintf("db: open %s ID == 0x%08lx\n",*argv,id);)
						if(~id) error = open(id);
					}
				}
			}
		}

		CloseLibrary( GfxBase ); /* clean up and exit */
	}
	else
	{
		error = TRUE;
	}

	exit(error);
}
@


36.67
log
@finally fixed loadview/rectfill timing interaction!!!! what a stud...
@
text
@d5 1
a5 1
*	$Header: db.c,v 36.66 89/03/14 18:11:12 bart Exp $
d115 4
a118 1
			if(queryinfo.Header.DisplayID == matchID) success= TRUE; 
@


36.66
log
@*** empty log message ***
@
text
@d5 1
a5 1
*	$Header: db.c,v 36.65 89/03/14 18:05:39 bart Exp $
a356 1
        /* SetRGB4(  vp,  0 , ~0, ~0, ~0); */
d359 1
a359 1
		if ( !otype ) RectFill( rp, 0, 0, vp->DWidth-1, vp->DHeight-1 );
@


36.65
log
@cp
@
text
@d5 1
a5 1
*	$Header: db.c,v 36.64 89/03/13 19:58:37 bart Exp $
d398 1
a398 1
                for(k=0; k+12 < vp->DHeight; k+=(1<<4))
d411 1
a411 1
                for(k=0; k+12 < vp->DWidth; k+=(1<<4))
@


36.64
log
@*** empty log message ***
@
text
@d5 1
a5 1
*	$Header: db.c,v 36.63 89/03/13 14:11:14 bart Exp $
d360 1
a360 1
		if( !otype ) RectFill( rp, 0, 0, vp->DWidth-1, vp->DHeight-1 );
d411 1
a411 1
                for(k=0; k < vp->DWidth; k+=(1<<4))
d556 5
a560 4
	LONG   DX = 0;
	LONG   DY = 0;
	ULONG  WIDTH  = querydims.Nominal.MaxX-querydims.Nominal.MinX;
	ULONG  HEIGHT = querydims.Nominal.MaxY-querydims.Nominal.MinY;
d562 1
a562 1
	if( otype )
d564 6
a569 1
		struct Rectangle *oscan;
d571 4
a574 8
		switch( otype )
		{
			case TXTOSCAN: oscan = &querydims.TxtOScan; break;
			case STDOSCAN: oscan = &querydims.StdOScan; break;
			case MAXOSCAN: oscan = &querydims.MaxOScan; break;
			case VIDOSCAN: oscan = &querydims.VideoOScan; break;
			default:  oscan = &querydims.TxtOScan; break;
		}
a575 6
		DX     = oscan->MinX;
		DY     = oscan->MinY;
		WIDTH  = oscan->MaxX-oscan->MinX+1;
		HEIGHT = oscan->MaxY-oscan->MinY+1;
	}

d625 1
a625 1
							default:  oscan = &querydims.TxtOScan; break;
@


36.63
log
@view range
@
text
@d5 1
a5 1
*	$Header: db.c,v 36.62 89/03/07 16:58:35 bart Exp $
d344 1
d360 1
a360 1
		RectFill( rp, 0, 0, vp->DWidth-1, vp->DHeight-1 );
@


36.62
log
@otype
@
text
@d5 1
a5 1
*	$Header: db.c,v 36.63 89/03/07 12:35:18 bart Exp $
d138 2
d142 7
@


36.61
log
@VTAG_ATTACH_CM_SET
@
text
@d5 1
a5 1
*	$Header: db.c,v 36.60 89/02/24 13:22:03 bart Exp $
d47 7
d344 1
d499 1
a499 1
					AllocMem( RASSIZE(vp->DWidth, vp->DHeight), MEMF_CHIP ) )
d546 2
d551 19
d584 2
a585 2
		vp->DxOffset = 0;
		vp->DyOffset = 0;
d611 1
a611 1
						struct Rectangle *oscan = &querydims.StdOScan;
d613 9
d824 1
a824 1
								
d889 6
a894 1
						if( STREQ(*argv,"-test") ) test = TRUE;
@


36.60
log
@*** empty log message ***
@
text
@d5 1
a5 1
*	$Header: db.c,v 36.59 89/02/23 18:32:26 bart Exp $
d53 1
a53 1
	{ VTAG_ATTACH_CM, NULL },
@


36.59
log
@commented out setrgb4 in display
@
text
@d5 1
a5 1
*	$Header: db.c,v 36.58 89/02/23 14:22:25 bart Exp $
d143 1
a143 1
			D(kprintf(" properties: ");)
d193 1
a193 1
					D(kprintf("BEAMSYNC ");)
d200 1
a200 1
			D(kprintf(" \n      ");)
@


36.58
log
@DTAG
@
text
@d5 1
a5 1
*	$Header: db.c,v 36.57 89/02/22 11:27:58 bart Exp $
d339 1
@


36.57
log
@checkpoint all
@
text
@d5 1
a5 1
*	$Header: db.c,v 36.56 89/02/22 11:08:57 bart Exp $
d86 1
a86 1
	GetDisplayInfoData(NULL,&queryinfo,sizeof(queryinfo),TAG_DISP,ID))
d112 1
a112 1
		GetDisplayInfoData(NULL,&queryname,sizeof(queryname),TAG_NAME,ID))
d118 1
a118 1
		GetDisplayInfoData(NULL,&querymonitor,sizeof(querymonitor),TAG_MNTR,ID))
d210 1
a210 1
	GetDisplayInfoData(NULL,&querydims,sizeof(querydims),TAG_DIMS,ID))
@


36.56
log
@*** empty log message ***
@
text
@d5 1
a5 1
*	$Header: db.c,v 36.55 89/02/22 10:36:53 bart Exp $
@


36.55
log
@*** empty log message ***
@
text
@d5 1
a5 1
*	$Header: db.c,v 36.54 89/02/21 16:53:18 bart Exp $
d49 1
d304 1
a304 1
		if(md( ID, match_id)) 
d306 4
a309 1
			if(!(~found_id)) found_id = ID; break;
d311 7
d835 1
d837 1
a837 1
			if(argc == 2 && debug) 
d844 1
@


36.54
log
@*** empty log message ***
@
text
@d5 1
a5 1
*	$Header: db.c,v 36.53 89/02/21 11:34:23 bart Exp $
d215 1
a215 1
			D(kprintf(" minimum width  ");)
d217 4
d223 6
a228 2
			D(kprintf(" minimum height ");)
			D(kprintf(" %4ld",querydims.MinRasterHeight);)
@


36.53
log
@*** empty log message ***
@
text
@d5 1
a5 1
*	$Header: db.c,v 36.52 89/02/21 11:28:41 bart Exp $
d204 2
a205 1
		if(debug) D(kprintf(" \(unavailable\): \n      ");)
@


36.52
log
@*** empty log message ***
@
text
@d5 1
a5 1
*	$Header: db.c,v 36.51 89/02/21 11:27:07 bart Exp $
@


36.51
log
@make
@
text
@d5 1
a5 1
*	$Header: db.c,v 36.50 89/02/17 21:57:20 bart Exp $
d48 1
@


36.50
log
@checkpoint
,
@
text
@d5 1
a5 1
*	$Header: db.c,v 36.49 89/02/17 21:54:16 bart Exp $
d579 1
a579 1
		if(!debug) 
d594 1
a594 1
		if(!error && !debug)
d596 1
a596 1
			view->Modes |= (LACE & queryinfo.PropertyFlags);
d704 1
a704 1
	if(!debug)
d821 2
d827 1
a827 1
						if( STREQ(*argv,"-debug") ) debug = TRUE;
@


36.49
log
@*** empty log message ***
@
text
@d5 1
a5 1
*	$Header: db.c,v 36.48 89/02/17 21:52:02 bart Exp $
@


36.48
log
@make
@
text
@d5 1
a5 1
*	$Header: db.c,v 36.47 89/02/17 21:41:03 bart Exp $
d141 2
a142 2
			D(kprintf(" properties\(%08lx\): ",queryinfo.PropertyFlags);)
			if(queryinfo.PropertyFlags & DIPF_IS_LACE)
d144 49
a192 1
				D(kprintf("LACE ");)
d194 1
a194 1
			if(queryinfo.PropertyFlags & DIPF_IS_DUALPF)
d196 1
a196 1
				D(kprintf("DUALPF ");)
a197 40
			if(queryinfo.PropertyFlags & DIPF_IS_PF2PRI)
			{
				D(kprintf("PF2PRI ");)
			}
			if(queryinfo.PropertyFlags & DIPF_IS_HAM)
			{
				D(kprintf("HAM ");)
			}
			if(queryinfo.PropertyFlags & DIPF_IS_ECS)
			{
				D(kprintf("ECS ");)
			}
			if(queryinfo.PropertyFlags & DIPF_IS_PAL)
			{
				D(kprintf("PAL ");)
			}
			if(queryinfo.PropertyFlags & DIPF_IS_SPRITES)
			{
				D(kprintf("SPRITES ");)
			}
			if(queryinfo.PropertyFlags & DIPF_IS_GENLOCK)
			{
				D(kprintf("GENLOCK ");)
			}
			if(queryinfo.PropertyFlags & DIPF_IS_WB)
			{
				D(kprintf("WB ");)
			}
			if(queryinfo.PropertyFlags & DIPF_IS_DRAGGABLE)
			{
				D(kprintf("DRAGGABLE ");)
			}
			if(queryinfo.PropertyFlags & DIPF_IS_PANELLED)
			{
				D(kprintf("PANELLED ");)
			}
			if(queryinfo.PropertyFlags & DIPF_IS_BEAMSYNC)
			{
				D(kprintf("BEAMSYNC ");)
			}
a199 1

@


36.47
log
@*** empty log message ***
@
text
@d5 1
a5 1
*	$Header: db.c,v 36.46 89/02/17 21:20:42 bart Exp $
d141 2
a142 1
			if(queryinfo.PropertyFlags)
d144 1
a144 50
				D(kprintf(" properties: ");)
				if(queryinfo.PropertyFlags & DIPF_IS_LACE)
				{
					D(kprintf("LACE ");)
				}
				if(queryinfo.PropertyFlags & DIPF_IS_DUALPF)
				{
					D(kprintf("DUALPF ");)
				}
				if(queryinfo.PropertyFlags & DIPF_IS_PF2PRI)
				{
					D(kprintf("PF2PRI ");)
				}
				if(queryinfo.PropertyFlags & DIPF_IS_HAM)
				{
					D(kprintf("HAM ");)
				}
				if(queryinfo.PropertyFlags & DIPF_IS_ECS)
				{
					D(kprintf("ECS ");)
				}
				if(queryinfo.PropertyFlags & DIPF_IS_PAL)
				{
					D(kprintf("PAL ");)
				}
				if(queryinfo.PropertyFlags & DIPF_IS_SPRITES)
				{
					D(kprintf("SPRITES ");)
				}
				if(queryinfo.PropertyFlags & DIPF_IS_GENLOCK)
				{
					D(kprintf("GENLOCK ");)
				}
				if(queryinfo.PropertyFlags & DIPF_IS_WB)
				{
					D(kprintf("WB ");)
				}
				if(queryinfo.PropertyFlags & DIPF_IS_DRAGGABLE)
				{
					D(kprintf("DRAGGABLE ");)
				}
				if(queryinfo.PropertyFlags & DIPF_IS_PANELLED)
				{
					D(kprintf("PANELLED ");)
				}
				if(queryinfo.PropertyFlags & DIPF_IS_BEAMSYNC)
				{
					D(kprintf("BEAMSYNC ");)
				}
				D(kprintf(" \n      ");)
d146 45
@


36.46
log
@checkpoint
@
text
@d5 1
a5 1
*	$Header: db.c,v 36.45 89/02/17 21:18:36 bart Exp $
d136 1
a136 1
			if(debug) D(kprintf(" \(monitor_not_found\):");)
d139 57
d199 1
a199 1
		if(debug) D(kprintf(" \(unavailable\):");)
@


36.45
log
@make
@
text
@d5 1
a5 1
*	$Header: db.c,v 36.44 89/02/17 17:15:10 bart Exp $
d92 1
a92 1
				D(kprintf("\(");)
@


36.44
log
@*** empty log message ***
@
text
@d5 1
a5 1
*	$Header: db.c,v 36.43 89/02/17 17:02:44 bart Exp $
d89 14
a151 5
			D(kprintf(" w %4ld",querydims.Nominal.MaxX-querydims.Nominal.MinX);)
			D(kprintf(" h %4ld",querydims.Nominal.MaxY-querydims.Nominal.MinY);)
			D(kprintf(" d %1ld",querydims.MaxDepth );) 
			D(kprintf(" \n      ");)

d158 3
@


36.43
log
@*** empty log message ***
@
text
@d5 1
a5 1
*	$Header: db.c,v 36.42 89/02/17 16:53:41 bart Exp $
d104 1
a104 1
			if(debug && !~matchID) 
d113 1
a113 1
			if(debug && !~matchID) 
d122 1
a122 1
			if(debug && !~matchID) D(kprintf(" \(monitor_not_found\):");)
d128 1
a128 1
		if(debug && !~matchID) D(kprintf(" \(unavailable\):");)
d136 1
a136 1
		if(debug && !~matchID) 
d149 9
@


36.42
log
@*** empty log message ***
@
text
@d5 1
a5 1
*	$Header: db.c,v 36.41 89/02/17 13:15:08 bart Exp $
d104 1
a104 1
			if(!~matchID) 
d122 1
a122 1
			if(!~matchID) D(kprintf(" \(monitor_not_found\):");)
d128 1
a128 1
		if(!~matchID) D(kprintf(" \(unavailable\):");)
d136 1
a136 1
		if(!~matchID) 
@


36.41
log
@*** empty log message ***
@
text
@d5 1
a5 1
*	$Header: db.c,v 36.40 89/02/17 13:14:28 bart Exp $
d115 2
a116 2
				D(kprintf(" origin x = %02lx",querymonitor.ViewPosition.x>>16);)
				D(kprintf(" y = %02lx",querymonitor.ViewPosition.y & 0xFFFF);)
d141 1
@


36.40
log
@*** empty log message ***
@
text
@d5 1
a5 1
*	$Header: db.c,v 36.39 89/02/17 13:13:32 bart Exp $
d199 1
a199 1
	if(!argv) 
d201 1
a201 1
		D(kprintf("----- mode information -----\n");) 
d205 1
a205 1
		if(sscanf(argv,"%lx",&match_id) == EOF) return(INVALID_ID); 
@


36.39
log
@*** empty log message ***
@
text
@d5 1
a5 1
*	$Header: db.c,v 36.38 89/02/17 13:12:31 bart Exp $
d205 1
a205 1
		if((sscanf(argv,"%lx",&match_id) == EOF) return(INVALID_ID); 
@


36.38
log
@*** empty log message ***
@
text
@d5 1
a5 1
*	$Header: db.c,v 36.37 89/02/17 12:49:18 bart Exp $
d192 1
a192 1
UBYTE *argv
@


36.37
log
@make
@
text
@d5 1
a5 1
*	$Header: db.c,v 36.36 89/02/16 16:43:37 bart Exp $
d42 2
d73 3
a75 3
md( ID , string )
ULONG  ID;
UBYTE *string;
d86 8
a93 1
		if(!string) D(kprintf("\nID%08lx ",queryinfo.Header.DisplayID);)
a94 2
		success= TRUE; /* found displayinfo data */

d98 1
a98 1
			if(!string) D(kprintf("%s ",queryname.Name);)
d104 1
a104 1
			if(!string) 
d113 1
a113 1
			if(debug && !string) 
d122 1
a122 1
			if(!string) D(kprintf(" \(monitor_not_found\):");)
d128 1
a128 1
		if(!string) D(kprintf(" \(unavailable\):");)
d136 1
a136 1
		if(!string) 
d191 2
a192 2
display_db(name)
UBYTE *name;
d195 2
a196 1
	ULONG match_id = ~0;
a197 1
	if(!name) { D(kprintf("----- mode information -----\n");) }
d199 8
a206 1
	/* display information for all current graphics modes */
d210 1
a210 1
		if(md( ID, name )) 
d212 1
a212 1
			if(!(~match_id)) match_id = ID; break;
d216 4
a219 1
	if(!name) { D(kprintf("\n----------------------------\n");) }
d221 1
a221 1
	return( match_id );
@


36.36
log
@*** empty log message ***
@
text
@d5 1
a5 1
*	$Header: db.c,v 36.35 89/02/16 16:35:00 bart Exp $
d63 1
a63 1
struct DimensionInfo querynorm;
d81 2
a82 2
	if(name = 
	GetDisplayInfoData(NULL,&queryname,sizeof(queryname),TAG_NAME,ID))
d84 1
a84 1
		if(!string) D(kprintf("\nID%08lx: %s",queryname.Header.DisplayID,queryname.Name);)
d86 1
a86 1
		if( STREQ( queryname.Name, string ) ) success= TRUE;
d88 2
a89 2
		if(info = 
		GetDisplayInfoData(NULL,&queryinfo,sizeof(queryinfo),TAG_DISP,ID))
d91 7
a97 2
			if(mntr = 
		    GetDisplayInfoData(NULL,&querymonitor,sizeof(querymonitor),TAG_MNTR,ID))
d99 6
a104 8
				if(!string) 
				{
					if( querymonitor.Mspc ) 
					D(kprintf(" \(%s\):",querymonitor.Mspc->ms_Node.xln_Name);)
					else 
					D(kprintf(" \(no current mspc\):");)
					D(kprintf("\n      ");)
				}
d106 11
a116 3
				if(debug && !string) 
				{ 
					struct Rect32 *oscan;
d118 5
a122 3
					D(kprintf(" origin x = %02lx",querymonitor.Origin >> 16);)
					D(kprintf(" y = %02lx",querymonitor.Origin & 0xFFFF);)
					D(kprintf(" \n      ");)
d124 4
a127 3
					D(kprintf(" minimum width  ");)
					D(kprintf(" %4ld",querymonitor.MinWide/queryinfo.AspectX);)
					D(kprintf(" \n      ");)
d129 5
a133 3
					D(kprintf(" minimum height ");)
					D(kprintf(" %4ld",querymonitor.MinHigh/queryinfo.AspectY);)
					D(kprintf(" \n      ");)
d135 3
a137 1
					oscan = &querymonitor.TxtOScan;
d139 3
a141 6
					D(kprintf(" text_oscan");)
					D(kprintf(" %4ld",oscan->MinX/(LONG)queryinfo.AspectX);)
					D(kprintf(" %4ld",oscan->MinY/(LONG)queryinfo.AspectY);)
					D(kprintf(" %4ld",oscan->MaxX/(LONG)queryinfo.AspectX);)
					D(kprintf(" %4ld",oscan->MaxY/(LONG)queryinfo.AspectY);)
					D(kprintf(" \n      ");)
d143 1
a143 1
					oscan = &querymonitor.StdOScan;
d145 6
a150 6
					D(kprintf(" std__oscan");)
					D(kprintf(" %4ld",oscan->MinX/(LONG)queryinfo.AspectX);)
					D(kprintf(" %4ld",oscan->MinY/(LONG)queryinfo.AspectY);)
					D(kprintf(" %4ld",oscan->MaxX/(LONG)queryinfo.AspectX);)
					D(kprintf(" %4ld",oscan->MaxY/(LONG)queryinfo.AspectY);)
					D(kprintf(" \n      ");)
d152 1
a152 1
					oscan = &querymonitor.MaxOScan;
d154 6
a159 6
					D(kprintf(" max__oscan");)
					D(kprintf(" %4ld",oscan->MinX/(LONG)queryinfo.AspectX);)
					D(kprintf(" %4ld",oscan->MinY/(LONG)queryinfo.AspectY);)
					D(kprintf(" %4ld",oscan->MaxX/(LONG)queryinfo.AspectX);)
					D(kprintf(" %4ld",oscan->MaxY/(LONG)queryinfo.AspectY);)
					D(kprintf(" \n      ");)
d161 1
a161 1
					oscan = &querymonitor.VideoOScan;
d163 6
a168 12
					D(kprintf(" videooscan");)
					D(kprintf(" %4ld",oscan->MinX/(LONG)queryinfo.AspectX);)
					D(kprintf(" %4ld",oscan->MinY/(LONG)queryinfo.AspectY);)
					D(kprintf(" %4ld",oscan->MaxX/(LONG)queryinfo.AspectX);)
					D(kprintf(" %4ld",oscan->MaxY/(LONG)queryinfo.AspectY);)
					D(kprintf(" \n      ");)
				}
			}
			else
			{
				if(!string) D(kprintf(" \(monitor_not_found\):");)
			}
d170 1
a170 5
		}
		else
		{
			if(!string) D(kprintf(" \(unavailable\):");)
		}
d172 6
a177 35
		if(norm = 
		GetDisplayInfoData(NULL,&querynorm,sizeof(querynorm),TAG_DIMS,ID))
		{
			if(!string) 
			{ 
				D(kprintf(" w %4ld",querynorm.Width);) 
				D(kprintf(" h %4ld",querynorm.Height);)
				D(kprintf(" d %1ld",querynorm.Depth );) 
			} 

			if( mntr && info )	
			{
				if( !queryinfo.Special )	
				{
					UWORD guns=querymonitor.ColorID >> 16;
					ULONG shades=pow((querymonitor.ColorID & 0xFFFF),guns);

					if(!string) 
					{ 
						D(kprintf("       %ld",pow(2,querynorm.Depth));) 

						if( guns > 1 ) 
						{
							D(kprintf(" colors out of %4ld shades\n",shades);) 
						} 
						else 
						{ 
							D(kprintf(" levels out of %4ld shades\n",shades);) 
						}
					}
				}
				else
				{
					if(!string) D(kprintf("       special  mode\n");)
				}
a178 1
		}
d181 1
a181 1
	return( (name && info && mntr && norm)? success : FALSE );
d227 1
a227 1
			WORD x_center = vp->DWidth >> 1;
d229 1
a229 1
			WORD width  =    vp->DWidth >> 2;
d231 1
a231 2
			(((LONG)(width * queryinfo.AspectX))/queryinfo.AspectY);

d355 1
a355 1
	ULONG DEPTH = querynorm.Depth;
d416 2
a417 2
	ULONG  WIDTH  = querynorm.Width;
	ULONG  HEIGHT = querynorm.Height;
d460 1
a460 1
						struct Rect32 *oscan = &querymonitor.StdOScan;
d464 4
a467 11
							vpx->DisplayClip.MinX =
								oscan->MinX/(LONG)queryinfo.AspectX;

							vpx->DisplayClip.MinY = 
								oscan->MinY/(LONG)queryinfo.AspectY;

							vpx->DisplayClip.MaxX =
								oscan->MaxX/(LONG)queryinfo.AspectX;

							vpx->DisplayClip.MaxY = 
								oscan->MaxY/(LONG)queryinfo.AspectY;
d496 1
a496 1
			view->Modes |= (LACE & queryinfo.ModeID);
a549 1
        Point p;
d560 2
a561 5
        p.x = querymonitor.Origin >> 16;
        p.y = querymonitor.Origin & 0xFFFF;

        view->DxOffset = p.x;
        view->DyOffset = p.y;
@


36.35
log
@max, vid oscan
@
text
@d5 1
a5 1
*	$Header: db.c,v 36.34 89/02/16 11:48:57 bart Exp $
a152 4
					D(kprintf(" \n      ");)

					D(kprintf(" dpmx %4ld",56320/queryinfo.AspectX);)
					D(kprintf(" dpmy %4ld",56320/queryinfo.AspectY);)
@


36.34
log
@queryname.Header.DisplayID
@
text
@d5 1
a5 1
*	$Header: db.c,v 36.33 89/02/16 11:04:53 bart Exp $
d131 18
@


36.33
log
@*** empty log message ***
@
text
@d5 1
a5 1
*	$Header: db.c,v 36.32 89/02/16 11:03:55 bart Exp $
d84 1
a84 1
		if(!string) D(kprintf("\nID%08lx: %s",queryname.DisplayID,queryname.Name);)
@


36.32
log
@*** empty log message ***
@
text
@d5 1
a5 1
*	$Header: db.c,v 36.31 89/02/16 11:02:46 bart Exp $
d472 1
a472 1
						struct Recr32 *oscan = &querymonitor.StdOScan;
@


36.31
log
@struct Rect32 *oscan
@
text
@d5 1
a5 1
*	$Header: db.c,v 36.30 89/02/16 11:00:10 bart Exp $
d472 1
a472 1
						struct DisplayOScan *oscan = &querymonitor.StdOScan;
@


36.30
log
@queryname.DisplayID
@
text
@d5 1
a5 1
*	$Header: db.c,v 36.29 89/02/16 10:54:47 bart Exp $
d105 1
a105 1
					struct DisplayOScan *oscan;
@


36.29
log
@DimensionInfo, NameInfo, MonitorInfo
@
text
@d5 1
a5 1
*	$Header: db.c,v 36.28 89/02/15 16:55:15 bart Exp $
d84 1
a84 1
		if(!string) D(kprintf("\n    %s",queryname.Name);)
@


36.28
log
@*** empty log message ***
@
text
@d5 1
a5 1
*	$Header: db.c,v 36.27 89/02/15 15:25:20 bart Exp $
d62 3
a64 3
struct DisplayName queryname;
struct DisplayNorm querynorm;
struct DisplayMonitor querymonitor;
@


36.27
log
@merged DisplaInfoDataBase with graphics
@
text
@d5 1
a5 1
*	$Header: db.c,v 36.26 89/02/15 14:11:29 bart Exp $
a21 2
#include <display/record.h>
#include <display/defines.h>
@


36.26
log
@*** empty log message ***
@
text
@d5 1
a5 1
*	$Header: db.c,v 36.25 89/02/15 14:04:03 bart Exp $
d34 1
a34 1
#define D(x) 	;
@


36.25
log
@*** empty log message ***
@
text
@d5 1
a5 1
*	$Header: db.c,v 36.24 89/02/14 18:19:54 bart Exp $
d582 2
a583 17
        p.x = view->DxOffset;
        p.y = view->DyOffset;

        /* transform default view position to this monitorspec */

        mspc_transform( mspc->ms_Node.xln_Library,
                mspc,
                &p,
                TO_MONITOR,
                &p);

        /* limit view position to legal bounds */

        p.x = MIN( p.x, mspc->ms_LegalView.MaxX );
        p.x = MAX( p.x, mspc->ms_LegalView.MinX );
        p.y = MIN( p.y, mspc->ms_LegalView.MaxY );
        p.y = MAX( p.y, mspc->ms_LegalView.MinY );
@


36.24
log
@checkpoint
@
text
@d5 1
a5 1
*	$Header: db.c,v 36.23 89/02/13 11:50:31 bart Exp $
a12 3
#include <display/display_base.h>
#include <display/record.h>
#include <display/defines.h>
d22 2
d30 1
a30 1
#define X(x) 	;
d33 1
d640 1
d644 1
a644 1
	if( GfxBase = OpenLibrary( "graphics.library", V1_POINT_4 ) )
d646 6
a651 1
		struct MonitorSpec *mspc, *OpenMonitor();
d653 3
a655 1
		X(kprintf("open: GfxBase = %lx\n",GfxBase);)
d657 1
a657 8
		if(!debug)
		{
			mspc = OpenMonitor( NULL, ID ) ;
		}
		else
		{
			mspc = OpenMonitor( NULL, NULL ) ;
		}
d659 1
a659 1
		if( mspc )
d661 1
a661 1
			struct View *view, *create_view();
d663 1
a663 1
			X(kprintf("open: mspc = %lx\n",mspc);)
d665 1
a665 1
			if( view = create_view( ID, mspc ) )
d667 1
a667 1
				struct ViewPort *vp, *create_vp();
d669 1
a669 1
				X(kprintf("open: view = %lx\n",view);)
d671 3
a673 1
				if( vp = create_vp( ID, view ) )
d675 1
a675 1
					struct BitMap *bm, *create_bm();
d677 1
a677 1
					X(kprintf("open: vp = %lx\n",vp);)
d679 1
a679 3
					view->ViewPort = vp;

					if( bm = create_bm( ID, vp ) )
d681 1
a681 1
						struct RasInfo *ri, create_ri();
d683 1
a683 1
						X(kprintf("open: bm = %lx\n",bm);)
d685 3
a687 1
						if( ri = create_ri( ID, bm ) )
d689 1
a689 1
							struct RastPort *rp, create_rp();
d691 1
a691 1
							X(kprintf("open: ri = %lx\n",ri);)
d693 1
a693 3
							vp->RasInfo = ri;

							if( rp = create_rp( ID, bm ) )
d695 2
a696 1
								/* show the productivity viewport */
d698 3
a700 1
								X(kprintf("open: rp = %lx\n",rp);)
d702 2
a703 14
								if(!(error = create_display(ID,vp,rp)))
								{
									struct View *restore_view;
									restore_view = GfxBase->ActiView;

									MakeVPort( view, vp );
									MrgCop( view );
									LoadView( view );

									X(kprintf("open: wait for CTRL_C\n");)
									Wait(SIGBREAKF_CTRL_C);
									
									LoadView( restore_view );
								}
d705 1
a705 1
								dispose_rp( rp );
d708 1
a708 1
							dispose_ri( ri );
d711 1
a711 1
						dispose_bm( bm );
d714 1
a714 1
					dispose_vp( vp );
d717 1
a717 1
				dispose_view( view );
d719 2
a720 6
			else
			{
				error = TRUE;
			}

			CloseMonitor( mspc );
d724 1
a724 1
				error = TRUE;
d727 1
a727 2
		
		CloseLibrary( GfxBase );
d731 1
a731 1
		error = TRUE;
d733 1
a733 1
	
d743 1
a743 2
	if( (argc) && (DisplayBase = (struct DisplayBase*)
				   OpenLibrary( DISPLAY_NAME, V1_POINT_4 )) )
d778 1
a778 2
		/* clean up and exit */
		CloseLibrary( DisplayBase );
@


36.23
log
@GetDisplayInfoData
@
text
@d5 1
a5 1
*	$Header: db.c,v 36.22 89/02/11 12:15:57 bart Exp $
d94 1
a94 1
		    GetDisplayInfoData(NULL,&querymonitor,sizeof(querymonitor),TAG_MSPC,ID))
d156 1
a156 1
		GetDisplayInfoData(NULL,&querynorm,sizeof(querynorm),TAG_NORM,ID))
@


36.22
log
@checkpoint
@
text
@d5 1
a5 1
*	$Header: db.c,v 36.21 89/02/11 11:06:06 bart Exp $
d83 2
a84 1
	if(name = QueryDisplayInfo(ID,&queryname,sizeof(queryname),TAG_NAME))
d90 2
a91 1
		if(info = QueryDisplayInfo(ID,&queryinfo,sizeof(queryinfo),TAG_DISP))
d94 1
a94 1
			   QueryDisplayInfo(ID,&querymonitor,sizeof(querymonitor),TAG_MSPC))
d155 2
a156 1
		if(norm = QueryDisplayInfo(ID,&querynorm,sizeof(querynorm),TAG_NORM))
@


36.21
log
@coalesce all info into displayinfo record, multiple monitorinfo chunks
@
text
@d5 1
a5 1
*	$Header: db.c,v 36.20 89/02/06 13:24:30 bart Exp $
@


36.20
log
@invalid id processing
@
text
@d5 1
a5 1
*	$Header: db.c,v 36.19 89/02/02 16:15:31 bart Exp $
d83 1
a83 1
	if(name = QueryDisplayName(ID,&queryname,sizeof(queryname),TAG_NAME))
d91 2
a92 1
			if(mntr = QueryDisplayMonitor(ID,&querymonitor,sizeof(querymonitor),TAG_MSPC))
d153 1
a153 1
		if(norm = QueryDisplayNorm(ID,&querynorm,sizeof(querynorm),TAG_NORM))
@


36.19
log
@*** empty log message ***
@
text
@d5 1
a5 1
*	$Header: db.c,v 36.18 89/02/02 16:07:45 bart Exp $
d196 1
a196 1
	ULONG       ID = NULL;
d203 1
a203 1
	do
a209 1
	while(ID = NextDisplayInfo( ID ));
@


36.18
log
@circle in the center
@
text
@d5 1
a5 1
*	$Header: db.c,v 36.17 89/02/02 15:03:55 bart Exp $
a244 3

        SetAPen(  rp,  -1 );
		SetDrMd(  rp,  JAM1 | COMPLEMENT );
@


36.17
log
@standard overscan
@
text
@d5 1
a5 1
*	$Header: db.c,v 36.16 89/02/02 13:54:05 bart Exp $
d235 1
a235 1
		/* square box in the center, 1/4 the width of the screen */
a236 1
			struct Rectangle square, *sq;
d243 1
a243 9
			sq = &square;

			sq->MinX = x_center - (width  >> 1);
			sq->MaxX = sq->MinX + (width      );
			sq->MinY = y_center - (height >> 1);
			sq->MaxY = sq->MinY + (height     );

			RectFill( rp, sq->MinX, sq->MinY, sq->MaxX, sq->MaxY );

@


36.16
log
@aspect ration processing
display a square square
@
text
@d5 1
a5 1
*	$Header: db.c,v 36.15 89/01/31 17:16:14 bart Exp $
a478 62
					{
						UWORD ratio = 0x0000002C/queryinfo.AspectX;

						X(kprintf("aspect_x == %lx\n",queryinfo.AspectX);)
						X(kprintf("ratio_x == %ld\n",ratio);)

						switch(ratio)
						{
							case(0): SHIFT_X = -1; break;
							case(1): SHIFT_X =  0; break;
							case(2): SHIFT_X =  1; break;
							case(3): SHIFT_X =  2; break;
							case(4): SHIFT_X =  2; break;
							case(5): SHIFT_X =  3; break;
							case(6): SHIFT_X =  3; break;
							case(7): SHIFT_X =  3; break;
							case(8): SHIFT_X =  3; break;
							default: break;
						}
					}
					{
						UWORD ratio = 0x00000034/queryinfo.AspectY;

						X(kprintf("aspect_y == %lx\n",queryinfo.AspectY);)
						X(kprintf("ratio_y == %ld\n",ratio);)

						switch(ratio)
						{
							case(0): SHIFT_Y = -1; break;
							case(1): SHIFT_Y =  0; break;
							case(2): SHIFT_Y =  1; break;
							case(3): SHIFT_Y =  2; break;
							case(4): SHIFT_Y =  2; break;
							case(5): SHIFT_Y =  3; break;
							case(6): SHIFT_Y =  3; break;
							case(7): SHIFT_Y =  3; break;
							case(8): SHIFT_Y =  3; break;
							default: break;
						}
					}

					X(kprintf("shift_x == %ld\n",SHIFT_X);)
					X(kprintf("shift_y == %ld\n",SHIFT_Y);)

					/* call mspc_oscan via assembly language interface */

					mspc_oscan( mspc->ms_Node.xln_Library,
								mspc,
								&rect,
								vp->Modes);

					rect.MaxX = rect.MaxX - rect.MinX + 1;
					rect.MaxY = rect.MaxY - rect.MinY + 1;

					/* adjust result for display mode */

					rect.MaxX <<= SHIFT_X;
					rect.MaxY <<= SHIFT_Y;

					rect.MaxX = MAX(rect.MinX + rect.MaxX - 1,0);
					rect.MaxY = MAX(rect.MinY + rect.MaxY - 1,0);

a480 1
					/* poof -- unless, of course, we don't */
a481 2

					if( vpx = GfxNew( VIEWPORT_EXTRA_TYPE ) )
d483 1
a483 2
						vpx->DisplayClip.MinX = rect.MinX - view->DxOffset;
						vpx->DisplayClip.MinY = rect.MinY - view->DyOffset;
d485 4
a488 2
						vpx->DisplayClip.MinX <<= SHIFT_X;
						vpx->DisplayClip.MinY <<= SHIFT_Y;
d490 2
a491 2
						vpx->DisplayClip.MaxX = rect.MaxX - rect.MinX + 1;
						vpx->DisplayClip.MaxY = rect.MaxY - rect.MinY + 1;
d493 2
a494 1
						/* specify displayclip as a rectangle structure */
d496 3
a498 2
						vpx->DisplayClip.MaxX += vpx->DisplayClip.MinX - 1;
						vpx->DisplayClip.MaxY += vpx->DisplayClip.MinY - 1;
@


36.15
log
@don't displayclip if a2024 for the moment
@
text
@d5 1
a5 1
*	$Header: db.c,v 36.14 89/01/27 14:29:12 bart Exp $
d233 24
a256 1
        SetDrMd(  rp,  JAM1 );
@


36.14
log
@*** empty log message ***
@
text
@d5 1
a5 1
*	$Header: db.c,v 36.13 89/01/26 17:41:43 bart Exp $
d235 18
d519 3
@


36.13
log
@final prototype version
@
text
@d5 1
a5 1
*	$Header: db.c,v 36.12 89/01/26 16:37:28 bart Exp $
d83 1
a83 1
	if(name = CookDisplayName(ID,&queryname,sizeof(queryname)))
d89 1
a89 1
		if(info = CookDisplayInfo(ID,&queryinfo,sizeof(queryinfo)))
d91 1
a91 1
			if(mntr = CookDisplayMonitor(ID,&querymonitor,sizeof(querymonitor)))
d152 1
a152 1
		if(norm = CookDisplayNorm(ID,&querynorm,sizeof(querynorm)))
@


36.12
log
@*** empty log message ***
@
text
@d5 1
a5 1
*	$Header: db.c,v 36.11 89/01/26 16:30:57 bart Exp $
d57 6
d564 3
a566 1
		if( vpx = GfxLookUp( vp ) )
d568 4
a571 1
			GfxFree( vpx );
@


36.11
log
@checkpoint
@
text
@d5 1
a5 1
*	$Header: db.c,v 36.10 89/01/26 14:59:39 bart Exp $
d785 1
a785 1
			if(argc == 2) 
@


36.10
log
@checkpoint
@
text
@d5 1
a5 1
*	$Header: db.c,v 36.9 89/01/26 14:47:30 bart Exp $
d783 3
a785 1
			if(argc == 2) if( STREQ(*(argv+1),"-debug") ) 
a786 1
				debug = TRUE;
@


36.9
log
@checkpoint
@
text
@d5 1
a5 1
*	$Header: db.c,v 36.8 89/01/26 14:30:42 bart Exp $
a43 2
#define EXTRA_DATA	/* display extra tag information */

d79 1
a79 1
		if(!string) { D(kprintf("\n    %s",queryname.Name);) }
d90 3
a92 7
					{
						D(kprintf(" \(%s\):",querymonitor.Mspc->ms_Node.xln_Name);)
					}
					else
					{
						D(kprintf(" \(no current mspc\):");) 
					}
d96 1
a96 2
#ifdef EXTRA_DATA
				if(!string) 
a133 1
#endif 
d137 1
a137 1
				if(!string) { D(kprintf(" \(monitor_not_found\):");) }
d143 1
a143 1
			if(!string) { D(kprintf(" \(unavailable\):");) 	}
d178 1
a178 1
					if(!string) { D(kprintf("       special  mode\n");) }
d783 20
a802 12
			while(--argc) 
			{	
				if( **(++argv) == '-' ) 
				{
					if( STREQ(*argv,"-debug") ) debug = TRUE;
					continue;
				}
				else
				{
					ULONG id = display_db(*argv);
					D(kprintf("db: open %s ID == 0x%08lx\n",*argv,id);)
					if(~id) error = open(id);
@


36.8
log
@*** empty log message ***
@
text
@d5 1
a5 1
*	$Header: db.c,v 36.7 89/01/26 13:55:15 bart Exp $
a104 4
					LONG    num = (ULONG *)querymonitor.MinWide;
					LONG	den;
					UWORD   x;
					UWORD   y;
d107 3
a109 2
					x = querymonitor.Origin >> 16;
					y = querymonitor.Origin & 0xFFFF;
d111 3
a113 2
					D(kprintf(" origin x = %02lx y = %02lx ", x, y);)
					D(kprintf("\n      ");)
d115 3
a117 1
					num = (ULONG *)querymonitor.MinWide;
a118 16
					D(kprintf(" minimum ");)

					den = queryinfo.AspectX;

					D(kprintf(" width  %4ld",num/den);)
					D(kprintf("\n      ");)

					num = (ULONG *)querymonitor.MinHigh;

					D(kprintf(" minimum ");)

					den = queryinfo.AspectY;
					D(kprintf(" height %4ld",num/den);)

					D(kprintf("\n      ");)

d122 5
a127 17
					den = queryinfo.AspectX;

					D(kprintf(" %4ld",oscan->MinX/den);)

					den = queryinfo.AspectY;

					D(kprintf(" %4ld",oscan->MinY/den);)

					den = queryinfo.AspectX;

					D(kprintf(" %4ld",oscan->MaxX/den);)
					den = queryinfo.AspectY;

					D(kprintf(" %4ld",oscan->MaxY/den);)

					D(kprintf("\n      ");)

d131 5
d137 3
a139 26
					den = queryinfo.AspectX;

					D(kprintf(" %4ld",oscan->MinX/den);)

					den = queryinfo.AspectY;

					D(kprintf(" %4ld",oscan->MinY/den);)

					den = queryinfo.AspectX;

					D(kprintf(" %4ld",oscan->MaxX/den);)
					den = queryinfo.AspectY;

					D(kprintf(" %4ld",oscan->MaxY/den);)
					D(kprintf("\n      ");)

					num = 0x0000DC00;
					den = queryinfo.AspectX;

					D(kprintf(" dpmx %4ld",num/den);)

					num = 0x0000DC00;
					den = queryinfo.AspectY;

					D(kprintf(" dpmy %4ld",num/den);)
					D(kprintf("\n      ");)
@


36.7
log
@*** empty log message ***
@
text
@d5 1
a5 1
*	$Header: db.c,v 36.6 89/01/26 11:43:39 bart Exp $
a68 34
UWORD udev( a, b )
ULONG a;
ULONG b;
{
	register LONG total = a; 
	register ULONG per = b; 
	register UWORD i;

	if(!per) return( NULL );

	for(i=0; total >= per; total -= per) i++;
	if( (total<<1) >= per) i++; 

	return( i );
}

WORD sdev( a, b )
LONG a;
ULONG b;
{
	register LONG total = (a < 0) ? -a : a ; 
	register ULONG per = b; 
	register UWORD i;

	if(!per) return( NULL );

	for(i=0; total >= per; total -= per) i++;
	if( (total<<1) >= per) i++; 

	if( a < 0 ) i = -i; 

	return( i );
}

d105 2
a106 2
					ULONG  tpm = (ULONG *)querymonitor.MinWide;
					ULONG	tpp;
d117 1
a117 1
					tpm = (ULONG *)querymonitor.MinWide;
d121 1
a121 1
					tpp = queryinfo.AspectX;
d123 1
a123 1
					D(kprintf(" width  %4ld",udev(tpm,tpp));)
d126 1
a126 1
					tpm = (ULONG *)querymonitor.MinHigh;
d130 2
a131 2
					tpp = queryinfo.AspectY;
					D(kprintf(" height %4ld",udev(tpm,tpp));)
d139 1
a139 1
					tpp = queryinfo.AspectX;
d141 1
a141 1
					D(kprintf(" %4ld",sdev(oscan->MinX,tpp));)
d143 1
a143 1
					tpp = queryinfo.AspectY;
d145 1
a145 1
					D(kprintf(" %4ld",sdev(oscan->MinY,tpp));)
d147 1
a147 1
					tpp = queryinfo.AspectX;
d149 2
a150 2
					D(kprintf(" %4ld",sdev(oscan->MaxX,tpp));)
					tpp = queryinfo.AspectY;
d152 1
a152 1
					D(kprintf(" %4ld",sdev(oscan->MaxY,tpp));)
d160 1
a160 1
					tpp = queryinfo.AspectX;
d162 1
a162 1
					D(kprintf(" %4ld",sdev(oscan->MinX,tpp));)
d164 1
a164 1
					tpp = queryinfo.AspectY;
d166 1
a166 1
					D(kprintf(" %4ld",sdev(oscan->MinY,tpp));)
d168 1
a168 1
					tpp = queryinfo.AspectX;
d170 2
a171 2
					D(kprintf(" %4ld",sdev(oscan->MaxX,tpp));)
					tpp = queryinfo.AspectY;
d173 1
a173 1
					D(kprintf(" %4ld",sdev(oscan->MaxY,tpp));)
d176 2
a177 2
					tpm = 0x0000DC00;
					tpp = queryinfo.AspectX;
d179 1
a179 1
					D(kprintf(" dpmx %4ld",udev(tpm,tpp));)
d181 2
a182 2
					tpm = 0x0000DC00;
					tpp = queryinfo.AspectY;
d184 1
a184 1
					D(kprintf(" dpmy %4ld",udev(tpm,tpp));)
d487 1
a487 1
						UWORD ratio = udev(0x0000002C,queryinfo.AspectX);
d507 1
a507 1
						UWORD ratio = udev(0x00000034,queryinfo.AspectY);
@


36.6
log
@viewportextra thru colormap
@
text
@d5 1
a5 1
*	$Header: db.c,v 36.5 89/01/26 11:35:45 bart Exp $
d44 1
a44 1
/* #define EXTRA_DATA */	/* display extra tag information */
a144 3
					D(kprintf(" ModeID = %08lx",queryinfo.ModeID);) 
					D(kprintf("\n      ");)

d210 1
a210 1
					tpm = 0xDD750000;
d215 1
a215 1
					tpm = 0xDD750000;
d521 1
a521 1
						UWORD ratio = udev(0x002C4A9A,queryinfo.AspectX);
d541 1
a541 1
						UWORD ratio = udev(0x0033A20A,queryinfo.AspectY);
@


36.5
log
@set viewportextra via colormap
@
text
@d5 1
a5 1
*	$Header: db.c,v 36.4 89/01/25 14:57:01 bart Exp $
@


36.4
log
@removed all voodoo
@
text
@d5 1
a5 1
*	$Header: db.c,v 36.3 89/01/25 14:52:49 bart Exp $
d54 1
d490 1
a490 1
		struct ViewPortExtra *vpx;
a504 26
		vc[0].ti_Data = vp;

		if(!debug) 
		{
			vc[1].ti_Data = (ULONG) FindDisplayInfo( ID );
		}
		else
		{
			vc[1].ti_Data = NULL;
		}

		/* get a full colormap */

		error = VideoControl( GetColorMap(32), vc );

		/* set the global lace */

		if(!error && !debug)
		{
			view->Modes |= (LACE & queryinfo.ModeID);
		}
		else
		{
			view->Modes |= (LACE & vp->Modes);
		}
	
a588 2
						GfxAssociate( vp, vpx ); 

d605 29
@


36.3
log
@*** empty log message ***
@
text
@d5 1
a5 1
*	$Header: db.c,v 36.2 89/01/25 14:12:57 bart Exp $
d44 1
a44 1
#define EXTRA_DATA		/* display extra tag information */
@


36.2
log
@*** empty log message ***
@
text
@d5 1
a5 1
*	$Header: db.c,v 36.1 89/01/25 14:10:01 bart Exp $
d274 1
a274 1
	return( success );
d291 1
a291 1
			if(!(~match_id)) match_id = ID;
d421 1
a421 3
	struct Record  *norm = FindDisplayNorm( ID );
	struct DisplayNorm *normal = NULL;
	ULONG DEPTH = 0;
a422 10
	if( norm )
	{
		normal = (struct DisplayNorm *) FindTag( &norm->rec_Tag, TAG_NORM );

		if( normal )
		{
			DEPTH = normal->Depth;
		}
	}

d482 2
a483 7
	struct Record      *mode   = FindDisplayInfo( ID );
	struct Record      *norm   = FindDisplayNorm( ID );
	struct DisplayInfo *info   = NULL;
	struct DisplayNorm *normal = NULL;
	struct TagItem     *item;
	ULONG  WIDTH  = 0;
	ULONG  HEIGHT = 0;
d485 2
a486 1
	if( mode )
d488 2
a489 1
		info = (struct DisplayInfo *) FindTag( &mode->rec_Tag, TAG_DISP );
d491 1
a491 3
		if( norm )
		{
			normal = (struct DisplayNorm *) FindTag( &norm->rec_Tag, TAG_NORM );
d493 1
a493 6
			if( normal )
			{
				WIDTH  = normal->Width;
				HEIGHT = normal->Height;
			}
		}
d495 1
a495 5
		if( WIDTH && HEIGHT )  
		if( vp = AllocMem( sizeof(*vp), MEMF_PUBLIC|MEMF_CLEAR ) )
		{
			int	error = FALSE;
			struct ViewPortExtra *vpx;
d497 1
a497 1
			InitVPort( vp );
d499 4
a502 1
			/* wow! -- 1.2 compatibility mode */
d504 1
a504 1
			vp->Modes    = (ID & 0xFFFF); 
d506 8
a513 1
			/* standard size and position productivity viewport */
d515 1
a515 4
			vp->DxOffset = 0;
			vp->DyOffset = 0;
			vp->DWidth   = WIDTH;
			vp->DHeight  = HEIGHT;
d517 1
a517 1
			vc[0].ti_Data = vp;
d519 1
a519 8
			if(!debug) 
			{
				vc[1].ti_Data = (ULONG) FindDisplayInfo( ID );
			}
			else
			{
				vc[1].ti_Data = NULL;
			}
d521 10
a530 1
			/* get a full colormap */
d532 3
a534 1
			error = VideoControl( GetColorMap(32), vc );
d536 1
a536 3
			/* set the global lace */

			if(!error && !debug)
d538 1
a538 8
				view->Modes |= (LACE & info->ModeID);
			}
			else
			{
				view->Modes |= (LACE & vp->Modes);
			}
		
			/* determine displayclip rectangle for this viewport */
d540 1
a540 5
			if (view->Modes & EXTEND_VSTRUCT)
			{
				struct ViewExtra *vx;

				if( vx = GfxLookUp( view ) )
d542 3
a544 1
					struct MonitorSpec *mspc;
d546 2
a547 1
					if( mspc = vx->Monitor )
d549 1
a549 3
						WORD  SHIFT_X =  0;
						WORD  SHIFT_Y =  0;
						struct Rectangle rect;
d551 2
a552 1
						X(kprintf("mspc == %lx\n",mspc);)
d554 1
d556 14
a569 1
							UWORD ratio = udev(0x002C4A9A,info->AspectX);
d571 2
a572 2
							X(kprintf("aspect_x == %lx\n",info->AspectX);)
							X(kprintf("ratio_x == %ld\n",ratio);)
d574 1
a574 14
							switch(ratio)
							{
								case(0): SHIFT_X = -1; break;
								case(1): SHIFT_X =  0; break;
								case(2): SHIFT_X =  1; break;
								case(3): SHIFT_X =  2; break;
								case(4): SHIFT_X =  2; break;
								case(5): SHIFT_X =  3; break;
								case(6): SHIFT_X =  3; break;
								case(7): SHIFT_X =  3; break;
								case(8): SHIFT_X =  3; break;
								default: break;
							}
						}
d576 10
a585 18
							UWORD ratio = udev(0x0033A20A,info->AspectY);

							X(kprintf("aspect_y == %lx\n",info->AspectY);)
							X(kprintf("ratio_y == %ld\n",ratio);)

							switch(ratio)
							{
								case(0): SHIFT_Y = -1; break;
								case(1): SHIFT_Y =  0; break;
								case(2): SHIFT_Y =  1; break;
								case(3): SHIFT_Y =  2; break;
								case(4): SHIFT_Y =  2; break;
								case(5): SHIFT_Y =  3; break;
								case(6): SHIFT_Y =  3; break;
								case(7): SHIFT_Y =  3; break;
								case(8): SHIFT_Y =  3; break;
								default: break;
							}
d587 1
d589 2
a590 2
						X(kprintf("shift_x == %ld\n",SHIFT_X);)
						X(kprintf("shift_y == %ld\n",SHIFT_Y);)
d592 1
a592 1
						/* call mspc_oscan via assembly language interface */
d594 4
a597 4
						mspc_oscan( mspc->ms_Node.xln_Library,
									mspc,
									&rect,
									vp->Modes);
d599 2
a600 2
						rect.MaxX = rect.MaxX - rect.MinX + 1;
						rect.MaxY = rect.MaxY - rect.MinY + 1;
d602 1
a602 1
						/* adjust result for display mode */
d604 2
a605 2
						rect.MaxX <<= SHIFT_X;
						rect.MaxY <<= SHIFT_Y;
d607 2
a608 2
						rect.MaxX = MAX(rect.MinX + rect.MaxX - 1,0);
						rect.MaxY = MAX(rect.MinY + rect.MaxY - 1,0);
d610 1
a610 1
						/* specify displayclip in view relative coordinates */
d612 3
a614 3
						if( vpx = GfxNew( VIEWPORT_EXTRA_TYPE ) )
						{
							GfxAssociate( vp, vpx ); 
d616 2
a617 2
							vpx->DisplayClip.MinX = rect.MinX - view->DxOffset;
							vpx->DisplayClip.MinY = rect.MinY - view->DyOffset;
d619 2
a620 2
							vpx->DisplayClip.MinX <<= SHIFT_X;
							vpx->DisplayClip.MinY <<= SHIFT_Y;
d622 2
a623 2
							vpx->DisplayClip.MaxX = rect.MaxX - rect.MinX + 1;
							vpx->DisplayClip.MaxY = rect.MaxY - rect.MinY + 1;
d625 1
a625 1
							/* specify displayclip as a rectangle structure */
d627 2
a628 3
							vpx->DisplayClip.MaxX += vpx->DisplayClip.MinX - 1;
							vpx->DisplayClip.MaxY += vpx->DisplayClip.MinY - 1;
						}
@


36.1
log
@CookDisplayMonitor
@
text
@d5 1
a5 1
*	$Header: db.c,v 36.0 89/01/25 13:20:01 bart Exp $
a119 1

d122 3
a124 3
					mspc = querymonitor.Mspc;

					if(!string) 
d126 1
a126 9
						if( mspc ) 
						{
							D(kprintf(" \(%s\):",mspc->ms_Node.xln_Name);)
						}
						else
						{
							D(kprintf(" \(no current mspc\):");) 
						}
						D(kprintf("\n      ");)
d128 6
d136 7
a142 7
					if(!string) 
					{ 
						ULONG  tpm = (ULONG *)querymonitor.MinWide;
						ULONG	tpp;
						UWORD   x;
						UWORD   y;
						struct DisplayOScan *oscan;
d144 2
a145 2
						D(kprintf(" ModeID = %08lx",queryinfo.ModeID);) 
						D(kprintf("\n      ");)
d147 2
a148 2
						x = querymonitor.Origin >> 16;
						y = querymonitor.Origin & 0xFFFF;
d150 2
a151 2
						D(kprintf(" origin x = %02lx y = %02lx ", x, y);)
						D(kprintf("\n      ");)
d153 1
a153 1
						tpm = (ULONG *)querymonitor.MinWide;
d155 1
a155 1
						D(kprintf(" minimum ");)
d157 1
a157 1
						tpp = queryinfo.AspectX;
d159 2
a160 2
						D(kprintf(" width  %4ld",udev(tpm,tpp));)
						D(kprintf("\n      ");)
d162 1
a162 1
						tpm = (ULONG *)querymonitor.MinHigh;
d164 1
a164 1
						D(kprintf(" minimum ");)
d166 2
a167 2
						tpp = queryinfo.AspectY;
						D(kprintf(" height %4ld",udev(tpm,tpp));)
d169 1
a169 1
						D(kprintf("\n      ");)
d171 1
a171 1
						oscan = &querymonitor.TxtOScan;
d173 1
a173 1
						D(kprintf(" text_oscan");)
d175 1
a175 1
						tpp = queryinfo.AspectX;
d177 1
a177 1
						D(kprintf(" %4ld",sdev(oscan->MinX,tpp));)
d179 1
a179 1
						tpp = queryinfo.AspectY;
d181 1
a181 1
						D(kprintf(" %4ld",sdev(oscan->MinY,tpp));)
d183 1
a183 1
						tpp = queryinfo.AspectX;
d185 2
a186 2
						D(kprintf(" %4ld",sdev(oscan->MaxX,tpp));)
						tpp = queryinfo.AspectY;
d188 1
a188 1
						D(kprintf(" %4ld",sdev(oscan->MaxY,tpp));)
d190 1
a190 1
						D(kprintf("\n      ");)
d192 1
a192 1
						oscan = &querymonitor.StdOScan;
d194 1
a194 1
						D(kprintf(" std__oscan");)
d196 1
a196 1
						tpp = queryinfo.AspectX;
d198 1
a198 1
						D(kprintf(" %4ld",sdev(oscan->MinX,tpp));)
d200 1
a200 1
						tpp = queryinfo.AspectY;
d202 1
a202 1
						D(kprintf(" %4ld",sdev(oscan->MinY,tpp));)
d204 1
a204 1
						tpp = queryinfo.AspectX;
d206 2
a207 2
						D(kprintf(" %4ld",sdev(oscan->MaxX,tpp));)
						tpp = queryinfo.AspectY;
d209 2
a210 2
						D(kprintf(" %4ld",sdev(oscan->MaxY,tpp));)
						D(kprintf("\n      ");)
d212 2
a213 2
						tpm = 0xDD750000;
						tpp = queryinfo.AspectX;
d215 1
a215 1
						D(kprintf(" dpmx %4ld",udev(tpm,tpp));)
d217 2
a218 2
						tpm = 0xDD750000;
						tpp = queryinfo.AspectY;
d220 3
a222 3
						D(kprintf(" dpmy %4ld",udev(tpm,tpp));)
						D(kprintf("\n      ");)
					}
@


36.0
log
@added to rcs for updating
@
text
@d5 1
a5 1
*	$Header: db.c,v 36.111 89/01/25 13:13:09 bart Exp $
d116 1
a116 1
		if( STREQ(queryname.Name,string)  ) success= TRUE;
a119 2
			struct Record *monitor = (struct Record *)
				   FindID( DisplayBase->Root , queryinfo.MspcID );
d121 1
a121 1
			if( monitor )
a122 9
				struct DisplayMonitor *display = (struct DisplayMonitor *)
					   FindTag( &monitor->rec_Tag, TAG_MSPC );

				if( mntr = display )
				{
					struct MonitorSpec *mspc;

					querymonitor = *display; /* no cooking yet */

a226 5
				}
				else
				{
					if(!string) { D(kprintf(" \(display_not_found\):");) }
				}
@
