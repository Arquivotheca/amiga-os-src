%
%	The ARexx User's Manual
%
% Copyright © 1987 by William S. Hawes.  All Rights Reserved.
%
\ifx\radeye\fmtversion\subdoc\else\input pmac \fi
%
% Second section of a long chapter!
%
\section{\chapterno-}{The Built-In Function Library}
This section of the chapter is devoted to descriptions of the individual
Built-In functions, which are listed alphabetically.
Many of the functions have optional as well as required arguments.
The optional arguments are shown in brackets,
and generally have a default value that is used if the argument is omitted.

\subsub{Maximum Arguments}.
While internal functions can be called with any number of arguments,
the Built-In functions (and external functions as well) are limited to a 
maximum of 15 arguments.

\subsub{Pad and Option Characters}.
For functions that accept a ``pad'' character argument, 
only the first character of the argument string is significant.
If a null string is supplied, 
the default padding character (usually a blank) will be used.
Similarly, where an option keyword is specified as an argument, 
only the first character is significant.  
Option keywords may be given in uppercase or lowercase.

\subsub{I/O Support Functions}.
\AR\ provides functions for creating and manipulating external DOS files.
The functions available at the present time are |OPEN()|, |CLOSE()|, 
|READCH()|, |READLN()|, |WRITECH()|, |WRITELN()|, |EOF()|, |SEEK()|, 
and |EXISTS()|.  
Files are referenced by a ``logical name,''
a case-sensitive name that is assigned to a file when it is first opened.  
There is no limit to the number of files that may be open simultaneously, 
and all open files are closed automatically when the program exits.

\subsub{Bit-Manipulation Functions}.
The functions |BITCHG()|, |BITCLR()|, |BITCOMP()|, |BITSET()|, and |BITTST()| 
are provided to implement extended bit-testing on character strings.  
These functions differ from similar string-manipulation functions in that 
the elementary unit of comparison is the bit rather than the byte.  
Bit numbers are defined such that bit 0 is the low-order bit of the 
rightmost byte of the string.  

\subsection{ABBREV()}%
\usage{|ABBREV(|string1,string2,[length]|)|}
Returns a boolean value that indicates whether \hp{string2} is an 
abbreviation of \hp{string1} with length greater than or equal to the 
specified \hp{length} argument.  
The default length is 0,
so the null string is an acceptable abbreviation.
\idxline{ABBREV(),}{Built-In function}

\begexamps
say abbrev('fullname','ful')    ==> 1
say abbrev('almost','alm',4)    ==> 0
say abbrev('any','')            ==> 1
#endverb

\subsection{ABS()}%
\usage{|ABS(|number|)|}
Returns the absolute value of the \hp{number} argument, which must be numeric.
\idxline{ABS(),}{Built-In function}

\begexamps
say abs(-5.35)                  ==> 5.35
say abs(10)                     ==> 10
#endverb

\subsection{ADDLIB()}%
\usage{|ADDLIB(|name,priority,[offset,version]|)|}
Adds a function library or a function host to the Library List maintained 
by the resident process.
The \hp{name} argument specifies either the name of a function library
or the public message port associated with a function host.
The name is case-sensitive, and any libraries thus declared should reside
in the system |LIBS:| directory.
The \hp{priority} argument specifies the search priority and must be an
integer between 100 and -100, inclusive.
The \hp{offset} and \hp{version} arguments apply only to libraries.
The \hp{offset} is the integer offset to the library's ``query'' entry 
point,
and the \hp{version} is an integer specifying the minimum acceptable release 
level of the library. 

The function returns a boolean result that indicates whether the operation
was successful.
Note that if a library is specified, it is not actually opened at this time;
similarly, no check is performed as to whether a specified function host port
has been opened yet.
\idxline{ADDLIB(),}{Built-In function}

\begexamp
say addlib("rexxsupport.library",0,-30,0) ==> 1
call addlib "EtherNet",-20      /* a gateway */
#endverb

\subsection{ADDRESS()}%
\usage{|ADDRESS()|}
Returns the current host address string.  
The host address is the message port to which commands will be sent.
THe |SHOW()| function can be used to check whether the required external
host is actually available.
\idxline{ADDRESS(),}{Built-In function}
\seealso{|SHOW()|}

\begexamp
say address()                   ==> REXX
#endverb

\subsection{ARG()}%
\usage{|ARG(|[number],[|'Exists'| |\|| |'Omitted'|]|)|}
|ARG()| returns the number of arguments supplied to the current environment.
If the \hp{number} parameter alone is supplied,
the corresponding argument string is returned.  
If a number and one of the keywords |Exists| or |Omitted| is given, 
the boolean return indicates the status of the corresponding argument.  
Note that the existence or omission test does not indicate whether the string
has a null value, 
but only whether a string was supplied.
\idxline{ARG(),}{Built-In function}

\begexamps
/* Assume arguments were: ('one',,10)           */
say arg()                       ==> 3
say arg(1)                      ==> one
say arg(2,'O')                  ==> 1
#endverb

\subsection{B2C()}%
\usage{|B2C(|string|)|}
Converts a string of binary digits (|0|, |1|) into the corresponding
(packed) character representation.
The conversion is the same as though the argument string had been specified
as a literal binary string (e.g. |'1010'B|).  
Blanks are permitted in the string,
but only at byte boundaries.
This function is particularly useful for creating strings that are to be 
used as bit masks.
\idxline{B2C(),}{Built-In function}
\seealso{|X2C()|}

\begexamps
say b2c('00110011')             ==> 3
say b2c('01100001')             ==> a
#endverb

\subsection{BITAND()}%
\usage{|BITAND(|string1,string2,[pad]|)|}
The argument strings are logically ANDed together,
with the length of the result being the longer of the two operand strings.  
If a pad character is supplied,
the shorter string is padded on the right; 
otherwise, the operation terminates at the end of the shorter string and 
the remainder of the longer string is appended to the result.
\idxline{BITAND(),}{Built-In function}

\begexamp
bitand('0313'x,'FFF0'x)         ==> '0310'x
#endverb

\subsection{BITCHG()}%
\usage{|BITCHG(|string,bit|)|}
Changes the state of the specified bit in the argument string.  
Bit numbers are defined such that bit 0 is the low-order bit of the 
rightmost byte of the string.
\idxline{BITCHG(),}{Built-In function}

\begexamp
bitchg('0313'x,4)               ==> '0303'x
#endverb

\subsection{BITCLR()}%
\usage{|BITCLR(|string,bit|)|}
Clears (sets to zero) the specified bit in the argument string.
Bit numbers are defined such that bit 0 is the low-order bit of the 
rightmost byte of the string.
\idxline{BITCLR(),}{Built-In function}

\begexamp
bitclr('0313'x,4)               ==> '0303'x
#endverb

\subsection{BITCOMP()}%
\usage{|BITCOMP(|string1,string2,[pad]|)|}
Compares the argument strings bit-by-bit, starting at bit number 0.  
The returned value is the bit number of the first bit in which the strings 
differ, or -1 if the strings are identical.
\idxline{BITCOMP(),}{Built-In function}

\begexamps
bitcomp('7F'x,'FF'x)            ==> 7
bitcomp('FF'x,'FF'x)            ==> -1
#endverb

\subsection{BITOR()}%
\usage{|BITOR(|string1,string2,[pad]|)|}
The argument strings are logically ORed together, with the length of the 
result being the longer of the two operand strings.  
If a \hp{pad} character is supplied,
the shorter string is padded on the right; 
otherwise, the operation terminates at the end of the shorter string and 
the remainder of the longer string is appended to the result.
\idxline{BITOR(),}{Built-In function}

\begexamp
bitor('0313'x,'003F'x)          ==> '033F'x
#endverb

\subsection{BITSET()}%
\usage{|BITSET(|string,bit|)|}
Sets the specified bit in the argument string is 1.
Bit numbers are defined such that bit 0 is the low-order bit of the
rightmost byte of the string.
\idxline{BITSET(),}{Built-In function}

\begexamp
bitset('0313'x,2)               ==> '0317'x
#endverb

\subsection{BITTST()}%
\usage{|BITTST(|string,bit|)|}
The boolean return indicates the state of the specified bit in the argument 
string.  
Bit numbers are defined such that bit 0 is the low-order bit of the 
rightmost byte of the string.
\idxline{BITTST(),}{Built-In function}

\begexamp
bittst('0313'x,4)               ==> 1
#endverb

\subsection{BITXOR()}%
\usage{|BITAND(|string1,string2,[pad]|)|}
The argument strings are logically exclusively-ORed together,
with the length of the result being the longer of the two operand strings.  
If a \hp{pad} character is supplied,
the shorter string is padded on the right; 
otherwise, the operation terminates at the end of the shorter string and 
the remainder of the longer string is appended to the result.
\idxline{BITXOR(),}{Built-In function}

\begexamp
bitxor('0313'x,'001F'x)         ==> '030C'x
#endverb

\subsection{C2B()}%
\usage{|C2B(|string|)|}
Converts the character string into the equivalent string of binary digits.
\idxline{C2B(),}{Built-In function}
\seealso{|C2X()|}

\begexamp
say c2b('abc')                  ==> 011000010110001001100011
#endverb

\subsection{C2D()}%
\usage{|C2D(|string,[n]|)|}
Converts the \hp{string} argument from its character representation to the 
corresponding decimal number, expressed as ASCII digits (|0|--|9|).
If \hp{n} is supplied, the character string is considered to be a number 
expressed in \hp{n} bytes.  
The string is truncated or padded with nulls on the left as required,
and the sign bit is extended for the conversion.
\idxline{C2D(),}{Built-In function}

\begexamps
say c2d('0020'x)                ==> 32
say c2d('FFFF')                 ==> -1
say c2d('FF0100'x,2)            ==> 256
#endverb

\subsection{C2X()}%
\usage{|C2X(|string|)|}
Converts the \hp{string} argument from its character representation to the 
corresponding hexadecimal number,
expressed as the ASCII characters |0|--|9| and |A|--|F|.
\idxline{C2X(),}{Built-In function}
\seealso{|C2B()|}

\begexamp
say c2x('abc')                  ==> 616263
#endverb

\page
\subsection{CENTER() or CENTRE()}%
\usage{|CENTER(|string,length,[pad]|)| or |CENTRE(|string,length,[pad]|)|}
Centers the \hp{string} argument in a string with the specified \hp{length}.
If the length is longer than that of the string, 
\hp{pad} characters or blanks are added as necessary.
\idxline{CENTER(),}{Built-In function}

\begexamps
say center('abc',6)             ==> ' abc  '
say center('abc',6,'+')         ==> '+abc++'
say center('123456',3)          ==> '234'
#endverb

\subsection{CLOSE()}%
\usage{|CLOSE(|file|)|}
Closes the file specified by the given logical name.  
The returned value is a boolean success flag, 
and will be 1 unless the specified file was not open.
\idxline{CLOSE(),}{Built-In function}

\begexamp
say close('input')              ==> 1
#endverb

\subsection{COMPRESS()}%
\usage{|COMPRESS(|string,[list]|)|}
If the \hp{list} argument is omitted,
the function removes leading, trailing, or embedded blank characters from 
the \hp{string} argument.
If the optional \hp{list} is supplied,
it specifies the characters to be removed from the string.
\idxline{COMPRESS(),}{Built-In function}

\begexamps
say compress('  why not ')      ==> whynot
say compress('++12-34-+','+-')  ==> 1234
#endverb

\subsection{COMPARE()}%
\usage{|COMPARE(|string1,string2,[pad]|)|}
Compares two strings and returns the index of the first position in which
they differ,
or 0 if the strings are identical.  
The shorter string is padded as required using the supplied character or 
blanks.
\idxline{COMPARE(),}{Built-In function}

\begexamps
say compare('abcde','abcce')     ==> 4
say compare('abcde','abcde')     ==> 0
say compare('abc++','abc+-','+') ==> 5
#endverb

\subsection{COPIES()}%
\usage{|COPIES(|string,number|)|}
Creates a new string by concatenating the specified number of copies of 
the original.
The \hp{number} argument may be zero,
in which case the null string is returned.
\idxline{COPIES(),}{Built-In function}

\begexamp
say copies('abc',3)             ==> abcabcabc
#endverb

\subsection{D2C()}%
\usage{|D2C(|number|)|}
Creates a string whose value is the binary (packed) representation of the 
given decimal number.
\idxline{D2C(),}{Built-In function}

\begexamp
d2c(31)                         ==> '1F'x
#endverb

\subsection{DATATYPE()}%
\usage{|DATATYPE(|string,[option]|)|}
If the \hp{option} parameter is not specified, |DATATYPE()| tests whether the 
\hp{string} parameter is a valid number and returns either |NUM| or |CHAR|.  
If an option keyword is given, 
the boolean return indicates whether the string satisfied the requested test.  
The following option keywords are recognized:
$$\vbox{\halign{\tt #\hfil&&\qquad#\hfil\cr
\multispan2\hfil Table \chapterno .1  |DATATYPE()| Options\hfil\cr
\bf Keyword&\bf Characters Accepted\cr
Alphanumeric&Alphabetics (A-Z,a-z)\cr 
            &or Numerics (0-9)\cr
Binary      &Binary Digits String\cr
Lowercase   &Lowercase Alphabetics (a-z)\cr
Mixed       &Mixed Upper/Lowercase\cr
Numeric     &Valid Numbers\cr
Symbol      &Valid REXX Symbols\cr
Upper       &Uppercase Alphabetics (A-Z)\cr
Whole       &Integer Numbers\cr
X           &Hex Digits String\cr}}$$
\idxline{DATATYPE(),}{Built-In function}

\begexamps
say datatype('123')             ==> NUM
say datatype('1a f2','x')       ==> 1
say datatype('aBcde','L')       ==> 0
#endverb

\subsection{DELSTR()}%
\usage{|DELSTR(|string,n,[length]|)|}
Deletes the substring of the \hp{string} argument beginning with the 
\hp{n}th character for the specified \hp{length} in characters.
The default length is the remaining length of the string.
\idxline{DELSTR(),}{Built-In function}

\begexamp
say delstr('123456',2,3)        ==> 156
#endverb

\page
\subsection{DELWORD()}%
\usage{|DELWORD(|string,n,[length]|)|}
Deletes the substring of the \hp{string} argument beginning with the 
\hp{n}th word for the specified \hp{length} in words.  
The default length is the remaining length of the string.  
The deleted string includes any trailing blanks following the last word.
\idxline{DELWORD(),}{Built-In function}

\begexamps
say delword('Tell me a story',2,2) ==> 'Tell story'
say delword('one two three',3)     ==> 'one two '
#endverb

\subsection{EOF()}%
\usage{|EOF(|file|)|}
Checks the specified logical file name and returns the boolean value 1 
({\bf True}) if the end-of-file has been reached, 
and 0 ({\bf False}) otherwise.
\idxline{EOF(),}{Built-In function}

\begexamp
say eof(infile)                 ==> 1
#endverb

\subsection{ERRORTEXT()}%
\usage{|ERRORTEXT(|n|)|}
Returns the error message associated with the specified \AR\ error code.
The null string is returned if the number is not a valid error code.
\idxline{ERRORTEXT(),}{Built-In function}

\begexamp
say errortext(41)               ==> Invalid expression
#endverb

\subsection{EXISTS()}%
\usage{|EXISTS(|filename|)|}
Tests whether an external file of the given \hp{filename} exists.  
The name string may include device and directory specifications. 
\idxline{EXISTS(),}{Built-In function}

\begexamp
say exists('df0:c/ed')          ==> 1 
#endverb

\subsection{EXPORT()}%
\usage{|EXPORT(|address,[string],[length],[pad]|)|}
Copies data from the (optional) string into a previously-allocated memory area,
which must be specified as a 4-byte address.
The \hp{length} parameter specifies the maximum number of characters to be 
copied;
the default is the length of the string.
If the specified length is longer than the string, 
the remaining area is filled with the \hp{pad} character or nulls (|'00'x|).
The returned value is the number of characters copied.

{\bf Caution is advised in using this function}.
Any area of memory can be overwritten,
possibly causing a system crash.  
Task switching is forbidden while the copy is being done, 
so system performance may be degraded if long strings are copied.
\idxline{EXPORT(),}{Built-In function}

\seealso{|IMPORT()|, |STORAGE()|}

\begexamp
count = export('0004 0000'x,'The answer')
#endverb

\subsection{FREESPACE()}%
\usage{|FREESPACE(|address,length|)|}
Returns a block of memory of the given length to the interpreter's internal 
pool.
The \hp{address} argument must be a 4-byte string obtained by a prior call to 
|GETSPACE()|, the internal allocator.
It is not always necessary to release internally-allocated memory,
since it will be released to the system when the program terminates.
However, if a very large block has been allocated,
returning it to the pool may avoid memory space problems.
The return value is a boolean success flag.
\idxline{FREESPACE(),}{Built-In function}

\seealso{|GETSPACE()|}

\begexamp
say freespace('00042000'x,32)   ==> 1
#endverb

\subsection{GETCLIP()}%
\usage{|GETCLIP(|name|)|}
Searches the Clip List for an entry matching the supplied \hp{name} parameter,
and returns the associated value string.
The name-matching is case-sensitive, 
and the null string is returned if the name cannot be found.  
The usage and maintenance of Clip List entries is described in the Chapter 9.
\idxline{GETCLIP(),}{Built-In function}

\seealso{|SETCLIP()|}

\begexamp
/* Assume 'numbers' contains 'PI=3.14159'       */
say getclip('numbers')          ==> PI=3.14159
#endverb

\subsection{GETSPACE()}%
\usage{|GETSPACE(|length|)|}
Allocates a block of memory of the specified length from the interpreter's 
internal pool.  
The returned value is the 4-byte address of the allocated block, 
which is not cleared or otherwise initialized.  
Internal memory is automatically returned to the system when the \AR\ program 
terminates, 
so this function should not be used to allocate memory for use by 
external programs.
The Support Library (described in Appendix D) includes the function 
|ALLOCMEM()| which to allocate memory from the system free list.
\idxline{GETSPACE(),}{Built-In function}

\seealso{|FREESPACE()|}

\begexamp
say c2x(getspace(32))           ==> '0003BF40'x
#endverb

\subsection{HASH()}%
\usage{|HASH(|string|)|}
Returns the hash attribute of a string as a decimal number, 
and updates the internal hash value of the string.
\idxline{HASH(),}{Built-In function}

\begexamp
say hash('1')                   ==> 49
#endverb

\subsection{IMPORT()}%
\usage{|IMPORT(|address,[length]|)|}
Creates a string by copying data from the specified 4-byte address.  
If the length parameter is not supplied, 
the copy terminates when a null byte is found.
\idxline{IMPORT(),}{Built-In function}

\seealso{|EXPORT()|}

\begexamp
extval = import('0004 0000'x,8)
#endverb

\subsection{INDEX()}%
\usage{|INDEX(|string,pattern,[start]|)|}
Searches for the first occurrence of the \hp{pattern} argument in the 
\hp{string} argument,
beginning at the specified \hp{start} position.
The default start position is 1.  
The returned value is the index of the matched pattern, 
or 0 if the pattern was not found.
\idxline{INDEX(),}{Built-In function}

\begexamps
say index("123456","23")        ==> 2
say index("123456","77")        ==> 0
say index("123123","23",3)      ==> 5
#endverb

\subsection{INSERT()}%
\usage{|INSERT(|new,old,[start],[length],[pad]|)|}
Inserts the \hp{new} string into the \hp{old} string after the specified 
\hp{start} position.  
The default starting position is 0.  
The new string is truncated or padded to the specified \hp{length} as required,
using the supplied pad character or blanks.
If the start position is beyond the end of the old string,
the old string is padded on the right.
\idxline{INSERT(),}{Built-In function}

\begexamps
say insert('ab','12345')        ==> ab12345
say insert('123','++',3,5,'-')  ==> ++-123--
#endverb

\subsection{LASTPOS()}%
\usage{|LASTPOS(|pattern,string,[start]|)|}
Searches backwards for the first occurrence of the \hp{pattern} argument
in the \hp{string} argument,
beginning at the specified \hp{start} position.  
The default starting position is the end of the string.
The returned value is the index of the matched pattern, 
or 0 if the pattern was not found.
\idxline{LASTPOS(),}{Built-In function}

\begexamps
say lastpos("123234","2")       ==> 4
say lastpos("123234","5")       ==> 0
say lastpos("123234","2",3)     ==> 2
#endverb

\subsection{LEFT()}%
\usage{|LEFT(|string,length,[pad]|)|}
Returns the leftmost substring in the given \hp{string} argument with the
specified \hp{length}.
If the substring is shorter than the requested length,
it is padded on the left with the supplied \hp{pad} character or blanks.
\idxline{LEFT(),}{Built-In function}

\begexamps
say left('123456',3)            ==> 123
say left('123456',8,'+')        ==> 123456++
#endverb

\subsection{LENGTH()}%
\usage{|LENGTH(|string|)|}
Returns the length of the string.
\idxline{LENGTH(),}{Built-In function}

\begexamp
say length('three')             ==> 5
#endverb

\subsection{MAX()}%
\usage{|MAX(|number,number[,number,...]|)|}
Returns the maximum of the supplied arguments,
all of which must be numeric.  
At least two parameters must be supplied.
\idxline{MAX(),}{Built-In function}

\begexamp
say max(2.1,3,-1)               ==> 3
#endverb

\subsection{MIN()}%
\usage{|MIN(|number,number[,number,...]|)|}
Returns the minimum of the supplied arguments,
all of which must be numeric. 
At least two parameters must be supplied.
\idxline{MIN(),}{Built-In function}

\begexamp
say min(2.1,3,-1)               ==> -1
#endverb

\subsection{OPEN()}%
\usage{|OPEN(|file,filename,[|'Append'| |\|| |'Read'| |\|| |'Write'|]|)|}
Opens an external file for the specified operation.
The \hp{file} argument defines the logical name by which the file will 
be referenced.
The \hp{filename} is the external name of the file,
and may include device and directory specifications.
The function returns a boolean value that indicates whether the operation 
was successful.
There is no limit to the number of files that can be open simultaneously,
and all open files are closed automatically when the program exits.
\idxline{OPEN(),}{Built-In function}

\seealso{|CLOSE()|, |READ()|, |WRITE()|}

\begexamps
say open('MyCon','CON:160/50/320/100/MyCon/cds')  ==> 1 
say open('outfile','ram:temp','W')                ==> 1
#endverb

\subsection{OVERLAY()}%
\usage{|OVERLAY(|new,old,[start],[length],[pad]|)|}
Overlays the \hp{new} string onto the \hp{old} string beginning at the 
specified \hp{start} position, 
which must be positive.
The default starting position is 1.  
The new string is truncated or padded to the specified \hp{length} as required,
using the supplied \hp{pad} character or blanks.
If the start position is beyond the end of the old string,
the old string is padded on the right.
\idxline{OVERLAY(),}{Built-In function}

\begexamps
say overlay('bb','abcd')        ==> bbcd
say overlay('4','123',5,5,'-')  ==> 123--4----
#endverb

\subsection{POS()}%
\usage{|POS(|pattern,string,[start]|)|}
Searches for the first occurrence of the \hp{pattern} argument in the 
\hp{string} argument,
beginning at the position specified by the \hp{start} argument.
The default starting position is 1.
The returned value is the index of the matched string, 
or 0 if the pattern wasn't found.
\idxline{POS(),}{Built-In function}

\begexamps
say pos('23','123234')          ==> 2
say pos('77','123234')          ==> 0
say pos('23','123234',3)        ==> 4
#endverb

\subsection{PRAGMA()}%
\usage{|PRAGMA(|option,[value]|)|}
This function allows a program to change various attributes relating to the 
system environment within which the program executes.
The {\it option} argument is a keyword that specifies an environmental 
attribute; the currently implemented options are |Directory| and |Priority|.
The {\it value} argument supplies the new attribute value to be installed.
The value returned by the function depends on the attribute selected.
Some attributes return the previous value installed,
while others may simply set a boolean success flag.
The currently defined option keywords are listed below.

\startlist
\item{$\bullet$} |Directory|.
Specifies a new ``current'' directory.
The current directory is used as the ``root'' for filenames that do not
explicitly include a device specification.
The return value is a boolean success flag.

\item{$\bullet$} |Priority|.
Specifies a new task priority.
The priority value must be an integer in the range -128 to 127, 
but the practical range is much more limited.
\AR\ programs should never be run at a priority higher than that of the
resident process, 
which currently runs at priority 4.
The returned value is the previous priority level.
\idxline{PRAGMA(),}{Built-In function}

\begexamps
say pragma('priority',-5)        ==> 0
call pragma 'Directory','df0:system'
#endverb

\subsection{RANDOM()}%
\usage{|RANDOM(|[min],[max],[seed]|)|}
Returns a pseudorandom integer in the interval specified by the {\it min} 
and {\it max} arguments.  
The default minimum value is 0 and the default maximum value is 999.
The interval |max-min| must be less than or equal to 1000.
If a greater range of random integers is required,
the values from the |RANDU()| function can be suitable scaled and translated.

The {\it seed} argument can be supplied to initialize the internal state
of the random number generator.
\idxline{RANDOM(),}{Built-In function}

\seealso{|RANDU()|}

\begexamp
thisroll = random(1,6)  /* might be 1   */ 
nextroll = random(1,6)  /* snake eyes?  */
#endverb

\subsection{RANDU()}%
\usage{|RANDU(|[seed]|)|}
Returns a uniformly-distributed pseudorandom number between 0 and 1.  
The number of digits of precision in the result is always equal to the 
current Numeric Digits setting.
With the choice of suitable scaling and translation values,
|RANDU()| can be used to generate pseudorandom numbers on an arbitrary 
interval.

The optional {\it seed} argument is used to initialize the internal state of
the random number generator.
\idxline{RANDU(),}{Built-In function}

\seealso{|RANDOM()|}

\begexamp
firsttry = randu()      /* 0.371902021? */ 
numeric digits 3
tryagain = randu()      /* 0.873?       */
#endverb

\subsection{READCH()}%
\usage{|READCH(|file,length|)|}
Reads the specified number of characters from the given logical file into 
a string.
The length of the returned string is the actual number of characters read,
and may be less than the requested length if, 
for example, the end-of-file was reached.
\idxline{READCH(),}{Built-In function}

\seealso{|READLN()|}

\begexamp
instring = readch('input',10)
#endverb

\subsection{READLN()}%
\usage{|READLN(|file|)|}
Reads characters from the given logical file into a string until a ``newline''
character is found.
The returned string does not include the ``newline.''
\idxline{READLN(),}{Built-In function}

\seealso{|READCH()|}

\begexamps
instring = readln('MyFile')
#endverb

\subsection{REMLIB()}%
\usage{|REMLIB(|name|)|}
Removes an entry with the given \hp{name} from the Library List maintained by 
the resident process.
The boolean return is 1 if the entry was found and successfully removed.
Note that this function does not make a distinction between function libraries
and function hosts,
but simply removes a named entry.
\idxline{REMLIB(),}{Built-In function}
\seealso{|ADDLIB()|}

\begexamp
say remlib('MyLibrary.library') ==> 1
#endverb

\subsection{REVERSE()}%
\usage{|REVERSE(|string|)|}
Reverses the sequence of characters in the string.
\idxline{REVERSE(),}{Built-In function}

\begexamp
say reverse('?ton yhw')         ==> why not?
#endverb

\subsection{RIGHT()}%
\usage{|RIGHT(|string,length,[pad]|)|}
Returns the rightmost substring in the given \hp{string} argument with 
the specified \hp{length}.
If the substring is shorter than the requested length,
it is padded on the left with the supplied \hp{pad} character or blanks.
\idxline{RIGHT(),}{Built-In function}

\begexamps
say right('123456',4)           ==> 3456
say right('123456',8,'+')       ==> ++123456
#endverb

\subsection{SEEK()}%
\usage{|SEEK(|file,offset,[|'Begin'| |\|| |'Current'| |\|| |'End'|]|)|}
Moves to a new position in the given logical file, 
specified as an offset from an anchor position.
The default anchor is |Current|.  
The returned value is the new position relative to the start of the file.
\idxline{SEEK(),}{Built-In function}

\begexamps
say seek('input',10,'B')        ==> 10
say seek('input',0,'E')         ==> 356  /* file length */
#endverb

\subsection{SETCLIP()}%
\usage{|SETCLIP(|name,[value]|)|}
Adds a name--value pair to the Clip List maintained by the resident process.
If an entry of the same name already exists,
its value is updated to the supplied value string.
Entries may be removed by specifying a null value.
The function returns a boolean value that indicates whether the operation
was successful.
\idxline{SETCLIP(),}{Built-In function}

\begexamps
say setclip('path','df0:s')     ==> 1
say setclip('path')             ==> 1
#endverb

\subsection{SHOW()}%
\usage{|SHOW(|option,[name],[pad]|)|}
Returns the names in the resource list specified by the \hp{option} argument,
or tests to see whether an entry with the specified \hp{name} is available.
The currently implemented options keywords are |Clip|, |Files|, |Libraries|,
and |Ports|, which are described below.
\startlist
\item{$\bullet$} |Clip|. Examines the names in the Clip List.

\item{$\bullet$} |Files|. Examines the names of the currently open logical 
file names.

\item{$\bullet$} |Libraries|. Examines the names in the Library List,
which are either function libraries or function hosts.

\item{$\bullet$} |Ports|. Examines the names in the system Ports List.
\endlist
\noindent
If the \hp{name} argument is omitted,
the function returns a string with the resource names separated by a blank
space or the \hp{pad} character, if one was supplied.
If the \hp{name} argument is given,
the returned boolean value indicates whether the name was found in the 
resource list.
The name entries are case-sensitive.
\idxline{SHOW(),}{Built-In function}

\subsection{SIGN()}%
\usage{|SIGN(|number|)|}
Returns 1 if the \hp{number} argument is positive or zero,
and -1 if \hp{number} is negative.
The argument must be numeric.
\idxline{SIGN(),}{Built-In function}

\begexamps
say sign(12)                    ==> 1
say sign(-33)                   ==> -1
#endverb

\subsection{SPACE()}%
\usage{|SPACE(|string,n,[pad]|)|}
Reformats the \hp{string} argument so that there are \hp{n} spaces 
(blank characters) between each pair of words.
If the \hp{pad} character is specified,
it is used instead of blanks as the separator character.  
Specifying \hp{n} as 0 will remove all blanks from the string.  
\idxline{SPACE(),}{Built-In function}

\begexamps
say space('Now is the time',3)  ==> 'Now   is   the   time'
say space('Now is the time,0)   ==> 'Nowisthetime'
say space('1 2 3',1,'+')        ==> '1+2+3'
#endverb

\subsection{STORAGE()}%
\usage{|STORAGE(|[address],[string],[length],[pad]|)|}
Calling |STORAGE()| with no arguments returns the available system memory.
If the \hp{address} argument is given, 
it must be a 4-byte string, 
and the function copies data from the (optional) \hp{string} into the 
indicated memory area.
The \hp{length} parameter specifies the maximum number of bytes to be copied,
and defaults to the length of the string.
If the specified length is longer than the string, 
the remaining area is filled with the \hp{pad} character or nulls (|'00'x|.)

The returned value is the previous contents of the memory area.
This can be used in a subsequent call to restore the original contents.

{\bf Caution is advised in using this function}.
Any area of memory can be overwritten,
possibly causing a system crash.
Task switching is forbidden while the copy is being done, 
so system performance may be degraded if long strings are copied.
\idxline{STORAGE(),}{Built-In function}

\seealso{|EXPORT()|}

\begexamps
say storage()                 ==> 248400
oldval = storage('0004 0000'x,'The answer')
call storage '0004 0000'x,,32,'+'
#endverb

\subsection{STRIP()}%
\usage{|STRIP(|string,[|\{'B'| |\|| |'L'| |\|| |'T'\}|],[pad]|)|}
If neither of the optional parameters is supplied, 
the function removes both leading and trailing blanks from the \hp{string} 
argument.  
The second argument specifies whether |Leading|, |Trailing|, or |Both| 
(leading and trailing) characters are to be removed.
The optional \hp{pad} (or unpad, perhaps) argument selects the character 
to be removed.
\idxline{STRIP(),}{Built-In function}

\begexamps
say strip('  say what?  ')      ==> 'say what?'
say strip('  say what?  ','L')  ==> 'say what?  '
say strip('++123+++','B','+')   ==> '123'
#endverb

\subsection{SUBSTR()}%
\usage{|SUBSTR(|string,start,[length],[pad]|)|}
Returns the substring of the \hp{string} argument beginning at the specified 
\hp{start} position for the specified \hp{length}.
The starting position must be positive,
and the default length is the remaining length of the string.
If the substring is shorter than the requested length,
it is padded on the left with the blanks or the specified \hp{pad} character.
\idxline{SUBSTR(),}{Built-In function}

\begexamps
say substr('123456',4,2)        ==> 45
say substr('myname',3,6,'=')    ==> name==
#endverb

\subsection{SUBWORD()}%
\usage{|SUBWORD(|string,n,[length]|)|}
Returns the substring of the \hp{string} argument beginning with the 
\hp{n}th word for the specified \hp{length} in words.
The default length is the remaining length of the string.  
The returned string will never have leading or trailing blanks.
\idxline{SUBWORD(),}{Built-In function}

\begexamp
say subword('Now is the time  ',2,2)  ==> is the
#endverb

\subsection{SYMBOL()}%
\usage{|SYMBOL(|name|)|}
Tests whether the \hp{name} argument is a valid REXX symbol.  
If the name is not a valid symbol, 
the function returns the string |BAD|.
Otherwise, 
the returned string is |LIT| if the symbol is uninitialized and |VAR| if 
it has been assigned a value.
\idxline{SYMBOL(),}{Built-In function}

\begexamps
say symbol('J')                 ==> VAR
say symbol('x')                 ==> LIT
say symbol('++')                ==> BAD
#endverb

\subsection{TIME()}%
\usage{|TIME(|option|)|}
Returns the current system time or controls the internal elapsed time counter.
The valid option keywords are listed below.
$$\vbox{\halign{\tt #\hfil&&\qquad#\hfil\cr
\multispan3\hfil Table \chapterno .2  TIME() Options\hfil\cr
\bf Option Keyword&\bf Description&\cr
Elapsed&Elapsed time in seconds\cr
Hours&Current time in hours since midnight\cr
Minutes&Current time in minutes since midnight\cr
Reset&Reset the elapsed time clock\cr
Seconds&Current time in seconds since midnight\cr}}$$
If no option is specified,
the function returns the current system time in the form |HH:MM:SS|.
\idxline{TIME(),}{Built-In function}

\begexamps
/* Suppose that the time is 1:02 AM ...         */
say time('Hours')               ==> 1
say time('m')                   ==> 62
say time('S')                   ==> 3720
call time 'R'                   /* reset timer  */
say time('E')                   ==> .020
#endverb

\subsection{TRACE()}%
\usage{|TRACE(|option|)|}
Sets the tracing mode to that specified by the \hp{option} keyword,
which must be one of the valid alphabetic or prefix options.  
The tracing options are described in Chapter 7.
The |TRACE()| function will alter the tracing mode even during interactive 
tracing, 
when |TRACE| instructions in the source program are ignored.  
The returned value is the mode in effect before the function call;
this allows the previous trace mode to be restored later.
\idxline{TRACE(),}{Built-In function}

\begexamp
/* Assume tracing mode is ?ALL                  */   
say trace('Results')            ==> ?A
#endverb

\subsection{TRANSLATE()}%
\usage{|TRANSLATE(|string,[output],[input],[pad]|)|}
This function constructs a translation table and uses it to replace selected 
characters in the argument string.  
If only the \hp{string} argument is given,
it is translated to uppercase.
If an \hp{input} table is supplied, 
it modifies the translation table so that characters in the argument string 
that occur in the input table are replaced with the corresponding character in 
the \hp{output} table.
Characters beyond the end of the output table are replaced with the specified
\hp{pad} character or a blank.

Note that the result string is always of the same length as the original 
string.
The input and output tables may be of any length.
\idxline{TRANSLATE(),}{Built-In function}

\begexamps
say translate("abcde","123","cbade","+")   ==> 321++
say translate("low")                       ==> LOW
say translate("0110","10","01")            ==> 1001
#endverb

\subsection{TRIM()}%
\usage{|TRIM(|string|)|}
Removes trailing blanks from the \hp{string} argument.
\idxline{TRIM(),}{Built-In function}

\begexamp
say length(trim(' abc  '))      ==> 4
#endverb

\subsection{UPPER()}%
\usage{|UPPER(|string|)|}
Translates the \hp{string} to uppercase.
The action of this function is equivalent to that of 
\hp{|TRANSLATE(|string|)|}, 
but it is slightly faster for short strings.
\idxline{UPPER(),}{Built-In function}

\begexamp
say upper('One Fine Day')       ==> ONE FINE DAY
#endverb

\subsection{VALUE()}%
\usage{|VALUE(|name|)|}
Returns the value of the symbol represented by the \hp{name} argument.
\idxline{VALUE(),}{Built-In function}

\begexamp
/* Assume that J has the value 12               */
say value('j')                  ==> 12
#endverb

\subsection{VERIFY()}%
\usage{|VERIFY(|string,list,[|'Match'|]|)|}
If the |Match| argument is omitted,
the function returns the index of the first character in the \hp{string} 
argument which is {\bf not} contained in the \hp{list} argument, 
or 0 if all of the characters are in the list.
If the |Match| keyword is supplied, 
the function returns the index of the first character which {\bf is} in 
the list, or 0 if none of the characters are.
\idxline{VERIFY(),}{Built-In function}

\begexamps
say verify('123456','0123456789')       ==> 0
say verify('123a56','0123456789')       ==> 4
say verify('123a45','abcdefghij','m')   ==> 4
#endverb

\subsection{WORD()}%
\usage{|WORD(|string,n|)|}
Returns the \hp{n}th word in the \hp{string} argument,
or the null string if there are fewer than \hp{n} words.
\idxline{WORD(),}{Built-In function}

\begexamp
say word('Now is the time  ',2)         ==> is
#endverb

\subsection{WORDINDEX()}%
\usage{|WORD(|string,n|)|}
Returns the starting position of the \hp{n}th word in the argument string, 
or 0 if there are fewer than \hp{n} words.
\idxline{WORDINDEX(),}{Built-In function}

\begexamp
say wordindex('Now is the time  ',3)    ==> 8
#endverb

\subsection{WORDLENGTH()}%
\usage{|WORDLENGTH(|string,n|)|}
Returns the length of the \hp{n}th word in the \hp{string} argument.
\idxline{WORDLENGTH(),}{Built-In function}

\begexamp
say wordlength('one two three',3)       ==> 5
#endverb

\subsection{WORDS()}%
\usage{|WORDS(|string|)|}
Returns the number of words in the \hp{string} argument.
\idxline{WORDS(),}{Built-In function}

\begexamp
say words("You don't say!")             ==> 3
#endverb

\subsection{WRITECH()}%
\usage{|WRITECH(|file,string|)|}
Writes the \hp{string} argument to the given logical file.
The returned value is the actual number of characters written.
\idxline{WRITECH(),}{Built-In function}

\begexamp
say writech('output','Testing')         ==> 7
#endverb

\subsection{WRITELN()}%
\usage{|WRITELN(|file,string|)|}
Writes the \hp{string} argument to the given logical file with a ``newline'' 
appended.  
The returned value is the actual number of characters written.
\idxline{WRITELN(),}{Built-In function}

\begexamp
say writeln('output','Testing')         ==> 8
#endverb

\subsection{X2C()}%
\usage{|X2C(|string|)|}
Converts a string of hex digits into the (packed) character representation.
Blank characters are permitted in the argument string at byte boundaries.
\idxline{X2C(),}{Built-In function}

\begexamps
say x2c('12ab')                 ==> '12ab'x
say x2c('12 ab')                ==> '12ab'x
#endverb

\subsection{XRANGE()}%
\usage{|XRANGE(|[start],[end]|)|}
Generates a string consisting of all characters numerically between the 
specified \hp{start} and \hp{end} values.
The default start character is |'00'x|, 
and the default end character is |'FF'x|.  
Only the first character of the \hp{start} and \hp{end} arguments is 
significant.
\idxline{XRANGE(),}{Built-In function}

\begexamps
say xrange()                    ==> '00010203 ... FDFEFF'x
say xrange('a','f')             ==> 'abcdef'
say xrange(,'10'x)              ==> '0001020304050607080910'x
#endverb

\thatsit
