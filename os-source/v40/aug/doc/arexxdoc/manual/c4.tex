%
%	The ARexx User's Manual
%
% Copyright © 1987 by William S. Hawes.  All Rights Reserved.
%
\ifx\radeye\fmtversion\subdoc\else\input pmac \fi

\chapter{Chapter}{4}{Instructions}%
Instruction clauses are identified by an initial keyword symbol that is not
followed by a colon (|:|) or an equals (|=|) operator.  
Each instruction signifies a specific action, 
and may be followed by one or more subkeywords, expressions, 
or other instruction-specific information.  
Instruction keywords and subkeywords are recognized only in this specific 
context, 
and are therefore not ``reserved words'' in the usual sense of the term.  
Keywords may be used freely as variables or function names, 
although such usage may become confusing at times.

In the descriptions that follow, 
keywords are shown in uppercase and optional parts of the instruction 
are enclosed in brackets.
Alternative selections are separated by a vertical bar (|\||), 
and required alternatives are enclosed in braces (|\{\}|).
\idxline{instruction clauses}{}

\section{\chapterno-}{ADDRESS}%
\usage{|ADDRESS| [symbol |\|| string |\|| [[|VALUE|] [expression]]}
This instruction specifies a \hp{host address} for commands issued by
the interpreter.
A host address is the name associated with an external program to which 
commands can be sent;
external hosts are described in Chapter 5.  
\AR\ maintains two host addresses:  a ``current'' and a ``previous'' value.  
Whenever a new host address is supplied, the ``previous'' address is lost, 
and the ``current'' address becomes the ``previous'' one.  
These host addresses are part of a program's storage environment and are 
preserved across internal function calls.  
The current address can be retrieved with the Built-In function |ADDRESS()|.
There are four distinct forms for the |ADDRESS| instruction: 
\idxline{host address}{}
\idxline{ADDRESS instruction}{}

\startlist
\item{$\bullet$} {\it |ADDRESS| |\{|string |\|| symbol|\}| expression}.
The expression is evaluated and the result is issued to the host specified
by the string or symbol,
which is taken as a literal.
No changes are made to the current or previous address strings.
This provides a convenient way to issue a single command to an external host
without disturbing the current host addresses.
The return code from the command is treated as it would be from a
command clause.

\item{$\bullet$} {\it |ADDRESS| |\{|string |\|| symbol|\}|}.
The string or symbol, taken as a literal, specifies the new host address. 
The current host address becomes the previous address.

\item{$\bullet$} {\it |ADDRESS| [|VALUE|] expression}.
The result of the expression specifies the new host address, 
and the current address becomes the previous address.
The |VALUE| keyword may be omitted if the first token of the expression is 
not a symbol or string.  

\item{$\bullet$} {\it |ADDRESS|}.
This form interchanges the current and previous hosts.  
Repeated execution will therefore ``toggle'' between the two host addresses.
\endlist

\begexamps
address edit            /* set an new host address      */
address edit 'top'      /* move to the top              */
address VALUE edit n    /* compute a new host address   */
address                 /* swap current and previous    */
#endverb%

\section{\chapterno-}{ARG}%
\usage{|ARG| [template] [,template ...]}
|ARG| is a shorthand form for the |PARSE UPPER ARG| instruction.  
It retrieves one or more of the argument strings available to the program, 
and assigns values to the variables in the template.
The number of argument strings available depends on the whether 
the program was invoked as a command or a function.
Command invocations normally have only one argument string,
but functions may have up to 15.
The argument strings are not altered by the |ARG| instruction.
\idxline{arguments,}{invocation}
\idxline{ARG instruction}{}

The structure and processing of templates is described briefly with the 
|PARSE| instruction, and in greater depth in Chapter 8.

\begexamp
arg first,second	/* fetch arguments	*/
#endverb%

\section{\chapterno-}{BREAK}%
\usage{|BREAK|}
The |BREAK| instruction is used to exit from the range of a |DO| instruction 
or from within an |INTERPRET|ed string, 
and is valid only in these contexts.
If used within a |DO| statement, 
|BREAK| exits from the innermost |DO| statement containing the |BREAK|.
This contrasts with the otherwise similar |LEAVE| instruction, 
which exits only from an iterative |DO|.
\idxline{BREAK instruction}{}

\begexamp
do                      /* begin block          */
   if i>3 then break    /* all done?            */
   a = a + 1
   y.a = name
   end                  /* end block            */
#endverb%

\section{\chapterno-}{CALL}%
\usage{|CALL| |\{|symbol |\|| string|\}| [expression] [,expression,...]}
The |CALL| instruction is used to invoke an internal or external function.  
The function name is specified by the symbol or string token,
which is taken as a literal.  
Any expressions that follow are evaluated and become the arguments 
to the called function.  
The value returned by the function is assigned to the special variable 
|RESULT|.  
It is not an error if a result string is not returned; 
in this case the variable |RESULT| is |DROP|ped (becomes uninitialized.)
\idxline{arguments,}{with CALL instruction}
\idxline{CALL instruction}{}

The linkage to the function is established dynamically at the time of the call.
\AR\ follows a specific search order in attempting to locate the called
function; 
this process is described in Chapter 6.
\idxline{RESULT,}{special variable}
\idxline{search order,}{function calls}

\begexamp
call center name,length+4,`+'
#endverb%

\page
\section{\chapterno-}{DO}%
\usage{|DO| [var=exp [|TO| exp] [|BY| exp]] [|FOR| exp] [|FOREVER|] 
[|WHILE| exp |\|| |UNTIL| exp]}
The |DO| instruction begins a group of instructions to be executed as a block.
The range of the |DO| instruction includes all statements up to and including 
an eventual |END| instruction.
There are two basic forms of the instruction:
\idxline{DO instruction}{}

\startlist
\item{$\bullet$} The |DO| keyword by itself defines a block of instructions
to be executed once.

\item{$\bullet$} If any iteration specifiers follow the |DO| keyword,
the block of instructions is executed repeatedly until a termination
condition occurs.
\endlist

An iterative |DO| instruction is sometimes called a ``loop'',
since the interpreter ``loops back'' to perform the instruction repeatedly.  
The various parts of the |DO| instruction are described below.

\subsub{Initializer expression}.
An initializer expression of the form ``|variable=expression|'' defines the 
\hp{index variable} of the loop.  
The expression is evaluated when the |DO| range is first activated, 
and the result is assigned to the index variable.  
On subsequent iterations an expression of the form
\hbox{``|variable = variable + increment|''} is evaluated, 
where the increment is the result of the |BY| expression.
If specified, 
the initializer expression must precede any of the other subkeywords.
\idxline{initializer expression}{}

\subsub{|BY| expression}.
The expression following a |BY| symbol defines the increment to be added to 
the index variable in each subsequent iteration.  
The expression must yield a numeric result,
which may be positive or negative and need not be an integer.
The default increment is 1.
\idxline{BY expression,}{with DO instruction}

\subsub{|TO| expression}.
The result of the |TO| expression specifies the upper (or lower) limit for 
the index variable.  
At each iteration the index variable is compared to the |TO| result.
If the increment (|BY| result) is positive and the variable is greater than 
the limit,
the |DO| instruction terminates and control passes to the statement following 
the |END| instruction. 
Similarly, the loop terminates if the increment is negative and the index 
variable is less than the limit.
\idxline{TO expression,}{with DO instruction}

\subsub{|FOR| expression}.
The |FOR| expression must yield a positive whole number when evaluated, 
and specifies the maximum number of iterations to be performed.  
The loop terminates when this limit is reached irrespective of the value 
of the index variable.
\idxline{FOR expression,}{with DO instruction}

\subsub{|FOREVER|}.
The |FOREVER| keyword can be used if an iterative |DO| instruction is required 
but no index variable is necessary.
Presumably the loop will be terminated by a |LEAVE| or |BREAK| instruction 
contained within the loop body.
\idxline{FOREVER,}{with DO instruction}

\subsub{|WHILE| expression}.
The |WHILE| expression is evaluated at the beginning of each iteration and 
must result in a boolean value.
The iteration proceeds if the result is 1; otherwise, the loop terminates.
\idxline{WHILE expression,}{with DO instruction}

\subsub{|UNTIL| expression}.
The |UNTIL| expression is evaluated at the end of each iteration and must
result in a boolean value.
The instruction continues with the next iteration if the result is 0, 
and terminates otherwise.
\idxline{UNTIL expression,}{with DO instruction}

The initializer, |BY|, |TO|, 
and |FOR| expressions are evaluated only when the instruction is first 
activated,
so the increment and limits are fixed throughout the execution.  
Note that a limit need not be supplied; 
for example, the instruction ``|DO| i=1'' will simply count away forever.
Note also that only one of the |WHILE| or |UNTIL| keywords can be specified.

\begexamp
do i=1 to limit for 5 while time < 50
   y.i = i*time
   end
#endverb

\section{\chapterno-}{DROP}%
\usage{|DROP| variable [variable...]}
The specified variable symbols are reset to their uninitialized state, 
in which the value of the variable is the variable name itself.
It is not an error to |DROP| a variable that is already uninitialized.
|DROP|ping a stem symbol is equivalent to |DROP|ping the values of all
possible compound symbols derived from that stem.
\idxline{DROP instruction}{}

\begexamp
a = 123                 /* assign a value       */
drop a b                /* drop some            */
say a b                 /* ==> A B              */
#endverb

\section{\chapterno-}{ECHO}%
\usage{|ECHO| [expression]}
The |ECHO| instruction is a synonym for the |SAY| instruction.
It displays the expression result on the console.
\idxline{ECHO instruction}{}

\begexamp
echo "You don't SAY!"
#endverb

\section{\chapterno-}{ELSE}%
\usage{|ELSE| [;] [conditional statement]}
The |ELSE| instruction provides the alternative conditional branch for an 
|IF| statement.  
It is valid only within the range of an |IF| instruction, 
and must follow the conditional statement of the |THEN| branch.  
If the |THEN| branch wasn't executed,
the statement following the |ELSE| clause is performed.  
\idxline{ELSE instruction}{}

\subsub{Binding}.
|ELSE| clauses always bind to the nearest (preceding) |IF| statement.
It may be necessary to provide ``dummy'' |ELSE| clauses for the inner |IF|
ranges of a compound |IF| statement in order to allow alternative branches 
for the outer |IF| statements.
In this case it is not sufficient to follow the |ELSE| with a semicolon 
or a null clause.
Instead, the |NOP| (no-operation) instruction can be used for this purpose.
\idxline{binding,}{with ELSE instruction}

\begexamp
if 1 > 2 then say 'really?'
         else say 'I thought so'
#endverb%

\section{\chapterno-}{END}%
\usage{|END| [variable]}
The |END| instruction terminates the range of a |DO| or |SELECT| instruction.
If the optional variable symbol is supplied,
it is compared to the index variable of the |DO| statement 
(which must therefore be iterative).
An error is generated if the symbols do not match, 
so this provides a simple mechanism for matching the |DO| and |END| statements. 
\idxline{END instruction}{}

\begexamp
do i=1 to 5             /* index variable is I  */
   say i
   end i                /* end ``I'' loop       */
#endverb%

\section{\chapterno-}{EXIT}%
\usage{|EXIT| [expression]}
The |EXIT| instruction terminates the execution of a program, 
and is valid anywhere within a program.  
The evaluated expression is passed back to the caller as the function or 
command result.
\idxline{EXIT instruction}{}

\subsub{Results Processing}.
The processing of the |EXIT| result depends on whether a result string was 
requested by the calling program, 
and whether the current invocation resulted from a command or function call.  
If a result string was requested, 
the expression result is copied to a block of allocated memory and a pointer
to the block is returned as the secondary result of the call.

If the caller did not request a result string, 
and the program was invoked as a command, 
then an attempt is made to convert the expression result to an integer.
This value is then returned as the primary result, 
with 0 as the secondary result.  
This allows the |EXIT| expression to be interpreted as a ``return code'' 
by the caller.
Refer to Chapter 10 for further information on the data structures used to
return the result string.
\idxline{Result string,}{from EXIT instruction}

\begexamps
exit                    /* no result needed     */
exit 12                 /* an error return?     */
#endverb%

\section{\chapterno-}{IF}%
\usage{|IF| expression [|THEN|] [;] [conditional statement]}
The |IF| instruction is used in conjunction with |THEN| and |ELSE| 
instructions to conditionally execute a statement.  
The result of the expression must be a boolean value.  
If the result is 1 ({\bf True}), 
the statement following the |THEN| symbol is executed; otherwise,
control passes to the next statement (which might be an |ELSE| clause.)
The |THEN| keyword need not immediately follow the |IF| expression, 
but may appear as a separate clause.  
The instruction is actually analyzed as 
\hbox{``|IF expression; THEN; statement;|.''}
In essence, the |IF| statement begins a syntactic range and establishes the
test condition that determines whether subsequent |THEN| or |ELSE| clauses
will be performed.
\idxline{IF instruction}{}

Any valid statement may follow the |THEN| symbol; in particular, 
a ``|DO; ... END;|'' group allows a series of statements to be performed
conditionally.

\begexamp
if result < 0 then exit  /* all done? */
#endverb

\section{\chapterno-}{INTERPRET}%
\usage{|INTERPRET| expression}
The expression is evaluated and the result is executed as one or more program 
statements.
The statements are considered as a group,
as though surrounded by a ``|DO; ...;END|'' combination.  
Any statements can be included in the |INTERPRET|ed source, 
including |DO| or |SELECT| instructions.
\idxline{INTERPRET instruction}{}

An |INTERPRET| instruction activates a control range when it is executed,
which serves as a ``fence'' for |LEAVE| and |ITERATE| instructions.  
These instructions can therefore be used only with |DO|-loops defined within 
the |INTERPRET|.
The |BREAK| instruction can be used to terminate the processing of
|INTERPRET|ed statements.
While it is not an error to include label clauses within the interpreted
string, 
only those labels defined in the original source code are searched during 
a transfer of control.

The |INTERPRET| instruction can be used to solve programming problems in
interesting and novel ways.
Programs can be constructed dynamically and then executed using this
instruction,
or program fragments may be passed as arguments to functions,
which then |INTERPRET| them.

\begexamp
inst = `say'            /* an instruction       */
interpret inst hello    /* ... "say HELLO"      */ 
#endverb

\section{\chapterno-}{ITERATE}%
\usage{|ITERATE| [variable]}
The |ITERATE| instruction terminates the current iteration of a
|DO| instruction and begins the next iteration.
Effectively, control passes to the |END| statement and then 
(depending on the outcome of the |UNTIL| expression) 
back to the |DO| statement.  
The instruction normally acts on the innermost iterative |DO| range containing 
the instruction.
An error results if the |LEAVE| instruction is not contained within an 
iterative |DO| instruction.
\idxline{ITERATE instruction}{}

The optional variable symbol specifies which |DO| range is to be exited,
in the event that several nested ranges exist.
The variable is taken as a literal and must match the index variable of 
a currently active |DO| instruction.
An error results if no such matching |DO| instruction is found.

\begexamp
do i=1 to 3
   if i = j then iterate i
   end
#endverb

\section{\chapterno-}{LEAVE}%
\usage{|LEAVE| [variable]}
|LEAVE| forces an immediate exit from the iterative |DO| range containing the 
instruction.  
An error results if the |LEAVE| instruction is not contained within
an iterative |DO| instruction.
\idxline{LEAVE instruction}{}

The optional variable symbol specifies which |DO| range is to be exited,
in the event that several nested ranges exist.
The variable is taken as a literal and must match the index variable of 
a currently active |DO| instruction.
An error results if no such matching |DO| instruction is found.

\begexamp
do i = 1 to limit
   if i > 5 then leave   /* maximum iterations   */
   end
#endverb

\section{\chapterno-}{NOP}%
\usage{|NOP|}
The |NOP| or ``no-operation'' instruction does just that:  nothing.  
It is provided to control the binding of |ELSE| clauses in compound |IF| 
statements.
\idxline{NOP instruction}{}

\begexamp
if i = j then           /* first (outer) IF     */
   if j = k then a = 0  /* inner IF             */
            else nop    /* binds to inner IF    */
   else a = a + 1       /* binds to outer IF    */
#endverb%

\section{\chapterno-}{NUMERIC}%
\usage{|NUMERIC \{DIGITS \| ~FUZZ\}| expression}
\useor{|NUMERIC FORM \{SCIENTIFIC \| ~ENGINEERING\}|}
This instruction sets options relating to the numeric precision and format.
The valid forms of the |NUMERIC| instruction are:
\idxline{NUMERIC instruction}{}

\startlist
\item{$\bullet$} {\it |NUMERIC DIGITS| expression}.
Specifies the number of digits of precision for arithmetic calculations.  
The expression must evaluate to a positive whole number.

\item{$\bullet$} {\it |NUMERIC FUZZ| expression}.
Specifies the number of digits to be ignored in numeric comparison operations.
This must be a positive whole number that is less than the current |DIGITS| 
setting.  

\item{$\bullet$} {\it |NUMERIC FORM SCIENTIFIC|}.
Specifies that numbers that require exponential notation be expressed in
|SCIENTIFIC| notation.
The exponent is adjusted so that the mantissa (for non-zero numbers) is 
between 1 and 10.
This is the default format.

\item{$\bullet$} {\it |NUMERIC FORM ENGINEERING|}.
Selects |ENGINEERING| format for numbers that require exponential notation.
|ENGINEERING| format normalizes a number so that its exponent is a multiple
of three and the mantissa (if not 0) is between 1 and 1000.
\endlist

\noindent
The numeric options are preserved when an internal function is called. 

\begexamps
numeric digits 12       /* precision            */	
numeric form scientific /* format               */
#endverb%

\section{\chapterno-}{OPTIONS}%
\usage{|OPTIONS| [|FAILAT| expression]}
\useor{|OPTIONS| [|PROMPT| expression]}
\useor{|OPTIONS| [|RESULTS|]}
The |OPTIONS| instruction is used to set various internal defaults.
The |FAILAT| expression sets the limit at or above which command return codes
will be signalled as errors, and must evaluate to an integer value.
The |PROMPT| expression provides a string to be used as the prompt with
the |PULL| (or |PARSE PULL|) instruction.
The |RESULTS| keyword indicates that the interpreter should request a result 
string when it issues commands to an external host.
\idxline{OPTIONS instruction}{}

The internal options controlled by this instruction are preserved across
function calls,
so an |OPTIONS| instruction can be issued within an internal function without
affecting the caller's environment.
If no keyword is specified with the |OPTIONS| instruction,
all controlled options revert to their default settings.

\begexamp
options failat 10
options prompt "Yes Boss?" 
options results
#endverb%

\section{\chapterno-}{OTHERWISE}%
\usage{|OTHERWISE| [;] [conditional statement]}
This instruction is valid only within the range of a |SELECT| instruction, 
and must follow the ``|WHEN ... THEN|'' statements.  
If none of the preceding |WHEN| clauses have succeeded, 
the statement following the |OTHERWISE| instruction is executed.  
An |OTHERWISE| is not mandatory within a |SELECT| range.
However, an error will result if the |OTHERWISE| clause is omitted and 
none of the |WHEN| instructions succeed.
\idxline{OTHERWISE instruction}{}

\begexamp
select	
   when i=1 then say `one'
   when i=2 then say `two'
   otherwise say `other'
   end
#endverb%

\page
\section{\chapterno-}{PARSE}%
\usage{|PARSE| [|UPPER|] inputsource [template] [,template...]}
The |PARSE| instruction provides a mechanism to extract one or more 
substrings from a string and assign them to variables.
The input string can come from a variety of sources, 
including argument strings, an expression, or from the console.  
The \hp{template} provides both the variables to be given values and the 
way to determine the value strings.  
The template may be omitted if the instruction is intended only to create 
the input string.
The different options of the instruction are described below.
\idxline{PARSE instruction}{}
\idxline{templates,}{with PARSE instruction}

\subsection{Input Sources}%
The sources for the input strings are specified by the keyword symbols 
listed below.  
When multiple templates are supplied, 
each template receives a new input string, 
although for some source options the new string will be identical to the 
previous one.
The input source string is copied before being parsed,
so the original strings are never altered by the parsing process.

\subsub{|UPPER|}.
This optional keyword may be used with any of the input sources, 
and specifies that the input string is to be translated to uppercase 
before being parsed.
It must be the first token following |PARSE|.
\idxline{UPPER,}{with PARSE instruction}

\startlist
\item{$\bullet$} {\it |ARG|}.
This input option retrieves the argument strings supplied when the 
program was invoked.  
Command invocations normally have only a single argument string, 
but functions may have up to 15 argument strings.  
Multiple templates may be given to retrieve successive argument strings.
\idxline{ARG,}{with PARSE instruction}

\item{$\bullet$} {\it |EXTERNAL|}.
The input string is read from the console.  
If multiple templates are supplied, each template will read a new string.
This source option is the same as |PULL|.
\idxline{EXTERNAL,}{with PARSE instruction}

\item{$\bullet$} {\it |NUMERIC|}.
The current numeric options are placed in a string in the order |DIGITS|, 
|FUZZ|, and |FORM|, separated by a single space.
\idxline{NUMERIC,}{with PARSE instruction}

\item{$\bullet$} {\it |PULL|}.
Reads a string from the input console.  
If multiple templates are supplied, each template will read a new string.
\idxline{PULL,}{with PARSE instruction}

\item{$\bullet$} {\it |SOURCE|}.
The ``source'' string for the program is retrieved.  
This string is formatted as 
\hbox{``|\{||COMMAND| |\|| |FUNCTION||\}| |\{|0 |\|| 1|\}| 
{\it called resolved ext host}.''}
The first token indicates whether the program was invoked as a command or 
as a function.
The second token is a boolean flag indicating whether a result string was
requested by the caller.  
The {\it called} token is the name used to invoke this program, 
while the {\it resolved} token is the final resolved name of the program.  
The {\it ext} token is the file extension to be used for searching 
(the default is ``REXX'').  
Finally, the {\it host} token is the initial host address for commands.
\idxline{SOURCE,}{with PARSE instruction}

\item{$\bullet$} {\it |VALUE| expression |WITH|}.
The input string is the result of the supplied expression.  
The |WITH| keyword is required to separate the expression from the template.  
The expression result may be parsed repeatedly by using multiple templates, 
but the expression is not reevaluated.
\idxline{VALUE,}{with PARSE instruction}

\item{$\bullet$} {\it |VAR| variable}.
The value of the specified variable is used as the input string.  
When multiple templates are provided, each template uses the current value 
of the variable.
This value may change if the variable is included as an assignment target 
in any of the templates.
\idxline{VAR,}{with PARSE instruction}

\item{$\bullet$} {\it |VERSION|}.
The current configuration of the \AR\ interpreter is supplied in the form 
\hbox{``{\it |\AR| version cpu mpu video freq}''}.
The {\it version} token is the release level of the interpreter,
formatted as |V1.0|.  
The {\it cpu} token indicates the processor currently running the program, 
and will be one of the values |68000|, |68010|, or |68020|.
The {\it mpu} token will be either |NONE| or |68881| depending on whether
a math coprocessor is available on the system.
The {\it video} token will indicate either |NTSC| or |PAL|,
and the {\it freq} token gives the clock (line) frequency as either |60HZ|
or |50HZ|.  
\idxline{VERSION,}{with PARSE instruction}
\endlist

\subsection{Templates}%
Parsing is controlled by a template, 
which may consist of symbols, strings, operators, and parentheses.  
During the parsing operation the input string is split into substrings that 
are assigned to the variable symbols in the template.  
The process continues until all of the variables in the template have been 
assigned a value; 
if the input string is ``used up'', 
any remaining variables are given null values.

Templates are described in depth in Chapter 8, 
so only a simplified description is presented here.  
The goal of the parsing operation is to associate a ``current'' and ``next''
position with each variable symbol in the template.  
The substring between these positions is then assigned as the value to 
the variable.  
There are three basic methods used to determine the value strings.

\subsub{Parsing by Tokenization}.
When a variable in the template is followed immediately by another variable,
the value string is determined by breaking the input string into words
separated by blanks.  
Each word is assigned to a variable in the template.
\idxline{Tokenization,}{parsing operation}

Values determined by tokenization will never have leading or trailing blanks. 
Normally the last variable in the template receives the untokenized remainder 
of the input string,
since it is not followed by a symbol.  
A ``placeholder'' symbol, signified by a period (.), 
may be used to force tokenization.  
Placeholders behave like variables in the template except that they are never
actually assigned a value.

\begexamp
/* Numeric string is: "9 0 SCIENTIFIC"  	*/
parse numeric digits fuzz form .
say digits              /* => 9                 */
say fuzz                /* => 0                 */
say form                /* => SCIENTIFIC        */
#endverb%

\subsub{Parsing by Position}.
If the fields in the input string have known positions, 
value strings can be specified by absolute or relative positions.  
Relative positions are indicated by a number preceded by a ``|+|'' or ``|-|''
operator.
Each positional marker updates the scan position in the string.
The value assigned to a variable is the string from the current position up to,
but not including, the next position in the string.

\begexamp
/* assume argument is "1234567890"              */
parse arg 1 a 3 b +2 1 c
say a b c               /* ==> 12 34 1234567890 */
#endverb%

\subsub{Parsing with Patterns}.
Fields in the input string separated by specific characters or strings can be
parsed using a pattern,
which is matched against the input string.
A pattern is specified in the template as a string token,
or alternatively as a symbol enclosed in parentheses.  
The position in the parse string matched by the pattern determines the 
value strings.
The pattern is removed from the input string when a match is found; 
this is the only parsing operation that modifies the input string.
\idxline{Patterns,}{in parsing}

\begexamp
check = `one,two,three'
parse var check a `,' b `,' c	
say a b c               /* ==> one two three    */
#endverb%

\section{\chapterno-}{PROCEDURE}%
\usage{|PROCEDURE| [|EXPOSE| variable [variable ...]]}
The |PROCEDURE| instruction is used within an internal function to create a 
new symbol table.  
This protects the symbols defined in the caller's environment from being 
altered by the execution of the function.
|PROCEDURE| is usually the first statement within the function, 
although it is valid anywhere withing the function body.  
It is an error to execute two |PROCEDURE| statements within the same function.
\idxline{PROCEDURE instruction}{}

\subsub{Exposing Variables}.
The |EXPOSE| subkeyword provides a selective mechanism for accessing the 
caller's symbol table, 
and for passing global variables to a function.  
The variables following the |EXPOSE| keyword are taken to refer to symbols
in the caller's table.  
Any subsequent changes made to these variables will be reflected in the
caller's environment.
\idxline{EXPOSE,}{ with PROCEDURE instruction}

The variables in the |EXPOSE| list may include stems or compound symbols, 
in which case the ordering of the variables becomes significant.
The |EXPOSE| list is processed from left to right, 
and compound symbols are expanded based on the values in effect in the 
new generation.
For example, 
suppose that the value of the symbol |J| in the previous generation is |123|,
and that |J| is uninitialized in the new generation.
Then |PROCEDURE EXPOSE J A.J| will expose |J| and |A.123|, 
whereas |PROCEDURE EXPOSE A.J J| will expose |A.J| and |J|.  
Exposing a stem has the effect of exposing all possible compound symbols 
derived from that stem.

\begexamp	
fact: procedure         /* a recursive function */
   arg i
   if i <= 1 
      then return 1
      else return i*fact(i-1)
#endverb%

\section{\chapterno-}{PULL}%
\usage{|PULL| [template] [,template...]}
This is a shorthand form of the |PARSE UPPER PULL| instruction.  
It reads a string from the input console, translates it to uppercase, 
and parses it using the template.
Multiple strings can be read by supplying additional templates.
The instruction will read from the console even if no template is given.
\idxline{PULL instruction}{}

Templates are described briefly with the |PARSE| instruction and in greater 
depth in Chapter 8.

\begexamp			
pull first last .       /* read names           */
#endverb

\section{\chapterno-}{PUSH}%
\usage{|PUSH| [expression]}
The |PUSH| instruction is used to prepare a stream of data to be read by
a command shell or other program.
It appends a ``newline'' to the result of the expression and then stacks or 
``pushes'' it into the |STDIN| stream.
Stacked lines are placed in the stream in ``last-in, first-out'' order,
and are then available to be read just as though they had been entered 
interactively.
For example, after issuing the instructions
\begprog
push line 1
push line 2
push line 3
\endverb
the stream would be read in the order ``|line 3|,'' ``|line 2|,'' and 
``|line 1|.''
\idxline{PUSH instruction}{}

There are several restrictions governing the use of the |PUSH| instruction 
and its alter ego |QUEUE|.
These instructions use a special I/O mechanism to accomplish their task,
and as a result can be used only with an interactive (stream-model) I/O device
like a console or pipe.
The stream must be managed by with a DOS handler that supports the special 
|ACTION\_STACK| (for |PUSH|) or |ACTION\_QUEUE| (for |QUEUE|) command.

|PUSH| allows the |STDIN| stream to be used as a private scratchpad 
to prepare data for subsequent processing.
For example, several files could be concatenated with delimiters between
them by simply reading the input files, 
|PUSH|ing the lines into the stream,
and inserting a delimiter where required.
Once the stacked lines are exhausted, 
the stream reverts to its normal source of data.
\idxline{STDIN stream,}{with PUSH instruction}

\begexamp
/* Stack commands for compile and link */
push "blink c.o+main.o library amiga.lib to myprog"
push "cc main"
#endverb

\page
\section{\chapterno-}{QUEUE}%
\usage{|QUEUE| [expression]}
The |QUEUE| instruction is used to prepare a stream of data to be read by
a command shell or other program.
It is very similar to the preceding |PUSH| instruction,
and differs only in that the data lines are placed in the |STDIN| stream 
in ``first-in, first-out'' order.
In this case the instructions
\begprog
queue line 1
queue line 2
queue line 3
\endverb
would be read in the order ``|line 1|,'' ``|line 2|,'' and ``|line 3|.''
The |QUEUE|d lines always precede all interactivly-entered lines,
and always follow any |PUSH|ed (stacked) lines.
\idxline{QUEUE instruction}{}

The same restrictions noted with the use of the |PUSH| instruction apply
to the |QUEUE| instruction.
The queueing mechanism uses the |ACTION\_QUEUE| command, 
so the DOS handler associated with the |STDIN| stream must support this 
command.
\idxline{STDIN stream,}{with PUSH instruction}

In most cases the choice of whether to use |PUSH| or |QUEUE| is just a
matter of convenience or personal preference.
Each of them provides a ``scratch pad'' facility similar to that provided
by an I/O pipe,
but useful within one program or task rather than just for interprocess 
communications.

\begexamp
/* Queue commands for compile and link */
queue "cc main"
queue "blink c.o+main.o library amiga.lib to myprog"
#endverb

\section{\chapterno-}{RETURN}%
\usage{|RETURN| [expression]}
|RETURN| is used to leave a function and return control to the point of the 
previous function invocation.  
The evaluated expression is returned as the function result.
If an expression is not supplied,
an error may result in the caller's environment.
Functions called from within an expression must return a result string, 
and will generate an error if no result is available.  
Function invoked by the |CALL| instruction need not return a result. 
\idxline{RETURN instruction}{}

A |RETURN| issued from the base environment of a program is not an error, 
and is equivalent to an |EXIT| instruction.  
Refer to the |EXIT| instruction for a description of how result strings 
are passed back to an external caller.
\idxline{result string}{from RETURN instruction}

\begexamp
return 6*7              /* the answer           */
#endverb					

\page
\section{\chapterno-}{SAY}%
\usage{|SAY| [expression]}
The result of the evaluated expression is written to the output console, 
with a ``newline'' character appended.  
If the expression is omitted,
a null string is sent to the console.
\idxline{SAY instruction}{}

\begexamp
say `The answer is ' value
#endverb

\section{\chapterno-}{SELECT}%
\usage{|SELECT|}
This instruction begins a group of instructions containing one or more 
|WHEN| clauses and possibly a single |OTHERWISE| clause, 
each followed by a conditional statement.

Only one of the conditional statements within the |SELECT| group will be 
executed.  
Each |WHEN| statement is executed in succession until one succeeds; 
if none succeeds,
the |OTHERWISE| statement is executed.
The |SELECT| range must be terminated by an eventual |END| statement.
\idxline{SELECT instruction}{}
\idxline{WHEN instruction,}{in SELECT range}
\idxline{OTHERWISE instruction,}{in SELECT range}

\begexamp
select	
   when i=1 then say `one'
   when i=2 then say `two'
   otherwise say `other'
   end
#endverb%

\section{\chapterno-}{SHELL}%
\usage{|SHELL| [symbol |\|| string] [expression]}
The |SHELL| instruction is a synonym for the |ADDRESS| instruction.
\idxline{SHELL instruction}{}

\begexamp
shell edit              /* set host to `EDIT'   */
#endverb

\section{\chapterno-}{SIGNAL}%
\usage{|SIGNAL| |\{ON \| OFF\}| condition}
\useor{|SIGNAL| [|VALUE|] expression}
There are two forms of the |SIGNAL| instruction.
The first form illustrated controls the state of the internal interrupt flags.
Interrupts allow a program to detect and retain control when certain errors 
occur, 
and are discussed in Chapter 7.
In this form |SIGNAL| must be followed by one of the keywords |ON| or |OFF| 
and one of the condition keywords listed below.
The interrupt flag specified by the condition symbol is then set to the 
indicated state.
The valid signal conditions are:
\startlist
\item{$\bullet$} |BREAK\_C|~~A ``control-C'' break was detected.

\item{$\bullet$} |BREAK\_D|~~A ``control-D'' break was detected.

\item{$\bullet$} |BREAK\_E|~~A ``control-E'' break was detected.

\item{$\bullet$} |BREAK\_F|~~A ``control-F'' break was detected.

\item{$\bullet$} |ERROR|~~A host command returned a non-zero code.

\item{$\bullet$} |HALT|~~An external HALT request was detected.	

\item{$\bullet$} |IOERR|~~An error was detected by the I/O system.

\item{$\bullet$} |NOVALUE|~~An uninitialized variable was used.

\item{$\bullet$} |SYNTAX|~~A syntax or execution error was detected.
\endlist
\noindent
The condition keywords are interpreted as labels to which control will be
transferred if the selected condition occurs.
For example,
if the |ERROR| interrupt is enabled and a command returns a non-zero code, 
the interpreter will transfer control to the label |ERROR:|.
The condition label must of course be defined in the program;
otherwise, an immediate |SYNTAX| error results and the program exits. 
\idxline{SIGNAL instruction}{}

In the second form of the instruction,
the tokens following |SIGNAL| are evaluated as an expression.  
An immediate interrupt is generated that transfers control to the label 
specified by the expression result.
The instruction thus acts as a ``computed goto.''

\subsub{Interrupts}.
Whenever an interrupt occurs,
all currently active control ranges 
(|IF|, |DO|, |SELECT|, |INTERPRET|, or interactive |TRACE|) 
are dismantled before the transfer of control.  
Thus, the transfer cannot be used to jump into the range of a |DO|-loop or 
other control structure.
Only the control structures in the current environment are affected by a
|SIGNAL| condition,
so it is safe to |SIGNAL| from within an internal function without 
affecting the state of the caller's environment.  
\idxline{Interrupts,}{with SIGNAL instruction}

\subsub{Special Variables}.
The special variable |SIGL| is set to the current line number whenever
a transfer of control occurs.
The program can inspect |SIGL| to determine which line was being executed 
before the transfer.  
If an |ERROR| or |SYNTAX| condition causes an interrupt,
the special variable |RC| is set to the error code that triggered the 
interrupt.
For the |ERROR| condition,
this code is usually an error severity level.  
The |SYNTAX| condition will always indicate an \AR\ error code.
\idxline{SIGL variable,}{with interrupts}
\idxline{RC variable,}{with interrupts}

\begexamps
signal on error         /* enable interrupt     */
signal off syntax       /* disable SYNTAX       */
signal start            /* goto START           */
#endverb%

\section{\chapterno-}{THEN}%
\usage{|THEN| [;] [conditional statement]}
The |THEN| instruction must be the next statement following an |IF| or |WHEN| 
instruction,
and is valid only in that context.  
It tests whether the preceding expression evaluated to 1 ({\bf True}), 
in which case the conditional statement following the |THEN| is performed.
If the expression result was a 0 ({\bf False}),
the conditional statement is skipped.
\idxline{THEN instruction}{}

\begexamp
if i = j 
   then say `equal'
   else say `not equal'
#endverb%

\section{\chapterno-}{TRACE}%
\usage{|TRACE| [symbol |\|| string |\|| [[|VALUE|] expression]]}
The |TRACE| instruction is used to set the internal tracing mode.
If a symbol or string is supplied,
it is taken as a literal. 
Otherwise,
the tokens following the |VALUE| keyword are evaluated as an expression.  
The |VALUE| keyword can be omitted if the expression doesn't start with a 
symbol or string token.
\idxline{TRACE instruction}{}

In either case the result string is converted to uppercase and checked first 
for one of the ``alphabetic'' options.
The valid alphabetic options are |ALL|, |COMMANDS|, |ERRORS|, |INTERMEDIATES|,
|LABELS|, |RESULTS|, and |SCAN|.
These can be spelled out in full or shortened to the initial character,
and are described in Chapter 7.  
If the result doesn't match any of these options, 
the interpreter attempts to convert it to an integer.  
A conversion failure here will be reported as an error.
\idxline{alphabetic option}{}

\subsub{Prefix Characters}.
Two special symbol characters may precede any of the alphabetic keywords.  
The ``|?|'' character controls {\it interactive tracing}, 
and the ``|!|'' character controls {\it command inhibition}.  
These characters act as ``toggles'' to alternatively select and de-select 
the respective modes.  
Any number of prefix characters may precede an alphabetic option.
Interactive tracing and command inhibition are described in Chapter 7.
\idxline{Prefix Characters}{with TRACE}
\idxline{command inhibition}{}
\idxline{interactive tracing}{}

\subsub{Numeric Option}.
If the specified trace option is a negative whole number, 
it is accepted as a trace suppression count.
The suppression count is the number of clauses (that would otherwise be traced)
to be passed over before resuming the tracing display.  
Suppression counts are ignored except during interactive tracing.

\begexamps
trace ?r                /* interactive RESULTS  */
trace off
trace -20               /* skip 20 clauses      */
#endverb%

\section{\chapterno-}{UPPER}%
\usage{|UPPER| variable [variable ...]}
The values of the variables in the list are converted to uppercase.
It is not an error to include an uninitialized variable in the list, 
but it will be trapped if the |NOVALUE| interrupt has been enabled.
\idxline{UPPER instruction}{}
\idxline{uninitialized variable,}{with UPPER instruction}

The |TRANSLATE()| or |UPPER()| Built-In functions could also be used to
convert variables to uppercase,
but the instruction form is more concise (and faster) if several variables 
are being converted.

\begexamp
when = 'Now is the time'
upper when
say when                /* NOW IS THE TIME      */
#endverb%

\section{\chapterno-}{WHEN}%
\usage{|WHEN| expression [|THEN| [;] [conditional statement]]}
The |WHEN| instruction is similar to the |IF| instruction, 
but is valid only within a |SELECT| range.  
Each |WHEN| expression is evaluated in turn and must result in a boolean value.
If the result is a 1,
the conditional statement is executed and control passes to the |END| 
statement that terminates the |SELECT|.  
As in the case of the |IF| instruction,
the |THEN| need not be part of the same clause.
\idxline{WHEN instruction}{}

\begexamp
select;
   when i<j then say `less'
   when i=j then say `equal'
   otherwise     say `greater'
   end
#endverb%

\thatsit
