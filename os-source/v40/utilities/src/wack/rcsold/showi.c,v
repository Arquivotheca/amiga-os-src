head     1.14;
branch   ;
access   ;
symbols  ;
locks    ; strict;
comment  @ * @;


1.14
date     91.05.29.08.48.03;  author peter;  state Exp;
branches ;
next     1.13;

1.13
date     91.04.24.20.50.46;  author peter;  state Exp;
branches ;
next     1.12;

1.12
date     90.03.20.17.53.06;  author jimm;  state Exp;
branches ;
next     1.11;

1.11
date     90.01.17.18.59.03;  author jimm;  state Exp;
branches ;
next     1.10;

1.10
date     90.01.15.18.06.37;  author jimm;  state Exp;
branches ;
next     1.9;

1.9
date     90.01.15.17.18.33;  author jimm;  state Exp;
branches ;
next     1.8;

1.8
date     90.01.15.12.29.25;  author jimm;  state Exp;
branches ;
next     1.7;

1.7
date     89.09.21.19.35.42;  author jimm;  state Exp;
branches ;
next     1.6;

1.6
date     88.01.22.13.48.26;  author jimm;  state Exp;
branches ;
next     1.5;

1.5
date     88.01.21.18.20.29;  author jimm;  state Exp;
branches ;
next     1.4;

1.4
date     88.01.21.17.55.19;  author jimm;  state Exp;
branches ;
next     1.3;

1.3
date     88.01.21.17.19.47;  author jimm;  state Exp;
branches ;
next     1.2;

1.2
date     88.01.21.13.38.06;  author root;  state Exp;
branches ;
next     1.1;

1.1
date     88.01.21.13.08.15;  author jimm;  state Exp;
branches ;
next     ;


desc
@@


1.14
log
@Added dumpIText().
@
text
@/* showi.c : wack "show intuition" functions.
 * $Id: showi.c,v 1.13 91/04/24 20:50:46 peter Exp Locker: peter $
 */

#include "exec/types.h"
#include "exec/nodes.h"
#include "exec/lists.h"
#include "exec/interrupts.h"
#include "exec/memory.h"
#include "exec/ports.h"
#include "exec/libraries.h"
#include "exec/devices.h"
#include "exec/tasks.h"
#include "exec/resident.h"
#include "exec/execbase.h"

#include "exec/semaphores.h"

#include "libraries/dos.h"
#include "libraries/dosextens.h"

#include "symbols.h"
#include "special.h"

#if 0
#include "intuall.h"
#undef printf
/***
#include "intuition.h"
#include "intuinternal.h"
#include "intuitionbase.h"
#include "screens.h"
***/

#else
#include "intuition/iprefs.h"
#include "intuition/sc.h"
#include "intuition/i.h"
#include "intuition/intuinternal.h"
#include "intuition/ifunctions.h"
#endif

extern APTR CurrAddr;
extern APTR SpareAddr;
extern struct Window *LastWindow;

/** Screens **/

ULONG dumpXScreen(addr, s)
APTR addr;
struct Screen *s;
{
    struct ViewPortExtra vpextra;
    struct PubScreenNode	psn;
    char	psname[MAXPUBSCREENNAME];

    printf("---------- Screen %lx ------------------------\n", addr);
    printf("Flags: %8lx\nNextScreen: %8lx\nFirstWindow: %8lx\n",
	s->Flags, s->NextScreen, s->FirstWindow);

    if (s->Title)
    {
	char	titlebuff[ 256 ];
	GetBlock( s->Title, titlebuff, sizeof( titlebuff ) );
	printf("\"%s\"\n", titlebuff );
    }

    printf("PSNode: %lx\n", XSC(s)->PSNode );
    if ( XSC(s)->PSNode )
    {
	GetBlock( XSC(s)->PSNode, &psn, sizeof psn );
	GetBlock( psn.psn_Node.ln_Name, psname, sizeof psname );
	printf("public name: %s\n", psname  );
    }

    printf("L/T/W/H: %d/%d/%d/%d\n",
	s->LeftEdge, s->TopEdge, s->Width, s->Height);
    printf("MouseX/Y:\t%d/%d\n", s->MouseX, s->MouseY);

    ShowAddress("ViewPort", CADDR(addr, s, &s->ViewPort));
    ShowAddress("RastPort", CADDR(addr, s, &s->RastPort));
    ShowAddress("LayerInfo", CADDR(addr, s, &s->LayerInfo));

    ShowAddress("VPExtra", XSC(s)->VPExtra);
    ShowAddress("BarLayer", s->BarLayer );

    {
	struct TextAttr	tattr;
	char	nameb[ 44 ];

	GetBlock( s->Font, &tattr, sizeof tattr );
	GetBlock( tattr.ta_Name, nameb, sizeof nameb );

	printf("Font (TAttr) at %lx,'%s' size: %d\n", s->Font, nameb, tattr.ta_YSize);
    }

    GetBlock( XSC(s)->VPExtra, &vpextra, sizeof vpextra);

    dumpRect("screen DClip\t", &XSC(s)->DClip);
    dumpRect("viewport DisplayClip", &vpextra.DisplayClip);

    printf("scale factors: %d/%d -\t",
	XSC(s)->ScaleFactor.X, XSC(s)->ScaleFactor.Y );
    printf("sprite factors: %d/%d\n",
	XSC(s)->SpriteFactor.X, XSC(s)->SpriteFactor.Y );
    printf("NaturalDRecord: %lx, NaturalMSpec: %lx, NaturalDisplayID %lx\n",
	XSC(s)->NaturalDRecord,
	XSC(s)->NaturalMSpec,
	XSC(s)->NaturalDisplayID );

    printf("coerced DRecord %lx MSpec %x DProperties %lx ModeStash %lx\n", 
	XSC(s)->DRecord,
	XSC(s)->MSpec,
	XSC(s)->DProperties,
	XSC(s)->VPModeStash );

/* missing:
	ColorMap, SpriteFactor
	VPModeStash
	SysImages
	SDraw stuff
	*/

    printf("\n");
    
    return(0);
}

SHOWSIMPLE(XScreen)

/* gadgets */

ULONG dumpGadget(addr, g)
APTR addr;
struct Gadget *g;
{
    printf("Gadget %lx, ID: %x", addr, g->GadgetID);
    if ( g->GadgetText )
    {
	struct IntuiText gtext;
	GetBlock( g->GadgetText, &gtext, sizeof( gtext ) );
	if ( gtext.IText )
	{
	    char	labelbuff[ 256 ];
	    GetBlock( gtext.IText, labelbuff, sizeof( labelbuff ) );
	    printf(", \"%s\"", labelbuff );
	}
    }
    printf("\n");
    ShowAddress("NextGadget", g->NextGadget);
    printf("L/T/W/H:\t\t%d/%d/%d/%d\n",
	g->LeftEdge, g->TopEdge, g->Width, g->Height);
    printf("Flags %x Activation %x GadgetType %x\n",
	g->Flags, g->Activation, g->GadgetType);
    printf("GadgetRender %lx, SelectRender %lx\n",
	g->GadgetRender, g->SelectRender);
    ShowAddress("SpecialInfo", g->SpecialInfo);
    ShowAddress("UserData", g->UserData);
    printf("\n");

    return (0);
}

SHOWSIMPLE(Gadget)

/* menu items */

ULONG dumpMenuItem(addr, i)
APTR addr;
struct MenuItem *i;
{
    ShowAddress("MenuItem", addr);
    ShowAddress("NextItem", i->NextItem);
    printf("L/T/W/H:\t\t%d/%d/%d/%d\n", i->LeftEdge, i->TopEdge, i->Width, i->Height);
    printf("Flags %x, MutualExclude %lx\n", i->Flags, i->MutualExclude);
    ShowAddress("ItemFill", i->ItemFill);
    ShowAddress("SelectFill", i->SelectFill);
    printf("Command: %x, NextSelect %x\n", i->Command, i->NextSelect);
    ShowAddress("SubItem", i->SubItem);
    printf("\n");

    return (0);
}

SHOWSIMPLE(MenuItem)

/* menus */
ULONG dumpMenu(addr, m)
APTR addr;
struct Menu *m;
{
#define NAMESIZE 100
    char   name[NAMESIZE];

    ShowAddress("Menu", addr);
    ShowAddress("NextMenu", m->NextMenu);
    printf("L/T/W/H:\t\t%d/%d/%d/%d\n", m->LeftEdge, m->TopEdge, m->Width, m->Height);
    printf("Flags\t\t%x\n", m->Flags);
    GetName (m->MenuName, name);
    printf("MenuName %s\t", name );
    ShowAddress("--", m->MenuName);
    ShowAddress("FirstItem", m->FirstItem);
    printf("JazzX/Y BeatX/Y %d/%d  %d/%d\n",m->JazzX,m->JazzY,m->BeatX,m->BeatY);
    printf("\n");

    return (0);
}

SHOWSIMPLE(Menu)

/* windows */
ULONG dumpXWindow(addr, w)
APTR addr;
struct Window *w;
{
    LastWindow = (struct Window *)addr;
    printf(" ----------- Window %lx -------------------\n", addr );

    printf("\tNextWindow %8lx\tTitle %8lx\n",
	w->NextWindow, w->Title);
    if (w->Title)
    {
	char	titlebuff[ 256 ];
	GetBlock( w->Title, titlebuff, sizeof( titlebuff ) );
	printf("\t\"%s\"\n", titlebuff );
    }

    printf("\tWScreen %8lx\tRPort %8lx\tFirstGadget %8lx\n",
	w->WScreen, w->RPort, w->FirstGadget);
    printf("\tL/T/W/H: %d/%d/%d/%d\n", w->LeftEdge, w->TopEdge,
	w->Width, w->Height);
    printf("\tMouse X/Y: %d/%d\n", w->MouseX, w->MouseY);
    printf("\tMin W/H %d/%d\n", w->MinWidth, w->MinHeight);
    printf("\tMax W/H %d/%d\n", w->MaxWidth, w->MaxHeight);
    printf("\tFlags %lx MoreFlags %lx\n", w->Flags, w->MoreFlags);
    printf("\tFirstRequest %lx\n", w->FirstRequest);
    printf("\tDMRequest %lx\n", w->DMRequest);
    printf("\tReqCount %d\n", w->ReqCount);
    printf("\tParent %8lx\tDescendant %8lx\n", w->Parent, w->Descendant);
    printf("\tIDCMPFlags %8lx\tWLayer %8lx\n", w->IDCMPFlags, w->WLayer);

    printf("\tborder l/t/r/b %d/%d/%d/%d\n",
    w->BorderLeft, w->BorderTop, w->BorderRight, w->BorderBottom);
    printf("\tBorderRPort %lx\n", w->BorderRPort);
    ShowAddress ("\tIDCMP user port", w->UserPort);
    ShowAddress("\tMenuStrip", w->MenuStrip);
    printf("\tMouseQueueLimit: %d\n", XWINDOW(w)->MouseQueueLimit );
    printf("\tMousePending: %d\n", XWINDOW(w)->MousePending );
    printf("\tRptQueueLimit: %d\n", XWINDOW(w)->RptQueueLimit );
    printf("\tRptPending: %d\n", XWINDOW(w)->RptPending );
    printf("\n");

    return (0);
}

SHOWSIMPLE(XWindow)

ULONG dumpRequester(addr, r)
APTR addr;
struct Requester *r;
{
    ShowAddress("Requester", addr);
    ShowAddress ("OlderRequest", r->OlderRequest);
    ShowAddress ("ReqLayer", r->ReqLayer);
    ShowAddress ("RWindow", r->RWindow);
    ShowAddress("ReqGadget", r->ReqGadget);
    printf("Flags %lx\n", r->Flags);
    dumpBox ("reqbox", &r->LeftEdge);
    printf("rel left/top %d %d\n", r->RelLeft, r->RelTop);

    return (0);
}


SHOWSIMPLE(Requester)

dumpBox(s, b)
UBYTE *s;
struct IBox *b;
{
    printf("[%s]\t", s);
    printf("\tl/t: %d, %d; w/h: %d, %d\n",
	b->Left, b->Top, b->Width, b->Height);
}


dumpGEnv(ge)
struct GListEnv *ge;
{
    printf("no such thing as GListEnv anymore\n");
#if 0
    ShowAddress ("Screen", ge->ge_Screen);
    ShowAddress ("Window", ge->ge_Window);
    ShowAddress ("Requester", ge->ge_Requester);
    ShowAddress ("RastPort", ge->ge_RastPort);
    ShowAddress ("Layer", ge->ge_Layer);
    ShowAddress ("GZZLayer", ge->ge_GZZLayer);
    printf("pens %x %x\n", ge->ge_Pens.DetailPen, ge->ge_Pens.BlockPen);
    dumpBox("Domain", &ge->ge_Domain);
    dumpBox("GZZDims", &ge->ge_GZZdims);
#endif
}

ShowGEnv(arg)
char *arg;
{
    struct GListEnv *ge;

    if (AddrArg(arg, &ge)) 
    {
	printf("\n");
	doMinNode(ge, sizeof (struct GListEnv), dumpGEnv);
    }
    else puts("\nbad syntax");
}

ShowISems()
{
    struct IntuitionBase *ibase;

    if (!(ibase = (struct IntuitionBase *) FindBase("intuition.library")))
    {
	printf("\ncan't find intuition.library\n");
	return;
    }

    semHeader();
    showSemList(&ibase->SemaphoreList);
}

ShowLayerInfoSems()
{
    struct IntuitionBase *ibase;
    struct Screen *screen;

    if (!(ibase = (struct IntuitionBase *) FindBase("intuition.library")))
    {
	printf("\ncan't find intuition.library\n");
	return;
    }

    for (screen = (struct Screen *) GetMemL(&ibase->FirstScreen); screen;
			screen = (struct Screen *) GetMemL(&screen->NextScreen))
    {
	Print ("\nScreen: %lx, LayerInfo: %lx\n", screen, &screen->LayerInfo);
	Print ("Locks: (Layer_Info.Lock first)");
	semHeader();
	showSem(&screen->LayerInfo.Lock);
	showSemList(&screen->LayerInfo.gs_Head);
    }
}




ULONG dumpPropInfo(addr, pi)
APTR addr;
struct PropInfo *pi;
{

    ShowAddress("PropInfo", addr);
    printf("\tflags %x, pots %x/%x\n", pi->Flags, pi->HorizPot, pi->VertPot);
    printf("\tbodies: %x/%x\n", pi->HorizBody, pi->VertBody);
    printf("\tCWidth/Height %d/%d, H/VPotRes %d/%d\n", 
	pi->CWidth, pi->CHeight, pi->HPotRes, pi->VPotRes);

    printf("\tL/T Borders %d/%d\n", pi->LeftBorder, pi->TopBorder);

    return (1);	/* make it stop */
}

SHOWSIMPLE(PropInfo)

ULONG dumpImage(addr, im)
APTR addr;
struct Image *im;
{
    ShowAddress("Image", addr);
    printf("\tL/T/W/H %d/%d/%d/%d\n",
	im->LeftEdge, im->TopEdge, im->Width, im->Height);
    printf("\tDepth %d, ImageData %lx\n", im->Depth, im->ImageData);
    printf("\tPlanePick/OnOff %d - %d\n", im->PlanePick, im->PlaneOnOff);

    return (1);
}

SHOWSIMPLE(Image)


ULONG dumpIntuiText(addr, it)
APTR addr;
struct IntuiText *it;
{
    ShowAddress("IntuiText", addr);
    if (it->IText)
    {
	char	textbuff[ 256 ];
	GetBlock( it->IText, textbuff, sizeof( textbuff ) );
	printf("\tText: \"%s\"\n", textbuff );
    }
    printf("\tL/T %d/%d\n",
	it->LeftEdge, it->TopEdge);
    printf("\tFrontPen %d, BackPen %d, DrawMode %d\n", it->FrontPen,
	it->BackPen, it->DrawMode);
    printf("\tITextFont at %lx\n", it->ITextFont);
    printf("\tNextText at %lx\n", it->NextText);

    return (1);
}

SHOWSIMPLE(IntuiText)

struct Thing {struct Thing *NextThing};

ULONG dumpThing(addr, p)
APTR addr;
struct Thing *p;
{
    if (addr == CurrAddr)
    {
	printf("* ");
    }
    else
    {
	printf("  ");
    }
    ShowAddress("Thing", addr);

    return (0);
}

SHOWSIMPLE(Thing)

dumpRect(s, r)
UBYTE *s;
struct Rectangle *r;
{
    printf("%s\t", s);
    printf("\tX: [%d/%d]\tY: [%d/%d]\n", r->MinX, r->MaxX, r->MinY, r->MaxY);
}

ShowAScreen()
{
    struct IntuitionBase IBase;
    APTR  ibase;

    if (ibase =  FindBase ("intuition.library"))
    {
	GetBlock(ibase, &IBase, sizeof IBase);
	SpareAddr = (APTR) IBase.ActiveScreen;
	printf (" at %08lx\n", IBase.ActiveScreen );
    }
    else
    {
	puts("\ncouldn't find intuition.library in exec library list.");
    }
}

ShowAWindow()
{
    struct IntuitionBase IBase;
    APTR  ibase;

    if (ibase =  FindBase ("intuition.library"))
    {
	GetBlock(ibase, &IBase, sizeof IBase);
	SpareAddr = (APTR) ( LastWindow = IBase.ActiveWindow );
	printf (" at %08lx\n", IBase.ActiveWindow );
    }
    else
    {
	puts("\ncouldn't find intuition.library in exec library list.");
    }
}

ShowFirstGad()
{
    struct Window win;

    if (LastWindow)
    {
	GetBlock(LastWindow, &win, sizeof win);
	SpareAddr = (APTR) win.FirstGadget;
	printf (" of window at %08lx is at %08lx\n", LastWindow, win.FirstGadget);
    }
    else
    {
	puts("\nof what window?");
    }
}

@


1.13
log
@Window dump now includes window's title-text and MoreFlags field.
Some offsets of the XWindow structure were stale.
Now show Gadget's label-text, if any.
Now insert blank line after each gadget.
Thing printer now puts asterisk beside current.
Added ShowFirstGad(), ShowAWindow() and ShowAScreen() functions.
Changed $Header to $Id.
@
text
@d2 1
a2 1
 * $Id: /usr2/peter/wack/RCS/showi.c,v 1.12 90/03/20 17:53:06 jimm Exp Locker: peter $
d216 1
a216 1
    LastWindow = addr;
d388 24
@


1.12
log
@no change
@
text
@d2 1
a2 1
 * $Header: showi.c,v 1.11 90/01/17 18:59:03 jimm Exp $
d44 2
d137 13
a149 1
    printf("Gadget %lx, ID: %x\n", addr, g->GadgetID);
d159 1
d216 1
d221 7
d235 1
a235 1
    printf("\tFlags %lx\n", w->Flags);
d395 9
a403 1
    ShowAddress("node at", addr);
d417 51
@


1.11
log
@minor changes to dumpXScreen
@
text
@d2 1
a2 1
 * $Header: showi.c,v 1.10 90/01/15 18:06:37 jimm Exp $
@


1.10
log
@more private screen/window info
@
text
@d2 1
a2 1
 * $Header: showi.c,v 1.9 90/01/15 17:18:33 jimm Exp $
d83 2
d97 1
a97 1
    dumpRect("screen DClip", &XSC(s)->DClip);
@


1.9
log
@change Window to XWindow and Screen to XScreen to pick up internal 
versions of the structs.
@
text
@d2 1
a2 1
 * $Header: showi.c,v 1.8 90/01/15 12:29:25 jimm Exp $
d55 3
a57 2
    printf("Screen %8lx\nFlags: %8lx\nNextScreen: %8lx\nFirstWindow: %8lx\n",
	addr, s->Flags, s->NextScreen, s->FirstWindow);
a81 1
    ShowAddress("ExtData", s->ExtData);
d98 1
a98 1
    printf("scale factors: %d/%d\n",
d100 6
a105 2
    printf("Drecord: %lx, NaturalMSpec: %lx, MSpec %lx, DProps %lx\n",
    XSC(s)->DRecord, XSC(s)->NaturalMSpec, XSC(s)->MSpec, XSC(s)->DProperties );
d107 13
d199 4
a202 2
    printf("Window %8lx\n\tNextWindow %8lx\tTitle %8lx\n",
	addr, w->NextWindow, w->Title);
d224 2
@


1.8
log
@change to track new intuition internal includes
@
text
@d2 1
a2 1
 * $Header: showi.c,v 1.7 89/09/21 19:35:42 jimm Exp $
d47 1
a47 1
ULONG dumpScreen(addr, s)
d108 1
a108 1
SHOWSIMPLE(Screen)
d178 1
a178 1
ULONG dumpWindow(addr, w)
d210 1
a210 1
SHOWSIMPLE(Window)
@


1.7
log
@bringing rcs up to sync
@
text
@d2 1
a2 1
 * $Header: $
d36 1
d65 2
a66 2
    printf("PSNode: %lx\n", s->PSNode );
    if ( s->PSNode )
d68 1
a68 1
	GetBlock( s->PSNode, &psn, sizeof psn );
d82 1
a82 1
    ShowAddress("VPExtra", s->VPExtra);
d93 1
a93 1
    GetBlock(s->VPExtra, &vpextra, sizeof vpextra);
d95 1
a95 1
    dumpRect("screen DClip", &s->DClip);
d98 2
a99 1
    printf("scale factors: %d/%d\n", s->ScaleFactor.X, s->ScaleFactor.Y );
d101 1
a101 1
	s->DRecord, s->NaturalMSpec, s->MSpec, s->DProperties );
d203 2
a204 2
    printf("\tMouseQueueLimit: %d\n", w->MouseQueueLimit );
    printf("\tMousePending: %d\n", w->MousePending );
@


1.6
log
@dicking around.  more stuff in ibase.
@
text
@d2 1
d25 13
d39 2
a40 1
#include "intuition/intuition.h"
a43 66
ShowIBase()
{
    struct IntuitionBase IBase;
    struct View	iview;
    APTR  ibase;

    if (ibase =  FindBase ("intuition.library"))
    {
	GetBlock(ibase, &IBase, sizeof IBase);

	printf (" at %08lx\n", ibase);
	Print ("Flags: %x\n", IBase.Flags);
	Print ("setWExcept: %x, GadgetReturn: %x, StateReturn %x\n",
		IBase.setWExcept, IBase.GadgetReturn, IBase.StateReturn);
	ShowAddress ("SemaphoreList", IBADDR(&IBase.SemaphoreList));

	Print ("\nMouse X/Y %d/%d\n",	IBase.Mouse.X, IBase.Mouse.Y);

	/**
	Print ("\tMinMouse X/Y %d/%d\n", IBase.MinXMouse, IBase.MinYMouse);
	Print ("\tMaxMouse X/Y %d/%d\n", IBase.MaxXMouse, IBase.MaxYMouse);
	**/

	dumpRect("MouseLimits", &IBase.MouseLimits);
	dumpRect("StdDisplay", &IBase.StdDisplay);
	dumpRect("StdOverscan", &IBase.StdOverscan);
	dumpRect("OuterLimits", &IBase.OuterLimits);

	ShowAddress ("View", IBADDR(&IBase.ViewLord));
	ShowAddress ("ActiveWindow", IBase.ActiveWindow);
	ShowAddress ("ActiveScreen", IBase.ActiveScreen);
	ShowAddress ("FirstScreen", IBase.FirstScreen);
	ShowAddress ("\nActiveGadget", IBase.ActiveGadget);
	ShowAddress ("ActivePInfo", IBase.ActivePInfo);
	ShowAddress ("ActiveImage", IBase.ActiveImage);
	ShowAddress ("GadgetEnv", IBADDR(&IBase.GadgetEnv));
	ShowAddress ("GadgetInfo", IBADDR(&IBase.GadgetInfo));

	/* omitting sysbase, gfxbase, layersbase, ... */

	ShowAddress ("\nActivePointer", IBase.APointer );
	Print("\tPointer Width/Height %d, %d\n",
		IBase.APtrWidth, IBase.APtrHeight);
	Print("\tPointer AX/YOffset %d, %d\n", IBase.AXOffset, IBase.AYOffset);

	Print ("\nMenuDrawn %x,\tMenuSelected %x\n", IBase.MenuDrawn,
		    IBase.MenuSelected);
	ShowAddress ("MenuRPort", IBADDR(&IBase.MenuRPort));
	ShowAddress ("ItemCRect", IBADDR(&IBase.ItemCRect));
	ShowAddress ("SubCRect", IBADDR(&IBase.SubCRect));
	ShowAddress ("IBitMap", IBADDR(&IBase.IBitMap));
	ShowAddress ("SBitMap", IBADDR(&IBase.SBitMap));

	/* omitting interrupt and input handler stuff */

#if 0	/* fields have been removed */
	Print ("\nEventCount %d\n", IBase.EventCount);
	ShowAddress ("IntuEvents", IBADDR(&IBase.IntuEvents[0]));
#endif
    }
    else
    {
	puts("\ncouldn't find intuition.library in exec library list.");
    }
}

d50 4
d57 15
d81 20
d156 3
d163 3
a165 1
    ShowAddress("MenuName", m->MenuName);
d201 2
d242 2
d253 1
@


1.5
log
@no change

@
text
@d32 1
d40 1
a40 1
	Print ("Flags: %lx\n", IBase.Flags);
d45 1
a45 3
	Print ("\nMouse X/Y %ld/%ld\n",	IBase.MouseX, IBase.MouseY);
	Print ("\tMinMouse X/Y %ld/%ld\n", IBase.MinXMouse, IBase.MinYMouse);
	Print ("\tMaxMouse X/Y %ld/%ld\n", IBase.MaxXMouse, IBase.MaxYMouse);
d47 10
d74 1
a74 1
	Print ("\nMenuDrawn %x, MenuSelected %x\n", IBase.MenuDrawn,
d85 1
a85 1
	Print ("\nEventCount %ld\n", IBase.EventCount);
d101 1
a101 1
    printf("Screen %8lx\nFlags: %8lx, NextScreen: %8lx, FirstWindow: %8lx\n",
d104 6
a109 1
    printf("\n");
d111 2
a112 1
    ShowAddress("ViewPort", CADDR(addr, s, &s->ViewPort));
d356 7
@


1.4
log
@just testing
@
text
@@


1.3
log
@just setting things up
@
text
@@


1.2
log
@kodiak's copy of jimm's version, snapshot jan 21
@
text
@d24 1
a24 1
#include "/usr/commodore/amiga/V/internal/src/kickstart/intuition/intuinternal.h"
@


1.1
log
@Initial revision
@
text
@d24 1
a24 1
#define INTUITION_INTUITIONBASE_H
a25 1
#include "intuinternal.h"	/* sorry, dale */
d327 13
@
