head     36.14;
branch   ;
access   ;
symbols  ;
locks    ; strict;
comment  @*   @;


36.14
date     90.11.07.10.05.40;  author andy;  state Exp;
branches ;
next     36.13;

36.13
date     90.11.05.16.36.55;  author eric;  state Exp;
branches ;
next     36.12;

36.12
date     88.07.29.13.03.33;  author kodiak;  state Exp;
branches ;
next     36.0;

36.0
date     88.07.29.13.01.23;  author kodiak;  state Exp;
branches ;
next     ;


desc
@@


36.14
log
@fixes the extra 0 length hunk problem
(didn't like unmamed sections)
@
text
@*------ startup.asm  v 36.13
*
* Copyright (c) 1990 Commodore-Amiga, Inc.
*
*
*------
*------ Conditional assembly flags
*------ ASTART:   1=Standard Globals Defined    0=Reentrant Only
*------ WINDOW:   1=AppWindow for WB startup    0=No AppWindow code
*------ XNIL:     1=Remove startup NIL: init    0=Default Nil: WB Output
*------ NARGS:    1=Argv[0] only                0=Normal cmd line arg parse
*------ DEBUG:    1=Set up old statics for Wack 0=No extra statics
*------ QARG:     1=No argv                     0=Passes argc,argv

* Include the appropriate startup.i (example rstartup.i) here or in
* your assem line

        INCLUDE "allstartup.i"

* Flags for  [A]start  AWstart  Rstart  RWstart  RXstart  QStart
* ASTART         1        1       0        0        0       0
* WINDOW         0        1       0        1        0       0
* XNIL           0        0       0        0        1       1
* NARGS          0        0       0        0        0       0
* DEBUG          0        0       0        0        0       0
* QARG           0        0       0        0        0       1

;------   Flag WB output initialization
NNIL	  SET	(1-XNIL)
WBOUT     SET   (ASTART!WINDOW!NNIL)

************************************************************************
*
*   startup.asm --- Reentrant C Program Startup/Exit (CLI and WB)
*                   v36.13  011/07/90
*
*   Copyright (c) 1988, 1990 Commodore-Amiga, Inc.
*
*   Title to this software and all copies thereof remain vested in the
*   authors indicated in the above copyright notice.  The object version
*   of this code may be used in software for Commodore Amiga computers.
*   All other rights are reserved.
*
*   NO REPRESENTATIONS OR WARRANTIES ARE MADE WITH RESPECT TO THE
*   ACCURACY, RELIABILITY, PERFORMANCE OR OPERATION OF THIS SOFTWARE,
*   AND ALL SUCH USE IS AT YOUR OWN RISK.  NEITHER COMMODORE NOR THE
*   AUTHORS ASSUME ANY RESPONSIBILITY OR LIABILITY WHATSOEVER WITH
*   RESPECT TO YOUR USE OF THIS SOFTWARE.
*
*
*   RSTARTUP.ASM
*
*  Changes for 2.0 - since commands may now receive a >256 character command
*  line, the argv buffer size is now dynamic, based on DosCmdLen passed in.
*  The argv count is also dynamic, based on number of spaces in the command
*  line.
*
*      This startup dynamically allocates a structure which includes
*   the argv buffers.  If you use this startup, your code must return
*   to this startup when it exits.  Use exit(n) or final curly brace
*   (rts) to return here.  Do not use AmigaDOS Exit( ) function.
*   Due to this dynamic allocation and some code consolidation, this
*   startup can make executables several hundred bytes smaller.
*
*       Because a static initialSP variable can not be used, this
*   code depends on the fact that AmigaDOS places the address of
*   the top of our stack in SP and proc->pr_ReturnAddr right before
*   JSR'ing to us.  This code uses pr_ReturnAddr when restoring SP.
*
*       Most versions of startup will initialize a Workbench process's
*   input and output streams (and stdio globals if present) to NIL:
*   if no other form of Workbench output (like WINDOW) is provided.
*   This should help prevent crashes if a user puts an icon on a CLI
*   program, and will also protect against careless stdio debugging
*   or error messages left in a Workbench program.  The code for
*   initializing Workbench IO streams only be removed by assembling
*   startup with ASTART and WINDOW set to 0, and XNIL set to 1.
*
*
*   Some startups which can be conditionally assembled:
*
*      1. Standard Astartup for non-reentrant code
*      2. Reentrant Rstartup (no unshareable globals)
*      3. Smaller reentrant-only RXstartup (no NIL: WB init code)
*      4. Standard AWstartup (WB output window) for non-reentrant code
*      5. Reentrant RWstartup (WB output window, no unshareable globals)
*      6. Smallest Qstartup  (No argv - argv is ptr to NULL string)
*
*
*   Explanation of conditional assembly flags:
*
*      ASTART (ASTART SET 1) startups will set up and XDEF the
*   global variables _stdin, _stdout, _stderr, _errno and  _WBenchMsg.
*   These startups can be used as smaller replacements for startups
*   like (A)startup.obj and TWstartup.obj.  Startups with ASTART
*   would generally be used for non-reentrant programs, although the
*   startup code itself is still reentrant if the globals are not
*   referenced.
*      Reentrant (ASTART SET 0) startups will NOT set up or
*   XDEF the stdio and WBenchMsg globals.  This not only makes the
*   startup slightly smaller, but also lets you know if your code
*   is referencing these non-reentrant globals (you will get an
*   unresolved external reference when you link).  Programs
*   get their input and output handles from Input( ) and Output( ),
*   and the WBenchMsg is passed in argv on Workbench startup.
*
*      WINDOW (WINDOW SET 1) startups use an XREF'd CON: string
*   named AppWindow, defined in your application, to open a stdio
*   console window when your application is started from Workbench.
*   For non-reentrant programs, this window can be used for normal
*   stdio (printf, getchar, etc).  For reentrant programs the window
*   is Input( ) and Output( ).  WINDOW is useful when adding Workbench
*   capability to a stdio application, and also for debugging other
*   Workbench applications.  To insure that applications requiring
*   a window startup are linked with a window startup, the label
*   _NeedWStartup can be externed and referenced in the application
*   so that a linker error will occur if linked with a standard
*   startup.
*
*       example:   /* Optional safety reference to NeedWStartup */
*                    extern UBYTE  NeedWStartup;
*                    UBYTE  *HaveWStartup = &NeedWStartup;
*                  /* Required window specification */
*                    char AppWindow[] = "CON:30/30/200/150/MyProgram";
*                    ( OR  char AppWindow[] = "\0";  for no window )
*
*
*      XNIL (XNIL SET 1) allows the creation of a smaller startup
*   by removing the code that initializes a Workbench process's
*   output streams to NIL:.  This flag can only remove the code
*   if it is not required for ASTART or WINDOW.
*
*      NARGS (NARGS SET 1) removes the code used to parse command line
*   arguments.  The command name is still passed to _main as argv[0].
*   This option can take about 120 bytes off the size of any program that
*   does not use command line args.
*
*      DEBUG (DEBUG SET 1) will cause the old startup.asm statics
*   initialSP, dosCmdLen and dosCmdBuf to be defined and initialized
*   by the startup code, for use as debugging symbols when using Wack.
*
*      QARG (QARG SET TO 1) will bypass all argument parsing.  A CLI
*   startup is passed argc == 1, and a Workbench startup is passed
*   argc == 0.  Argv[0] will be a pointer to a NULL string rather than
*   a pointer to the command name.  This option creates a very small
*   startup with no sVar structure allocation, and therefore must be used
*   with XNIL (it is incompatible with default or AWindow output options).
*
*
*   RULES FOR REENTRANT CODE
*
*      - Make no direct or indirect (printf, etc) references to the
*        globals _stdin, _stdout, _stderr, _errno, or _WBenchMsg.
*
*      - For stdio use either special versions of printf and getchar
*        that use Input( ) and Output( ) rather than _stdin and _stdout,
*        or use fprintf and fgetc with Input( ) and Output( ) file handles.
*
*      - Workbench applications must get the pointer to the WBenchMsg
*        from argv rather than from a global extern WBenchMsg.
*
*      - Use no global or static variables within your code.  Instead,
*        put all former globals in a dynamically allocated structure, and
*        pass around a pointer to that structure.  The only acceptable
*        globals are constants (message strings, etc) and global copies
*        of Library Bases to resolve Amiga.lib references.  Your code
*        must return all OpenLibrary's into non-global variables,
*        copy the result to the global library base only if successful,
*        and use the non-globals when deciding whether to Close any
*        opened libraries.
*
************************************************************************


******* Included Files *************************************************

        INCLUDE "exec/types.i"
        INCLUDE "exec/alerts.i"
        INCLUDE "exec/memory.i"
        INCLUDE "libraries/dos.i"
        INCLUDE "libraries/dosextens.i"
        INCLUDE "workbench/startup.i"


******* MACROS *********************************************************

	CODE

xlib    macro
        xref    _LVO\1
        endm

callsys macro
        CALLLIB _LVO\1
        endm

******* Imported *******************************************************

ABSEXECBASE     EQU     4

        xref    _main           ; C code entry point

        IFGT    WINDOW
        xref    _AppWindow      ; CON: spec in application for WB stdio window
        xdef    _NeedWStartup   ; May be externed and referenced in application
        ENDC    WINDOW

        xlib    Alert
        xlib    AllocMem
        xlib    FindTask
        xlib    Forbid
        xlib    FreeMem
        xlib    GetMsg
        xlib    OpenLibrary
        xlib    CloseLibrary
        xlib    ReplyMsg
        xlib    Wait
        xlib    WaitPort

        xlib    CurrentDir
        xlib    Open
        xlib    Close
        xlib    Input
        xlib    Output

******* Exported *******************************************************

*----- These globals are set up for standard startup code only
        IFGT    ASTART
        xdef    _stdin
        xdef    _stdout
        xdef    _stderr
        xdef    _errno
        xdef    _WBenchMsg
        ENDC    ASTART

*----- These globals available to normal and reentrant code

        xdef    _SysBase
        xdef    _DOSBase
        xdef    _exit           ; standard C exit function


***** Startup Variables structure **********************************

        IFEQ    QARG

; NOTE - the ArgvArray must be last
; It and the ArgvBuffer which follow it are dynamically sized/allocated (2.0)

 STRUCTURE  SVar,0
    ULONG   sv_Size
    LONG    sv_WbOutput
    ULONG   sv_ArgvBufPtr
    ULONG   sv_MaxArgc
    LABEL   sv_ArgvArray
    LABEL   SV_SIZEOF
        ENDC    QARG

************************************************************************
*   Standard Program Entry Point
************************************************************************
*
*       Entered with
*           d0  dosCmdLen
*           a0  dosCmdBuf
*       Any registers (except sp) are allowed to be modified
*
*       Calls
*           main (argc, argv)
*               int   argc;
*               char *argv[];
*
*           For Workbench startup, argc=0, argv=WBenchMsg
*
************************************************************************
startup:
        IFGT    DEBUG
                move.l  sp,initialSP
                move.l  d0,dosCmdLen
                move.l  a0,dosCmdBuf
        ENDC    DEBUG

        IFEQ    QARG
                move.l  d0,d2
                move.l  a0,a2
        ENDC    QARG

        ;------ get Exec library base pointer
                movea.l ABSEXECBASE,a6
                move.l  a6,_SysBase

        ;------ get the address of our task
                suba.l  a1,a1           ; clear a1
                callsys FindTask
                move.l  d0,a4           ; keep task address in a4

        ;------ get DOS library base pointer
                moveq   #0,d0
                lea     DOSName(pc),A1  ; dos.library
                callsys OpenLibrary

                tst.l   d0
                beq     alertDOS        ; fail on null with alert
                move.l  d0,_DOSBase     ; Else set the global


        IFEQ    QARG
        ;------ branch over argv calculations if not a CLI process
                move.l  pr_CLI(A4),d0
		bne.s	vcnt
		moveq	#2,d4		; if wb startup alloc 2 argv's
		moveq   #8,d2		; fake dos cmd line size for alloc
                bra.s   wbnoargs

vcnt:
	;------ estimate max number of argv's for CLI command line
	;------ command + number spaces + 1 + null argv
		movea.l	a2,a0		; dos command line
		moveq	#3,d4		; start count at 3, add spaces
vcnt1:
		cmp.b	#' ',(a0)
		bne.s	vcnt2
		addq	#1,d4
vcnt2:
		tst.b	(a0)+
		bne.s	vcnt1


	;------ branch to here has d4=2, d2=8 for wb startup
wbnoargs:

	;------ d4 now equals at least max number argv's needed
		move.l	d4,d0
		lsl.l	#2,d0		; convert to bytes needed for argv ptrs
		move.l	d0,d5		; save in d5
		add.l	d2,d0		; add dos command line size for buffer

                add.l  #SV_SIZEOF+1,d0	; add structure size + 1 for null term

        ;------ alloc the argument structure	
		move.l	d0,d3		; save total size for de-allocation
                move.l  #(MEMF_PUBLIC!MEMF_CLEAR),d1
                callsys AllocMem
                tst.l   d0
                beq     alertMem        ; fail on null with alert
                move.l  d0,-(sp)        ; save sVar ptr on stack
                move.l  d0,a5           ; sVar ptr to a5
		move.l	d3,sv_Size(a5)  ; size for de-allocation later (2.0)
		subq.l	#1,d4
		move.l	d4,sv_MaxArgc(a5) ; max argc
		lea.l	sv_ArgvArray(a5),a0
		adda.l	d5,a0
		move.l  a0,sv_ArgvBufPtr(a5)

        ENDC    QARG
        IFGT    QARG
                clr.l   -(sp)
        ENDC    QARG

                clr.l   -(sp)           ; reserve space for WBenchMsg if any

        ;------ branch to Workbench startup code if not a CLI process
                move.l  pr_CLI(A4),d0
                beq     fromWorkbench

;=======================================================================
;====== CLI Startup Code ===============================================
;=======================================================================
;       d0  process CLI BPTR (passed in), then temporary
;       d2  dos command length (passed in)
;       d3  argument count
;       a0  temporary
;       a1  argv buffer
;       a2  dos command buffer (passed in)
;       a3  argv array
;       a4  Task (passed in)
;       a5  SVar structure if not QARG (passed in)
;       a6  AbsExecBase (passed in)
;       sp  WBenchMsg (still 0), sVar or 0, then RetAddr (passed in)
;       sp  argc, argv, WBenchMsg, sVar or 0,RetAddr (at bra domain)

        IFEQ    QARG
        ;------ find command name
                lsl.l   #2,d0           ; pr_CLI bcpl pointer conversion
                move.l  d0,a0
                move.l  cli_CommandName(a0),d0
                lsl.l   #2,d0           ; bcpl pointer conversion

                ;-- start argv array
                move.l	sv_ArgvBufPtr(a5),a1
                lea     sv_ArgvArray(a5),a3

                ;-- copy command name
                move.l  d0,a0
                moveq.l #0,d0
                move.b  (a0)+,d0        ; size of command name
                clr.b   0(a0,d0.l)      ; terminate the command name
                move.l  a0,(a3)+
                moveq   #1,d3           ; start counting arguments

        IFEQ    NARGS
        ;------ null terminate the arguments, eat trailing control characters
                lea     0(a2,d2.l),a0
stripjunk:
                cmp.b   #' ',-(a0)
                dbhi    d2,stripjunk

                clr.b   1(a0)

        ;------ start gathering arguments into buffer
newarg:
                ;-- skip spaces
                move.b  (a2)+,d1
                beq.s   parmExit
                cmp.b   #' ',d1
                beq.s   newarg
                cmp.b   #9,d1           ; tab
                beq.s   newarg

                ;-- check for argument count overflow
                cmp.l   sv_MaxArgc(a5),d3
                beq.s   parmExit

                ;-- push address of the next parameter
                move.l  a1,(a3)+
                addq.w  #1,d3

                ;-- process quotes
                cmp.b   #'"',d1
                beq.s   doquote

                ;-- copy the parameter in
                move.b  d1,(a1)+

nextchar:
                ;------ null termination check
                move.b  (a2)+,d1
                beq.s   parmExit
                cmp.b   #' ',d1
                beq.s   endarg

                move.b  d1,(a1)+
                bra.s   nextchar

endarg:
                clr.b   (a1)+
                bra.s   newarg

doquote:
        ;------ process quoted strings
                move.b  (a2)+,d1
                beq.s   parmExit
                cmp.b   #'"',d1
                beq.s   endarg

                ;-- '*' is the BCPL escape character
                cmp.b   #'*',d1
                bne.s   addquotechar

                move.b  (a2)+,d1
                move.b  d1,d2
                and.b   #$df,d2         ;d2 is temp toupper'd d1

                cmp.b   #'N',d2         ;check for dos newline char
                bne.s   checkEscape

                ;--     got a *N -- turn into a newline
                moveq   #10,d1
                bra.s   addquotechar

checkEscape:
                cmp.b   #'E',d2
                bne.s   addquotechar

                ;--     got a *E -- turn into a escape
                moveq   #27,d1

addquotechar:
                move.b  d1,(a1)+
                bra.s   doquote

parmExit:
        ;------ all done -- null terminate the arguments
                clr.b   (a1)
                clr.l   (a3)
        ENDC NARGS

                pea     sv_ArgvArray(a5) ; argv
                move.l  d3,-(sp)         ; argc
        ENDC    QARG

        IFGT    QARG
                pea     nullArgV(pc)    ; pointer to pointer to null string
                pea     1               ; only one pointer
        ENDC

        IFGT    ASTART
                movea.l _DOSBase,a6
        ;------ get standard input handle:
                callsys Input
                move.l  d0,_stdin

        ;------ get standard output handle:
                callsys Output
                move.l  d0,_stdout
                move.l  d0,_stderr
                movea.l ABSEXECBASE,a6
        ENDC ASTART

                bra     domain


;=======================================================================
;====== Workbench Startup Code =========================================
;=======================================================================
;       a2  WBenchMsg
;       a4  Task (passed in)
;       a5  SVar structure if not QARG (passed in)
;       a6  AbsExecBase (passed in)
;       sp  WBenchMsg (still 0), sVar or 0, then RetAddr (passed in)
;       sp  argc=0,argv=WBenchMsg,WBenchMsg,sVar or 0,RetAddr (at domain)

fromWorkbench:
        ;------ get the startup message that workbench will send to us.
        ;       must get this message before doing any DOS calls
                bsr.s   getWbMsg

        ;------ save the message so we can return it later
                move.l  d0,(sp)
        IFGT    ASTART
                move.l  d0,_WBenchMsg
        ENDC    ASTART

        ;------ push the message on the stack for wbmain (as argv)
                move.l  d0,-(sp)
                clr.l   -(sp)           ; indicate run from Workbench (argc=0)

        IFNE    (1-QARG)+WBOUT
        ;------ put DOSBase in a6 for next few calls
                move.l  _DOSBase,a6
        ENDC    (1-QARG)+WBOUT

        IFEQ    QARG
        ;------ get the first argument
                move.l  d0,a2
                move.l  sm_ArgList(a2),d0
                beq.s   doCons

        ;------ and set the current directory to the same directory
                move.l  d0,a0
                move.l  wa_Lock(a0),d1
                ;should be a  beq.s doCons  here
                callsys CurrentDir
doCons:
        ENDC    QARG

        IFGT    WBOUT

        ;------ Open NIL: or AppWindow for WB Input()/Output() handle
        ;       Also for possible initialization of stdio globals
        ;       Stdio used to be initialized to -1


        IFGT    WINDOW
        ;------ Get AppWindow defined in application
                lea     _AppWindow,a0
                cmp.b   #0,(a0)
                bne.s   doOpen          ; Open if not null string
        ENDC    WINDOW

        ;------ Open NIL: if no window provided
        lea     NilName(PC),a0

doOpen:
        ;------ Open up the file whose name is in a0
        ;       DOSBase still in a6
                move.l  a0,d1
                move.l  #MODE_OLDFILE,d2
                callsys Open
        ;------ d0 now contains handle for Workbench Output
        ;------ save handle for closing on exit
                move.l  d0,sv_WbOutput(a5)
                bne.s   gotOpen
                moveq.l #RETURN_FAIL,d2
                bra     exit2
gotOpen:
        IFGT ASTART
        ;------ set the C input and output descriptors
                move.l  d0,_stdin
                move.l  d0,_stdout
                move.l  d0,_stderr
        ENDC ASTART

        ;------ set the console task (so Open( "*", mode ) will work
        ;       task pointer still in A4
                move.l  d0,pr_CIS(A4)
                move.l  d0,pr_COS(A4)
                lsl.l   #2,d0
                move.l  d0,a0
                move.l  fh_Type(a0),d0
                beq.s   noConTask
                move.l  d0,pr_ConsoleTask(A4)
noConTask:
        ENDC WBOUT

        ;------ Fall though to common WB/CLI code


****************************************************
** This code now used by both CLI and WB startup  **
****************************************************

domain:
                jsr     _main
        ;------ main didn't use exit(n) so provide success return code
                moveq.l #RETURN_OK,d2
                bra.s   exit2


****************************************************
**    subroutines here to allow short branches    **
****************************************************

getWbMsg:
        ;------ a6 = ExecBase
                lea     pr_MsgPort(A4),a0       ; our process base
                callsys WaitPort
                lea     pr_MsgPort(A4),a0       ; our process base
                callsys GetMsg
                rts

****************************************************

alertDOS:
        ;------ do recoverable alert for no DOS and exit
                ALERT   (AG_OpenLib!AO_DOSLib)

        ;------ do recoverable alert for no memory and exit
        ;------ If we got this far, DOS is open, so close it
        IFEQ QARG
                bra.s   failExit
alertMem:
                movea.l _DOSBase,a1
                callsys CloseLibrary
                ALERT   AG_NoMemory
        ENDC QARG
failExit:
                tst.l   pr_CLI(a4)
                bne.s   fail2
                bsr.s   getWbMsg
                movea.l d0,a2
                bsr.s   repWbMsg
fail2:
                moveq.l #RETURN_FAIL,d0
                rts

****************************************************

repWbMsg:
        ;------ return the startup message to our parent
        ;       a6 = ExecBase (passed)
        ;       a2 = WBenchMsg (passed)
        ;       we forbid so workbench can't UnLoadSeg() us before we are done
                callsys Forbid
                move.l  a2,a1
                callsys ReplyMsg
                rts


*******************************************************
**  C Program exit() Function, return code on stack  **
**                                                   **
**  pr_ReturnAddr points to our RTS addr on stack    **
**  and we use this to calculate our stack ptr:      **
**                                                   **
**      SP ->   WBenchMsg or 0 (CLI)                 **
**              sVar ptr or 0 (QARG)                 **
**              Address for RTS to DOS               **
*******************************************************

_exit:
                move.l  4(sp),d2        ; exit(n) return code to d2

exit2:                                  ;exit code in d2
        ;------ restore initial stack ptr
                ;-- FindTask
                movea.l ABSEXECBASE,a6
                suba.l  a1,a1
                callsys FindTask
                ;-- get SP as it was prior to DOS's jsr to us
                move.l  d0,a4
                move.l  pr_ReturnAddr(a4),a5
                ;-- subtract 4 for return address, 4 for SVar, 4 for WBenchMsg
                suba.l  #12,a5

                ;-- restore sp
                move.l  a5,sp

                ;-- recover WBenchMsg
                move.l  (sp)+,a2
                ;-- recover SVar
                move.l  (sp)+,a5


        IFGT    WBOUT
        ;------ Close any WbOutput file before closing dos.library
                move.l  sv_WbOutput(a5),d1
                beq.s   noWbOut
                move.l  _DOSBase,a6
                callsys Close
noWbOut:
        ;------ Restore a6 = ExecBase
                movea.l ABSEXECBASE,a6
        ENDC    WBOUT

        ;------ Close DOS library, if we got here it was opened
        ;       SysBase still in a6
                movea.l _DOSBase,a1
                callsys CloseLibrary

        ;------ if we ran from CLI, skip workbench reply
checkWB:
                move.l  a2,d0
                beq.s   deallocSV

                bsr.s   repWbMsg

deallocSV:
        IFEQ    QARG
        ;------ deallocate the SVar structure
                move.l  a5,a1
                move.l  sv_Size(a5),d0
                callsys FreeMem
        ENDC    QARG

        ;------ this rts sends us back to DOS:
                move.l  d2,d0
                rts


**********************************************************************

;----- PC relative data

DOSName         DOSNAME
NilName         dc.b    'NIL:',0
        IFGT    QARG
		CNOP	0,2
nullArgV        dc.l    nullArg
nullArg         dc.l    0               ; "" & the null entry after nullArgV
        ENDC

**********************************************************************
		DATA
**********************************************************************

_SysBase        dc.l    0
_DOSBase        dc.l    0

        IFGT    ASTART
_WBenchMsg      dc.l    0
_stdin          dc.l    0
_stdout         dc.l    0
_stderr         dc.l    0
_errno          dc.l    0
        ENDC    ASTART

        IFGT    DEBUG
initialSP       dc.l    0
dosCmdLen       dc.l    0
dosCmdBuf       dc.l    0
        ENDC    DEBUG

VerRev          dc.w    36,13
        IFGT    ASTART
                dc.b    'A'
        ENDC    ASTART
        IFEQ    ASTART
                dc.b    'R'
        ENDC    ASTART
        IFGT    WINDOW
_NeedWStartup:
                dc.b    'W'
        ENDC    WINDOW
        IFEQ    WBOUT
                dc.b    'X'
        ENDC    WBOUT
        IFGT    NARGS
                dc.b    'N'
        ENDC    NARGS
        IFGT    DEBUG
                dc.b    'D'
        ENDC    DEBUG
        IFGT    QARG
                dc.b    'Q'
        ENDC    QARG

        END
@


36.13
log
@Incorporates Carolyn's changes to set no (or a very large) limit on argument
length.
@
text
@d1 1
a1 1
*------ startup.asm  v 36.11
d15 2
a16 2
* Define the appropriate startup name in your assem line
* (for example, ASTARTUP, RSTARTUP, etc)
d29 2
a30 1
WBOUT     SET   (ASTART!WINDOW!(1-XNIL))
d35 1
a35 1
*                   v36.11  07/25/88
d185 1
a185 1
******* Macros *********************************************************
d187 1
a187 1
	section code
d313 1
d330 1
a330 1
	;------ branch to here has d4=2 for wb startup
d695 1
a695 1
                suba.w  #12,a5
d749 1
d755 1
a755 1
	section data
d775 1
a775 1
VerRev          dc.w    36,11
@


36.12
log
@Scheppner's v34.12
@
text
@d1 5
a5 1
*------ startup.asm  v 34.12   Copyright 1988 Commodore-Amiga, Inc.
d13 1
a13 1
*------ QARG:     1=No argv		     	0=Passes argc,argv
d15 2
a16 1
* Prepend the appropriate .i file to set the flags
d18 2
d34 1
a34 3
*                   Made reentrant by C. Scheppner
*		    Optimized by Kodiak Burns
*                   v34.12  07/25/88
d36 1
a36 1
*   Copyright (c) 1988 Commodore-Amiga, Inc.
d52 5
d60 1
a60 1
*   (rts) to return here.  Do not use AmigaDOS Exit() function.
d103 1
a103 1
*   get their input and output handles from Input() and Output(),
d111 1
a111 1
*   is Input() and Output().  WINDOW is useful when adding Workbench
d155 2
a156 2
*        that use Input() and Output() rather than _stdin and _stdout,
*        or use fprintf and fgetc with Input() and Output() file handles.
d169 1
a169 1
*        opened libraries.  
d176 6
a181 6
	INCLUDE	"exec/types.i"
	INCLUDE	"exec/alerts.i"
	INCLUDE	"exec/memory.i"
	INCLUDE	"libraries/dos.i"
	INCLUDE	"libraries/dosextens.i"
	INCLUDE	"workbench/startup.i"
d186 1
a186 3
xlib	macro
	xref	_LVO\1
	endm
d188 3
a190 3
callsys	macro
	CALLLIB	_LVO\1
	endm
d192 4
d198 1
a198 1
ABSEXECBASE	EQU	4
d200 1
a200 1
	xref	_main		; C code entry point
d202 4
a205 4
	IFGT	WINDOW
	xref	_AppWindow	; CON: spec in application for WB stdio window
	xdef	_NeedWStartup	; May be externed and referenced in application
	ENDC	WINDOW
d207 11
a217 11
	xlib	Alert
	xlib	AllocMem
	xlib	FindTask
	xlib	Forbid
	xlib	FreeMem
	xlib	GetMsg
	xlib	OpenLibrary
	xlib	CloseLibrary
	xlib	ReplyMsg
	xlib	Wait
	xlib	WaitPort
d219 5
a223 5
	xlib	CurrentDir
	xlib	Open
	xlib	Close
	xlib	Input
	xlib	Output
d228 7
a234 7
	IFGT	ASTART
	xdef	_stdin
	xdef	_stdout
	xdef	_stderr
	xdef	_errno
	xdef	_WBenchMsg
	ENDC	ASTART
d238 3
a240 3
	xdef	_SysBase
	xdef	_DOSBase
	xdef	_exit		; standard C exit function
d245 1
a245 2
	IFEQ	QARG
ARGVSLOTS	EQU	32
d247 3
d251 1
d253 3
a255 2
    STRUCT  sv_argvArray,ARGVSLOTS*4
    STRUCT  sv_argvBuffer,256
d257 1
a257 1
	ENDC	QARG
a259 1
*
a260 1
*
d263 4
a266 4
*	Entered with
*	    d0  dosCmdLen
*	    a0  dosCmdBuf
*	Any registers (except sp) are allowed to be modified
d268 4
a271 4
*	Calls
*	    main (argc, argv)
*		int   argc;
*		char *argv[]; 
d273 1
a273 1
*	    For Workbench startup, argc=0, argv=WBenchMsg
d277 5
a281 5
	IFGT	DEBUG
		move.l	sp,initialSP
		move.l	d0,dosCmdLen
		move.l	a0,dosCmdBuf
	ENDC	DEBUG
d283 4
a286 4
	IFEQ	QARG
		move.l	d0,d2
		move.l	a0,a2
	ENDC	QARG
d288 3
a290 3
	;------ get Exec library base pointer
		movea.l	ABSEXECBASE,a6
		move.l	a6,_SysBase
d292 4
a295 4
	;------ get the address of our task
		suba.l	a1,a1		; clear a1
		callsys	FindTask
		move.l	d0,a4		; keep task address in a4
d297 4
a300 4
	;------ get DOS library base pointer
		moveq	#0,d0
		lea	DOSName(pc),A1	; dos.library
		callsys	OpenLibrary
d302 3
a304 4
		tst.l   d0
		beq	alertDOS	; fail on null with alert
		move.l	d0,_DOSBase	; Else set the global
	
a305 13
	IFEQ	QARG
	;------ alloc the argument structure
		move.l	#SV_SIZEOF,d0
		move.l	#(MEMF_PUBLIC!MEMF_CLEAR),d1
		callsys	AllocMem
		tst.l	d0
		beq	alertMem	; fail on null with alert
		move.l	d0,-(sp)	; save sVar ptr on stack
		move.l	d0,a5		; sVar ptr to a5
	ENDC	QARG
	IFGT	QARG
		clr.l	-(sp)
	ENDC	QARG
d307 6
a312 1
		clr.l	-(sp)		; reserve space for WBenchMsg if any
d314 12
a325 3
	;------ branch to Workbench startup code if not a CLI process
		move.l	pr_CLI(A4),d0
		beq	fromWorkbench
d327 38
d368 12
a379 12
;	d0  process CLI BPTR (passed in), then temporary
;	d2  dos command length (passed in)
;	d3  argument count
;	a0  temporary
;	a1  argv buffer
;	a2  dos command buffer (passed in)
;	a3  argv array
;	a4  Task (passed in)
;	a5  SVar structure if not QARG (passed in)
;	a6  AbsExecBase (passed in)
;	sp  WBenchMsg (still 0), sVar or 0, then RetAddr (passed in)
;	sp  argc, argv, WBenchMsg, sVar or 0,RetAddr (at bra domain)
d381 6
a386 6
	IFEQ	QARG
	;------ find command name
		lsl.l	#2,d0		; pr_CLI bcpl pointer conversion
		move.l	d0,a0
		move.l	cli_CommandName(a0),d0
		lsl.l	#2,d0		; bcpl pointer conversion
d388 3
a390 3
		;-- start argv array
		lea	sv_argvBuffer(a5),a1
		lea	sv_argvArray(a5),a3
d392 7
a398 7
		;-- copy command name
		move.l	d0,a0
		moveq.l	#0,d0
		move.b	(a0)+,d0	; size of command name
		clr.b	0(a0,d0.l)	; terminate the command name
		move.l	a0,(a3)+
		moveq	#1,d3		; start counting arguments
d400 3
a402 3
	IFEQ	NARGS	
	;------ null terminate the arguments, eat trailing control characters
		lea	0(a2,d2.l),a0
d404 2
a405 2
		cmp.b	#' ',-(a0)
		dbhi	d2,stripjunk
d407 1
a407 1
		clr.b	1(a0)
d409 1
a409 1
	;------ start gathering arguments into buffer
d411 7
a417 7
		;-- skip spaces
		move.b	(a2)+,d1
		beq.s	parmExit
		cmp.b	#' ',d1
		beq.s	newarg
		cmp.b	#9,d1		; tab
		beq.s	newarg
d419 3
a421 3
		;-- check for argument count overflow
		cmp.w	#ARGVSLOTS-1,d3
		beq.s	parmExit
d423 3
a425 3
		;-- push address of the next parameter
		move.l	a1,(a3)+
		addq.w	#1,d3
d427 3
a429 3
		;-- process quotes
		cmp.b	#'"',d1
		beq.s	doquote
d431 2
a432 2
		;-- copy the parameter in
		move.b	d1,(a1)+
d435 5
a439 5
		;------ null termination check
		move.b	(a2)+,d1
		beq.s	parmExit
		cmp.b	#' ',d1
		beq.s	endarg
d441 2
a442 2
		move.b	d1,(a1)+
		bra.s	nextchar
d445 2
a446 2
		clr.b	(a1)+
		bra.s	newarg
d449 5
a453 5
	;------ process quoted strings
		move.b	(a2)+,d1
		beq.s	parmExit
		cmp.b	#'"',d1
		beq.s	endarg
d455 3
a457 3
		;-- '*' is the BCPL escape character
		cmp.b	#'*',d1
		bne.s	addquotechar
d459 3
a461 3
		move.b	(a2)+,d1
		move.b	d1,d2
		and.b	#$df,d2		;d2 is temp toupper'd d1
d463 2
a464 2
		cmp.b	#'N',d2		;check for dos newline char
		bne.s	checkEscape
d466 3
a468 3
		;--	got a *N -- turn into a newline
		moveq	#10,d1
		bra.s	addquotechar
d471 2
a472 2
		cmp.b	#'E',d2
		bne.s	addquotechar
d474 2
a475 2
		;--	got a *E -- turn into a escape
		moveq	#27,d1
d478 2
a479 2
		move.b	d1,(a1)+
		bra.s	doquote
d482 4
a485 4
	;------ all done -- null terminate the arguments
		clr.b	(a1)
		clr.l	(a3)
	ENDC NARGS
d487 3
a489 3
		pea	sv_argvArray(a5) ; argv
		move.l	d3,-(sp)	 ; argc
	ENDC	QARG
d491 4
a494 4
	IFGT	QARG
		pea	nullArgV(pc)	; pointer to pointer to null string
		pea	1		; only one pointer
	ENDC
d496 5
a500 5
	IFGT	ASTART
		movea.l	_DOSBase,a6
	;------ get standard input handle:
		callsys	Input
		move.l	d0,_stdin
d502 6
a507 6
	;------ get standard output handle:
		callsys	Output
		move.l	d0,_stdout
		move.l	d0,_stderr
		movea.l	ABSEXECBASE,a6
	ENDC ASTART
d509 1
a509 1
		bra	domain
d515 6
a520 6
;	a2  WBenchMsg
;	a4  Task (passed in)
;	a5  SVar structure if not QARG (passed in)
;	a6  AbsExecBase (passed in)
;	sp  WBenchMsg (still 0), sVar or 0, then RetAddr (passed in)
;	sp  argc=0,argv=WBenchMsg,WBenchMsg,sVar or 0,RetAddr (at domain)
d523 3
a525 3
	;------ get the startup message that workbench will send to us.
	;	must get this message before doing any DOS calls
		bsr.s   getWbMsg
d527 5
a531 5
	;------ save the message so we can return it later
		move.l	d0,(sp)
	IFGT	ASTART
		move.l	d0,_WBenchMsg
	ENDC	ASTART
d533 3
a535 3
	;------ push the message on the stack for wbmain (as argv)
		move.l	d0,-(sp)
		clr.l	-(sp)		; indicate run from Workbench (argc=0)
d537 4
a540 4
	IFNE	(1-QARG)+WBOUT
	;------ put DOSBase in a6 for next few calls
		move.l	_DOSBase,a6
	ENDC	(1-QARG)+WBOUT
d542 5
a546 5
	IFEQ	QARG
	;------ get the first argument
		move.l	d0,a2
		move.l	sm_ArgList(a2),d0
		beq.s	doCons
d548 7
a554 6
	;------ and set the current directory to the same directory
		move.l	d0,a0
		move.l	wa_Lock(a0),d1
		callsys	CurrentDir
doCons: 
	ENDC	QARG
d556 1
a556 1
	IFGT	WBOUT
d558 3
a560 3
	;------ Open NIL: or AppWindow for WB Input()/Output() handle
	;	Also for possible initialization of stdio globals
	;	Stdio used to be initialized to -1
a561 7
      
	IFGT	WINDOW
	;------ Get AppWindow defined in application
		lea	_AppWindow,a0
		cmp.b	#0,(a0)
		bne.s	doOpen		; Open if not null string
	ENDC	WINDOW
d563 6
a568 2
	;------ Open NIL: if no window provided
	lea	NilName(PC),a0
d570 3
d574 11
a584 11
	;------ Open up the file whose name is in a0
	;	DOSBase still in a6
		move.l	a0,d1
		move.l	#MODE_OLDFILE,d2 
		callsys	Open 
	;------ d0 now contains handle for Workbench Output
	;------ save handle for closing on exit
		move.l	d0,sv_WbOutput(a5)
		bne.s	gotOpen
		moveq.l #RETURN_FAIL,d2
		bra     exit2
d586 6
a591 6
	IFGT ASTART
	;------ set the C input and output descriptors 
		move.l	d0,_stdin
		move.l	d0,_stdout
		move.l	d0,_stderr
	ENDC ASTART
d593 9
a601 9
	;------ set the console task (so Open( "*", mode ) will work 
	;	task pointer still in A4
		move.l	d0,pr_CIS(A4)
		move.l	d0,pr_COS(A4)
		lsl.l	#2,d0 
		move.l	d0,a0 
		move.l	fh_Type(a0),d0
		beq.s	noConTask
		move.l	d0,pr_ConsoleTask(A4)
d603 1
a603 1
	ENDC WBOUT
d605 1
a605 1
	;------ Fall though to common WB/CLI code
a608 1
**                                                **
d610 1
a610 2
**                                                **
****************************************************
d613 4
a616 4
		jsr	_main
	;------ main didn't use exit(n) so provide success return code
		moveq.l	#RETURN_OK,d2
		bra.s	exit2
a619 1
**                                                **
d621 1
a621 2
**                                                **
****************************************************
d624 6
a629 6
	;------ a6 = ExecBase
		lea	pr_MsgPort(A4),a0	; our process base
		callsys	WaitPort
		lea	pr_MsgPort(A4),a0	; our process base
		callsys	GetMsg
		rts
d634 7
a640 7
	;------ do recoverable alert for no DOS and exit
		ALERT	(AG_OpenLib!AO_DOSLib)
	
	;------ do recoverable alert for no memory and exit
	;------ If we got this far, DOS is open, so close it
	IFEQ QARG
		bra.s	failExit
d642 4
a645 4
		movea.l _DOSBase,a1
		callsys CloseLibrary	
		ALERT	AG_NoMemory
	ENDC QARG
d647 5
a651 5
		tst.l   pr_CLI(a4)
		bne.s   fail2
		bsr.s	getWbMsg
		movea.l d0,a2
		bsr.s	repWbMsg
d653 2
a654 2
		moveq.l	#RETURN_FAIL,d0
		rts
d659 8
a666 8
	;------ return the startup message to our parent
	;       a6 = ExecBase (passed)
	;	a2 = WBenchMsg (passed)
	;	we forbid so workbench can't UnLoadSeg() us before we are done
		callsys	Forbid
		move.l	a2,a1
		callsys	ReplyMsg
		rts
a669 1
**                                                   **
d673 1
a673 1
**  and we use this to calculate our stack ptr:      ** 
a677 1
**                                                   **
d681 1
a681 1
		move.l	4(sp),d2	; exit(n) return code to d2
d683 11
a693 11
exit2:					;exit code in d2
	;------ restore initial stack ptr
		;-- FindTask
		movea.l	ABSEXECBASE,a6
		suba.l	a1,a1
		callsys	FindTask
		;-- get SP as it was prior to DOS's jsr to us
		move.l	d0,a4
		move.l	pr_ReturnAddr(a4),a5
		;-- subtract 4 for return address, 4 for SVar, 4 for WBenchMsg
		suba.w	#12,a5
d695 2
a696 7
		;-- restore sp
		move.l	a5,sp
	
		;-- recover WBenchMsg
		move.l	(sp)+,a2
		;-- recover SVar
		move.l	(sp)+,a5
d698 4
d703 7
a709 6
	IFGT	WBOUT
	;------ Close any WbOutput file before closing dos.library
		move.l	sv_WbOutput(a5),d1
		beq.s	noWbOut
		move.l	_DOSBase,a6
		callsys Close
d711 3
a713 3
	;------ Restore a6 = ExecBase
		movea.l ABSEXECBASE,a6
	ENDC	WBOUT
d715 4
a718 4
	;------ Close DOS library, if we got here it was opened
	;	SysBase still in a6
		movea.l	_DOSBase,a1
		callsys	CloseLibrary
d720 1
a720 1
	;------ if we ran from CLI, skip workbench reply
d722 2
a723 2
		move.l	a2,d0
		beq.s	deallocSV
d725 1
a725 1
		bsr.s	repWbMsg
d728 6
a733 6
	IFEQ	QARG
	;------ deallocate the SVar structure
		move.l	a5,a1
		move.l	#SV_SIZEOF,d0
		callsys FreeMem
	ENDC	QARG
d735 3
a737 3
	;------ this rts sends us back to DOS:
		move.l	d2,d0
		rts
d744 6
a749 6
DOSName		DOSNAME
NilName		dc.b	'NIL:',0
	IFGT	QARG
nullArgV	dc.l	nullArg
nullArg		dc.l	0		; "" & the null entry after nullArgV
	ENDC
d752 1
a752 3

   DATA

d755 2
a756 2
_SysBase	dc.l	0
_DOSBase	dc.l	0
d758 7
a764 7
	IFGT	ASTART
_WBenchMsg	dc.l	0
_stdin		dc.l	0
_stdout		dc.l	0
_stderr		dc.l	0
_errno		dc.l	0
	ENDC	ASTART
d766 5
a770 5
	IFGT	DEBUG
initialSP	dc.l	0
dosCmdLen	dc.l	0
dosCmdBuf	dc.l	0
	ENDC	DEBUG
d772 8
a779 8
VerRev		dc.w	34,12
	IFGT	ASTART
		dc.b	'A'
	ENDC	ASTART
	IFEQ	ASTART
		dc.b	'R'
	ENDC	ASTART
	IFGT	WINDOW
d781 14
a794 14
		dc.b	'W'
	ENDC	WINDOW
	IFEQ	WBOUT
		dc.b	'X'
	ENDC	WBOUT
	IFGT	NARGS
		dc.b	'N'
	ENDC	NARGS
	IFGT	DEBUG
		dc.b	'D'
	ENDC	DEBUG
	IFGT	QARG
		dc.b	'Q'
	ENDC	QARG
d796 1
a796 1
	END
@


36.0
log
@*** empty log message ***
@
text
@d1 1
a1 1
*------ Rstartup.asm  v 34.9k   Copyright 1988 Commodore-Amiga, Inc.
d6 2
a7 1
*------ XNIL:     1=Remove Rstartup NIL: init   0=Default Nil: WB Output
d9 1
a9 1
*------ XARG:     1=Do not provide argc,argv	0=Standard argc,argv
d11 3
a13 1
* Flags for  [A]start  AWstart  Rstart  RWstart  RXstart  XStart
d17 1
d19 1
a19 1
* XARG           0        0       0        0        0       1
d26 4
a29 3
*   Rstartup.asm --- Reentrant C Program Startup/Exit (CLI and WB)
*                    by C. Scheppner, based on Amiga startup.asm
*                    v34.9k  05/25/88
d59 1
a59 1
*       Most versions of Rstartup will initialize a Workbench process's
d66 1
a66 1
*   Rstartup with ASTART and WINDOW set to 0, and XNIL set to 1.
d69 1
a69 1
*   Some Rstartups which can be conditionally assembled:
d72 2
a73 5
*            Astartup.obj     ASTART=1    WINDOW=0    XNIL=0
*      2. Reentrant startup (no unshareable globals)
*            Rstartup.obj     ASTART=0    WINDOW=0    XNIL=0
*      3. Smaller reentrant-only startup (no NIL: WB init code)
*            RXstartup.obj    ASTART=0    WINDOW=0    XNIL=1
d75 2
a76 3
*            AWstartup.obj    ASTART=1    WINDOW=1    XNIL=0
*      5. Reentrant AWstartup (no unshareable globals)
*            RWstartup.obj    ASTART=0    WINDOW=1    XNIL=0
d92 3
a94 1
*   unresolved external reference when you link).
d117 1
a117 1
*      XNIL (XNIL SET 1) allows the creation of a smaller Rstartup
d122 5
d131 6
d138 1
a160 3
*
*   By Carolyn Scheppner
*   Based on the following source
a161 29
*
* Source Control:
* --------------
*
* $Header: startup.asm,v 1.1 86/08/25 12:50:07 root Exp $
*
* $Locker: root $
*
* $Log:   startup.asm,v $
* Revision 1.1  86/08/25  12:50:07  root
* Initial revision
*
* Revision 33.6  86/06/12  10:34:36  neil
* changed so any version of dos is OK
* 
* Revision 33.5  86/06/11  19:03:47  neil
* fixed CloseLibrary if open of dos failed
* 
* Revision 33.4  86/06/09  16:48:59  neil
* now processes escapes also
* 
* Revision 33.3  86/06/09  16:18:12  neil
* another checkpoint -- quoted strings now work
* 
* Revision 1.1  85/11/23  13:49:01  neil
* Initial revision
* 
*
************************************************************************
d166 6
a171 6
   INCLUDE "exec/types.i"
   INCLUDE "exec/alerts.i"
   INCLUDE "exec/memory.i"
   INCLUDE "libraries/dos.i"
   INCLUDE "libraries/dosextens.i"
   INCLUDE "workbench/startup.i"
d176 3
a178 3
xlib   macro
   xref   _LVO\1
   endm
d180 3
a182 3
callsys   macro
   CALLLIB   _LVO\1
   endm
d188 1
a188 1
   xref   _main         ; C code entry point
d190 4
a193 4
   IFGT  WINDOW
   xref   _AppWindow    ; CON: spec in application for WB stdio window
   xdef   _NeedWStartup ; May be externed and referenced in application
   ENDC  WINDOW
d195 11
a205 11
   xlib   Alert
   xlib   AllocMem
   xlib   FindTask
   xlib   Forbid
   xlib   FreeMem
   xlib   GetMsg
   xlib   OldOpenLibrary
   xlib   CloseLibrary
   xlib   ReplyMsg
   xlib   Wait
   xlib   WaitPort
d207 5
a211 5
   xlib   CurrentDir
   xlib   Open
   xlib   Close
   xlib   Input
   xlib   Output
d216 7
a222 7
   IFGT  ASTART
   xdef   _stdin
   xdef   _stdout
   xdef   _stderr
   xdef   _errno
   xdef   _WBenchMsg
   ENDC  ASTART
d226 3
a228 3
   xdef   _SysBase
   xdef   _DOSBase
   xdef   _exit         ; standard C exit function
d233 2
a234 11
  STRUCTURE   SVAR,0
   LONG     sv_DOSBase
   LONG     sv_dosCmdLen
   LONG     sv_dosCmdBuf
   LONG     sv_WBenchMsg
   LONG     sv_WbOutput
   LONG     sv_Reserved1
   LONG     sv_Reserved2
   STRUCT   sv_argvArray,32*4
   STRUCT   sv_argvBuffer,256
  LABEL    SV_SIZEOF
d236 7
d249 4
a252 1
* Entered with  d0=dosCmdLen  a0=dosCmdBuf
d254 4
a257 3
* calls  main (argc, argv)
*        int  argc;
*        char *argv[]; 
d259 2
a260 1
* On Workbench startup, argc=0, argv=WBenchMsg
a261 1

d263 5
d269 4
a272 5
   IFGT DEBUG
      move.l   SP,initialSP
      move.l   d0,dosCmdLen
      move.l   a0,dosCmdBuf
   ENDC DEBUG
d274 3
a276 1
      movem.l  d0/a0,-(sp)
d278 4
a281 3
      ;------ get Exec's library base pointer:
      movea.l  ABSEXECBASE,a6
      move.l   a6,_SysBase
d283 4
a286 4
      ;------ alloc the argument structure
      move.l   #SV_SIZEOF,d0
      move.l   #(MEMF_PUBLIC!MEMF_CLEAR),d1
      callsys  AllocMem
d288 4
a291 8
      movem.l  (sp)+,d1/a0       ;recover dos cmd len, buf, and stack
      move.l   d0,-(sp)          ;save SVar structure and set condition
      bne.s    gotmem            ;got SVar
      addq.l   #4,a7             ;didn't get SVar: clean up stack
      moveq.l  #RETURN_FAIL,d0   ;set error code
      ;------ NOTE:  Exiting here if can't get arg memory
      ;------ Normal exits dependent on ptr to arg memory on stack
      rts
d293 13
a305 3
gotmem:
      move.l   d0,a5
      movem.l  d1/a0,sv_dosCmdLen(a5) ;Save dos command buf len and ptr
d307 1
a307 4
      ;------ get the address of our task  a6 = ExecBase
      suba.l   a1,a1               ;clear a1
      callsys  FindTask
      move.l   d0,a4               ;keep task address in a4
d309 3
a311 4
;-----------------------------------------------------------------------
;  Open the DOS library - a6 = AbsExecBase, a5 = svar
;  If successful, set up Global _DOSBase
;  Else Alert and exit
a312 22
openDOS
      lea     DOSName(pc),A1     ;dos.library
      callsys OldOpenLibrary
      move.l  d0,sv_DOSBase(a5)
      bne.s   gotDOS             ;Branch if successful

      ;----- Else do recoverable alert and exit
noDOS:
      ALERT   (AG_OpenLib!AO_DOSLib)
      moveq.l #100,d0
      bra     exit2

gotDOS:
      move.l  d0,_DOSBase        ;Set the global

;-----------------------------------------------------------------------
;  Branch to Workbench startup code if not a CLI process

      move.l  pr_CLI(A4),d0
      beq     fromWorkbench


d316 12
d329 6
a334 1
*** Note    a4=Task    a5=SVAR structure    a6=AbsExecBase
d336 3
a338 7
fromCLI:
	IFEQ	XARG
      ;------ find command name:
      suba.l   a0,a0
      lsl.l    #2,d0      ; pr_CLI bcpl pointer conversion
      move.l   cli_CommandName(a0,d0.l),d0
      lsl.l    #2,d0      ; bcpl pointer conversion
d340 7
a346 3
      ;------ create buffer and array:
      lea   sv_argvBuffer(a5),a2
      lea   sv_argvArray(a5),a3
d348 3
a350 12
      ;------ fetch command name:
      move.l   d0,a0
      moveq.l  #0,d0
      move.b   (a0)+,d0   ; size of command name
      clr.b    0(a0,d0.l)   ; terminate the string
      move.l   a0,(a3)+

      ;------   collect parameters:
      movem.l  sv_dosCmdLen(a5),d0/a0

      ;------ null terminate the string, eat trailing garbage
      lea     0(a0,d0.l),a1
d352 2
a353 1
      cmp.b   #' ',-(a1)
d355 1
a355 3
      ;-- jimm: 8/25/86: per kodiak's recommendation
      ; bls.s   stripjunk
      dbhi   D0,stripjunk
d357 1
a357 2
      clr.b   1(a1)

d359 7
a365 7
      ;------ skip spaces
      move.b   (a0)+,d1
      beq.s   parmExit
      cmp.b   #' ',d1
      beq.s   newarg
      cmp.b   #9,d1         ; tab
      beq.s   newarg
d367 3
a369 2
      ;------ push address of the next parameter
      move.l  a2,(a3)+
d371 3
a373 3
      ;------ process quotes
      cmp.b   #'"',d1
      beq.s   doquote
d375 3
a377 2
      ;------ copy the parameter in
      move.b  d1,(a2)+
d379 3
d383 5
a387 5
      ;------ null termination check
      move.b  (a0)+,d1
      beq.s   parmExit
      cmp.b   #' ',d1
      beq.s   endarg
d389 2
a390 2
      move.b  d1,(a2)+
      bra.s   nextchar
d393 2
a394 2
      clr.b   (a2)+
      bra.s   newarg
d397 5
a401 5
      ;------ process quoted strings
      move.b  (a0)+,d1
      beq.s   parmExit
      cmp.b   #'"',d1
      beq.s   endarg
d403 3
a405 3
      ;------ '*' is the BCPL escape character
      cmp.b   #'*',d1
      bne.s   addquotechar
d407 3
a409 3
      move.b  (a0)+,d1
      move.b  d1,d2
      and.b   #$df,d2
d411 2
a412 2
      cmp.b   #'N',d2
      bne.s   checkEscape
d414 3
a416 3
      ;------ got a *N -- turn into a newline
      moveq   #10,d1
      bra.s   addquotechar
d419 2
a420 2
      cmp.b   #'E',d2
      bne.s   addquotechar
d422 2
a423 2
      ;------ got a *E -- turn into a escape
      moveq   #27,d1
d426 2
a427 2
      move.b  d1,(a2)+
      bra.s   doquote
d430 4
a433 3
      ;------ all done -- null terminate the baby
      clr.b   (a2)
      clr.l   (a3)
d435 3
a437 5
      ;------ compute the # of arguments (argc)
      move.l  a3,d0
      lea.l   sv_argvArray(a5),a3
      sub.l   a3,d0
      lsr.l   #2,d0
d439 3
a441 2
      pea      sv_argvArray(a5)
      move.l   d0,-(sp)
d444 5
a448 4
	IFGT	XARG
		clr.l	-(sp)
		clr.l	-(sp)
	ENDC
d450 6
d457 1
a457 11
*
*  The above code relies on the end of line containing a control
*  character of any type, i.e. a valid character must not be the
*  last.  This fact is ensured by DOS.
*
      
   IFGT ASTART
      movea.l  _DOSBase,a6
      ;------ get standard input handle:
      callsys  Input
      move.l   d0,_stdin
a458 6
      ;------ get standard output handle:
      callsys  Output
      move.l   d0,_stdout
      move.l   d0,_stderr
      movea.l  ABSEXECBASE,a6
   ENDC ASTART
a459 3
      bra      domain


d463 6
a469 2
*** Note  a4=Task    a5=SVAR structure    a6=AbsExecBase

d471 3
d475 5
a479 3
;-----------------------------------------------------------------------
; This gets the startup message that workbench will send to us
; Must get this message before doing any DOS calls
d481 3
a483 5
waitmsg:
      lea   pr_MsgPort(A4),a0     * our process base
      callsys   WaitPort
      lea   pr_MsgPort(A4),a0     * our process base
      callsys GetMsg
d485 4
a488 5
      ;------ save the message so we can return it later
      move.l   d0,sv_WBenchMsg(a5)
   IFGT ASTART
      move.l   d0,_WBenchMsg
   ENDC ASTART
d490 5
a494 3
      ;------ push the message on the stack for wbmain (as argv)
      move.l   d0,-(SP)
      clr.l    -(SP)      indicate: run from Workbench (argc==0)
d496 6
a501 2
      ;------ put DOSBase in a6 for next few calls
      move.l   sv_DOSBase(a5),a6
d503 1
a503 4
      ;------ get the first argument
      move.l   d0,a2
      move.l   sm_ArgList(a2),d0
      beq.s    docons
d505 3
a507 4
      ;------ and set the current directory to the same directory
      move.l   d0,a0
      move.l   wa_Lock(a0),d1
      callsys  CurrentDir
a508 9

docons: 
   IFGT WBOUT

      ;------ Open NIL: or AppWindow for WB Input()/Output() handle
      ;------ Also for possible initialization of stdio globals
      ;------ Stdio used to be initialized to -1
      ;------ a4 = task, a2 = wbenchmsg, DOSBase still in a6

d510 6
a515 6
   IFGT WINDOW
   ;------ Get AppWindow defined in application
      lea.l    _AppWindow,a0
      cmp.b    #0,(a0)
      bne.s    doOpen         ;Open if not null string
   ENDC WINDOW
d517 2
a518 3
      
   ;------ Open NIL: if no window provided
      lea.l    NilName(PC),a0
d521 18
a538 7
   ;------ Open up the file whose name is in a0
   ;------ Note - DOSBase still in a6
      move.l   a0,d1
      move.l   #MODE_OLDFILE,d2 
      callsys   Open 
      tst.l    d0
      beq.s    exit2
d540 9
a548 21
   ;------ save handle for closing on exit
      move.l   d0,sv_WbOutput(a5)

   ;------ d0 now contains handle for Workbench Output

   IFGT ASTART
   ;------ set the C input and output descriptors 
      move.l   d0,_stdin
      move.l   d0,_stdout
      move.l   d0,_stderr
   ENDC ASTART

   ;------ set the console task (so Open( "*", mode ) will work 
   ;       task pointer still in A4
      move.l   d0,pr_CIS(A4)
      move.l   d0,pr_COS(A4)
      lsl.l    #2,d0 
      move.l   d0,a0 
      move.l   fh_Type(a0),d0
      beq.s    noConTask
      move.l   d0,pr_ConsoleTask(A4)
d550 1
d552 1
a552 1
   ENDC WBOUT
a553 1
   ;------ Fall though to common WB/CLI code
a554 1

d562 4
a565 4
      jsr      _main
      ;----- main didn't use exit(n) so provide success return code
      moveq.l  #RETURN_OK,d0
      bra.s    exit2
d567 53
d624 7
d634 1
a634 1
      move.l   4(SP),d0   ;exit(n) return code to d0
d636 11
a646 1
exit2:
d648 7
a654 1
      move.l   d0,d2      ;save return code in d2
a655 14
      ;------ restore initial stack ptr
      ;------ FindTask
      movea.l  ABSEXECBASE,a6
      suba.l   a1,a1
      callsys  FindTask
      ;------ get SP as it was prior to DOS's jsr to us
      move.l   d0,a4
      move.l   pr_ReturnAddr(a4),a5
      ;------ subtract 4 for return address, 4 for the a5 we pushed
      suba.l   #8,a5
      ;------ restore sp (stack now contains our a5, then address for rts)
      move.l   a5,sp
      ;------ pull our a5 (= ptr to svar)
      move.l   (sp)+,a5
d657 6
a662 7

   IFGT WBOUT
   ;----- Close any WbOutput file before closing dos.library
      move.l  sv_WbOutput(a5),d1
      beq.s   noWbOut
      move.l  sv_DOSBase(a5),a6
      callsys Close
d664 3
a666 3
      ;------ Restore a6 = ExecBase
      movea.l ABSEXECBASE,a6
    ENDC WBOUT
d668 4
a671 7
      ;------ ExecBase still in a6
      ;------ Close DOS library if it was opened
      move.l   sv_DOSBase(a5),d0
      beq.s    1$
      move.l   d0,a1
      callsys  CloseLibrary
1$:
d673 4
a676 3
      ;------ if we ran from CLI, skip workbench reply
      move.l   sv_WBenchMsg(a5),d3
      beq.s   deallocSV
d678 1
a678 6
      ;------ return the startup message to our parent
      ;------   we forbid so workbench can't UnLoadSeg() us
      ;------   before we are done:
      callsys  Forbid
      move.l   d3,a1
      callsys  ReplyMsg
d681 6
a686 4
      ;------ deallocate the SVAR structure
      move.l  a5,a1
      move.l  #SV_SIZEOF,d0
      callsys FreeMem     ;a6 still holds AbsExecBase
d688 3
a690 1
      ;------ this rts sends us back to DOS:
a691 3
exitToDOS:
      move.l   d2,d0
      rts
d693 1
d697 6
a702 2
DOSName      DOSNAME
NilName      dc.b   'NIL:',0
d704 1
a704 1
************************************************************************
d708 1
a708 1
************************************************************************
d710 2
a711 2
_SysBase     dc.l   0
_DOSBase     dc.l   0
d713 7
a719 7
   IFGT ASTART
_WBenchMsg   dc.l   0
_stdin       dc.l   0
_stdout      dc.l   0
_stderr      dc.l   0
_errno       dc.l   0
   ENDC ASTART
d721 5
a725 5
   IFGT DEBUG
initialSP    dc.l   0
dosCmdLen    dc.l   0
dosCmdBuf    dc.l   0
   ENDC DEBUG
d727 8
a734 8
VerRev       dc.w   34,9,'k'
   IFGT ASTART
             dc.b   'A'
   ENDC ASTART
   IFEQ ASTART
             dc.b   'R'
   ENDC ASTART
   IFGT WINDOW
d736 14
a749 8
             dc.b   'W'
   ENDC WINDOW
   IFEQ WBOUT
             dc.b   'X'
   ENDC WBOUT
   IFGT DEBUG
             dc.b   'D'
   ENDC DEBUG
d751 1
a751 3
   END


@
